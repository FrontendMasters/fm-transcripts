WEBVTT

1
00:00:00.240 --> 00:00:02.218
Okay, functions and Lambdas.

2
00:00:02.218 --> 00:00:07.190
So a function it's similar
as the functions that you're

3
00:00:07.190 --> 00:00:11.960
used to with a little,
some tweaks on the syntax.

4
00:00:11.960 --> 00:00:16.890
For example, instead of using the function
keyword, it's the fun keyword.

5
00:00:16.890 --> 00:00:21.672
Some people say fun, it's up to you, but
let's say fun, fun is funnier, I guess.

6
00:00:21.672 --> 00:00:26.827
So fun, the name of the function and
parentheses as you're used to, Aniko look.

7
00:00:26.827 --> 00:00:31.299
If the function returns a value,
we must say so

8
00:00:31.299 --> 00:00:37.393
by using column and
the datatype that we are returning, okay?

9
00:00:37.393 --> 00:00:39.830
By default, we're not returning.

10
00:00:39.830 --> 00:00:44.703
So if you either return is not gonna work,
it's not gonna compile because

11
00:00:44.703 --> 00:00:50.710
the signature of the function doesn't
say that is returning something, okay?

12
00:00:50.710 --> 00:00:54.080
So we must add column sometimes
you add a space here.

13
00:00:54.080 --> 00:00:56.520
In that case you can
pick the one you prefer.

14
00:00:56.520 --> 00:01:01.692
Something interesting that we
have is that if the function

15
00:01:01.692 --> 00:01:07.570
has only one line,
I can get rid of the return first, okay?

16
00:01:07.570 --> 00:01:09.650
But also I can get rid of the code block.

17
00:01:10.910 --> 00:01:13.225
And instead of a code block,
I can use equals.

18
00:01:15.104 --> 00:01:19.451
So in that case,
it's a one-line function declaration.

19
00:01:19.451 --> 00:01:24.822
And there is an implicit return, the
equals it's kind of an implicit return.

20
00:01:24.822 --> 00:01:30.126
So calling a function returning
to is equals to that string,

21
00:01:30.126 --> 00:01:32.420
that's the idea, okay?

22
00:01:32.420 --> 00:01:37.095
It's not mandatory,
is something that you can picture use.

23
00:01:37.095 --> 00:01:41.855
Arguments, arguments are actually
pretty straightforward with

24
00:01:41.855 --> 00:01:45.850
the differences in syntax
that we have in Kotlin.

25
00:01:45.850 --> 00:01:49.553
So we use the name of the argument
colon and the type coma.

26
00:01:49.553 --> 00:01:51.931
The name of the argument colon and
the type.

27
00:01:51.931 --> 00:01:56.070
We can have default values if you want to,
okay?

28
00:01:56.070 --> 00:01:57.420
So that's fine.

29
00:01:57.420 --> 00:02:02.110
Even if you have a default value,
you must declare the type, okay?

30
00:02:02.110 --> 00:02:05.890
So you cannot use implicit type here.

31
00:02:05.890 --> 00:02:08.260
We must declare the type in this case.

32
00:02:09.750 --> 00:02:11.120
So in this case, actually pretty simple.

33
00:02:11.120 --> 00:02:14.780
How do you call some, as you're used to.

34
00:02:14.780 --> 00:02:15.711
Like so, but

35
00:02:15.711 --> 00:02:21.310
look at what happens here because the
first time you see that it's confusing.

36
00:02:22.310 --> 00:02:28.960
So there isn't a colon,
like that, and a b colon, okay?

37
00:02:28.960 --> 00:02:31.350
But I didn't type those.

38
00:02:31.350 --> 00:02:35.270
Actually, those are not
characters in the file.

39
00:02:35.270 --> 00:02:36.880
Be careful with this, okay?

40
00:02:36.880 --> 00:02:41.240
So be careful, mostly when you are looking
at my code, when you're typing,

41
00:02:41.240 --> 00:02:45.910
you don't need to type a colon and
b colon because they're not there, okay?

42
00:02:45.910 --> 00:02:50.960
It's just a hint from the IDE, okay?

43
00:02:50.960 --> 00:02:56.750
So, you can disable that if you don't
want, but also this is interesting.

44
00:02:56.750 --> 00:03:01.289
You can also call the same
function naming the arguments, but

45
00:03:01.289 --> 00:03:03.737
instead of column width equals.

46
00:03:06.397 --> 00:03:11.936
You decide when you call the function,
if you wanna call the function

47
00:03:11.936 --> 00:03:16.616
in the classic way,
like with values comma separator, or

48
00:03:16.616 --> 00:03:21.315
by naming its arguments with
the name equal and the value.

49
00:03:22.745 --> 00:03:24.635
It's doing exactly the same.

50
00:03:24.635 --> 00:03:25.785
Is that your question or not?

51
00:03:25.785 --> 00:03:28.335
&gt;&gt; Yeah,
does that mean you could switch them?

52
00:03:28.335 --> 00:03:28.875
&gt;&gt; Good question.

53
00:03:28.875 --> 00:03:31.935
That means that if you're
using the second version,

54
00:03:31.935 --> 00:03:34.939
you can actually change
the order of the operators.

55
00:03:34.939 --> 00:03:37.798
So the order doesn't matter
when you're naming them.

56
00:03:39.633 --> 00:03:43.528
To make things even weirder,
when you have another one,

57
00:03:43.528 --> 00:03:46.541
let me clone this one
with a third argument.

58
00:03:48.780 --> 00:03:50.510
Like so.

59
00:03:50.510 --> 00:03:52.590
When you're calling let's say some three.

60
00:03:53.860 --> 00:03:58.885
When you're calling that one, I can say
I want a and then, so that doesn't have

61
00:03:58.885 --> 00:04:04.390
a name a, even if you see a colon that's
not a name, I'm not naming the argument.

62
00:04:04.390 --> 00:04:08.060
And then the other two,
you can change the order.

63
00:04:08.060 --> 00:04:13.233
So the first one is not using the name and
the other two is using the names.

64
00:04:13.233 --> 00:04:14.943
And by the way that feels weird, but

65
00:04:14.943 --> 00:04:17.511
then we are going to use this
a lot in jetpack compose.

66
00:04:19.358 --> 00:04:23.647
A lot more than you want
[LAUGH] some points.

67
00:04:23.647 --> 00:04:27.157
Okay, this idea of naming the argument,
or sometimes we name the argument,

68
00:04:27.157 --> 00:04:29.410
sometimes we don't name the argument.

69
00:04:29.410 --> 00:04:30.460
&gt;&gt; Is that a colon?

70
00:04:30.460 --> 00:04:33.980
Is that a IDE hint or-
&gt;&gt; Yeah it's an IDE hint,

71
00:04:33.980 --> 00:04:35.540
so a colon is actually not there.

72
00:04:35.540 --> 00:04:39.780
In fact,
if I'm moving this you can see the cursor.

73
00:04:39.780 --> 00:04:41.290
I mean, I cannot delete that.

74
00:04:41.290 --> 00:04:45.410
If I try to select a,
I cannot do that because it's not there.

75
00:04:45.410 --> 00:04:49.940
If you open that file from VS code,
you're not going to see a colon.

76
00:04:49.940 --> 00:04:53.367
So again, have in mind that a equals
is something that I wrote and

77
00:04:53.367 --> 00:04:57.570
a colon is something that I'm not writing
and it's not there in the text file.

78
00:04:59.070 --> 00:05:02.515
You can disable that hint
if you don't like it, okay?

79
00:05:02.515 --> 00:05:09.707
There are many hints like that like
those in Android Studio, okay?

80
00:05:09.707 --> 00:05:12.310
Well, that's simple to get, I guess.

81
00:05:12.310 --> 00:05:16.180
Then we have extension functions,
that is actually pretty cool.

82
00:05:16.180 --> 00:05:19.240
Not every language is letting you do this.

83
00:05:19.240 --> 00:05:26.248
An extension function is a way that we
have to inject to have new functions to

84
00:05:26.248 --> 00:05:31.487
any object or any time,
even if you don't own the type.

85
00:05:31.487 --> 00:05:37.060
So in this case,
I'm adding an even method to integers.

86
00:05:37.060 --> 00:05:44.220
So now you will see that I can 2 is
even to 4, because it's an integer.

87
00:05:44.220 --> 00:05:46.160
That's something I have just created.

88
00:05:46.160 --> 00:05:49.944
The only difference is the function
that you write anywhere,

89
00:05:49.944 --> 00:05:52.210
but you have a prefix with a type dot.

90
00:05:53.870 --> 00:05:56.850
This is heavily used in Kotlin.

91
00:05:56.850 --> 00:05:58.190
Heavily used in Kotlin.

92
00:05:59.410 --> 00:06:04.352
So, sometimes you will be using functions
that you don't know where the function is

93
00:06:04.352 --> 00:06:09.293
coming from because when you get into the
type, the function is not there, and say,

94
00:06:09.293 --> 00:06:10.420
what's going on?

95
00:06:10.420 --> 00:06:13.100
Well, the function is
coming from an extension.

96
00:06:15.440 --> 00:06:18.844
And I am saying careful OOP extremist
because think about it from an OOP

97
00:06:18.844 --> 00:06:21.627
perspective, from
an object-oriented perspective.

98
00:06:21.627 --> 00:06:25.050
This is a thin, actually, right?

99
00:06:25.050 --> 00:06:30.602
Because you're messing with other types
that you don't have permission, right?

100
00:06:30.602 --> 00:06:33.110
&gt;&gt; It's like a global object.

101
00:06:33.110 --> 00:06:37.276
&gt;&gt; It's like a global object but receiving
the integer as an argument, but instead of

102
00:06:37.276 --> 00:06:41.580
doing it like so, we're doing this other
method that has its own unique advantages.

103
00:06:43.890 --> 00:06:48.363
Okay, so we're going to see this a lot
during the rest of the training, and

104
00:06:48.363 --> 00:06:50.870
finally we have lambda functions.

105
00:06:50.870 --> 00:06:53.736
That's the name that we use here for
literal functions or

106
00:06:53.736 --> 00:06:56.750
anonymous functions,
closures in other languages.

107
00:06:56.750 --> 00:06:58.890
Here it's called a Lambda function.

108
00:06:58.890 --> 00:07:02.100
So a Lambda function it's a variable.

109
00:07:02.100 --> 00:07:03.570
It's a data type.

110
00:07:03.570 --> 00:07:08.024
The data type is actually
when you create a lambda,

111
00:07:08.024 --> 00:07:13.940
the data type is parenthesis,
thin arrow and then the return type.

112
00:07:13.940 --> 00:07:18.289
Now for example, if I have receive
two integers and return an integer,

113
00:07:18.289 --> 00:07:20.621
that's how you express that, okay?

114
00:07:20.621 --> 00:07:23.575
This's actually pretty
similar to swift and

115
00:07:23.575 --> 00:07:28.872
maybe swift is the only one that looks
exactly the same like this, the data type.

116
00:07:28.872 --> 00:07:33.088
What happens if you don't
wanna return anything, weird.

117
00:07:33.088 --> 00:07:37.960
There is a void, but
we don't use that in Android.

118
00:07:37.960 --> 00:07:41.330
Here we have one difference between
compiling for Android and compiling for

119
00:07:41.330 --> 00:07:42.970
other platforms in Kotlin.

120
00:07:42.970 --> 00:07:49.394
It's called unit, and please don't
ask me why it's called a unit.

121
00:07:49.394 --> 00:07:50.527
It's a weird name.

122
00:07:50.527 --> 00:07:54.888
But unit means that we are not going
to return a value in that function.

123
00:07:57.201 --> 00:08:02.911
Okay, for Android SDK.

124
00:08:02.911 --> 00:08:05.917
And how do you assign a value?

125
00:08:05.917 --> 00:08:07.060
Code block.

126
00:08:08.340 --> 00:08:11.750
So you open curly braces,
and you put the code inside.

127
00:08:11.750 --> 00:08:12.890
How do you curl the function?

128
00:08:12.890 --> 00:08:14.488
Like any other function.

129
00:08:14.488 --> 00:08:15.522
You just curl it.

130
00:08:18.569 --> 00:08:22.737
Okay, something interesting
about arguments.

131
00:08:22.737 --> 00:08:29.494
Let me put this here, if I have in this
function I receive an integer, okay?

132
00:08:29.494 --> 00:08:33.350
If you see here I have a new hint.

133
00:08:33.350 --> 00:08:35.028
That says it int.

134
00:08:35.028 --> 00:08:40.374
If you have only one argument one and
only one argument,

135
00:08:40.374 --> 00:08:46.307
that argument has an implicit name of it,
so you can print it.

136
00:08:48.210 --> 00:08:52.130
So the idea is that it is
the option that we are receiving,

137
00:08:52.130 --> 00:08:55.326
the only option that we are receiving,
okay?

138
00:08:55.326 --> 00:09:01.100
So you can print it, you can save it,
you can, wherever the with it.

139
00:09:01.100 --> 00:09:04.246
If you don't like it, okay?
You can rename that implicit int.

140
00:09:04.246 --> 00:09:07.232
But the idea is that this will improve or

141
00:09:07.232 --> 00:09:12.583
it will improve the speed of your
coding having that int there, okay?

142
00:09:12.583 --> 00:09:16.810
So instead of doing that I can
actually put a name on it.

143
00:09:16.810 --> 00:09:20.800
And it's an integer,
so I will call it int.

144
00:09:21.970 --> 00:09:23.746
And we use the arrow,

145
00:09:23.746 --> 00:09:28.781
the thin arrow as a way to separate
the name of your argument or

146
00:09:28.781 --> 00:09:33.940
arguments and the code, and
that goes within the code block.

147
00:09:35.310 --> 00:09:41.170
So within the code block,
not outside of the code block, okay?

148
00:09:41.170 --> 00:09:45.690
So if I have two arguments,
an integer and a Boolean, well,

149
00:09:45.690 --> 00:09:50.410
I can just name the Boolean,
like is radio wherever.

150
00:09:50.410 --> 00:09:55.641
So now I don't have int,
I have is already an int,

151
00:09:55.641 --> 00:09:58.910
my two arguments, okay?

152
00:09:58.910 --> 00:10:03.726
So I think here I have an example
like that, but it takes some time to

153
00:10:03.726 --> 00:10:08.628
get used to this syntax because I
know the first time you see at this,

154
00:10:08.628 --> 00:10:12.870
it's like,
it takes some time to read this, okay?

155
00:10:12.870 --> 00:10:17.808
But actually it's a variable with
a name myCalc that I know it's

156
00:10:17.808 --> 00:10:21.839
a lambda expression because
this is the whole type.

157
00:10:21.839 --> 00:10:24.339
So that's the type,
the type is a lambda expression.

158
00:10:24.339 --> 00:10:28.698
I know that because there is an arrow, the
lambda expression receives two arguments,

159
00:10:28.698 --> 00:10:30.619
two integers and returns an integer.

160
00:10:30.619 --> 00:10:33.610
And then we have an equals, an assignment.

161
00:10:33.610 --> 00:10:39.380
So we have actually the current value of
that variable that is actually this code.

162
00:10:40.600 --> 00:10:45.698
And that code can be like this, but
because there is only one line,

163
00:10:45.698 --> 00:10:50.680
I don't need the curly braces,
like we saw before.

164
00:10:50.680 --> 00:10:54.612
So I'm saying that I'm receiving
two arguments a and b, and

165
00:10:54.612 --> 00:10:56.241
I'm returning a plus b.

166
00:10:58.783 --> 00:11:03.574
So as a lambda expression that you can
quickly write a lambda expression for

167
00:11:03.574 --> 00:11:06.180
functional programming, okay?

168
00:11:06.180 --> 00:11:06.680
Any question?

169
00:11:07.850 --> 00:11:12.358
&gt;&gt; So as soon as you have more
than one parameter or variable,

170
00:11:12.358 --> 00:11:15.680
it is-
&gt;&gt; No, you're forced to name them.

171
00:11:15.680 --> 00:11:18.400
So if you have more than one argument
you're forced to name the arguments.

172
00:11:20.010 --> 00:11:21.168
It works only with one argument.

173
00:11:23.885 --> 00:11:24.940
&gt;&gt; Is that kind of like this?

174
00:11:26.180 --> 00:11:27.840
&gt;&gt; No, because you still have this.

175
00:11:27.840 --> 00:11:28.369
&gt;&gt; You still have this?

176
00:11:28.369 --> 00:11:32.074
&gt;&gt; Yeah, when you have a context for
this, like a class or an object,

177
00:11:32.074 --> 00:11:33.540
you still have this, so.

178
00:11:33.540 --> 00:11:36.070
&gt;&gt; But it's functional we don't have this?

179
00:11:36.070 --> 00:11:38.780
&gt;&gt; Well, let me change your question.

180
00:11:38.780 --> 00:11:42.765
So is this functional programming or
is Kotlin functional programming?

181
00:11:42.765 --> 00:11:47.641
You can kind of use some of
the functional programming ideas,

182
00:11:47.641 --> 00:11:52.329
but when we are compiling for
Android, we are compiling for

183
00:11:52.329 --> 00:11:56.670
a Java VM or for
a BM compatible with Java, let's say.

184
00:11:57.680 --> 00:12:00.890
And on Java, everything is a class.

185
00:12:00.890 --> 00:12:04.944
So actually,
if you wanna execute this code like so

186
00:12:04.944 --> 00:12:10.170
without the class, in Android,
it's not gonna work.

187
00:12:10.170 --> 00:12:12.520
In android,
you cannot create global variables.

188
00:12:12.520 --> 00:12:16.626
Everything must be within
some sort of class or

189
00:12:16.626 --> 00:12:21.692
structure because of
the restriction of the Android BN.

190
00:12:21.692 --> 00:12:24.814
But if you're writing Kotlin,
for console or for native,

191
00:12:24.814 --> 00:12:26.880
you can actually do whatever you want.

192
00:12:29.060 --> 00:12:31.421
But just remember that Kotlin for

193
00:12:31.421 --> 00:12:36.483
Android is working within the restrictions
of the Android runtime that

194
00:12:36.483 --> 00:12:41.390
is compatible with a Java VM,
at least in terms of the architecture.

