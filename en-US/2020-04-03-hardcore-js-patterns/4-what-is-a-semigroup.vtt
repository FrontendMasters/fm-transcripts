WEBVTT

1
00:00:00.110 --> 00:00:02.620
So we're gonna start here with monoids.

2
00:00:02.620 --> 00:00:06.420
And I'm gonna define what
we call a semi group.

3
00:00:06.420 --> 00:00:09.500
Raise your hand if you've heard
of a semi group or used it.

4
00:00:09.500 --> 00:00:10.870
Okay, we got one.

5
00:00:10.870 --> 00:00:13.890
All right, how about monoids,
people are using, cool.

6
00:00:15.030 --> 00:00:19.340
So, we're gonna start by defining a semi
group and let's look at some examples.

7
00:00:19.340 --> 00:00:25.090
So one plus two, plus three plus six,
doesn't really matter.

8
00:00:25.090 --> 00:00:29.590
What's happening here is it
doesn't matter if I parenthesize

9
00:00:29.590 --> 00:00:34.700
these ones in the right or
the left first, I'll get the same answer.

10
00:00:34.700 --> 00:00:38.510
So again,
associativity keeps coming into play.

11
00:00:38.510 --> 00:00:43.970
So addition is associative,
it also is closed.

12
00:00:43.970 --> 00:00:50.260
So if I add a bunch of integers I can
never break out of integers with addition.

13
00:00:50.260 --> 00:00:53.762
I'll always get integers back, so
it's closed under composition.

14
00:00:53.762 --> 00:00:55.050
I mean this is the composition so

15
00:00:55.050 --> 00:00:58.620
binary operators,
we're gonna compose these numbers.

16
00:00:58.620 --> 00:01:04.710
So now, let's go ahead and say, we’re
gonna take the product of a few numbers.

17
00:01:04.710 --> 00:01:08.330
So how about two and five and eight.

18
00:01:08.330 --> 00:01:10.530
And again, it’s associative right?

19
00:01:10.530 --> 00:01:13.410
It doesn’t matter how I
parenthesize this operation.

20
00:01:13.410 --> 00:01:16.669
And again, it is closed.

21
00:01:17.750 --> 00:01:22.951
Under the data type I'm
getting the product of.

22
00:01:22.951 --> 00:01:27.417
Now, contrast just as a counter example,
if,

23
00:01:27.417 --> 00:01:32.120
let's say I have 10
divided by 4 divided by 2.

24
00:01:32.120 --> 00:01:36.720
This is neither closed nor associative.

25
00:01:36.720 --> 00:01:40.900
So if I do four over two,
I'm gonna get two, right?

26
00:01:40.900 --> 00:01:43.000
And then 10 divided by two is five.

27
00:01:43.000 --> 00:01:47.899
So there's that answer but
if I parenthesized

28
00:01:47.899 --> 00:01:52.190
it this way 10 over 4 is like 2.5.

29
00:01:52.190 --> 00:01:54.588
And that not over two is like, 1.2.

30
00:01:54.588 --> 00:01:59.200
And it's, so we're breaking out
of integers into floats and

31
00:01:59.200 --> 00:02:02.610
we're getting different answers but
depending on how we parenthesize.

32
00:02:02.610 --> 00:02:10.870
Just as FYI, if you're closed and
you're associative, you're parallel.

33
00:02:10.870 --> 00:02:11.860
That's pretty neat.

34
00:02:11.860 --> 00:02:12.810
You can parallelize that,

35
00:02:12.810 --> 00:02:15.870
you can chunk it up into a bunch
of different additions, right?

36
00:02:15.870 --> 00:02:17.760
x plus y plus z.

37
00:02:17.760 --> 00:02:20.190
We can send it to different
servers have them all combined and

38
00:02:20.190 --> 00:02:21.920
then combine the results.

39
00:02:21.920 --> 00:02:23.350
And we can do it in parallel.

40
00:02:23.350 --> 00:02:25.350
That's pretty great.

41
00:02:25.350 --> 00:02:28.210
Spelled associative wrong, but whatever.

42
00:02:28.210 --> 00:02:29.820
Let's look at more examples of this.

43
00:02:29.820 --> 00:02:34.450
Let's say we have a true and
a true and a false.

44
00:02:35.700 --> 00:02:37.080
This is again associative.

45
00:02:38.510 --> 00:02:42.610
We could do ORS, that's associated with
we're just looking at these binary

46
00:02:42.610 --> 00:02:45.460
operators they are associative and
they are closed.

47
00:02:45.460 --> 00:02:49.770
There's something to this, how about
set intersection, we have 1, 2, 3.

48
00:02:49.770 --> 00:02:54.280
And we'll do the meet,
that's not a real operator.

49
00:02:54.280 --> 00:02:57.744
I'm just making that up for this.

50
00:02:57.744 --> 00:03:03.439
We have 2, 5, 6 and do that again,
we could, essentially that's associative,

51
00:03:03.439 --> 00:03:07.890
we'll get the intersection
of all the arrays, right?

52
00:03:07.890 --> 00:03:16.310
So in this case, it'd be two but,
let's go down to this junction or union.

53
00:03:16.310 --> 00:03:17.130
You get the same thing.

54
00:03:17.130 --> 00:03:19.340
You get the union of all them.

55
00:03:19.340 --> 00:03:21.270
This is associative, it's closed.

56
00:03:21.270 --> 00:03:26.125
So try to think of any other examples
of a semigroup, that's that's

57
00:03:26.125 --> 00:03:28.905
what we're getting at is any kind of-
&gt;&gt; What does closed mean again?

58
00:03:28.905 --> 00:03:33.005
&gt;&gt; Close means that we're,
if I'm going to get the intersection or

59
00:03:33.005 --> 00:03:36.825
union of these sets, I'll get a new
set back or array in this case.

60
00:03:36.825 --> 00:03:37.795
Same thing with integers.

61
00:03:37.795 --> 00:03:40.355
I don't change the data type.

62
00:03:40.355 --> 00:03:44.420
When we looked at division,
I know in JavaScript is just number.

63
00:03:44.420 --> 00:03:47.410
But we had integers and we were dividing
integers and boom, you get a float or

64
00:03:47.410 --> 00:03:51.080
you get a real number out of nowhere,
right and so that is not closed.

