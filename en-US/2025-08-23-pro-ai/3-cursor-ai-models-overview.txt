[00:00:00]
>> Steve Kinney: Let's talk about our first contestant on the Agent A code is right, which is Cursor. I'm going to show you this next slide, which is a picture of a web page that's going to buy you a second in case you need to go Download it@cursor.com that is my reminder to remind you to download it if you have not.

[00:00:19]
As I explained a few things that thereby when I go jump into it, you also have it downloaded. Cursor, effectively, has three and a half modes. I rolled two of them in together, mostly because I was running out of room on the slide. Three of them that you can trigger and one of them that is just kind of there and is arguably my favorite.

[00:00:41]
You've got inline edit, which is this is true with Copilot and Visual Studio Code as well. You highlight some text or put your cursor somewhere in the document. You hit Cmd or Ctrl+K and you get a little modal above your code. For those of you who are Vs Code power users, you're like Cmd+K is what I use to use move windows around.

[00:01:06]
That's Cmd+R. Now you'll get the muscle memory eventually and you'll hate it. Whenever you switch back and forth you have then Cmd or Ctrl+L, Ctrl for the Windows folks and Linux folks, Cmd for the Mac, Cmd for those of you who have a Cmd key. Ctrl for those of you who don't, which opens up that chat window along the side, much like ChatGPT.

[00:01:26]
In the past that was very much like ChatGPT where you could talk to it about the code. And these tools are great because they have the context of your code base and will learn, as I alluded to, we'll learn lots about managing what context it has, but it knows about your code base.

[00:01:45]
A lot of times it is better than my old workflow of just randomly asking ChatGPT how to write a really fast hashing algorithm. Now I can at least see what I'm trying to do. So on and so forth. In that same side panel, there's also this idea of agent mode.

[00:02:06]
Agent mode is and now go do things to my code base for me, they're kind of in there. Third and a half is this tab, which you might remember from GitHub, copilot and visual Studio code. The Cursor one's just better. It's just like if you started renaming a variable or tweaking something or even should probably delete a conditional that wasn't doing anything.

[00:02:29]
You'll see it highlighted. We'll have to see that in practice because it's very hard to create a situation where I know it will do it reliably, but it'll do it, it's all the time and it will just kind of that tedious thing and not only for where you are in the code.

[00:02:42]
Let's say you changed two variables names or added a fourth argument to a given function. It will then give you the ability to hit tab to jump down 200 lines to the next place where you probably were going to go do that. Honestly, not all of this working with AI tools has to be generate me a SaaS app in a weekend.

[00:03:02]
Sometimes it can be don't make me hunt and look for that code, which is very nice stuff. It will read your ESLint errors and let you jump to them, so on and so forth. So those are kind of the three and a half major modalities and we'll kind of take a look at them in a second as I buy you a little bit of time to download this.

[00:03:23]
Like I said before, we are going to look at all of these things in a second. But the best practices from earlier apply. If you don't review the code, you deserve whatever happens to you. If you don't use version control, you deserve whatever happens to you. So on and so forth.

[00:03:42]
It has some heuristics. Again, it is not magic for how this works. It will read whatever file you currently have open. That entire file is there. It has a list of the recently viewed files that it will determine if it needs to go reread those. It will try to do a search look for active lintering compilers and recent edit history.

[00:04:02]
There are some caveats though, because again you can only load so much into context. It tries to be clever and if you don't know how it is clever, then you don't know why it's not working, which is it'll get the first 250 lines of a file and if it's searching we'll get the first hundred lines.

[00:04:23]
So you can either there's some lessons to learn about how do you architect your code base there? Is it that you just assume that and just deal with it or do you keep your files under 250 lines or as close as you can possibly get away with it might use a smaller model if you give it more to do.

[00:04:47]
So on and so forth. We can figure out ways. Okay, if 250 is a little hard, maybe it's 400. Can we have ESLint rules that stop any AI writing code from making files because it will make you 1000 line file that then cannot read. Can you keep these files smaller, so on and so forth.

[00:05:14]
Can you actually point it in the right direction rather than rely on these heuristics? You can say I need you to look at this file, this file and this file, or in this folder, or this given symbols are basically a function or a variable name or a class or something like that, or go read these docs.

[00:05:32]
You actually give it a URL for the docs and we'll go read those docs before you do the thing. Or go search the web for the recent version of Svelte or Zod or React or Redux or what have you and go read that before we do the thing and all of those things.

[00:05:51]
The other conceptual thing just to wrap our heads around is you get a choice of models, right? And that choice has trade offs, even if you are infinite money bags, right? Like there are trade offs in all of those. Because the bigger the model, the longer it's going to take, the more it has a bigger context window.

[00:06:17]
Cool, now it has to process that. You got the anthropic models, which we'll see again later in the day. Sonnet is the daily driver. There's older versions of Sonnet, so on and so forth. There's Haiku as well, which is even smaller. Opus is the big one. Opus will cost you somewhere between four and six times as much though.

[00:06:38]
A lot of times in dollars or in rate limits, your choice, same thing. I gotta say, even as somebody who aspires to be good at front end engineering, that's a pretty nice looking ui. As long as you like Tailwind, that's a pretty nice UI that you did there.

[00:06:56]
I like it, I'm impressed. Some code, simplification, refactoring sometimes. It is usually my go to for coding tasks. For brainstorming, I tend to use either Gemini or O3, which we'll talk about in a second. But for the actual doing of the code, I really like Sonnet most of the time because it's that sweet spot of affordable and also good.

[00:07:23]
We like that sweet spot. We've got the Google family of models. The numbers change, but you've got Flash, you've got Pro. Flash is fast Pro does thinking, which is before it tries to do anything, it thinks about what does it mean by that question and considers an approach before.

[00:07:46]
Before spitting out an answer, which I aspire to be good at one day. It has a giant window. OpenSoc has a giant window. And O3 does as well of 200 million tokens. So for those keeping track at home, that's almost like 8 million characters. That said, your entire conversation is taking up that.

[00:08:05]
So work accordingly. I really like it for code reviews or giving it an entire repo and saying, help me make sense of this because you can even. I'll show you some tools towards the end of our time together where you can even just go into regular Gemini, like the browser chat thing and give it an entire code base and be like, help me make sense of this.

[00:08:29]
So it's great for the planning because you can feed it in the entire code base. Maybe it's not so good then the surgical precision there. But again, you're in the brainstorming, you're in the planning phase. Also, it's deep research is far and away, in my opinion the best.

[00:08:43]
It feels faster if you download both Gemini CLI today and Claude Code, Gemini always just seems a lot faster. Again, these could always change at some point too, but it's really good for, I think, writing, brainstorming, understanding a large code generation. I use a lot more for the planning and I use a lot of the anthropic models for the actual doing of the thing.

[00:09:10]
Sonnet will go wild if you leave it on its own because it's very good at writing code. You have somebody on your team like that, right? Very good at writing a lot of code. Yeah, you got the OpenAI ones. Again, brainstorming predominantly. What am I missing here is what I use it for.

[00:09:30]
Less likely to hallucinate on the factual questions. Not so good at writing code. Sorry. In my opinion, your mileage may vary and we'll definitely give up halfway through a task if you actually haven't tried to implement something 40 in particular, I'm looking at you. That said Sonnet, we'll do that sometimes as well.

[00:09:49]
So again, it is a lot of times the one I am brainstorming with as well. Sometimes it just depends on the day and my mood. But yes, this one I don't use, but it's worth mention. You can host your own models. There's an app called LM Studio which I think is cross platform which will download models from Hugging Face and and let you host whatever your poor little computer can handle.

[00:10:17]
Great. If you are like I don't need ChatGPT, not the GPT models. It's remembering every conversation you have and referencing it. Knows what kind of car I drive. I don't like that. So I get it. And so you better have some pretty good hardware you can host your own models, you can give it an OpenAI compliant API around any given model you find.

[00:10:40]
That said, you probably don't have the hardware for this in any meaningful way, but I think it's always a useful thing. So there's this app LM code. You can download all of these different models, you can chat with it, you can expose it as a local host server and it'll have you can point the OpenAI SDK at it and use your own models on your machine.

[00:11:01]
I think definitely worth playing with and worthy mention if you're getting the scaries from shipping all of your code or your security and IT department is getting the scaries as well. This is theoretically an option that one day when I own a $10,000 Mac Studio, I might use the last piece of advice.

[00:11:24]
Smaller models are also faster, cheaper models. If you're on a free plan, you are rate limited. If you like to use it, I will say I can confirm that and we'll see this later with Claude code. If you write a really good detailed plan, if you do all the things that we're going to talk about today, if you have the feedback loops, if you have solid plans.

[00:11:47]
If you've written everything out in incredible detail, a small model with good detail plan will do better than Opus let loose, right? If I have to do one like major hit on the theme of today, that is it. And with that, let's go look at another.

