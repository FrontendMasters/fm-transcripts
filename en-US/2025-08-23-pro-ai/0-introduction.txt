[00:00:00]
>> Speaker 1: We're going to talk a little bit today about building your own or customizing or learning to live with an AI developer setup, or put another way, using various AI tools 2 + in particular, to kind of aid on a good day in your software engineering journey. Or as the kids like to say, vibe coding, which I get it when I hear that term.

[00:00:28]
It brings up the image of a YouTuber who built a SaaS company in a weekend and wants you to know about it. The term, in fairness, does come from one of the founders of OpenAI. I think it really captures a lot of the experience where you start to get into a flow state.

[00:00:50]
You're working with some of these tools that are generating a bunch of stuff, code. Allegedly, things feel good. You feel like you're some kind of wizard of sorts until you hit this part that I've kind of got highlighted here that I really love. The code grows beyond my usual comprehension.

[00:01:08]
I have to really read through it for a while, right? And I think that that, like, summarizes a lot of the like flow that myself. A lot of people nodding the room right now are like, giving me the hint that that might be a shared experience. And then a lot of the other people I've talked to kind of like on this journey of kind of experience, which is like, getting to the point where it's like, wait a second, where did this go?

[00:01:32]
And so a big theme of our talk today is gonna be about, like, not only what are these tools and how do I use them and am I missing out on something and has the gravy train left the station? When we convince you that that is not true, then there will also be the like, how do we actually, like, corral the complexity, right?

[00:01:51]
Cause on one hand, these tools are really great at generating a lot of code quickly. On the other hand, anyone who has ever dropped into a legacy code base with lots of code can tell you that's not always a great thing. There are some fundamental principles that I think, once we wrap our head around them, take a little bit of magic out, which is good.

[00:02:19]
Cause it's a statistical model, there shouldn't be that much magic in it, right. And kind of help us understand what's going on so we can begin to corral that complexity, put in some safeguards, understand it, figure out how to make best use of it, right? And so, like, less that, like, it seems like some sorcery, and more that it seems like, you know, a kind of various approaches to like, what we do every day.

[00:02:43]
Am I central thesis that I'M going to argue to you is there are a bunch of decades old best practices in our industry that a lot of times we sometimes play fast and loose with that actually work really well. I aspire to have the best git discipline in the world.

[00:03:05]
Sometimes I write a bunch of code and then I make the commits later. I aspire to do test driven development. Sometimes, sometimes I write a bunch of code and then I write the test and kind of seeing how some of those principles actually really kind of come into play in really interesting ways in this case as well.

[00:03:25]
And we'll kind of get a sense for how all these things work because like, at the end of the day, writing software has always just been about trying to use something that like somewhat resembles human language to get a computer which only understands like millions of on and off switches and electrons going through a copper wire to do the thing we want it to do.

[00:03:46]
Right, and that is the name of the game. It has always been the name of the game. Whether you're putting in punch cards, writing assembly or Ruby or Shockwave, Flash or JavaScript or what have you, the levels of abstraction keep rising. I'm no longer in my day to day Life as a JavaScript engineer, manually managing memory, some weak maps here there, sometimes worried about garbage collection.

[00:04:12]
Sure. I think as the levels of extraction keep rising, there is more and more opportunities to do more, to have more leverage in the things we're doing. I think a lot of today is about how do we get that leverage, how do we learn how to use some of these tools to get that leverage and not be on the other side of it where we think we're being productive but actually slowing ourselves down.

[00:04:33]
I think it just comes to most things like kind of like understanding some of the basic concepts in Primitives all of a sudden makes this wild magic an understandable thing that you at least know how to somewhat control. At least turned sorcery into alchemy, which we'll take for now.

[00:04:51]
And AI tools are very good at generating lots of code, right? But there's kind of, if you think about even career progressions, there's a joke that as you move up the career ladder, you write less and less code. That's a fair joke. It's also true that as you move up and up the career ladder, you get paid more, right?

[00:05:12]
So generally speaking, we could say that maybe that kind of systems thinking and high level stuff is also the interesting and hard part. And so I have this hypothesis, especially for junior engineers or people earlier on, it is really hard to get some of that stuff, systems thinking and architecture and large code bases, large, messy code bases.

[00:05:34]
Early on in your career, kind of have to just work at companies that have existed longer than you've been working to inherit all sorts of wild stuff, and then have to dig out to earn that experience. But the good news is you can generate huge messes on your own now and figure out how to navigate them and work through everything.

[00:05:52]
So that's going to be a part of what we're talking about today.

