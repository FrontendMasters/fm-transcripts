WEBVTT

1
00:00:00.024 --> 00:00:01.461
&gt;&gt; Evgenii Ray: Okay, let's summarize.

2
00:00:01.461 --> 00:00:06.458
So we went through the core fundamentals
section where you got the knowledge of

3
00:00:06.458 --> 00:00:08.890
how the browser renders the element.

4
00:00:08.890 --> 00:00:13.404
Then when we brush up
the knowledge on our DOM API,

5
00:00:13.404 --> 00:00:18.576
on a DOM API usage, and
also the intersection observer.

6
00:00:18.576 --> 00:00:22.928
So we built a virtualization from
scratch utilizing this core fundamentals

7
00:00:22.928 --> 00:00:23.680
knowledge.

8
00:00:23.680 --> 00:00:28.049
So also we went through
the application state design, so

9
00:00:28.049 --> 00:00:33.602
now you know how you could potentially
optimize the way you store the data

10
00:00:33.602 --> 00:00:38.534
on the client to minimize the device
memory usage and CPU usage.

11
00:00:38.534 --> 00:00:42.814
And we also overviewed all network
protocols that are available to us as

12
00:00:42.814 --> 00:00:46.397
a web developers and
how can we fetch the data efficiently.

13
00:00:46.397 --> 00:00:51.367
And we also looked at the way how can
we optimize the JavaScript assets.

14
00:00:51.367 --> 00:00:54.735
So I hope that this will
be useful to you and

15
00:00:54.735 --> 00:01:00.526
you will be able to apply this knowledge
in your real life and daily job.

16
00:01:00.526 --> 00:01:06.379
&gt;&gt; Speaker 2: What is the best practice
for updating UI when streaming?

17
00:01:06.379 --> 00:01:07.612
&gt;&gt; Evgenii Ray: Updating the UI when?

18
00:01:07.612 --> 00:01:09.720
&gt;&gt; Speaker 2: Streaming updates.

19
00:01:09.720 --> 00:01:14.905
So, for instance, probably,
just thinking like ChatGPT responses.

20
00:01:14.905 --> 00:01:19.875
&gt;&gt; Evgenii Ray: So first of all,
you need to connect to your

21
00:01:19.875 --> 00:01:25.548
endpoint that allows us
to stream the text data.

22
00:01:25.548 --> 00:01:31.031
And the server-sent events is very good
way how you can stream the text data.

23
00:01:31.031 --> 00:01:36.689
But one thing about the data streaming
is when you see that the ChatGPT streams

24
00:01:36.689 --> 00:01:42.971
the text, it's actually already received
the chunk of data that it wants to render.

25
00:01:42.971 --> 00:01:47.994
So the way you can wait until you get
the chunk of data that you want to render.

26
00:01:47.994 --> 00:01:49.823
And once this chunk is ready,

27
00:01:49.823 --> 00:01:53.783
you'll be able to kind of simulate
the streaming of the answer.

28
00:01:53.783 --> 00:01:55.894
This is how I would implement this.

29
00:01:58.919 --> 00:02:03.978
&gt;&gt; Speaker 2: When the final slide says,
minimize run time state, does that mean

30
00:02:03.978 --> 00:02:09.947
normalizing it or simplifying the data so
there's less to consider over time?

31
00:02:09.947 --> 00:02:14.185
&gt;&gt; Evgenii Ray: It's actually both,
so you minimize duplication, so

32
00:02:14.185 --> 00:02:19.965
you store less nested objects, and
you also store things on the hard drive.

33
00:02:19.965 --> 00:02:24.083
So when you offload
the data to the hard drive,

34
00:02:24.083 --> 00:02:28.211
you reduce the RAM
consumption by the device.

35
00:02:28.211 --> 00:02:33.257
Yeah, all right, thanks a lot for
watching the course, I hope you liked it.

36
00:02:33.257 --> 00:02:38.025
And yeah, feel free to subscribe
to my YouTube channel and

37
00:02:38.025 --> 00:02:41.443
also share the course with your friends.

38
00:02:41.443 --> 00:02:44.445
&gt;&gt; [APPLAUSE]
&gt;&gt; Evgenii Ray: Thank you.

39
00:02:44.445 --> 00:02:47.325
&gt;&gt; [APPLAUSE]

