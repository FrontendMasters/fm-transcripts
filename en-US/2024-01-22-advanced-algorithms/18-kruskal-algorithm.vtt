WEBVTT

1
00:00:00.250 --> 00:00:04.960
All right, step one of Kruskal,
sort edges.

2
00:00:06.810 --> 00:00:11.631
All right, so
that means I'm gonna have this,

3
00:00:11.631 --> 00:00:17.294
I'm going to have (e, f,
1), I'm gonna have (c,

4
00:00:17.294 --> 00:00:21.872
b, 1), I'm going to have (f, g, 2),

5
00:00:21.872 --> 00:00:26.570
I'm gonna o have e,
beautiful e, by the way,

6
00:00:26.570 --> 00:00:30.571
c, 3, I'm going to have where is it?

7
00:00:30.571 --> 00:00:35.718
On top of the e, [SOUND] to g, 3,
I'm going to have, what is it?

8
00:00:35.718 --> 00:00:40.625
(F, d, 4), I'm gonna have (d, b,

9
00:00:40.625 --> 00:00:45.252
8), I'm gonna have (c, d, 8),

10
00:00:45.252 --> 00:00:49.485
and then finally, (b, a, 9).

11
00:00:49.485 --> 00:00:51.859
So there we go,
we've ordered all the lists, right?

12
00:00:51.859 --> 00:00:58.017
So we have every single edge possible and
now, we just simply start here and

13
00:00:58.017 --> 00:01:02.437
go, all right,
this is our first edge we need to add.

14
00:01:02.437 --> 00:01:06.970
I'm gonna use red, so everyone can see
we're still producing the same graph, but

15
00:01:06.970 --> 00:01:09.708
we're going about it in a different way.

16
00:01:09.708 --> 00:01:12.907
So I'm gonna put a little
red line right here,

17
00:01:12.907 --> 00:01:18.138
e to f is called group red, all right,
we're all fans of group red.

18
00:01:18.138 --> 00:01:20.498
So we process this first one,
it's in the graph,

19
00:01:20.498 --> 00:01:22.444
how do we know it should be in the graph?

20
00:01:22.444 --> 00:01:26.838
Well, minimum spanning trees
don't create cycles, and

21
00:01:26.838 --> 00:01:30.174
it's the smallest edges, okay, easy.

22
00:01:30.174 --> 00:01:32.774
We're gonna go to the next one,
my goodness,

23
00:01:32.774 --> 00:01:36.834
I gotta get these lids organized, hold on,
I'm having lid anxiety right now.

24
00:01:37.934 --> 00:01:39.846
My goodness, I'm gonna get them all wrong.

25
00:01:42.684 --> 00:01:47.267
Beautiful, all right, now,
we're gonna process this one,

26
00:01:47.267 --> 00:01:49.957
all right, so that means we go C to B.

27
00:01:49.957 --> 00:01:53.200
I'm gonna actually color
this with a different color,

28
00:01:53.200 --> 00:01:56.064
I'm gonna color this one green, all right?

29
00:01:56.064 --> 00:01:59.572
So we have two groups kind of forming
here, we have the C, B's, and

30
00:01:59.572 --> 00:02:00.689
we have the E, F's.

31
00:02:02.129 --> 00:02:07.859
Next, we need to add the next item,
which is gonna be F to G of a weight 2.

32
00:02:07.859 --> 00:02:10.671
Since F's already a part
of a colored group,

33
00:02:10.671 --> 00:02:15.559
we'll call it red, that means G will
join him in this group, fantastic.

34
00:02:15.559 --> 00:02:18.429
So we do the next item, my goodness,
I just colored on myself.

35
00:02:18.429 --> 00:02:24.367
We do e E to C, so now, we go, hey, E,
E's in group red, C's in group green.

36
00:02:24.367 --> 00:02:27.922
We can totally add these two together,
they're a part of two different groups,

37
00:02:27.922 --> 00:02:29.343
therefore, we have no cycles.

38
00:02:33.912 --> 00:02:36.709
There we go, fantastic,
green, you're there,

39
00:02:36.709 --> 00:02:39.126
I just want green in there for
just a second.

40
00:02:39.126 --> 00:02:41.969
Even though it's my favorite color,
it just looks really bad on camera.

41
00:02:41.969 --> 00:02:45.389
All right, next we go e to g with 3, well,

42
00:02:45.389 --> 00:02:49.590
e is a part of group red,
g is a part of group red.

43
00:02:49.590 --> 00:02:52.023
If we were to add a line right here,
we'd create a cycle,

44
00:02:52.023 --> 00:02:54.800
you don't wanna add it,
we don't do that around here.

45
00:02:54.800 --> 00:02:56.720
All right, next one, where are we?

46
00:02:56.720 --> 00:03:01.844
We're right here, F to D,
D does not have a color, F has a color.

47
00:03:01.844 --> 00:03:06.934
Therefore, we can add, my goodness, that's
like the thinnest line I've ever done.

48
00:03:06.934 --> 00:03:11.494
There we go, we can go F to D,
now, we go again,

49
00:03:11.494 --> 00:03:15.564
we can go D to B,
D is in red, B is in red.

50
00:03:15.564 --> 00:03:19.878
Therefore, we do not add this, because
if we did, it would create a cycle.

51
00:03:19.878 --> 00:03:24.253
We're gonna go C to D, C is in red,
D is in red, we cannot add that.

52
00:03:24.253 --> 00:03:29.055
Therefore, we're gonna go B to A,
B is in red, A does not have a color, and

53
00:03:29.055 --> 00:03:31.968
boom, we just saw the line right here.

54
00:03:31.968 --> 00:03:35.024
Notice we created, again,
the exact same spanning tree, but

55
00:03:35.024 --> 00:03:38.546
Kruskal's algorithm is
really really simple, right?

56
00:03:38.546 --> 00:03:42.096
Like that one is way simpler than
whatever happened over here.

57
00:03:42.096 --> 00:03:44.757
Like this was a whole thing that
was really straightforward.

58
00:03:44.757 --> 00:03:48.155
And so it feels like
Kruskal's is really easy, but

59
00:03:48.155 --> 00:03:53.379
then you start thinking about how in
the heavens did we do this group coloring.

60
00:03:53.379 --> 00:03:58.026
Cuz that's like not easy, right,
that's a very hard problem.

61
00:03:58.026 --> 00:03:59.533
It's actually a pretty easy problem, okay?

62
00:03:59.533 --> 00:04:03.743
So, [LAUGH] the greatest turnaround ever,
all right, so

63
00:04:03.743 --> 00:04:09.033
we're gonna do what is called union find,
all right, union find.

64
00:04:09.033 --> 00:04:12.033
This is a pretty fantastic algorithm,
okay?

65
00:04:12.033 --> 00:04:19.025
So let's just imagine we take
this whole graph right here and

66
00:04:19.025 --> 00:04:24.368
we have A, B, C, D, E, that is not an E,

67
00:04:24.368 --> 00:04:28.774
F, G, [SOUND] all right, there we go.

68
00:04:28.774 --> 00:04:34.474
Now, I'm not gonna use this graph as a
guide, I'm just gonna use the same nodes.

69
00:04:34.474 --> 00:04:38.034
And they all point to each other,
they're all their own little group.

70
00:04:38.034 --> 00:04:41.140
A little group on to themselves,
how great is this?

71
00:04:41.140 --> 00:04:43.510
Everyone's happy, happy little groups, and

72
00:04:43.510 --> 00:04:46.199
now we want to start
unioning them together.

73
00:04:46.199 --> 00:04:49.514
So how that works is you have to
create something called a bijection,

74
00:04:49.514 --> 00:04:51.339
which is a fancy term for a mapping.

75
00:04:51.339 --> 00:04:54.587
So we're gonna have A map to something,
B map to something,

76
00:04:54.587 --> 00:04:58.730
C map to something and typically,m
you'd have them all in different order,

77
00:04:58.730 --> 00:05:00.981
because it makes the example more clear.

78
00:05:00.981 --> 00:05:08.374
So I'll say we're gonna
kind of reverse the order,

79
00:05:08.374 --> 00:05:13.750
so A = 7, let's see B = 4, C = 2,

80
00:05:13.750 --> 00:05:19.647
D= 1, E = 3, F =goes to what is left?

81
00:05:19.647 --> 00:05:23.044
5 and G = 6, honestly, you don't
have to do them in some crazy order,

82
00:05:23.044 --> 00:05:25.571
you could literally just make A1,
B2, C3, D4.

83
00:05:25.571 --> 00:05:30.148
But if I did that, you may not get what's
actually happening underneath the hood.

84
00:05:30.148 --> 00:05:35.122
Then I'm gonna have an array underneath
that has what group do I belong

85
00:05:35.122 --> 00:05:36.768
to in this array?

86
00:05:36.768 --> 00:05:41.646
So A has a 7, inside of it,
so position 7 has a 7,

87
00:05:41.646 --> 00:05:45.402
B, let's see, let's go backwards.

88
00:05:45.402 --> 00:05:49.734
So 6 goes to 6, 5 goes to 5, 4 goes to 4,

89
00:05:49.734 --> 00:05:53.838
3 goes to 3, 2 goes to 2, 1 goes to 1.

90
00:05:53.838 --> 00:05:57.623
And so if you look at the numbers, they
each match to that one, that's how you

91
00:05:57.623 --> 00:06:01.484
know it's a root node, it is its own color
is that when your index is the value.

92
00:06:01.484 --> 00:06:05.919
So 3 goes to 3, that means I
mapped myself, I am the root spot.

93
00:06:05.919 --> 00:06:10.954
We're all roots to begin with, so let's
just pretend we're gonna union E and G.

94
00:06:10.954 --> 00:06:15.162
So I start at E, I go, hey, E, let me
actually write each one of these numbers.

95
00:06:15.162 --> 00:06:16.584
My goodness,
we're gonna move this slightly.

96
00:06:18.014 --> 00:06:23.361
So much work, lost completely, all right,

97
00:06:23.361 --> 00:06:27.593
A, B, C, D, E, F, G, awesome.

98
00:06:27.593 --> 00:06:31.156
They're gonna map to themselves, to
themselves, to themselves, to themselves,

99
00:06:31.156 --> 00:06:33.740
to themselves, to themselves,
to themselves, all right.

100
00:06:33.740 --> 00:06:38.177
So this will be A, B, C D, E, F,

101
00:06:38.177 --> 00:06:41.667
G, okay,, fantastic,

102
00:06:41.667 --> 00:06:46.602
we see all these things now, right?

103
00:06:46.602 --> 00:06:50.705
Everyone's there, all right, so
we're gonna union, let's do E and G,

104
00:06:50.705 --> 00:06:53.321
we're gonna create a union
between these two.

105
00:06:53.321 --> 00:06:57.902
So I go to E and I say, hey, E is its own
parent, it's a 3, because I have a 3,

106
00:06:57.902 --> 00:07:00.279
it's a 3, it's a 3, its own parent.

107
00:07:00.279 --> 00:07:06.107
I go to G, G is a 6, its bijection
is also a 6, it's at its own parent.

108
00:07:06.107 --> 00:07:10.362
All right, so
therefore I'll just make G point to E,

109
00:07:10.362 --> 00:07:14.915
all right, fantastic, so
that means this becomes a 3.

110
00:07:14.915 --> 00:07:19.625
So now when I go to G, it says, hey,
different index, I jump to that index,

111
00:07:19.625 --> 00:07:21.110
it's now E, awesome.

112
00:07:21.110 --> 00:07:26.528
So let union B and C together,
B and C, exact same situation.

113
00:07:26.528 --> 00:07:29.801
I have no rhyme or reason which one I'm
picking right now, I'm just picking one.

114
00:07:29.801 --> 00:07:33.438
There we go, if you keep counts for
groups, you could always pick

115
00:07:33.438 --> 00:07:37.861
the group with the bigger count,
gets merged into versus the other way.

116
00:07:37.861 --> 00:07:40.581
There's extra things you could do,
but we're not gonna do that.

117
00:07:40.581 --> 00:07:46.631
So that means C now points to B, which is
4, all right, now, we're gonna do D and A.

118
00:07:47.731 --> 00:07:54.391
So A will point to D, so
A is 7, D is 1, so there we go.

119
00:07:54.391 --> 00:07:57.971
I think we have everything all mapped
out except for F, F is by itself.

120
00:07:57.971 --> 00:08:02.344
And so now if F, If we wanted to
join union D, we would take F and

121
00:08:02.344 --> 00:08:04.456
we pointed at D.

122
00:08:04.456 --> 00:08:08.146
And we do that by going hey F,
all right, position 5, that's still you,

123
00:08:08.146 --> 00:08:10.036
you're your own parent, D.

124
00:08:10.036 --> 00:08:12.199
Okay, point to you,
you're your own parent, so

125
00:08:12.199 --> 00:08:14.226
I'll just update F to point to that.

126
00:08:14.226 --> 00:08:17.370
Now, what happened if we
wanted A union B with A?

127
00:08:17.370 --> 00:08:22.239
This is where things get a little bit
wild, are they a part of the same group?

128
00:08:22.239 --> 00:08:26.329
Well, B goes to, did we not update?

129
00:08:26.329 --> 00:08:30.759
We didn't update, we didn't update B,
look, I actually did it backwards.

130
00:08:30.759 --> 00:08:35.583
Look at that, B's pointing to C, but
C's pointing to B, that's incorrect,

131
00:08:35.583 --> 00:08:38.188
I picked this intentionally, okay?

132
00:08:38.188 --> 00:08:43.286
So we go to B, B points to C, so we have
C as its parent, and then we go to A,

133
00:08:43.286 --> 00:08:48.068
A points to D, D points to itself,
so C, D two different groups.

134
00:08:48.068 --> 00:08:50.998
So therefore,
we can union these two groups together.

135
00:08:52.088 --> 00:08:54.963
So that means I'll just make,
which one were we doing again?

136
00:08:54.963 --> 00:08:58.672
Yeah, B and A, I'll simply make B,

137
00:08:58.672 --> 00:09:04.073
I'll make C instead of
pointing to itself point to D.

138
00:09:04.073 --> 00:09:09.576
Because we took the parent and redirected
the parent, so the parent becomes D.

139
00:09:09.576 --> 00:09:14.116
So that means B points to C,
C points the D, D points to itself,

140
00:09:14.116 --> 00:09:18.549
all right, so that is unioning,
and we can keep on going.

141
00:09:18.549 --> 00:09:22.569
What happens if we do E and B?

142
00:09:22.569 --> 00:09:26.087
Well, B points to C, C points to D,
so we're unioning B, and

143
00:09:26.087 --> 00:09:28.859
we're gonna also do, what did I say, E?

144
00:09:28.859 --> 00:09:32.076
E points to itself, therefore, we have E,
these are two different groups,

145
00:09:32.076 --> 00:09:33.139
we can now union them.

146
00:09:33.139 --> 00:09:36.821
I'll just pick the larger group,
cuz I can do that with my eyeballs,

147
00:09:36.821 --> 00:09:38.991
so it goes right here, E now Points do D.

148
00:09:38.991 --> 00:09:41.028
So that means if we were
to go to any of these,

149
00:09:41.028 --> 00:09:45.312
we can find which group are you part of,
if I say, hey, F, what group are you in?

150
00:09:45.312 --> 00:09:48.032
F goes to D, D goes to itself,
it's a part of D group.

151
00:09:48.032 --> 00:09:51.270
If I go to B, B points to C, C points
to D, it's part of the D group, and so

152
00:09:51.270 --> 00:09:53.602
you can tell right away
what group you're in.

153
00:09:53.602 --> 00:09:57.552
But still, this isn't necessarily
the most efficient algorithm.

154
00:09:57.552 --> 00:10:02.333
You can imagine a situation where you have
A points to B, B points to C, C points

155
00:10:02.333 --> 00:10:07.622
to D, D points to E, E points to F, and
it just becomes this really long path.

156
00:10:07.622 --> 00:10:10.627
That is where we have to apply
a second algorithm here.

157
00:10:10.627 --> 00:10:13.877
We're gonna apply a second
one called path compression.

158
00:10:16.269 --> 00:10:19.665
Now, this is pretty clever,
because if you think about it,

159
00:10:19.665 --> 00:10:24.535
as you walk this array, you're eventually
gonna find out who the parent is.

160
00:10:24.535 --> 00:10:29.117
So if you unwalk the array,
meaning that like say you use recursion,

161
00:10:29.117 --> 00:10:34.425
you'll be able to update every single
node along the path to point to the root.

162
00:10:34.425 --> 00:10:37.729
So let's do that again,
let's pretend we do path compression and

163
00:10:37.729 --> 00:10:40.766
we're gonna start with B,
and let's pretend F.

164
00:10:40.766 --> 00:10:44.542
Yeah, look, just my head's in here,
let's pretend F points to itself and

165
00:10:44.542 --> 00:10:45.370
B is right here.

166
00:10:45.370 --> 00:10:48.340
So we're gonna use path
compression to kind of fix this.

167
00:10:48.340 --> 00:10:51.990
So I'll write a very simple
little find parent, right?

168
00:10:51.990 --> 00:10:58.781
So find parent should literally
be as follows, if self-index,

169
00:10:58.781 --> 00:11:04.598
we have found it,
we will return out our index, right?

170
00:11:04.598 --> 00:11:08.139
Very, very simple, if we refer to
ourselves, we return ourselves out, else,

171
00:11:08.139 --> 00:11:10.168
I'm gonna move this code goes right here.

172
00:11:10.168 --> 00:11:12.645
This is like classic interview
white boarding right now,

173
00:11:12.645 --> 00:11:14.628
moving code all over the place.

174
00:11:14.628 --> 00:11:20.577
We're gonna like this,
root = find parent, right?

175
00:11:20.577 --> 00:11:24.455
We'll pretend you can grab the parent
index, whatever it is, find

176
00:11:24.455 --> 00:11:29.234
parent with the next one, it goes to the
next one, keeps on going, returns it out.

177
00:11:29.234 --> 00:11:34.089
And when we do that,
we'll do we'll call it

178
00:11:34.089 --> 00:11:38.562
like self.parent = root return root.

179
00:11:38.562 --> 00:11:42.356
So along the way back,
we update every single index.

180
00:11:42.356 --> 00:11:48.039
So if you had something
that looked like this,

181
00:11:48.039 --> 00:11:55.774
F, G, D, A, and we wanted to
union it with E, I didn't use E.

182
00:11:55.774 --> 00:11:58.965
I'm gonna use different letters now,

183
00:11:58.965 --> 00:12:03.420
cuz I forgot which ones I've already used,
H, I, J.

184
00:12:03.420 --> 00:12:07.702
So if we're like, hey,
union D and J, we'd go, okay,

185
00:12:07.702 --> 00:12:10.400
D goes to G, G goes to F, F goes to A.

186
00:12:10.400 --> 00:12:14.625
Therefore, update F to point to A,
therefore,

187
00:12:14.625 --> 00:12:19.467
update G to point to A,
therefore update D to point to A,

188
00:12:19.467 --> 00:12:25.255
we're unioning A, J, I, H, E,
update H, update I, update J.

189
00:12:25.255 --> 00:12:27.698
And now,
we've updated them all along the path.

190
00:12:27.698 --> 00:12:33.058
And so that means at any one point,
the path gets more and more compressed.

191
00:12:33.058 --> 00:12:36.097
Every single time you look it up,
you may hop a couple times, but

192
00:12:36.097 --> 00:12:38.606
the next time you'll never hop again.

193
00:12:38.606 --> 00:12:41.596
And so
it's amortized constant time lookup,

194
00:12:41.596 --> 00:12:46.826
you just have to look up the path
one time, that's it, pretty cool?

195
00:12:46.826 --> 00:12:52.001
Pretty neat, and so that's how you make
Kruskal's algorithm super efficient,

196
00:12:52.001 --> 00:12:56.501
but it's still dictated by this,
what is the runtime of any good sort?

197
00:12:56.501 --> 00:13:00.156
&gt;&gt; Nlogn.
&gt;&gt; Nlogn, boom, this is E though, so

198
00:13:00.156 --> 00:13:06.915
we do E log E, so Kruskal's gonna be E
log E, Prim's gonna be E log V proper.

199
00:13:06.915 --> 00:13:12.336
When I say proper, if you really think
about it, when you really think about it,

200
00:13:12.336 --> 00:13:16.825
the size of E is proportional to V
squared in worst case situation.

201
00:13:16.825 --> 00:13:21.703
It's technically V times V minus 1 over 2,
but don't worry about that,

202
00:13:21.703 --> 00:13:24.046
that's V squared still.

203
00:13:24.046 --> 00:13:27.036
Because you can just imagine
an adjacency matrix, and

204
00:13:27.036 --> 00:13:30.746
every single one has a 1 on it on
both sides of the adjacency matrix.

205
00:13:30.746 --> 00:13:33.833
So you have an adjacency matrix
completely filled up, therefore,

206
00:13:33.833 --> 00:13:35.356
there are V squared edges.

207
00:13:35.356 --> 00:13:39.474
So, if you wish to do some sweet math, you
could put a V squared in there, then move

208
00:13:39.474 --> 00:13:43.914
the square out here, and then be like,
the bullshit, get the 2 out of there.

209
00:13:43.914 --> 00:13:46.194
And then now, you got E log V,
but I feel like that's cheating.

210
00:13:46.194 --> 00:13:49.279
So I'm not gonna do that,
I feel cheated when I do that,

211
00:13:49.279 --> 00:13:50.864
it makes me upset and angry.

212
00:13:50.864 --> 00:13:56.424
So we're gonna keep it at E log E, all
right, there we go, that's the difference.

213
00:13:56.424 --> 00:13:58.168
So when should you use Kruskal's?

214
00:13:58.168 --> 00:14:02.715
Well, if you have a graph that's sparse,
sorting's not that expensive,

215
00:14:02.715 --> 00:14:06.538
it's pretty low, and
the algorithm's really simple.

216
00:14:06.538 --> 00:14:09.958
Well, I mean, sort of simple, right?

217
00:14:09.958 --> 00:14:12.068
But Prim's, it's kind of expensive, right?

218
00:14:12.068 --> 00:14:16.008
Like you're doing 2ElogV, then you're
also popping everything else off,

219
00:14:16.008 --> 00:14:17.963
which is like log|V|.

220
00:14:17.963 --> 00:14:21.191
And then you have to do that a whole
bunch, you have to do that V times, and so

221
00:14:21.191 --> 00:14:22.641
it's just there's a lot Prims.

222
00:14:22.641 --> 00:14:27.237
Because really what you're actually
seeing underneath the hood is you're

223
00:14:27.237 --> 00:14:29.255
actually seeing (E + V)logV.

224
00:14:29.255 --> 00:14:33.012
But since we had that whole E
is greater than or equal to V,

225
00:14:33.012 --> 00:14:34.827
this becomes irrelevant.

226
00:14:34.827 --> 00:14:36.800
And therefore,
you drop it off, cuz remember,

227
00:14:36.800 --> 00:14:38.546
you could technically put this V squared.

228
00:14:38.546 --> 00:14:42.790
And you do all that, and then you
always do the highest polynomial, and

229
00:14:42.790 --> 00:14:44.562
you get the idea, okay?

230
00:14:44.562 --> 00:14:50.932
Awesome, so that is tree stuff, we just
made more trees, we made trees and graphs.

231
00:14:50.932 --> 00:14:53.222
Everyone like that,
everyone's happy about that?

232
00:14:53.222 --> 00:14:54.760
Do we have any questions?

233
00:15:00.193 --> 00:15:01.953
Just some tree stuff,
you know what I'm talking about?

234
00:15:01.953 --> 00:15:04.319
Just a little bit of tree stuff.

235
00:15:04.319 --> 00:15:09.320
&gt;&gt; Is every graph problem something
that can be reduced to a tree?

236
00:15:09.320 --> 00:15:12.207
&gt;&gt; I don't know, I don't know
if that's true, we did see that,

237
00:15:12.207 --> 00:15:15.380
because not all trees are graphs,
not all graphs are trees, right?

238
00:15:15.380 --> 00:15:21.035
A tree is a directed acyclic graphm but
not all directed acyclic graphs are trees.

239
00:15:21.035 --> 00:15:23.543
It's kinda like the whole
square rectangle thing,

240
00:15:23.543 --> 00:15:27.305
you can imagine a graph that looks like
the following, why did I choose green?

241
00:15:27.305 --> 00:15:29.665
We already talked about how
we should not choose green.

242
00:15:29.665 --> 00:15:34.429
This is not a valid tree, but
that's a valid directed acyclic graph,

243
00:15:34.429 --> 00:15:36.393
no cycles, it is directed.

244
00:15:36.393 --> 00:15:41.792
There you go, so graphs can be trees, you
can't break all things down into trees,

245
00:15:41.792 --> 00:15:44.169
but you can break down some of them.

246
00:15:44.169 --> 00:15:47.832
And so this is pretty exciting, I like
this one, this one made me very excited,

247
00:15:47.832 --> 00:15:48.989
I really did enjoy this.

248
00:15:48.989 --> 00:15:54.886
All right, we have one more really
kick-ass graph algorithm coming up, okay?

249
00:15:54.886 --> 00:15:58.886
I hope everyone is very excited
about the graph algorithm.

