WEBVTT

1
00:00:00.130 --> 00:00:00.989
I could do a Q and A.

2
00:00:00.989 --> 00:00:03.222
Also use Vim.

3
00:00:03.222 --> 00:00:04.813
And if you don't
understand this course and

4
00:00:04.813 --> 00:00:07.500
it's too hard, remember I have
a first one that's for free forever.

5
00:00:07.500 --> 00:00:12.820
Free forever algorithms course
on frontendmasters.com.

6
00:00:12.820 --> 00:00:16.210
Aljean, so I'm reading the chat now.

7
00:00:16.210 --> 00:00:19.314
&gt;&gt; Is there any specific reason
you use three hash functions?

8
00:00:19.314 --> 00:00:21.838
&gt;&gt; No,
I just did Grab a set of hash functions.

9
00:00:21.838 --> 00:00:26.071
&gt;&gt; Over sufficient over a sufficiently
large period of time wouldn't we always

10
00:00:26.071 --> 00:00:27.568
say things are available or

11
00:00:27.568 --> 00:00:30.771
shouldn't there be a strategy
to clear the bloom filter?

12
00:00:30.771 --> 00:00:32.217
&gt;&gt; So that would be where you a,

13
00:00:32.217 --> 00:00:35.834
if you have a sufficiently large amount
of data like a megabyte of ones,

14
00:00:35.834 --> 00:00:39.753
is a million ones, and so depending on
how many index points you get per item,

15
00:00:39.753 --> 00:00:43.229
it should be pretty sparse for
a while, it obviously at some point.

16
00:00:43.229 --> 00:00:46.713
I mean, again, these are like more
practical questions which is how long do

17
00:00:46.713 --> 00:00:49.991
you keep something running before
you reset it, is the reset worth it?

18
00:00:49.991 --> 00:00:51.658
Meaning that you don't go and
check things up.

19
00:00:51.658 --> 00:00:56.492
So you got to play with that because if
you're actually using when you're using it

20
00:00:56.492 --> 00:01:01.393
to try to speed up a system practically,
which means that there is no right answer,

21
00:01:01.393 --> 00:01:04.326
it depends on the problem and
how much memory.

22
00:01:04.326 --> 00:01:06.736
I hope at the end of this you never
wanna look at algorithms again.

23
00:01:06.736 --> 00:01:09.616
We just went way hard and
you're just like, that's it,

24
00:01:09.616 --> 00:01:12.236
and you just never wanna do it again.

25
00:01:12.236 --> 00:01:14.846
That's why the other one's the one
you need because you want that for

26
00:01:14.846 --> 00:01:17.606
interviewing, this one's the one you
want to stop wanting ever again.

27
00:01:21.183 --> 00:01:24.521
&gt;&gt; Could you briefly describe the
difference between dynamic programming and

28
00:01:24.521 --> 00:01:25.103
recursion?

29
00:01:26.223 --> 00:01:30.699
&gt;&gt; Yeah, recursion uses a stack and
calls itself and you may solve the same

30
00:01:30.699 --> 00:01:36.233
sub-problem multiple times, as we saw with
Fibonacci, over and over and over again.

31
00:01:37.393 --> 00:01:39.708
&gt;&gt; Are there any drawbacks
to dynamic program?

32
00:01:39.708 --> 00:01:42.418
&gt;&gt; It's hard, it's really hard.

33
00:01:42.418 --> 00:01:46.111
Like really good dynamic programming
problems are hard until you understand it,

34
00:01:46.111 --> 00:01:47.188
then it's simple.

35
00:01:47.188 --> 00:01:50.380
And so if you actually had like if
you really did a dynamic programming

36
00:01:50.380 --> 00:01:52.691
problem for your job, for
somebody to look at it,

37
00:01:52.691 --> 00:01:55.128
they'd be like,
what the hell am I even looking at?

38
00:01:55.128 --> 00:01:56.288
This makes no sense.

39
00:01:56.288 --> 00:02:01.028
And so until they understand it,
you completely don't understand it.

40
00:02:01.028 --> 00:02:02.568
Recursion tends to be really elegant,
right?

41
00:02:02.568 --> 00:02:06.150
You can look at it and just totally
understand everything that's happening,

42
00:02:06.150 --> 00:02:07.028
and so it's nice.

43
00:02:08.128 --> 00:02:11.418
Skill issues, dynamic programming
is the epitome of skill issues.

44
00:02:12.698 --> 00:02:17.803
&gt;&gt; Do you think that there's like
a particular area of math study,

45
00:02:17.803 --> 00:02:22.247
combinatorics, something
like that that would lend to

46
00:02:22.247 --> 00:02:26.703
understanding dynamic
programming problems better?

47
00:02:26.703 --> 00:02:28.903
&gt;&gt; I don't know,
I don't know if that's true.

48
00:02:28.903 --> 00:02:31.463
At one point that was pretty
good at the old combinatorics.

49
00:02:31.463 --> 00:02:33.593
I can't remember any of that stuff
at this point, the permutation.

50
00:02:33.593 --> 00:02:36.034
I could use to do the 5C4 and
be able to tell you all that stuff,

51
00:02:36.034 --> 00:02:39.563
now I can't remember any of that stuff,
it's been too long since discrete math.

52
00:02:39.563 --> 00:02:40.748
But that never helped me.

53
00:02:40.748 --> 00:02:46.735
I never personally got help from it,
discrete math didn't do a lot for me.

54
00:02:46.735 --> 00:02:47.745
&gt;&gt; Got you.

55
00:02:47.745 --> 00:02:50.847
&gt;&gt; I think one of the problems is
I also took discrete math before I

56
00:02:50.847 --> 00:02:52.798
took a data structure course.

57
00:02:52.798 --> 00:02:56.252
And so I solving all these theoretical
problems that I never actually seen

58
00:02:56.252 --> 00:02:59.384
before, and then all of a sudden
it was really hard to relate that.

59
00:02:59.384 --> 00:03:03.080
And then when I did the data structures
course, I looked back on the on

60
00:03:03.080 --> 00:03:07.188
the discrete math I was like,
that makes perfect sense why you do that?

61
00:03:07.188 --> 00:03:10.564
And then it was like really valuable but

62
00:03:10.564 --> 00:03:14.562
that's like such a value
in the past problem.

63
00:03:14.562 --> 00:03:16.182
&gt;&gt; Where do you work?

64
00:03:16.182 --> 00:03:17.439
&gt;&gt; I work at Netflix, by the way.

65
00:03:20.213 --> 00:03:23.242
Okay, I'm almost at my ten-year
anniversary, okay, and Netflix.

66
00:03:23.242 --> 00:03:24.845
At some point I'm not
gonna work at Netflix,

67
00:03:24.845 --> 00:03:27.702
I won't be able to say that anymore and
it'll be a sad day.

68
00:03:27.702 --> 00:03:30.052
By the way, just casual flex,
not a big deal, whatever.

69
00:03:31.512 --> 00:03:35.139
&gt;&gt; What language do you think lends
itself well to implementing these kinds

70
00:03:35.139 --> 00:03:36.502
of things?

71
00:03:36.502 --> 00:03:38.272
&gt;&gt; Any language but Rust.

72
00:03:38.272 --> 00:03:42.237
Rust is a horrible language to implement
data structures in, it's just awful,

73
00:03:42.237 --> 00:03:43.832
it's just awful.

74
00:03:43.832 --> 00:03:47.318
It's just the worst thing in the universe,
don't do Rust and data structures, okay?

75
00:03:47.318 --> 00:03:49.662
You'll get stuck on a linked list and
then you'll quit.

76
00:03:49.662 --> 00:03:52.887
C is great because C gives
you the actual picture, but

77
00:03:52.887 --> 00:03:57.132
you can also use things like,
you can use TypeScript, you can use Go.

78
00:03:57.132 --> 00:04:01.244
Go kind of sucks cuz Go doesn't have a
really strong generics and methods, and so

79
00:04:01.244 --> 00:04:03.432
it's just like it's not as good for this.

80
00:04:03.432 --> 00:04:07.866
C, TypeScript,
those are really easy ones to do.

81
00:04:07.866 --> 00:04:10.274
&gt;&gt; I did your previous one in C Sharp.

82
00:04:10.274 --> 00:04:13.659
&gt;&gt; Okay, C Sharp would be a good one,
Java, great one to do these things in,

83
00:04:13.659 --> 00:04:16.006
they're very concrete and simple.

84
00:04:16.006 --> 00:04:19.422
OCaml, I don't know OCaml good
enough to know if OCaml is great for

85
00:04:19.422 --> 00:04:20.536
this kind of stuff.

86
00:04:20.536 --> 00:04:23.597
I assume it is because it has a really
strong type system, and it's garbage

87
00:04:23.597 --> 00:04:26.669
collected, which means you can do all
the things that Rust can't easily.

88
00:04:26.669 --> 00:04:30.271
All right, so there you go,
that is the entirety of the course,

89
00:04:30.271 --> 00:04:32.359
that's what I wanted to go through.

90
00:04:32.359 --> 00:04:36.301
I really wanted to emphasize the fun stuff
at the beginning, the trees, the graphs,

91
00:04:36.301 --> 00:04:38.839
and really kinda dive a little
bit into some analysis.

92
00:04:38.839 --> 00:04:42.746
Hopefully, you like the Prim's algorithm
analysis where we actually broke it down

93
00:04:42.746 --> 00:04:44.186
and went several levels down.

94
00:04:44.186 --> 00:04:46.022
I really liked union
find path compression,

95
00:04:46.022 --> 00:04:49.262
that's a pretty useful algorithm just to
know because there are times where you

96
00:04:49.262 --> 00:04:52.579
want to be able to shortcut something but
you don't wanna always be able to do it.

97
00:04:52.579 --> 00:04:55.017
B-trees, super, super-duper useful.

98
00:04:55.017 --> 00:04:58.225
You could imagine you have you can have,
there's just situations,

99
00:04:58.225 --> 00:05:01.046
I've ran into these range to
binary trees where I want to have

100
00:05:01.046 --> 00:05:04.086
a binary tree that has ranges to be
able to find quick values out and

101
00:05:04.086 --> 00:05:07.238
spend super useful to use
concepts like it or M -Way trees.

102
00:05:07.238 --> 00:05:08.918
So hopefully everyone learned something.

103
00:05:08.918 --> 00:05:09.918
Does everyone feel pretty good?

104
00:05:09.918 --> 00:05:13.405
Do you feel like you've gotten smarter,
faster, stronger?

105
00:05:13.405 --> 00:05:15.292
All right, fantastic.

106
00:05:15.292 --> 00:05:17.689
Well, the name,
&gt;&gt; [APPLAUSE]

107
00:05:17.689 --> 00:05:18.895
&gt;&gt; Right there, is the Prime Jam.

108
00:05:18.895 --> 00:05:20.278
All right, thank you, appreciate that.

