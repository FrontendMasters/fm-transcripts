WEBVTT

1
00:00:00.022 --> 00:00:02.594
So let's talk about the next
most important point,

2
00:00:02.594 --> 00:00:04.119
which is gonna be traversals.

3
00:00:04.119 --> 00:00:07.444
We're gonna talk about this several
times throughout the day, and

4
00:00:07.444 --> 00:00:09.610
the order of traversals
makes a big impact.

5
00:00:09.610 --> 00:00:12.738
So I'm just gonna put out
another tree right here, and

6
00:00:12.738 --> 00:00:15.468
we're gonna talk about
the three traversals.

7
00:00:15.468 --> 00:00:18.870
All right, I guess I should have just
left it up, but what can you do?

8
00:00:18.870 --> 00:00:26.294
Okay, you can't win them all,
27, we'll do 10, 15, and 3.

9
00:00:26.294 --> 00:00:28.538
All right, so
there are three types of traversals.

10
00:00:28.538 --> 00:00:33.777
There's a pre-order, which we will not do
anything that requires pre-order today,

11
00:00:33.777 --> 00:00:35.842
I'm sure we could use something.

12
00:00:35.842 --> 00:00:38.380
I'm sure you could do la module
system with pre-ordering,

13
00:00:38.380 --> 00:00:40.284
I just don't know about it yet.

14
00:00:40.284 --> 00:00:44.414
Then we're gonna have in-order,
and then, we'll do post-order.

15
00:00:46.214 --> 00:00:51.231
So what that means is that, there's really
just three operations you do in any

16
00:00:51.231 --> 00:00:56.414
search in a binary tree, is that you will
go down the left-hand side of the node.

17
00:00:57.904 --> 00:01:03.574
You'll go down the right-hand side of
a node, or you will visit the node.

18
00:01:03.574 --> 00:01:07.204
Right, like this right
here is a traversal.

19
00:01:07.204 --> 00:01:09.824
This right here is a post-order traversal.

20
00:01:09.824 --> 00:01:12.828
Meaning that I'm gonna go down the left
side, I'm gonna go down the right side,

21
00:01:12.828 --> 00:01:14.244
and then I'll visit the node.

22
00:01:14.244 --> 00:01:17.172
So let's just pretend that visiting
the node, adds it to a list, and

23
00:01:17.172 --> 00:01:19.784
we print out that list at
the end of the traversal.

24
00:01:19.784 --> 00:01:20.570
So what does that look like?

25
00:01:20.570 --> 00:01:21.802
We'd start right here.

26
00:01:21.802 --> 00:01:23.736
What do we do first?

27
00:01:23.736 --> 00:01:25.891
&gt;&gt; We go left.
&gt;&gt; We go left, okay?

28
00:01:25.891 --> 00:01:27.460
We go here, what do we do next?

29
00:01:27.460 --> 00:01:27.995
&gt;&gt; We go left.

30
00:01:27.995 --> 00:01:31.340
&gt;&gt; Left, all right, we go here,
we go left, there's nothing here, so

31
00:01:31.340 --> 00:01:32.662
we go back up, we go right.

32
00:01:32.662 --> 00:01:36.441
There's nothing here,
we then visit the three.

33
00:01:36.441 --> 00:01:39.835
We go back up, we go to the 10, we go to
the 15, we go to its child, nothing there,

34
00:01:39.835 --> 00:01:41.415
nothing there, come back to the 15.

35
00:01:41.415 --> 00:01:44.991
And then, we're able to say, hey, there's
15, then we go back up, we hit the 10,

36
00:01:44.991 --> 00:01:47.885
the 10 now has gone left and right,
so therefore, we write the 10.

37
00:01:47.885 --> 00:01:53.115
We go to the 20, go to the 25,
go to the 23, nothing, nothing, 23.

38
00:01:53.115 --> 00:01:57.625
Go back up 27, 27 has no children.

39
00:01:57.625 --> 00:02:01.209
So therefore, we write that out,
we go to 25, 25 now gets printed out,

40
00:02:01.209 --> 00:02:03.486
then we go to 20, 20 gets printed out.

41
00:02:03.486 --> 00:02:05.539
This is called a post-order traversal.

42
00:02:05.539 --> 00:02:06.916
This should be pretty obvious, why?

43
00:02:06.916 --> 00:02:08.836
It's because we visit last.

44
00:02:09.846 --> 00:02:15.598
So, if we were to simply move this up
once, we'll do an in-order traversal,

45
00:02:15.598 --> 00:02:19.710
meaning, we go left,
then we visit, then we go right.

46
00:02:19.710 --> 00:02:23.037
So let's just see the difference
in values when we do that.

47
00:02:23.037 --> 00:02:26.819
So we start here at 20, we go to the left,
to 10, go to the left, 3,

48
00:02:26.819 --> 00:02:31.578
go to the left nothing, print out 3,
all right, hey, same value to begin with.

49
00:02:31.578 --> 00:02:37.068
Go back up to the 10, print out the 10,
go to the 15, left, right, 15.

50
00:02:37.068 --> 00:02:42.625
Up to the 20, print out the 20.

51
00:02:42.625 --> 00:02:47.285
To the 25, to the 23,
nothing on the left, print out the 23.

52
00:02:47.285 --> 00:02:52.733
Go to the right, nothing on the right,
25, print out the 25.

53
00:02:52.733 --> 00:02:56.902
To this side, left 27.

54
00:02:56.902 --> 00:02:58.815
Let me fix that 5, that's a terrible 5.

55
00:02:58.815 --> 00:03:00.856
Nothing here and back up the tree.

56
00:03:00.856 --> 00:03:03.346
Notice what happened with our numbers.

57
00:03:03.346 --> 00:03:05.252
Our numbers are in-order.

58
00:03:05.252 --> 00:03:08.570
You wanna guess where they got
the term in-order traversal from?

59
00:03:08.570 --> 00:03:13.816
If you have a binary search tree
it produces in order, make sense?

60
00:03:13.816 --> 00:03:17.739
Yes, that should make sense because we
know to the left is always less than.

61
00:03:17.739 --> 00:03:20.927
So we first go to the littlest node,
visit that, and

62
00:03:20.927 --> 00:03:24.047
then start slowly going to
the bigger side as we go.

63
00:03:24.047 --> 00:03:27.276
So this should hopefully make sense,
we're not gonna do pre-order traversal.

64
00:03:27.276 --> 00:03:29.857
I think you guys can guess
what pre-order traversal does.

65
00:03:29.857 --> 00:03:34.205
We put the visit at the top,
so we print out that first, so

66
00:03:34.205 --> 00:03:38.475
it'd go 20, 10, 3, 15, 25, 23, 27.

67
00:03:38.475 --> 00:03:40.975
And so, it just kind of goes that way,
is that useful?

68
00:03:40.975 --> 00:03:43.607
I don't know, I don't know any
applications for pre-order traversal,

69
00:03:43.607 --> 00:03:44.701
I just know it exists.

70
00:03:44.701 --> 00:03:46.289
I've never had to use that yet.

71
00:03:46.289 --> 00:03:49.451
But, there you go, so
this is binary search tree traversal.

72
00:03:49.451 --> 00:03:52.986
Do we have any questions for this?

73
00:03:52.986 --> 00:03:57.867
&gt;&gt; Just kind of a general question,
I can understand the concepts clearly, but

74
00:03:57.867 --> 00:04:02.540
when reading a question and trying to
translate this actually into code.

75
00:04:02.540 --> 00:04:04.810
Do you have any suggestions for
how to do that?

76
00:04:05.810 --> 00:04:08.328
&gt;&gt; Yeah,
like how to translate this into code.

77
00:04:08.328 --> 00:04:10.670
First thing you gotta think of
is how do you represent a note?

78
00:04:10.670 --> 00:04:13.559
There are several different ways
depending on that, there are strategies.

79
00:04:13.559 --> 00:04:16.827
So the first thing I usually start off
with, just simply the representation.

80
00:04:16.827 --> 00:04:19.992
So, node of some sort of value t, right?

81
00:04:19.992 --> 00:04:22.851
We don't know what the value is
inside of every single node,

82
00:04:22.851 --> 00:04:26.494
you're gonna have a left,
that's gonna be potentially null, right?

83
00:04:26.494 --> 00:04:30.391
And it's also gonna be a node t,
you're gonna have a right,

84
00:04:30.391 --> 00:04:34.244
exact same thing,
it may not exist, node, right?

85
00:04:34.244 --> 00:04:36.769
And then, you're gonna have a value,

86
00:04:36.769 --> 00:04:40.299
which is whatever the type
is being held within there.

87
00:04:40.299 --> 00:04:43.989
So long as you see that, the rest
should become more and more obvious.

88
00:04:43.989 --> 00:04:47.923
If you had to do a pre-order traversal,
well, you just start with a node,

89
00:04:47.923 --> 00:04:51.645
you visit it, then you go to its left and
call the same function.

90
00:04:51.645 --> 00:04:55.382
It keeps on doing that, when it's done,
you call right, you keep on doing that,

91
00:04:55.382 --> 00:04:56.895
and you're kind of done.

92
00:04:56.895 --> 00:05:00.830
And so, for me, representation usually is
the first step to understanding a problem,

93
00:05:00.830 --> 00:05:03.224
as long as you know what
shapes you're working with,

94
00:05:03.224 --> 00:05:06.999
the rest isn't too hard because now
you're literally just going left, left.

95
00:05:06.999 --> 00:05:10.363
Well, I'm walking left until
there's nothing left to walk on.

96
00:05:10.363 --> 00:05:11.539
And so, it just becomes easy.

97
00:05:11.539 --> 00:05:13.555
So once you kind of make that jump, and

98
00:05:13.555 --> 00:05:16.650
it takes a few programming
experiences to make that jump.

99
00:05:16.650 --> 00:05:20.509
Then implementing data structures become
excessively easy as opposed to really,

100
00:05:20.509 --> 00:05:21.177
really hard.

101
00:05:21.177 --> 00:05:24.771
As you get to the more advanced ones
like Prim's algorithm or Kruskal's,

102
00:05:24.771 --> 00:05:26.776
they just involve a lot more programing.

103
00:05:26.776 --> 00:05:30.944
And then, all of a sudden, you also get
a much wider choice of kind of the data

104
00:05:30.944 --> 00:05:32.981
structures you use in combination.

105
00:05:32.981 --> 00:05:36.494
So something to think about, fun times.

106
00:05:36.494 --> 00:05:40.280
&gt;&gt; And what if the number
three was the number 28?

107
00:05:40.280 --> 00:05:44.180
&gt;&gt; What if the number 3 was 28?

108
00:05:44.180 --> 00:05:48.110
We would have a very lovely binary tree.

109
00:05:48.110 --> 00:05:52.498
It just wouldn't be a binary search tree,
cuz it has broken the fundamental rule of

110
00:05:52.498 --> 00:05:56.214
this should always be less than,
cuz this is not less than its parent.

111
00:05:56.214 --> 00:05:59.846
So therefore, it's not a binary search
tree, this is just a binary tree.

112
00:05:59.846 --> 00:06:03.816
Great times, everyone has two children,
or one child, or no child,

113
00:06:03.816 --> 00:06:05.845
and filled with all the same types.

114
00:06:05.845 --> 00:06:08.681
So, nothing unique about it,
you couldn't use it for searching,

115
00:06:08.681 --> 00:06:10.140
it'd be kind of a worthless tree.

116
00:06:10.140 --> 00:06:12.712
I'm not even sure why you'd use just
a binary tree at that point other than

117
00:06:12.712 --> 00:06:14.511
you're just displaying
something in a document.

118
00:06:14.511 --> 00:06:17.415
Then you just become a general tree,
which then you just become the DOM, right?

119
00:06:17.415 --> 00:06:19.552
That's what the DOM is,
it's just a tree with a bunch of children.

120
00:06:19.552 --> 00:06:23.432
Once you understand that, all of a sudden
the DOM becomes a little bit easier.

121
00:06:23.432 --> 00:06:27.082
All right, no more questions for now.

122
00:06:27.082 --> 00:06:28.678
Well, we'll do more.

123
00:06:28.678 --> 00:06:29.907
Don't worry, we're gonna do more.

124
00:06:29.907 --> 00:06:31.122
Okay, we're looking pretty good.

125
00:06:31.122 --> 00:06:34.047
So, I do wanna talk about,
just in case we have to use these terms,

126
00:06:34.047 --> 00:06:36.522
I want you to make sure
that you know them.

127
00:06:36.522 --> 00:06:40.316
So, this right here is obviously,
we often call this the root.

128
00:06:40.316 --> 00:06:43.881
So this would be the root, it's just
a node, it has no special designation.

129
00:06:43.881 --> 00:06:47.608
I've been in classes where the teacher
tries to make it such that the root is

130
00:06:47.608 --> 00:06:49.204
special, and so, therefore,

131
00:06:49.204 --> 00:06:53.365
you have a class that represents the root,
and then a class that represents nodes.

132
00:06:53.365 --> 00:06:57.656
No, I mean every single, if you think
about it, this is a root right here.

133
00:06:57.656 --> 00:07:02.286
It is the root of a subtree, they're all
all the same thing, that's just that.

134
00:07:02.286 --> 00:07:04.436
Typically, we call these things nodes.

135
00:07:04.436 --> 00:07:07.803
Typically people think
of this as directed,

136
00:07:07.803 --> 00:07:11.353
meaning that you never
traverse back up a tree.

137
00:07:11.353 --> 00:07:13.167
Even though that's not technically true,

138
00:07:13.167 --> 00:07:15.616
you don't typically
traverse back up a tree.

139
00:07:15.616 --> 00:07:18.816
All right, you let recursion do
the recusing back up the tree.

140
00:07:18.816 --> 00:07:23.282
All right, now that we have that kind
of figured out, the next thing is that,

141
00:07:23.282 --> 00:07:26.582
besides for the root,
if we're looking at this person,

142
00:07:26.582 --> 00:07:32.211
this would be called the parent, the
uncle, the children, these are siblings.

143
00:07:32.211 --> 00:07:34.961
So that's usually what we say
when we say all these phrases.

144
00:07:34.961 --> 00:07:39.044
And so, if I say, hey, a sibling,
the left sibling, I'm meaning,

145
00:07:39.044 --> 00:07:42.035
this person's same level,
same parent, child.

146
00:07:42.035 --> 00:07:45.112
And so, can you kind of get it
because we all understand a family?

147
00:07:45.112 --> 00:07:48.674
So it kind of mostly makes sense,
they describe it in familial terms.

148
00:07:48.674 --> 00:07:52.580
All right, there we go, I think that's
pretty much everything you will need to

149
00:07:52.580 --> 00:07:54.518
know to just excel and crush this course

