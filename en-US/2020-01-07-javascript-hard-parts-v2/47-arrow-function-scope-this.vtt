WEBVTT

1
00:00:00.003 --> 00:00:03.911
&gt;&gt; Will Sentance: I think this is
the scope of nice moment to see

2
00:00:03.911 --> 00:00:09.500
the increasingly more standard
way of doing this nowadays.

3
00:00:09.500 --> 00:00:15.400
That uses this feature of a new
way of defining or declaring or

4
00:00:15.400 --> 00:00:20.851
saving functions in JavaScript
that we saw yesterday.

5
00:00:20.851 --> 00:00:23.630
Which was our arrow function style.

6
00:00:23.630 --> 00:00:26.975
Cuz our arrow function style,
of declaring or

7
00:00:26.975 --> 00:00:31.790
saving functions,
&gt;&gt; Will Sentance: Automatically,

8
00:00:31.790 --> 00:00:36.030
I'm gonna tell you right now,
is lexically scoped.

9
00:00:36.030 --> 00:00:40.750
That means where we save the function or,
let me set that clear on that, no, sorry.

10
00:00:40.750 --> 00:00:44.490
Is, it's this assignment
is lexically scoped.

11
00:00:44.490 --> 00:00:48.130
That is to say, when we save the function,
when we execute it,

12
00:00:48.130 --> 00:00:53.010
what this is set to is determined
by where the function was saved.

13
00:00:53.010 --> 00:00:56.730
So if it was saved where this is user 1,
when we end up running it,

14
00:00:56.730 --> 00:01:01.240
this inside will be this value from where
the function was saved, which is User1.

15
00:01:01.240 --> 00:01:02.720
So let's just see that example here.

16
00:01:03.720 --> 00:01:06.970
We've defined in now with an arrow
function, let's make this slight change.

17
00:01:06.970 --> 00:01:10.700
Let's quickly execute it together,
one more time, make sure we've got it.

18
00:01:10.700 --> 00:01:14.580
Let's quickly execute it one more time,
so we're executing here.

19
00:01:14.580 --> 00:01:15.800
These are little intricacies here, but

20
00:01:15.800 --> 00:01:18.290
little fun bonus bits I wanted
to include for you all.

21
00:01:18.290 --> 00:01:21.530
So we're running user1.increment.

22
00:01:21.530 --> 00:01:26.170
It runs the increment method
from function store via user1.

23
00:01:26.170 --> 00:01:28.210
I said you go through that quickly.

24
00:01:28.210 --> 00:01:30.590
Dan, user1.increment, user1 is in?

25
00:01:30.590 --> 00:01:31.680
&gt;&gt; Speaker 2: Global memory.

26
00:01:32.710 --> 00:01:36.290
&gt;&gt; Will Sentance: Global memory, we look
for the increment method, is it there?

27
00:01:36.290 --> 00:01:38.650
&gt;&gt; Speaker 2: Nope, so
we go to the proto, and

28
00:01:38.650 --> 00:01:41.460
let me find it in the user
function should store object.

29
00:01:41.460 --> 00:01:44.700
&gt;&gt; Will Sentance: Fantastic, we grab
its code, and we thought executing it.

30
00:01:44.700 --> 00:01:47.378
And the first thing and
local memory Dan is?

31
00:01:47.378 --> 00:01:51.677
&gt;&gt; Speaker 2: Constant at 1, this.

32
00:01:51.677 --> 00:01:53.981
&gt;&gt; Will Sentance: Yeah,
as a parameter, no problem, which is?

33
00:01:53.981 --> 00:01:54.837
&gt;&gt; Speaker 2: User1.
&gt;&gt; Will Sentance: Which is what

34
00:01:54.837 --> 00:01:56.886
we hope because that's what
we're running this function

35
00:01:56.886 --> 00:01:59.160
owns that we hope it's
going to affect this.

36
00:01:59.160 --> 00:02:01.610
We always wanna have our functionality and
our data.

37
00:02:01.610 --> 00:02:04.320
Able to use the functionality
directly on the data right there and

38
00:02:04.320 --> 00:02:06.330
then that's the kind of
the whole goal of this.

39
00:02:06.330 --> 00:02:08.240
So don't forget that as we go
into these intricacies and

40
00:02:08.240 --> 00:02:10.240
don't forget that overall goal.

41
00:02:10.240 --> 00:02:11.780
This is what a fantastic looking good.

42
00:02:13.380 --> 00:02:14.668
Let's declare that function Dan.

43
00:02:14.668 --> 00:02:18.110
&gt;&gt; Speaker 2: add1 and.

44
00:02:18.110 --> 00:02:20.710
&gt;&gt; Will Sentance: In the arrow
function style, but it's no different.

45
00:02:20.710 --> 00:02:21.399
There it is.

46
00:02:22.900 --> 00:02:24.740
And we immediately do what with it, Dan?

47
00:02:24.740 --> 00:02:26.046
&gt;&gt; Speaker 2: We call it, e execute it.

48
00:02:26.046 --> 00:02:28.420
&gt;&gt; Will Sentance: We call it,
e execute it.

49
00:02:28.420 --> 00:02:30.180
Brand new what, Dan?

50
00:02:30.180 --> 00:02:31.095
&gt;&gt; Speaker 2: Execution kinda.

51
00:02:31.095 --> 00:02:36.380
&gt;&gt; Will Sentance: Execution beautiful,
and in it's local memory.

52
00:02:36.380 --> 00:02:38.440
Because it's an arrow function.

53
00:02:38.440 --> 00:02:43.630
Let me put like a, I don't know, it's not really necessary,
it's in our function.

54
00:02:43.630 --> 00:02:51.420
It's this assignment inside the local
memory, will it be global because note,

55
00:02:51.420 --> 00:02:56.420
our one simple rule is any function
that's being run to the right hand side

56
00:02:56.420 --> 00:02:59.330
of the dot whatever the left hand side
that's going to be the list assignment.

57
00:02:59.330 --> 00:03:02.890
But when there's no dot here,
it defaults the global to the window.

58
00:03:04.430 --> 00:03:07.630
Unless that function was
defined as an arrow function,

59
00:03:07.630 --> 00:03:11.570
in which case Dan our this
assignment will be what?

60
00:03:11.570 --> 00:03:12.450
&gt;&gt; Speaker 2: User1 still.

61
00:03:12.450 --> 00:03:17.193
&gt;&gt; Will Sentance: User one, exactly what
was this assignment around the definition

62
00:03:17.193 --> 00:03:19.489
of that 1 is lexically scoped.

63
00:03:19.489 --> 00:03:21.770
It staticly the scope, this assignment.

64
00:03:21.770 --> 00:03:24.720
It's a statically or lexically this
assignment, that is to say it's from

65
00:03:24.720 --> 00:03:30.840
the moment of definition that
we set our this to User1.

66
00:03:30.840 --> 00:03:36.180
Therefore, our line of
code this.score plus plus,

67
00:03:36.180 --> 00:03:38.206
is going to evaluate to what Todd, now?

68
00:03:38.206 --> 00:03:41.425
&gt;&gt; Speaker 2: User1.score++.

69
00:03:41.425 --> 00:03:46.185
&gt;&gt; Will Sentance: Fantastic,
user1.score++.

70
00:03:46.185 --> 00:03:48.070
You gotta go a few levels out.

71
00:03:48.070 --> 00:03:52.660
1, 2, 3, there's our score property.

72
00:03:52.660 --> 00:03:56.993
It would increment to four but,
let's increment it to,

73
00:03:58.760 --> 00:04:01.989
&gt;&gt; Will Sentance: 5, fantastic people.

74
00:04:01.989 --> 00:04:05.466
This now I think is a nice way
of solving this problem for

75
00:04:05.466 --> 00:04:07.459
writing this clean code here.

76
00:04:07.459 --> 00:04:13.610
All right people, let's have to
start with thumbs here at this point

77
00:04:13.610 --> 00:04:17.440
on any of those bonus pieces anyone want
to add any thumbs, yeah, go ahead Peter.

78
00:04:17.440 --> 00:04:20.390
&gt;&gt; Speaker 2: Would
declaring the increment

79
00:04:20.390 --> 00:04:24.850
property as an arrow
function as well help us?

80
00:04:24.850 --> 00:04:26.050
&gt;&gt; Will Sentance: Would it though?

81
00:04:26.050 --> 00:04:30.020
Because if we did so,
when we ran that increment.

82
00:04:30.020 --> 00:04:34.370
So Peter's question there is what if we
say an increment as an arrow function?

83
00:04:35.900 --> 00:04:41.165
If we ran it, would it's this assignment
be determined by where it's being run

84
00:04:41.165 --> 00:04:46.366
to the right hand side of the dot or by
where it was stored, which was in global?

85
00:04:46.366 --> 00:04:49.737
By where it was stored, and therefore
the whole thing would fall apart.

86
00:04:49.737 --> 00:04:51.587
And now this will not be User1.

87
00:04:51.587 --> 00:04:54.787
So we don't want to use arrow
functions for our include for

88
00:04:54.787 --> 00:04:56.168
our methods on objects.

89
00:04:56.168 --> 00:04:59.668
But for the functions inside of them
that we want to have point there this to

90
00:04:59.668 --> 00:05:02.047
the method in which they were defined,
perfect.

