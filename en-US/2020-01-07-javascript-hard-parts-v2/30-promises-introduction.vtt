WEBVTT

1
00:00:00.050 --> 00:00:06.029
&gt;&gt; Will Sentance: So we are now going to
move onto what changed in the ES2015 and

2
00:00:06.029 --> 00:00:07.035
on world.

3
00:00:07.035 --> 00:00:07.967
The ES6 world.

4
00:00:07.967 --> 00:00:11.237
So until then, what we saw here before.

5
00:00:11.237 --> 00:00:14.267
This model,
remember that beautiful model here we had?

6
00:00:14.267 --> 00:00:15.698
That was pretty much it.

7
00:00:15.698 --> 00:00:21.428
And then along came promises, and
everything got a little bit different.

8
00:00:21.428 --> 00:00:23.628
The premise for it is this.

9
00:00:23.628 --> 00:00:28.024
If I were to try and sum it up,
the premise would be this.

10
00:00:28.024 --> 00:00:31.348
When I had this model here,
when I used setTimeout.

11
00:00:31.348 --> 00:00:34.046
Did setTimeout do anything in JavaScript?

12
00:00:34.046 --> 00:00:36.500
No, where was its consequence, Kayla?

13
00:00:36.500 --> 00:00:37.939
&gt;&gt; Kayla: In the web browser.

14
00:00:37.939 --> 00:00:39.310
&gt;&gt; Will Sentance: In the web browser,
spot-on.

15
00:00:39.310 --> 00:00:42.393
But once I've set up
the timer in the web browser,

16
00:00:42.393 --> 00:00:47.402
keeping track of the fact that I've
started it, or other background features?

17
00:00:47.402 --> 00:00:51.514
I didn't really get any way of tracking
that back in JavaScript, right?

18
00:00:51.514 --> 00:00:52.986
In JavaScript,
I kinda just threw them out.

19
00:00:52.986 --> 00:00:58.009
Now, I can console.log state In JavaScript
data and JavaScript using my console.

20
00:00:58.009 --> 00:01:00.507
But I can't go and visualize all
the stuff that was down here.

21
00:01:00.507 --> 00:01:04.295
There's no like console visualize it for
the web browser,

22
00:01:04.295 --> 00:01:06.957
which is that is a little bit old, right?

23
00:01:06.957 --> 00:01:10.397
That half of what you're doing obviously
more than half what you do in JavaScript

24
00:01:10.397 --> 00:01:11.472
is happening down here.

25
00:01:11.472 --> 00:01:16.390
And I'm getting kind of no tracking of
it can no maintaining of consistency

26
00:01:16.390 --> 00:01:20.057
between the state,
the data I see up here in my memory and

27
00:01:20.057 --> 00:01:22.726
the stuff that's happening down here.

28
00:01:22.726 --> 00:01:26.808
There's no kind of way of mapping
what I'm doing down here in

29
00:01:26.808 --> 00:01:30.904
the web browser with what's
going on up here in JavaScript.

30
00:01:30.904 --> 00:01:36.562
That's in terms of developer reasoning and
thinking about what we're doing as we

31
00:01:36.562 --> 00:01:42.389
go and sort of maintaining the application
scale that isn't that ideal I would say.

32
00:01:42.389 --> 00:01:46.368
And I would put promises as
the absolute one of the most valuable

33
00:01:46.368 --> 00:01:51.097
pieces they offer, they have all
the benefits as well, is a desire to say,

34
00:01:51.097 --> 00:01:56.158
when you trigger something in the
background, don't just throw it out there.

35
00:01:56.158 --> 00:02:02.380
But have it have some sort of consequence
in JavaScript memory as well.

36
00:02:02.380 --> 00:02:06.697
So, that I have a consistency between
things going on in background is gonna

37
00:02:06.697 --> 00:02:09.536
have some consequence back
in Java at some point.

38
00:02:09.536 --> 00:02:13.718
And I'm somehow keeping track of that
within JavaScript memory as well.

39
00:02:13.718 --> 00:02:19.274
So with ES6, we introduced what I'm
gonna call two-pronged facade functions.

40
00:02:19.274 --> 00:02:25.568
They did not just, let's remember
our web browser, what's in it.

41
00:02:25.568 --> 00:02:32.028
We had our JavaScript engine,
we had our JS, our JavaScript engine,

42
00:02:32.028 --> 00:02:36.298
and then we also had a ton
of browser features,

43
00:02:36.298 --> 00:02:42.123
one of which was speaking to
the Internet the network request.

44
00:02:42.123 --> 00:02:46.079
And that its label.

45
00:02:46.079 --> 00:02:50.615
We have an old school label, that by the
way worked in the same way as set timeout.

46
00:02:50.615 --> 00:02:53.382
Took a function,
threw it down into the web browser,

47
00:02:53.382 --> 00:02:55.483
set up a timer with the old school style.

48
00:02:55.483 --> 00:03:01.025
We have a new school style of setting up
the browser feature speak to the Internet,

49
00:03:01.025 --> 00:03:03.850
speak to Twitter, whatever it might be.

50
00:03:03.850 --> 00:03:06.084
Send a request for
more data over the Internet.

51
00:03:06.084 --> 00:03:08.949
And the label for
it in JavaScript is fetch.

52
00:03:08.949 --> 00:03:12.195
But there's a new star way of doing it.

53
00:03:12.195 --> 00:03:15.739
It's one I'm gonna call it
two-pronged facade function.

54
00:03:15.739 --> 00:03:20.235
It does set up a network
request in the web

55
00:03:20.235 --> 00:03:24.610
browser features, I keep doing that.

56
00:03:24.610 --> 00:03:30.232
In the web browser features, it does
set up a network request down here.

57
00:03:30.232 --> 00:03:33.827
But rather than just doing that and
then nothing,

58
00:03:33.827 --> 00:03:38.192
no way of knowing this being
done in JavaScript from then on,

59
00:03:38.192 --> 00:03:43.094
it's gonna have a consequence
immediately in JavaScript as well.

60
00:03:43.094 --> 00:03:47.176
This fetch label is gonna trigger
speaking to the Internet down here.

61
00:03:47.176 --> 00:03:50.438
Sending a network request,
speaking to the internet, asking for

62
00:03:50.438 --> 00:03:51.902
data from Twitter down here.

63
00:03:51.902 --> 00:03:57.025
And simultaneously it's
going to also in JavaScript,

64
00:03:57.025 --> 00:04:00.077
in the JavaScript land return out

65
00:04:00.077 --> 00:04:04.659
a special kind of object
called a promise object.

66
00:04:04.659 --> 00:04:06.990
That's going to sit in memory.

67
00:04:06.990 --> 00:04:11.358
And when the background work is done here,
that's going to fill in and

68
00:04:11.358 --> 00:04:15.294
update that object's data with
the data from the background.

69
00:04:15.294 --> 00:04:18.117
And now when we finish
our background work,

70
00:04:18.117 --> 00:04:22.315
we are not surprised that something's
gonna have a result back in

71
00:04:22.315 --> 00:04:26.073
JavaScript because we had
a two pronged facade function.

72
00:04:26.073 --> 00:04:29.775
It had consequences out here, one prong.

73
00:04:29.775 --> 00:04:32.597
But it had another consequence
immediately in JavaScript.

74
00:04:32.597 --> 00:04:35.935
A little sort of placeholder object
that's gonna allow us to keep

75
00:04:35.935 --> 00:04:38.727
track in JavaScript in our local memory or
in our global

76
00:04:38.727 --> 00:04:42.388
memory there of the stuff we triggered
off down here in the web browser.

77
00:04:42.388 --> 00:04:46.182
So now we kinda have these two mapped
together and they're intimately linked.

78
00:04:46.182 --> 00:04:49.844
The background feature when it completes
is going to have consequences for

79
00:04:49.844 --> 00:04:52.471
that immediately returned
down JavaScript object.

80
00:04:52.471 --> 00:04:56.324
We're gonna see it play through here,
but take a look at it,

81
00:04:56.324 --> 00:05:01.314
two pronged facade functions that both
initiate background web browser works

82
00:05:01.314 --> 00:05:04.734
being the Internet and
return a place holder object.

83
00:05:04.734 --> 00:05:06.744
It's just a charge of object but

84
00:05:06.744 --> 00:05:11.072
a special type of one with a promise
immediately in JavaScript land.

85
00:05:11.072 --> 00:05:15.675
So that we have a way of making sure we
know what's going on down here because

86
00:05:15.675 --> 00:05:17.734
we've kept it up to date up here.

87
00:05:17.734 --> 00:05:21.545
Really interesting,
is very interesting concept.

88
00:05:21.545 --> 00:05:22.094
So here we go.

89
00:05:22.094 --> 00:05:23.771
We're gonna see it play out here.

90
00:05:23.771 --> 00:05:29.549
Save a function display, which hopefully
is gonna be run with the data that

91
00:05:29.549 --> 00:05:35.986
comes back from Twitter as input, then
we're going to have his label future data.

92
00:05:35.986 --> 00:05:38.436
And then on the right hand side there,

93
00:05:38.436 --> 00:05:42.429
the five letter word that is
the most powerful in JavaScript.

94
00:05:42.429 --> 00:05:46.349
It is profoundly complex
what those five letters do.

95
00:05:46.349 --> 00:05:49.315
They are going to set out
speaking to the Internet.

96
00:05:49.315 --> 00:05:53.496
That five letter word literally
speaks to the Internet down here from

97
00:05:53.496 --> 00:05:54.589
the web browser.

98
00:05:54.589 --> 00:05:56.734
Not in JavaScript, JavaScript can't do it,
but the web browser can.

99
00:05:56.734 --> 00:05:59.501
That is how powerful
that five letter word is.

100
00:05:59.501 --> 00:06:02.352
It's using a myriad of
technologies to go and

101
00:06:02.352 --> 00:06:06.338
get data from the other side of
the world Adrian, JavaScript.

102
00:06:06.338 --> 00:06:07.754
JavaScript does not have that feature,
believe me.

103
00:06:07.754 --> 00:06:10.795
But the web browser has
a whole myriad of remarkable

104
00:06:10.795 --> 00:06:13.564
technologies that get
all that work started.

105
00:06:13.564 --> 00:06:18.050
But it also simultaneously in
JavaScript returns out a little object,

106
00:06:18.050 --> 00:06:23.450
that's gonna be called a promise object,
that is just a regular JavaScript object.

107
00:06:23.450 --> 00:06:27.958
But has some little bonus features on it
a little bonus properties two we're gonna

108
00:06:27.958 --> 00:06:30.260
see them and
how they play out in a moment.

