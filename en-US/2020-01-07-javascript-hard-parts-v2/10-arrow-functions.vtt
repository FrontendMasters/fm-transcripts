WEBVTT

1
00:00:00.120 --> 00:00:02.622
&gt;&gt; Will Sentance: But for now,
I actually want to add something here.

2
00:00:02.622 --> 00:00:05.972
I want a little bonus here,
related to what we just saw.

3
00:00:05.972 --> 00:00:12.783
I want to introduce arrow functions,
a shorthand way to save our code.

4
00:00:12.783 --> 00:00:14.033
Let's have a look at this here.

5
00:00:14.033 --> 00:00:16.563
We've got our original
function definition up here.

6
00:00:16.563 --> 00:00:18.148
We know it's a function because look,

7
00:00:18.148 --> 00:00:20.269
it's got the beautiful word
function at the front.

8
00:00:20.269 --> 00:00:21.996
That is, in my view, really readable.

9
00:00:21.996 --> 00:00:23.958
I know exactly when
the function's showing up.

10
00:00:23.958 --> 00:00:27.038
It's got a body and it's got a parameter.

11
00:00:27.038 --> 00:00:30.812
That when I end up running multiply
by two with a bit of three,

12
00:00:30.812 --> 00:00:33.336
it's going to insert three into input.

13
00:00:33.336 --> 00:00:36.976
Three by two return out six into output.

14
00:00:36.976 --> 00:00:39.804
There are other ways to save functions.

15
00:00:39.804 --> 00:00:41.173
Let's look at the next version down.

16
00:00:41.173 --> 00:00:45.091
Each of these ignore the fact that we
read acquiring a console our way through.

17
00:00:45.091 --> 00:00:48.762
This is not the individual
files of code each time.

18
00:00:48.762 --> 00:00:50.109
Next line down.

19
00:00:50.109 --> 00:00:54.760
We now here declare what's known as
an arrow function introducing ESX.

20
00:00:54.760 --> 00:00:59.537
Remember function definitions can
be stored, assigned to labels.

21
00:00:59.537 --> 00:01:01.766
Because they're just objects
behind the scenes, and

22
00:01:01.766 --> 00:01:03.470
that's exactly what we're doing here.

23
00:01:03.470 --> 00:01:07.305
We are taking that function there on
the right hand side and storing and

24
00:01:07.305 --> 00:01:08.549
label multiply by 2.

25
00:01:08.549 --> 00:01:13.043
It has some differences under the hood for
all, but for our purposes here for now,

26
00:01:13.043 --> 00:01:14.555
let's just put this here.

27
00:01:14.555 --> 00:01:19.778
That second line down there we declare,
multiply by 2.

28
00:01:19.778 --> 00:01:21.414
There it is.

29
00:01:21.414 --> 00:01:25.969
And we assign it a function definition.

30
00:01:25.969 --> 00:01:29.432
There it is, no change.

31
00:01:29.432 --> 00:01:34.748
Now I will say this, let's just just like
up here the parameter name is input.

32
00:01:34.748 --> 00:01:36.933
You know, let's put it here
the blue being a bit more focused.

33
00:01:36.933 --> 00:01:38.882
The parameter name is input.

34
00:01:38.882 --> 00:01:42.481
But nothing has changed
in that second line.

35
00:01:42.481 --> 00:01:46.721
Well, the designers of
JavaScript love to reduce code.

36
00:01:46.721 --> 00:01:49.666
I like to think of this
as being a desire for

37
00:01:49.666 --> 00:01:53.973
legibility, but maybe not for
readability, legibility.

38
00:01:53.973 --> 00:01:57.145
This makes it nice and
short and less stuff written.

39
00:01:57.145 --> 00:01:58.745
That is makes it more legible.

40
00:01:58.745 --> 00:02:03.146
I can kind of literally there's less to
read and it sort of prettier on the page.

41
00:02:03.146 --> 00:02:04.714
But it may reduce readability.

42
00:02:04.714 --> 00:02:06.281
It will be like I'll say in a second.

43
00:02:06.281 --> 00:02:07.109
But why?

44
00:02:07.109 --> 00:02:08.865
But let's look at this
next line down here.

45
00:02:08.865 --> 00:02:11.588
This next line down here.

46
00:02:11.588 --> 00:02:16.377
Here we declaring multiply by two.

47
00:02:16.377 --> 00:02:18.138
We got a parameter input.

48
00:02:18.138 --> 00:02:19.839
And then what's this thing
happen on the right hand side?

49
00:02:19.839 --> 00:02:23.097
Well, if you will function
only does one thing and

50
00:02:23.097 --> 00:02:25.668
that is its return value, its output.

51
00:02:25.668 --> 00:02:28.139
JavaScript designers said, you know what?

52
00:02:28.139 --> 00:02:32.947
We'll let you actually skip the curly
braces and the return keyword and

53
00:02:32.947 --> 00:02:34.963
we'll insert those for you.

54
00:02:34.963 --> 00:02:36.474
We'll insert those automatically.

55
00:02:36.474 --> 00:02:41.483
And so this next line down here, Parameter
input, arrow input by to JavaScript

56
00:02:41.483 --> 00:02:46.442
behind the scenes, when we run that
multiply by two function is gonna insert.

57
00:02:46.442 --> 00:02:49.926
The Return key word in
front of input by two.

58
00:02:49.926 --> 00:02:51.597
We'll see that one in a second.

59
00:02:51.597 --> 00:02:52.880
Look at this one below.

60
00:02:52.880 --> 00:02:58.518
We can even remove if you've only
got one input, the parentheses.

61
00:02:58.518 --> 00:03:03.403
I just literally say multiply by two is
that function definition, that bottom one.

62
00:03:03.403 --> 00:03:07.538
But in terms of executing we'll see
its changes in tomorrow morning or

63
00:03:07.538 --> 00:03:08.734
tomorrow afternoon.

64
00:03:08.734 --> 00:03:13.016
But for our purposes right now,
nothing has changed in that final version.

65
00:03:13.016 --> 00:03:17.207
The point I wanna execute that final
version with the parameter input.

66
00:03:17.207 --> 00:03:19.507
And then return input by 2 as its body,

67
00:03:19.507 --> 00:03:22.518
just to make sure we know
that nothing's changed.

68
00:03:22.518 --> 00:03:24.746
So let's actually execute
that final one there.

69
00:03:24.746 --> 00:03:27.581
Let's do it down here.

70
00:03:27.581 --> 00:03:32.432
Let's declare Toward, let's clear
the left hand side of that final line.

71
00:03:32.432 --> 00:03:33.914
There we go.
And I multiply by two functions.

72
00:03:33.914 --> 00:03:36.269
We're using the very last version here.

73
00:03:36.269 --> 00:03:40.658
We're using that very last version,
not even any params no curly braces,

74
00:03:40.658 --> 00:03:41.643
super legible.

75
00:03:41.643 --> 00:03:44.621
And I tell you in a moment
why question it's

76
00:03:44.621 --> 00:03:49.271
honestly it's readability in terms
of its meaning to the reader.

77
00:03:49.271 --> 00:03:53.583
Because there are many folk people will
be watching this going that's the same

78
00:03:53.583 --> 00:03:54.706
thing as at the top.

79
00:03:54.706 --> 00:03:59.008
I mean, it's an under the hood changes for
how we use it but not at this point.

80
00:03:59.008 --> 00:04:00.815
And yet it's essentially the same.

81
00:04:00.815 --> 00:04:02.196
So yeah, Todd.

82
00:04:02.196 --> 00:04:04.076
Let's now use the left hand side there.

83
00:04:04.076 --> 00:04:05.898
What are we declaring first?

84
00:04:05.898 --> 00:04:06.931
&gt;&gt; Speaker 2: Constant output.

85
00:04:06.931 --> 00:04:10.589
&gt;&gt; Will Sentance: Yeah, excellent,
and we've gotta go ahead now and

86
00:04:10.589 --> 00:04:12.012
run what function?

87
00:04:12.012 --> 00:04:12.711
&gt;&gt; Speaker 2: Multiply By2.

88
00:04:12.711 --> 00:04:15.758
&gt;&gt; Will Sentance: MultiplyBy2, and
again, people, just be really clear,

89
00:04:15.758 --> 00:04:19.179
we're running the very bottom one,
with the input of what, Todd?

90
00:04:19.179 --> 00:04:21.068
&gt;&gt; Speaker 2: 3.
&gt;&gt; Will Sentance: 3, brand-new what, Todd,

91
00:04:21.068 --> 00:04:22.573
any change, no, brand-new?

92
00:04:22.573 --> 00:04:23.397
&gt;&gt; Speaker 2: Execution context.

93
00:04:23.397 --> 00:04:25.811
&gt;&gt; Will Sentance: Execution context,
it is what it is.

94
00:04:25.811 --> 00:04:29.657
There it is, brand new execution context,
and into we go.

95
00:04:29.657 --> 00:04:31.301
What's in our local memory,

96
00:04:31.301 --> 00:04:34.731
what's the value passed into
our local memory first, Todd?

97
00:04:34.731 --> 00:04:36.475
&gt;&gt; Speaker 2: Input, value of 3.

98
00:04:36.475 --> 00:04:38.329
&gt;&gt; Will Sentance: Value of 3
assigned to what parameter?

99
00:04:38.329 --> 00:04:40.576
&gt;&gt; Speaker 2: Input.
&gt;&gt; Will Sentance: Input, any change yet,

100
00:04:40.576 --> 00:04:41.291
people?

101
00:04:41.291 --> 00:04:42.538
&gt;&gt; Speaker 2: Nope.
&gt;&gt; Will Sentance: Nope.

102
00:04:42.538 --> 00:04:44.409
Now, what's the body of that function?

103
00:04:44.409 --> 00:04:48.780
It's a stuff on the right hand side
of the arrow with an inserted word.

104
00:04:48.780 --> 00:04:50.063
I'm going to do in,

105
00:04:50.063 --> 00:04:54.373
I know, I'm gonna do in purple
here with what inserted word, Tom?

106
00:04:54.373 --> 00:04:54.925
&gt;&gt; Speaker 2: Return.

107
00:04:54.925 --> 00:05:01.030
&gt;&gt; Will Sentance: Return
in front of what code?

108
00:05:01.030 --> 00:05:01.668
&gt;&gt; Speaker 2: 3 times 2.

109
00:05:01.668 --> 00:05:05.822
&gt;&gt; Will Sentance: Yeah, input by 2,
which is 3 by 2, which is 6.

110
00:05:05.822 --> 00:05:13.529
And that is then return out
into output and there it is.

111
00:05:13.529 --> 00:05:15.433
You maybe watching and
then go, yeah, I knew that.

112
00:05:15.433 --> 00:05:21.315
But I think let me see that stuff
down there, input arrow input by 2.

113
00:05:21.315 --> 00:05:25.094
And it looks so similar to an assignment,
by the equals sign,

114
00:05:25.094 --> 00:05:28.888
I promise you people are seeing
that right-hand side there.

115
00:05:28.888 --> 00:05:34.344
And not realizing that is a full function
definition, with a parameter and

116
00:05:34.344 --> 00:05:39.640
a body, with a return statement
inserted automatically for us, okay?

117
00:05:39.640 --> 00:05:43.331
Would you do something in a second is
actually let's have a look at this in

118
00:05:43.331 --> 00:05:43.947
practice.

119
00:05:43.947 --> 00:05:46.896
So look at this,
I've taken a higher order function and

120
00:05:46.896 --> 00:05:48.918
callback function from just before.

121
00:05:48.918 --> 00:05:54.373
And you see I've changed the function
multiply by 2 into the arrow style.

122
00:05:54.373 --> 00:05:55.966
Has anything changed?

123
00:05:55.966 --> 00:05:59.444
Nothing's changed,
I take that code I insert it.

124
00:05:59.444 --> 00:06:04.159
In, I use it as instructions,
I would take a reposition zero

125
00:06:04.159 --> 00:06:08.884
which will be the number one
on inserted into instructions.

126
00:06:08.884 --> 00:06:13.326
Which is inserting it into
everybody multiply by two.

127
00:06:13.326 --> 00:06:17.484
One is going to then be in the well one
would be in the local memory of the input

128
00:06:17.484 --> 00:06:19.336
parameters value argument and.

129
00:06:19.336 --> 00:06:23.785
And then we do 1 by 2 and
return out 2 into the execution

130
00:06:23.785 --> 00:06:28.627
context of copyArrayManipulate,
and push it into output.

131
00:06:28.627 --> 00:06:35.293
Nothing has changed here, folk, but
you're gonna see this style more and more.

132
00:06:35.293 --> 00:06:37.244
And it gets even more,

133
00:06:37.244 --> 00:06:42.808
Extreme you probably know what's coming,
have a look at that.

134
00:06:42.808 --> 00:06:45.906
This is what you end up
seeing a lot of the time,

135
00:06:45.906 --> 00:06:50.447
given that I'm saving the multiply
by two function here in global.

136
00:06:50.447 --> 00:06:55.362
And then just grabbing it referring to
it as Dan said by his label to pull it

137
00:06:55.362 --> 00:06:59.408
into copyright manipulate Developers go,
you know what?

138
00:06:59.408 --> 00:07:04.206
Might as well just skip that step,
might as well just take the code and

139
00:07:04.206 --> 00:07:06.045
insert that in directly.

140
00:07:06.045 --> 00:07:11.266
Given that we don't use the label multiply
by 2 inside of the execution context of

141
00:07:11.266 --> 00:07:12.102
manipulate.

142
00:07:12.102 --> 00:07:15.346
We just use the code And
give it a new label instructions,

143
00:07:15.346 --> 00:07:18.261
why even bother giving it a label and
inserting it?

144
00:07:18.261 --> 00:07:21.130
Why not just grab the code and
just use it inside?

145
00:07:21.130 --> 00:07:23.770
And that's exactly what happens, but

146
00:07:23.770 --> 00:07:28.340
when you see that line of code there,
we are so tempted to feel that.

147
00:07:28.340 --> 00:07:31.870
That function is being kind
of executed right there and

148
00:07:31.870 --> 00:07:34.485
then it's so unclear what it's doing.

149
00:07:34.485 --> 00:07:38.802
But that there is the full function
definition of multiply by two,

150
00:07:38.802 --> 00:07:41.743
which is that function
definition up there.

151
00:07:41.743 --> 00:07:44.328
Nothing has changed in reality.

152
00:07:44.328 --> 00:07:47.342
That function definition we
know we grabbed by name and

153
00:07:47.342 --> 00:07:49.774
inserted engaged the labor instructions.

154
00:07:49.774 --> 00:07:51.001
Nothing's changed.

155
00:07:51.001 --> 00:07:53.203
We've taken exactly the same situation,
and

156
00:07:53.203 --> 00:07:55.413
we've now just inserted
the whole function.

157
00:07:55.413 --> 00:07:59.076
I could take this input
arrow input by two and

158
00:07:59.076 --> 00:08:02.842
it's just this code now inserted directly.

159
00:08:02.842 --> 00:08:06.556
All right, if you wanna have thumbs on
this, you're gonna see this a lot and

160
00:08:06.556 --> 00:08:09.126
I'm gonna give my view on
this approach in a second.

161
00:08:09.126 --> 00:08:10.435
But you lost me.

162
00:08:10.435 --> 00:08:14.249
I'm clear clarification of really
interested in anyone's clarification on

163
00:08:14.249 --> 00:08:16.339
this cuz this is a challenging shift here.

164
00:08:16.339 --> 00:08:20.972
Okay, we're not gonna tend to use
this style too much today, but

165
00:08:20.972 --> 00:08:26.126
this is increasingly A standard style,
why nobody use it too much a day.

166
00:08:26.126 --> 00:08:31.058
So, anonymous in our functions, they
improve immediate legibility of the code.

167
00:08:31.058 --> 00:08:33.564
It makes it look like kind of pretty,
right?

168
00:08:33.564 --> 00:08:36.186
I'm not storing stuff separately.

169
00:08:36.186 --> 00:08:39.650
Why am i so when i'm doing hard parts?

170
00:08:39.650 --> 00:08:42.467
Why do I,
Like declare function separately,

171
00:08:42.467 --> 00:08:46.075
when in reality will tend to
just insert them directly.

172
00:08:46.075 --> 00:08:48.632
It was a rhetorical question,
but okay, Kyle, go ahead.

173
00:08:48.632 --> 00:08:51.293
&gt;&gt; Speaker 3: You might have another
function where you want to pass.

174
00:08:51.293 --> 00:08:53.310
&gt;&gt; Will Sentance: I love that,
that's a very good reason.

175
00:08:53.310 --> 00:08:57.669
For me, I'm sort of talking in a more I
guess, pedagogical sense, I do it because

176
00:08:57.669 --> 00:09:02.239
while this improves legibility, we write
less code, it looks prettier, perhaps.

177
00:09:02.239 --> 00:09:03.838
And therefore it is very standard.

178
00:09:03.838 --> 00:09:06.899
And I'm very standard and
full endorsement of it,

179
00:09:06.899 --> 00:09:09.897
in terms of when I'm
explaining these concepts.

180
00:09:09.897 --> 00:09:12.680
And that's a good predictor of
whether it's readable in a sense of

181
00:09:12.680 --> 00:09:15.128
understandable and
comprehensible for the developers.

182
00:09:15.128 --> 00:09:16.980
And by the way, this is not me
saying that you shouldn't do this.

183
00:09:16.980 --> 00:09:19.803
It's very standard, it's absolutely
border line better practice.

184
00:09:19.803 --> 00:09:22.522
But in terms of our understanding.

185
00:09:22.522 --> 00:09:25.747
In terms of deciding how
it's actually working,

186
00:09:25.747 --> 00:09:29.605
I would distinguish between legibility and
readability.

187
00:09:29.605 --> 00:09:32.858
How this is understanding under the hood,
how is this working under the hood is

188
00:09:32.858 --> 00:09:34.893
vital to understand
what's really happening.

189
00:09:34.893 --> 00:09:39.081
That function, whole definition that's
being passed in is much easier to track

190
00:09:39.081 --> 00:09:42.109
that that's happening when
we've declared it by label.

191
00:09:42.109 --> 00:09:44.317
With the key word function and
then pass it in.

192
00:09:44.317 --> 00:09:47.379
And that's why we're going to
continue in hard part today,

193
00:09:47.379 --> 00:09:49.250
to mostly use the keyword function.

194
00:09:49.250 --> 00:09:54.314
And this design here, this little
shorthand version of functions, is really,

195
00:09:54.314 --> 00:09:58.938
really nice for legibility when
you're passing little mini functions.

196
00:09:58.938 --> 00:10:03.370
In is the input to other functions there
is really readable and fully endorse and

197
00:10:03.370 --> 00:10:06.955
I would absolutely you know,
you will see there's a standard.

198
00:10:06.955 --> 00:10:11.496
But it's not automatically the case that
we should always be using arrow functions.

199
00:10:11.496 --> 00:10:15.273
And we'll see you later on situations in
which you will completely under undo what

200
00:10:15.273 --> 00:10:16.538
we're trying to achieve.

201
00:10:16.538 --> 00:10:21.350
There is an under the hood change
to how arrow functions treat.

202
00:10:21.350 --> 00:10:25.005
This key word assignment that we're
going to see in our courses and

203
00:10:25.005 --> 00:10:27.821
prototypes session where
it can be really useful.

204
00:10:27.821 --> 00:10:32.582
By the way, I tell you this little preview
now if he was a function inside a method,

205
00:10:32.582 --> 00:10:37.067
that lexically scoped arrow function was
he was a Toronto where I can be really

206
00:10:37.067 --> 00:10:37.622
useful.

207
00:10:37.622 --> 00:10:41.644
But if you're using that for regular
methods on objects, It ain't gonna work.

208
00:10:41.644 --> 00:10:46.323
So we're gonna continue to default
to the function declaration style.

209
00:10:46.323 --> 00:10:49.430
But, for when we're parsing
little baby functions in,

210
00:10:49.430 --> 00:10:52.742
I do endorse that that makes it,
that says map array 123.

211
00:10:52.742 --> 00:10:55.235
So we take each element,
and multiply it by 2.

212
00:10:55.235 --> 00:10:56.626
And see that one in one line?

213
00:10:56.626 --> 00:10:58.688
That is pretty nice, I do like that.

214
00:10:58.688 --> 00:11:02.139
But in understanding how
it's working under the hood,

215
00:11:02.139 --> 00:11:06.702
it's important ever more to understand
what's really happening here.

216
00:11:06.702 --> 00:11:08.602
Okay, Jason go ahead.

217
00:11:08.602 --> 00:11:11.585
&gt;&gt; Speaker 2: Is, [COUGH] excuse me,
are there any memory or

218
00:11:11.585 --> 00:11:15.521
memory allocation savings for
that strategy of inlining.

219
00:11:15.521 --> 00:11:19.356
Where you instead of creating
an external global context for

220
00:11:19.356 --> 00:11:22.148
A function to store multipyBy2 in memory.

221
00:11:22.148 --> 00:11:23.805
&gt;&gt; Will Sentance: The thing with that,
Jason,

222
00:11:23.805 --> 00:11:28.597
is just that we're talking here about such
small memory gains or losses at any point.

223
00:11:28.597 --> 00:11:32.042
We don't live in the world where we're
constructed on that sort of thing.

224
00:11:32.042 --> 00:11:35.866
Now, if you were calling that function
recursively, if you were, and

225
00:11:35.866 --> 00:11:38.302
we'll see tomorrow in class in prototypes.

226
00:11:38.302 --> 00:11:43.921
Saving a 100 functions to 1,000
objects where each of them is copied.

227
00:11:43.921 --> 00:11:46.121
Where we could just have
one set of functions and

228
00:11:46.121 --> 00:11:47.992
point all to that same set of functions.

229
00:11:47.992 --> 00:11:51.030
Yeah, that's where performance counts,
this sort of thing here it's so

230
00:11:51.030 --> 00:11:52.489
minor that we don't need to worry.

231
00:11:52.489 --> 00:11:55.708
More and more the most valuable
resource as a developer,

232
00:11:55.708 --> 00:11:58.935
is the developer's time and
ability to reason about it.

233
00:11:58.935 --> 00:12:02.588
Versus do we end up automatically
garbage collecting and

234
00:12:02.588 --> 00:12:05.639
therefore, in the moment
saving some memory?

235
00:12:05.639 --> 00:12:09.007
On these marginal cases,
readability comes first.

236
00:12:09.007 --> 00:12:11.949
That being said, as long as you
understand how this is working here,

237
00:12:11.949 --> 00:12:13.842
passing in that function directly?

238
00:12:13.842 --> 00:12:15.837
I think it does it really nice.

239
00:12:15.837 --> 00:12:18.803
Mapping, 1, 2, 3 by this mapping rule,

240
00:12:18.803 --> 00:12:24.205
where it's explicitly in that line I
think people don't know how it's working.

241
00:12:24.205 --> 00:12:27.285
But I think people get a sense, they can
make it work if they don't understand how

242
00:12:27.285 --> 00:12:28.476
it's working under the hood.

243
00:12:28.476 --> 00:12:31.508
But we wanna be those people who
understand how it's working under

244
00:12:31.508 --> 00:12:33.140
the hood, and hopefully now we do.

