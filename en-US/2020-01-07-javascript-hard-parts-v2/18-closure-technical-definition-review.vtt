WEBVTT

1
00:00:00.780 --> 00:00:06.040
&gt;&gt; Will Sentance: All right,
so let's talk about what

2
00:00:06.040 --> 00:00:11.400
this backpack is called,
because I think we can all agree.

3
00:00:11.400 --> 00:00:15.240
This is an ever by the way,
things have changed since we won.

4
00:00:15.240 --> 00:00:18.040
This lady's name backpack
has been blowing up

5
00:00:18.040 --> 00:00:21.700
somebody's got me a T shirt with
a backpack on the back of it.

6
00:00:21.700 --> 00:00:26.550
I count that as constituting
blowing up huge.

7
00:00:26.550 --> 00:00:30.790
There is one t shirt, exactly.

8
00:00:32.260 --> 00:00:39.650
But also, there is now a blog post
the most popular blog posts on closure.

9
00:00:39.650 --> 00:00:41.170
Outlet written by the Guardian and
New York Times.

10
00:00:41.170 --> 00:00:43.890
Engineering manager New York Times
you came to hard part's, cool.

11
00:00:43.890 --> 00:00:45.950
I never understood closure
until I thought about this way,

12
00:00:45.950 --> 00:00:50.500
learnt about this way, in which he
referred to the backpack, 14 times.

13
00:00:50.500 --> 00:00:54.320
Yeah, exactly, wow,
14/15 millimeter wide, exactly.

14
00:00:54.320 --> 00:00:57.480
That's how real is becoming.

15
00:00:57.480 --> 00:00:59.548
We're lobbying the spec makers.

16
00:00:59.548 --> 00:01:03.141
&gt;&gt; Speaker 2: [LAUGH]
&gt;&gt; Will Sentance: And obviously not but

17
00:01:03.141 --> 00:01:06.100
I don't think any of you heard of, and

18
00:01:06.100 --> 00:01:11.110
certainly another heard of it,
but there is a fancy name for it.

19
00:01:11.110 --> 00:01:13.720
There is a colloquial name
used by developers for it.

20
00:01:13.720 --> 00:01:17.980
I just don't love the reason being
is I think it's vague and imprecise.

21
00:01:17.980 --> 00:01:23.150
It refers to both of the overall concept,
and they call the backpack this as well.

22
00:01:23.150 --> 00:01:24.790
So these are, let me put that better.

23
00:01:24.790 --> 00:01:28.990
They refer to the thing that results
in the backpack existing and

24
00:01:28.990 --> 00:01:31.710
they call the backpack all
this same umbrella term.

25
00:01:31.710 --> 00:01:33.840
I think that is a bit vague and confusing.

26
00:01:33.840 --> 00:01:36.960
So I'm gonna give us some fancy names for
the backpack and

27
00:01:36.960 --> 00:01:38.410
then why we have the backpack.

28
00:01:39.420 --> 00:01:44.243
So first name, well I already told
you earlier on that people pool

29
00:01:44.243 --> 00:01:48.553
their local memory sometimes
the variable environment.

30
00:01:48.553 --> 00:01:52.941
As a brilliant I think developer out there
who's a wonderful book actually which I

31
00:01:52.941 --> 00:01:55.803
highly recommend for
friends known as like a smart but

32
00:01:55.803 --> 00:01:58.300
isn't like a book like let me take notes.

33
00:01:58.300 --> 00:02:02.860
This is called
If Hemingway Wrote Javascript.

34
00:02:02.860 --> 00:02:06.650
Yeah, I think it's a perfect gift book,
I bought ten copies actually.

35
00:02:06.650 --> 00:02:11.540
It doesn't suggest much about the- anyway,
I got them for

36
00:02:11.540 --> 00:02:15.520
Code Smith people, I think, it's gotta
be the worst Christmas gift ever,

37
00:02:15.520 --> 00:02:17.580
right, you're getting a copy
of When Hemingway Wrote.

38
00:02:17.580 --> 00:02:20.660
So if I read, Hemingway wrote
JavaScript by Gaga Angus Crow,

39
00:02:20.660 --> 00:02:25.080
a big fan of it, he calls this is
basically he takes little snippets of code

40
00:02:25.080 --> 00:02:29.720
like Fibonacci sequence and writes them in
the site in the style of famous writers.

41
00:02:29.720 --> 00:02:34.580
So Hemingway's is very terse,
Nabokov's I don't know, I didn't read it,

42
00:02:34.580 --> 00:02:36.410
but I don't know what to say.

43
00:02:36.410 --> 00:02:42.066
But so,
&gt;&gt; Will Sentance: He calls this backpack,

44
00:02:42.066 --> 00:02:45.950
he calls it the closed over.

45
00:02:45.950 --> 00:02:51.810
That is to say we close a lid on this data
here, closed over variable environment.

46
00:02:51.810 --> 00:02:53.240
That is to say,
we take the variable environment,

47
00:02:53.240 --> 00:02:55.130
kinda close a lid on it, and pull it out.

48
00:02:55.130 --> 00:02:59.443
Okay, so he calls it the curve,
closed over

49
00:02:59.443 --> 00:03:04.487
variable environment code,
not a bad name for it.

50
00:03:04.487 --> 00:03:09.210
I guess I like it,
now here's a name I quite like for it.

51
00:03:09.210 --> 00:03:13.533
I think this is the one that I said if
you can say you're guaranteed a senior

52
00:03:13.533 --> 00:03:14.529
developer job.

53
00:03:14.529 --> 00:03:17.072
I have to take that back obviously.

54
00:03:17.072 --> 00:03:20.827
So hear the name, that it is nice,

55
00:03:20.827 --> 00:03:25.070
it shows a depth to understanding.

56
00:03:25.070 --> 00:03:28.740
So this data here is persistent.

57
00:03:30.580 --> 00:03:32.970
Right, it sticks around, it's not like
the regular data that gets deleted,

58
00:03:32.970 --> 00:03:33.790
it's persistent.

59
00:03:35.090 --> 00:03:37.190
It's data, okay, d for data.

60
00:03:39.720 --> 00:03:42.250
It's referenced, it's linked

61
00:03:44.490 --> 00:03:50.010
referenced by a scope property, okay.

62
00:03:50.010 --> 00:03:51.840
What is scope?

63
00:03:51.840 --> 00:03:55.890
Scope is the rules in any
programming language.

64
00:03:55.890 --> 00:04:01.190
For at any given line of code,
what data do I have available to me?

65
00:04:01.190 --> 00:04:04.780
So if I'm in this line every day as
this is it, if I'm in this line,

66
00:04:04.780 --> 00:04:07.910
somehow I have access to this data,
and this data.

67
00:04:07.910 --> 00:04:11.520
Scope is the fancy word for
what data and what are the rules for

68
00:04:11.520 --> 00:04:14.580
but we assume that if I
run a function like outer.

69
00:04:14.580 --> 00:04:18.622
in global that if we don't find data
inside out to be connected to global, why?

70
00:04:18.622 --> 00:04:22.706
That's not like inherent in a programming
language that was decided by the developer

71
00:04:22.706 --> 00:04:26.807
of the language, when they're deciding the
rules of scope for that given language.

72
00:04:26.807 --> 00:04:30.746
The rules of what data is available to
me at any given line in my running of

73
00:04:30.746 --> 00:04:31.770
my code.

74
00:04:31.770 --> 00:04:34.360
You can imagine a language says
no new data available inside that

75
00:04:34.360 --> 00:04:35.150
function, that's it.

76
00:04:36.730 --> 00:04:38.280
Beep every regional language and

77
00:04:38.280 --> 00:04:43.500
the scoping rule would be protecting
the data only inside the function itself.

78
00:04:43.500 --> 00:04:44.700
You don't have access
to that functions data.

79
00:04:44.700 --> 00:04:46.670
That would be that language is scope rule.

80
00:04:47.890 --> 00:04:51.940
This the language of JavaScript
has a very particular scope rule.

81
00:04:52.990 --> 00:04:54.960
Its scope rule is.

82
00:04:54.960 --> 00:04:58.440
What's called lexical or static scoping.

83
00:04:58.440 --> 00:05:03.670
That is to say that
where I save my function

84
00:05:03.670 --> 00:05:08.560
determines for the rest of that life,
for the life of that function.

85
00:05:08.560 --> 00:05:12.350
Whenever it gets run under
whatever new label it gets,

86
00:05:12.350 --> 00:05:16.670
what data it will have access
to when that function runs.

87
00:05:16.670 --> 00:05:17.630
Is not where I run it.

88
00:05:17.630 --> 00:05:20.850
That would be called dynamic scoping.

89
00:05:20.850 --> 00:05:23.610
It changes depending on
where I run the function.

90
00:05:23.610 --> 00:05:26.820
If I were to dynamically scope language,
I'd run my new functioning and

91
00:05:26.820 --> 00:05:29.950
I'd look straight down to global,
wouldn't find counter that was it.

92
00:05:29.950 --> 00:05:33.180
JavaScript is a static or
lexically scoped language.

93
00:05:33.180 --> 00:05:35.550
Lexical means the physical
positioning on the page.

94
00:05:35.550 --> 00:05:38.650
I physically position this
inside the running of outer.

95
00:05:38.650 --> 00:05:41.030
Is a lexical statically scope language.

96
00:05:41.030 --> 00:05:44.890
That means that even if I
returned my function out, and

97
00:05:44.890 --> 00:05:46.700
theoretically all this data
should have been deleted.

98
00:05:46.700 --> 00:05:52.430
Nope, because I have this fundamental
rule of lexically scoped language.

99
00:05:52.430 --> 00:05:54.680
I'm gonna have to grab all that
data behind the scenes and

100
00:05:54.680 --> 00:05:56.740
put it out on the backpack.

101
00:05:56.740 --> 00:06:00.570
Such that when I run the function, I still
have all the data from when I last scope.

102
00:06:00.570 --> 00:06:03.490
Not because I go back into
the earlier execution context, uh-uh.

103
00:06:03.490 --> 00:06:04.800
I'm going back up into outer.

104
00:06:04.800 --> 00:06:09.030
I didn't have to, I pulled the data from
when the function incrementCounter was

105
00:06:09.030 --> 00:06:12.930
born out with me on my
lexical scope property.

106
00:06:12.930 --> 00:06:15.140
Behind the scenes I
pulled the data out and

107
00:06:15.140 --> 00:06:18.690
left it attached to now my new function.

108
00:06:18.690 --> 00:06:20.300
It's a lexically scoped language.

109
00:06:21.480 --> 00:06:25.410
Persistent lexically or
static scope reference data.

110
00:06:25.410 --> 00:06:28.360
So special type of scope, the lexical
scope, with static scoping rule

111
00:06:28.360 --> 00:06:32.290
which means we literally bring the data
with us from when the function was born.

112
00:06:32.290 --> 00:06:36.920
Because our rule is where my
function was saved determines

113
00:06:36.920 --> 00:06:41.380
what data I have access to, when it's
eventually run, wherever that may be.

114
00:06:42.460 --> 00:06:46.880
And there it is persistent lexical
static scope reference data.

115
00:06:46.880 --> 00:06:54.945
And you can see that's why I call it the
back pack, look at that beautiful name.

116
00:06:54.945 --> 00:06:58.017
&gt;&gt; Will Sentance: But
in industry they tend to use

117
00:06:58.017 --> 00:07:03.220
the colloquial term that
Kayla gave us earlier.

118
00:07:03.220 --> 00:07:09.740
Which is they say,
put the data in the function's closure.

119
00:07:09.740 --> 00:07:13.780
My problem with that term is a cool
the overall concept, the notion of

120
00:07:13.780 --> 00:07:18.190
lexical scoping and they call that closure
and then they call the backpack closure.

121
00:07:18.190 --> 00:07:21.750
It's the backpack as a result of
JavaScript being a lexically scoped

122
00:07:21.750 --> 00:07:26.600
language, one that brings the data with
the function wherever that function goes,

123
00:07:27.760 --> 00:07:30.460
hidden on the scope property,
hidden on the backpack.

124
00:07:30.460 --> 00:07:33.080
Meaning that if you save a function
inside the room another function.

125
00:07:33.080 --> 00:07:35.910
When it exits,
that should all be deleted, nope.

126
00:07:35.910 --> 00:07:39.300
But bringing that data with us on
the backpack so when we run that function,

127
00:07:39.300 --> 00:07:43.000
it still has access to that
persistent data from its backpack.

128
00:07:45.030 --> 00:07:47.015
There we go people,
we're not quite done yet.

129
00:07:47.015 --> 00:07:54.307
[SOUND] Let's do thumbs at that point in
case this is raise any new questions.

130
00:07:54.307 --> 00:07:57.640
You lost me clear clarification,
no looking around.

131
00:07:57.640 --> 00:07:59.050
Todd, I saw you looking around.

132
00:07:59.050 --> 00:08:00.620
Is okay good clarifications.

133
00:08:00.620 --> 00:08:01.320
Peter has one.

134
00:08:01.320 --> 00:08:02.860
Peter, go ahead please.

135
00:08:02.860 --> 00:08:07.650
&gt;&gt; Peter: If you defined a new variable
that you defined as my new function,

136
00:08:07.650 --> 00:08:09.890
would it also get its backpack?

137
00:08:09.890 --> 00:08:10.590
&gt;&gt; Will Sentance: Okay, so

138
00:08:10.590 --> 00:08:13.200
there is a couple of interesting
bonus things we can say around that.

139
00:08:13.200 --> 00:08:18.133
So you're saying if we
said let's say Peter =

140
00:08:18.133 --> 00:08:23.630
my new Function,
is that what you're saying?

141
00:08:23.630 --> 00:08:26.450
Yeah, so that would just be
peter is now a new label for

142
00:08:26.450 --> 00:08:28.730
this same function with the same backpack.

143
00:08:28.730 --> 00:08:30.500
Yeah.
&gt;&gt; Peter: It still gets access to all the-

144
00:08:30.500 --> 00:08:31.110
&gt;&gt; Will Sentance: Yeah, absolutely.

145
00:08:31.110 --> 00:08:32.870
Cuz that's just now
peter is a new label for

146
00:08:32.870 --> 00:08:34.930
this same function with all
the stuff attached to it.

147
00:08:34.930 --> 00:08:36.870
This is literally
attached to the function.

148
00:08:36.870 --> 00:08:39.530
myNewFunction is the label for
all of this together now.

149
00:08:39.530 --> 00:08:42.790
Function code to run, I mean,
just think about this.

150
00:08:42.790 --> 00:08:47.040
It's labeled for a function code
to run that can create, so memory.

151
00:08:47.040 --> 00:08:49.470
But it's also got its own
permanent memory attached to it.

152
00:08:49.470 --> 00:08:51.440
That is kind of extraordinary.

153
00:08:51.440 --> 00:08:52.620
Yeah.
There's one other thing I do want to add

154
00:08:52.620 --> 00:08:53.510
actually, keep it short.

155
00:08:53.510 --> 00:09:00.040
But, if I returned out from the same
outer execution, free functions.

156
00:09:00.040 --> 00:09:01.906
Which by the way,
if you need to return that one things,

157
00:09:01.906 --> 00:09:04.028
how can I return out three
functions from a student contracts?

158
00:09:04.028 --> 00:09:04.855
Yeah, Dan.

159
00:09:04.855 --> 00:09:05.786
&gt;&gt; Dan: In array of array of functions.

160
00:09:05.786 --> 00:09:08.745
&gt;&gt; Will Sentance: Array of function or
object for the methods yeah,

161
00:09:08.745 --> 00:09:12.060
they would all be linking
to the same backpack.

162
00:09:12.060 --> 00:09:14.420
And so they'd all have access
to that share backpack.

163
00:09:14.420 --> 00:09:14.980
That's kind of cool.

164
00:09:14.980 --> 00:09:17.100
But that's not where we're going yet.

165
00:09:17.100 --> 00:09:19.610
I thought we were going to raise
Peter is this final piece here.

166
00:09:19.610 --> 00:09:20.570
So we saw all this here.

167
00:09:22.260 --> 00:09:25.440
What I call the backpack close over
variable environment persistent lexically,

168
00:09:25.440 --> 00:09:30.470
scoped or standard eastcote, reference
data, cache, backpack or closure.

169
00:09:30.470 --> 00:09:34.990
The backpack or closure of live data
is attached to increment counter

170
00:09:34.990 --> 00:09:38.650
via the hidden property known as scope.

171
00:09:38.650 --> 00:09:41.750
Which persists, even when this
inner function is returned out.

172
00:09:41.750 --> 00:09:45.840
We grab all that data with us and
pull it out, on the back of the function.

173
00:09:45.840 --> 00:09:47.930
So as we we use that
function by its new label,

174
00:09:47.930 --> 00:09:50.100
we still have access to all that data.

175
00:09:50.100 --> 00:09:50.820
And it's permanent.

176
00:09:50.820 --> 00:09:51.320
It ain't going away.

