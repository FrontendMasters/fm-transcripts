WEBVTT

1
00:00:00.860 --> 00:00:02.490
&gt;&gt; Will Sentance: And
so it cave whereas but

2
00:00:02.490 --> 00:00:05.790
when he got returned up the function
increment counters definition

3
00:00:05.790 --> 00:00:09.808
got returned out of the running into
my new function and brought with it.

4
00:00:09.808 --> 00:00:16.540
All its surrounding local data
attached onto the function definition.

5
00:00:16.540 --> 00:00:19.538
We'll see all about how
this works in a moment.

6
00:00:19.538 --> 00:00:25.080
For now, here's a beautiful
little there it is a beautiful

7
00:00:25.080 --> 00:00:29.560
backpack of data such that here it is,

8
00:00:29.560 --> 00:00:34.080
such that when I run
my new function before

9
00:00:35.670 --> 00:00:41.440
I look into global in full.

10
00:00:41.440 --> 00:00:43.620
Where do you think Mark
that we look into the?

11
00:00:43.620 --> 00:00:45.272
&gt;&gt; Mark: Backpack.
&gt;&gt; Will Sentance: Into the backpack,

12
00:00:45.272 --> 00:00:46.337
spot on by Mark.

13
00:00:51.427 --> 00:00:56.830
&gt;&gt; Will Sentance: Into the backpack we go,
where what do we find, Kayla?

14
00:00:56.830 --> 00:00:57.970
&gt;&gt; Kayla: The counter is zero.

15
00:00:57.970 --> 00:00:59.350
&gt;&gt; Will Sentance: And what do we do to it?

16
00:00:59.350 --> 00:01:00.430
&gt;&gt; Kayla: We increment it.

17
00:01:00.430 --> 00:01:04.120
&gt;&gt; Will Sentance: We increment it to one,
she's spot on.

18
00:01:04.120 --> 00:01:05.300
She was so

19
00:01:05.300 --> 00:01:09.000
spot on, we have to cut the earlier
bit because she gave away the game.

20
00:01:09.000 --> 00:01:10.510
And let's keep running.

21
00:01:10.510 --> 00:01:11.070
Let's keep running.

22
00:01:11.070 --> 00:01:13.700
We'll talk more about it in a moment but
let's get out of this execution context.

23
00:01:13.700 --> 00:01:16.530
By the way, if there had been anything in
local memory, it would've been deleted.

24
00:01:16.530 --> 00:01:20.790
I have a feeling this data over here
attached to the function definition,

25
00:01:20.790 --> 00:01:22.030
that ain't going anywhere.

26
00:01:22.030 --> 00:01:25.480
That stuck on the function definition,
that ain't going anywhere.

27
00:01:25.480 --> 00:01:29.950
Let's keep running, out we come in my new
function, we pop it off the call stack.

28
00:01:29.950 --> 00:01:33.060
I'm actually gonna have to, even though
we're gonna run it again just so

29
00:01:33.060 --> 00:01:34.900
that we don't think it's the same,

30
00:01:34.900 --> 00:01:38.120
I'm literally gonna take it off
the call stack and add it again.

31
00:01:39.190 --> 00:01:40.030
There it is.

32
00:01:40.030 --> 00:01:43.830
Go back out to global where
we hit calling what function.

33
00:01:43.830 --> 00:01:45.200
Who should I call on, Dan.

34
00:01:45.200 --> 00:01:47.460
Dan, when we hit calling, what function?

35
00:01:47.460 --> 00:01:48.050
&gt;&gt; Dan: MyNewfunction.

36
00:01:48.050 --> 00:01:49.950
&gt;&gt; Will Sentance: MyNewfunction.

37
00:01:49.950 --> 00:01:51.600
Brand new what Dan?

38
00:01:51.600 --> 00:01:52.460
&gt;&gt; Bran: Execution context.

39
00:01:52.460 --> 00:01:56.026
&gt;&gt; Will Sentance: Execution context,
cool stack, that, what happens, Dan?

40
00:01:56.026 --> 00:01:58.490
&gt;&gt; Dan: MyNewfunction is pushed on.

41
00:01:58.490 --> 00:02:00.670
&gt;&gt; Will Sentance: Pushed on,
very nicely put.

42
00:02:00.670 --> 00:02:03.530
Let's create that execution context for
MyNewfunction.

43
00:02:04.730 --> 00:02:09.480
Into it we go,
nothing in the local memory declared.

44
00:02:09.480 --> 00:02:11.953
And what is our line of
code we got to run, Todd?

45
00:02:11.953 --> 00:02:13.220
&gt;&gt; Todd: Counter post post.

46
00:02:13.220 --> 00:02:14.485
&gt;&gt; Will Sentance: Well on Todd, excellent.

47
00:02:14.485 --> 00:02:19.028
Where Todd do we look for counter first?

48
00:02:19.028 --> 00:02:19.741
&gt;&gt; Todd: In the local memory.

49
00:02:19.741 --> 00:02:21.640
&gt;&gt; Will Sentance: In the local memory.

50
00:02:21.640 --> 00:02:22.660
Do we find counter?

51
00:02:22.660 --> 00:02:23.840
&gt;&gt; Todd: No.
&gt;&gt; Will Sentance: We don't.

52
00:02:23.840 --> 00:02:26.100
Todd, where do we go and look out to next?

53
00:02:26.100 --> 00:02:27.576
&gt;&gt; Todd: Backpack.
&gt;&gt; Will Sentance: Into the backpack,

54
00:02:27.576 --> 00:02:28.420
he's spot on.

55
00:02:28.420 --> 00:02:30.760
We go look at myNewFunction's definition,

56
00:02:30.760 --> 00:02:35.020
we look at the little connection to its
permanent stored data, the backpack.

57
00:02:35.020 --> 00:02:36.001
And off we go to it.

58
00:02:41.162 --> 00:02:42.958
&gt;&gt; Todd: [LAUGH]
&gt;&gt; Will Sentance: There it is and

59
00:02:42.958 --> 00:02:44.410
in we go.

60
00:02:44.410 --> 00:02:49.200
We used to be that bit up in the and in we
go and it's one and we do what with it?

61
00:02:49.200 --> 00:02:55.100
We increment it to, to look at that folk.

62
00:02:55.100 --> 00:02:58.700
For the very first time,
our function myNewFunction,

63
00:02:58.700 --> 00:03:03.510
a function definition doesn't just have it
local memory that gets literally I should

64
00:03:03.510 --> 00:03:08.600
have actually done this,
literally gets right, deleted each time.

65
00:03:08.600 --> 00:03:12.100
We now have not only
the temporary local memory,

66
00:03:12.100 --> 00:03:15.980
that if we don't return something out
in storing global, it's gone forever.

67
00:03:15.980 --> 00:03:18.480
We also have the very
definition the label,

68
00:03:18.480 --> 00:03:23.070
the function storage has attached
to it a permanent memory.

69
00:03:23.070 --> 00:03:24.840
That is remarkable.

70
00:03:24.840 --> 00:03:28.475
That is a say no longer is this a label
for just a function from code saved,

71
00:03:28.475 --> 00:03:32.400
it's a label for funds in closing and
some permanent store data attached.

72
00:03:33.860 --> 00:03:37.820
Genuinely very very, this is the most
elegant feature of all of JavaScript.

73
00:03:37.820 --> 00:03:41.370
Elegant meaning like, I know what that
means it was sort of like interesting,

74
00:03:41.370 --> 00:03:45.590
intriguing and surprisingly
kind of nicely crafted feature.

75
00:03:45.590 --> 00:03:47.090
And that's what I mean by elegant.

76
00:03:47.090 --> 00:03:47.660
I like using that word,

77
00:03:47.660 --> 00:03:50.790
that's one of those words people use
when they don't know what they mean.

78
00:03:50.790 --> 00:03:52.320
To mask not knowing what they mean.

79
00:03:52.320 --> 00:03:54.660
They're not sure why they think it's good,
and they're like that's elegant.

80
00:03:55.680 --> 00:04:00.330
So, let's start talking about
some caveats around this,

81
00:04:00.330 --> 00:04:02.410
including what do we call this.

82
00:04:02.410 --> 00:04:07.450
The first bit I want to talk about though
is, how does the function get to grab

83
00:04:07.450 --> 00:04:11.760
onto what it surrounding data and return
it out with the function definition?

84
00:04:11.760 --> 00:04:13.460
What is like this?

85
00:04:13.460 --> 00:04:17.310
As soon as,
I never quite even have room for this, but

86
00:04:17.310 --> 00:04:21.000
as soon as we declare increment counter.

87
00:04:21.000 --> 00:04:24.380
That is literally saving in the computer's
memory, in the computer store

88
00:04:24.380 --> 00:04:28.090
of functions and data, a label, and
the code of the function kinda plus plus.

89
00:04:28.090 --> 00:04:29.760
That's what this is here.

90
00:04:29.760 --> 00:04:33.440
Under the hood, if you had a console log
that would see the function definition.

91
00:04:33.440 --> 00:04:37.060
Depending on how sophisticated a console
is, we'd see the whole code of it, or

92
00:04:37.060 --> 00:04:39.460
in more traditional console,
you'd might see like function.

93
00:04:41.190 --> 00:04:47.100
That behind the scenes, in JavaScript,
immediately gets a hidden property.

94
00:04:47.100 --> 00:04:49.730
You always know they're hidden properties
when they have little square brackets

95
00:04:49.730 --> 00:04:52.790
before and after them, in the spec,
in the rules of JavaScript.

96
00:04:52.790 --> 00:04:56.640
It gets a hidden property,
square bracket, square bracket,

97
00:04:56.640 --> 00:04:59.030
that means there's a hidden property.

98
00:04:59.030 --> 00:05:02.770
Scope, square bracket, square bracket,

99
00:05:02.770 --> 00:05:09.480
it is a hidden property that links to
where all this surrounding data is stored.

100
00:05:09.480 --> 00:05:11.800
It gives a little link to
all that surrounding data.

101
00:05:12.810 --> 00:05:16.550
Meaning when I return that function out,
increment counter

102
00:05:16.550 --> 00:05:21.420
out of out of into my NewFunction,
you bet it brings it's hidden property and

103
00:05:21.420 --> 00:05:27.055
pulls that data with it through
its hidden square bracket,

104
00:05:27.055 --> 00:05:32.420
square bracket, scope, property.

105
00:05:32.420 --> 00:05:36.800
It's still attached when we give
that function its new global label,

106
00:05:36.800 --> 00:05:38.190
my new function.

107
00:05:38.190 --> 00:05:42.110
And when I run my new function I don't
find in the local memory counter,

108
00:05:42.110 --> 00:05:44.000
it kind of intercedes.

109
00:05:44.000 --> 00:05:50.880
It gets stuck in the way before we go out
to global, which first check the backpack.

110
00:05:50.880 --> 00:05:54.990
And that's where we see our counter is
stored and it ain't going anywhere.

111
00:05:54.990 --> 00:05:57.290
It's not like an execution
context temporary memory.

112
00:05:57.290 --> 00:06:00.810
It's permanent as long as its function
definitions they're not overwritten,

113
00:06:00.810 --> 00:06:02.889
this stuck around,
is still there permanently.

114
00:06:03.980 --> 00:06:10.270
We can't get access to it though in any
other way besides running this function

115
00:06:10.270 --> 00:06:14.290
and hoping the code was written in such
a way when it was defined, when was born,

116
00:06:14.290 --> 00:06:18.140
was initially saved, that it looks for
something a local memory, it ain't there.

117
00:06:18.140 --> 00:06:20.640
It refers to something
is not a local memory.

118
00:06:20.640 --> 00:06:24.930
Then it goes out and looks on
the scope property into the backpack.

119
00:06:24.930 --> 00:06:28.330
And there was something from when we save
that function that's being pulled out

120
00:06:28.330 --> 00:06:29.240
in the backpack.

121
00:06:29.240 --> 00:06:30.830
We cannot do this, this is not allowed.

122
00:06:30.830 --> 00:06:36.390
There's no like
MyNewFunction.backpack.counter.

123
00:06:36.390 --> 00:06:38.140
That is not we can't get
access to it that way.

124
00:06:38.140 --> 00:06:41.120
We can't go MyNewFunction even.scope.

125
00:06:41.120 --> 00:06:42.870
This is a hidden property,
we can't access it.

126
00:06:42.870 --> 00:06:47.330
It's ther, behind the scenes, but we can't
even go myNewFunction.scope.counter.

127
00:06:47.330 --> 00:06:50.450
The only way to get to that data
is by running this function,

128
00:06:50.450 --> 00:06:53.840
having it refer to something not in
local memory of it, and going out to

129
00:06:53.840 --> 00:06:57.390
the function's definition looking in
its backpack and finding counter there.

130
00:06:59.130 --> 00:07:02.420
Absolutely a very, very special feature.

131
00:07:02.420 --> 00:07:08.510
We now have permanent, but also by
the way, let's call it private data.

132
00:07:08.510 --> 00:07:11.880
No one else can access it besides by
running the function that we created to

133
00:07:11.880 --> 00:07:14.310
get access to it in our application.

134
00:07:14.310 --> 00:07:19.020
And you know what, I'm actually gonna save
for now any further words on this besides

135
00:07:19.020 --> 00:07:23.220
to say, just be thinking, if I have a
function now that has a permanent memory,

136
00:07:23.220 --> 00:07:24.550
think what sort of things I can do.

137
00:07:24.550 --> 00:07:27.130
I won't talk about all
the things we can do, but for

138
00:07:27.130 --> 00:07:30.750
just a hint, I can have this
function the second time it runs,

139
00:07:30.750 --> 00:07:35.030
check if counter is one,
suppose I increment it first time.

140
00:07:35.030 --> 00:07:40.800
If counter is one then return, sorry,
you can't run me more than once.

141
00:07:40.800 --> 00:07:44.572
That is to say this function remembers the
previous running via its permanent memory.

