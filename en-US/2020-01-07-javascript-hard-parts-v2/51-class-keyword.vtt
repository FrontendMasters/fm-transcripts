WEBVTT

1
00:00:00.190 --> 00:00:01.210
&gt;&gt; Will Sentance: Let's see, solution 3,

2
00:00:01.210 --> 00:00:03.590
the keyword that automates the hard work,
new.

3
00:00:03.590 --> 00:00:05.500
Benefits, faster to write, I get it.

4
00:00:05.500 --> 00:00:07.110
Look at all the blue,
that wasn't us writing anymore.

5
00:00:08.610 --> 00:00:10.940
Often still used professionally.

6
00:00:10.940 --> 00:00:14.310
And a big part of it is, but we'll see,
solution 4 changes it slightly.

7
00:00:14.310 --> 00:00:19.330
Problems, 95% of developers have no
idea how it's working under the hood.

8
00:00:19.330 --> 00:00:23.950
I think therefore fail interview, there's
a slightly mercenary motivation to learn,

9
00:00:23.950 --> 00:00:29.920
and therefore can't debug and build
clean and reliable code all the time.

10
00:00:29.920 --> 00:00:32.400
Here's another little problem with it,
this is the design,

11
00:00:32.400 --> 00:00:37.220
I would say, flow not a flow,
it's a not smart design move.

12
00:00:37.220 --> 00:00:41.230
That user create a function if I
ran it without the new keyword,

13
00:00:41.230 --> 00:00:42.160
I found it in the code base.

14
00:00:42.160 --> 00:00:44.579
And when I was running my team and
I started running without the new keyword.

15
00:00:44.579 --> 00:00:51.830
What would the this end up that I refer
to in order to six stuff in the object?

16
00:00:51.830 --> 00:00:53.032
What would it point to Braden?

17
00:00:53.032 --> 00:00:53.930
&gt;&gt; Braydon: The global.

18
00:00:53.930 --> 00:00:59.040
&gt;&gt; Will Sentance: The global object,
as know great as it and yet,

19
00:00:59.040 --> 00:01:02.152
you might say, well, it's kinda obvious
I need to have the new keyword, right?

20
00:01:02.152 --> 00:01:03.420
So we're gonna get this so early.

21
00:01:03.420 --> 00:01:06.810
It kind of isn't because I might have
other code before that this is even there.

22
00:01:06.810 --> 00:01:08.980
I might have like a function
declared that I am using it,

23
00:01:08.980 --> 00:01:11.700
that this might be inside
the function that this equals.

24
00:01:11.700 --> 00:01:16.670
The point is I do not know when I look
at that function that it requires a new

25
00:01:16.670 --> 00:01:19.230
keyword in order to do its job.

26
00:01:19.230 --> 00:01:23.170
That is probably not the smartest
design decision, right?

27
00:01:23.170 --> 00:01:25.890
You probably tend to want to be able
to look at the function and go,

28
00:01:25.890 --> 00:01:29.334
I know that that requires a new
key word to do anything useful.

29
00:01:30.960 --> 00:01:33.550
So developers helped each other out.

30
00:01:33.550 --> 00:01:36.440
If you can imagine the language
where if it's going to be a function

31
00:01:36.440 --> 00:01:39.590
that requires is going to automate stuff,
you wouldn't declare it with function you

32
00:01:39.590 --> 00:01:43.150
declare it with and
the constructor is a typical term for

33
00:01:43.150 --> 00:01:45.880
anything that creates
constructs an object.

34
00:01:45.880 --> 00:01:47.020
But JavaScript didn't do that.

35
00:01:47.020 --> 00:01:50.410
They said no problem is functions,
leaving it as regular function.

36
00:01:50.410 --> 00:01:54.380
And then insert three letters beforehand
new when you run the function.

37
00:01:54.380 --> 00:01:55.550
I don't know.

38
00:01:55.550 --> 00:01:56.547
That's not ideal for

39
00:01:56.547 --> 00:01:59.770
your team members who are like if
you write comments to tell them but.

40
00:01:59.770 --> 00:02:04.233
So what did developers in a short
hand do to help each other out so

41
00:02:04.233 --> 00:02:08.951
that they know when they see a function
that it needs a new keyword in

42
00:02:08.951 --> 00:02:12.230
front of it in order to do it's job?

43
00:02:12.230 --> 00:02:14.080
Yeah, go ahead Adam.

44
00:02:14.080 --> 00:02:14.890
&gt;&gt; Adam: Capitalize.

45
00:02:14.890 --> 00:02:16.110
&gt;&gt; Will Sentance: Capitalize
the first letter.

46
00:02:16.110 --> 00:02:19.380
And that's why you won't see, whenever you
see a new keyword being used in front of

47
00:02:19.380 --> 00:02:21.620
a function the function
will have an upper case.

48
00:02:21.620 --> 00:02:25.060
It doesn't have any meaning,
it doesn't have any impact to the code.

49
00:02:25.060 --> 00:02:28.970
Is just to help each other help
folk out to be able to spot

50
00:02:28.970 --> 00:02:30.630
that this function needs a new keyword.

51
00:02:30.630 --> 00:02:35.270
That is clearly something that
probably needed to be improved.

52
00:02:35.270 --> 00:02:36.820
And that is where solution 4 came in.

53
00:02:36.820 --> 00:02:39.390
We had to advocate first one of
the functions we know it requires new

54
00:02:39.390 --> 00:02:41.040
keywords we've worked.

55
00:02:41.040 --> 00:02:42.620
And that's where solution 4 came along.

56
00:02:42.620 --> 00:02:45.220
The cloth syntactic sugar.

57
00:02:45.220 --> 00:02:46.490
But it is a syntactic sugar.

58
00:02:46.490 --> 00:02:48.910
That means something that
changes the way it looks, but

59
00:02:48.910 --> 00:02:49.930
doesn't change it under the hood.

60
00:02:49.930 --> 00:02:52.790
For our purposes, for this bit here,
the way we're going to use it here,

61
00:02:52.790 --> 00:02:56.140
it doesn't change anything under the hood.

62
00:02:56.140 --> 00:02:57.910
Two things motivate this.

63
00:02:58.940 --> 00:03:04.710
It came along in the year 2015,
ES6, In declaring

64
00:03:04.710 --> 00:03:10.250
our function user creator, when executed

65
00:03:10.250 --> 00:03:14.470
automatically with the new keywords
help returns out an object into user1.

66
00:03:14.470 --> 00:03:20.340
Run it again will return an object into
user2, there's two important parts to it.

67
00:03:20.340 --> 00:03:23.270
There's the function that produces
the object automatically.

68
00:03:23.270 --> 00:03:26.230
And then there's the shared
store of functions.

69
00:03:26.230 --> 00:03:28.970
They're all bundled up on
the same functional object combo.

70
00:03:30.690 --> 00:03:35.470
But we announced to JavaScript
the two parts separately.

71
00:03:35.470 --> 00:03:37.595
We declare user creator,
that creates a function and

72
00:03:37.595 --> 00:03:40.058
an object with a prototype property
on it with an object to it.

73
00:03:40.058 --> 00:03:45.850
Which we can store then totally,
independently, the functions.

74
00:03:45.850 --> 00:03:51.130
In other languages, these two things are
so kind of intimately connected, right?

75
00:03:51.130 --> 00:03:54.820
It makes sense, this function when it
runs creates an object, returns it out,

76
00:03:54.820 --> 00:03:56.620
and that object has access
to these functions.

77
00:03:56.620 --> 00:03:58.280
So they're like intimately connected.

78
00:03:58.280 --> 00:03:59.770
In other languages you.

79
00:03:59.770 --> 00:04:02.080
Even in JavaScript,
they're intimately connected and

80
00:04:02.080 --> 00:04:04.390
they're on the same
functional object combo.

81
00:04:05.460 --> 00:04:09.270
But in other languages you
can declare them together.

82
00:04:09.270 --> 00:04:14.320
Know declaring the function who when run
returns out an object that has access to

83
00:04:14.320 --> 00:04:16.270
totally separately declared.

84
00:04:16.270 --> 00:04:20.770
The functions that go into the prototype
object sold on the project property,

85
00:04:20.770 --> 00:04:24.240
sorry that the objects on the project
property, all that function object combo.

86
00:04:24.240 --> 00:04:27.290
So yes, they are stored together,

87
00:04:27.290 --> 00:04:32.390
but they're not declared that means we
don't write them to JavaScript together.

88
00:04:32.390 --> 00:04:35.380
We don't write the instructions of jobs
to achieve those two things together.

89
00:04:35.380 --> 00:04:36.910
We don't write them together,
we run separately.

90
00:04:38.320 --> 00:04:42.130
Another language is we do that all
in one construct, in all in one go,

91
00:04:42.130 --> 00:04:45.240
all in one format.

92
00:04:45.240 --> 00:04:48.870
And that format people,
anyone know what that construct's called

93
00:04:48.870 --> 00:04:51.650
that allows us to do these together,
save these at the same time, Peter?

94
00:04:51.650 --> 00:04:52.270
&gt;&gt; Adam: A clause.

95
00:04:52.270 --> 00:04:53.960
&gt;&gt; Will Sentance: A clause exactly.

96
00:04:53.960 --> 00:04:55.800
It's pronounced clause, Peter.

97
00:04:55.800 --> 00:04:56.300
&gt;&gt; Adam: Sorry.

98
00:04:57.590 --> 00:05:02.520
&gt;&gt; Will Sentance: That's a joke, obviously
joke, a clause exactly, there we go.

99
00:05:02.520 --> 00:05:05.400
But Peter, you're so
kind that you were pointed out you do not.

100
00:05:06.640 --> 00:05:09.850
You truly in a very, very nice person.

101
00:05:09.850 --> 00:05:12.701
Unclearly unlike myself, so
we're writing I shared methods,

102
00:05:12.701 --> 00:05:14.718
these methods that get
shared by all others.

103
00:05:14.718 --> 00:05:21.192
Actually let's just to help
ourselves out here have a user 701,

104
00:05:21.192 --> 00:05:26.643
which would have come out of
running user creator again,

105
00:05:26.643 --> 00:05:30.504
let's actually do it here just in case,

106
00:05:30.504 --> 00:05:36.089
user 701 with a result of
another call to user Creator.

107
00:05:36.089 --> 00:05:42.933
Let's say with Sarah and 19 and
the new key word of course in front and

108
00:05:42.933 --> 00:05:47.600
that would have returned
out into user 701.

109
00:05:47.600 --> 00:05:55.020
And this time let's get this right,
have the object

110
00:05:55.020 --> 00:05:59.350
with the proto property up to

111
00:06:02.790 --> 00:06:07.808
the shared object and then name, Sarah,

112
00:06:07.808 --> 00:06:12.751
score 19.

113
00:06:14.360 --> 00:06:17.430
Everyone gets this portion here,
I hope that's not throwing people.

114
00:06:17.430 --> 00:06:24.640
Those two objects, they both have access
to these shared functions, methods.

115
00:06:26.230 --> 00:06:28.573
We're saving them on the same
functional combo, but

116
00:06:28.573 --> 00:06:32.730
we're declaring them,
&gt;&gt; Will Sentance: Separately.

117
00:06:33.860 --> 00:06:35.430
Let's do it all in one place.

118
00:06:35.430 --> 00:06:38.420
And the class construct lets us do that.

119
00:06:38.420 --> 00:06:41.850
Here it is, it's syntactic sugar folk,
I'm actually going to go straight to here.

120
00:06:43.780 --> 00:06:45.610
These were the two parts we did before,
right?

121
00:06:45.610 --> 00:06:47.602
Remember, we got our
function user created,

122
00:06:47.602 --> 00:06:49.348
which creates a function object combo.

123
00:06:49.348 --> 00:06:54.939
Though when it's run Will create
inside of itself with a new keyword,

124
00:06:54.939 --> 00:06:59.773
an object storing user1 first time,
storing user 701,

125
00:06:59.773 --> 00:07:05.386
701st time that each have access
to this object full of functions.

126
00:07:05.386 --> 00:07:08.170
User creator.prototype.increment.

127
00:07:08.170 --> 00:07:10.620
User creator.prototype.login.

128
00:07:10.620 --> 00:07:11.630
We save them there.

129
00:07:13.330 --> 00:07:16.170
Now nothing has changed under the hood.

130
00:07:16.170 --> 00:07:21.330
We just get to do these two separate
declarations or assignments

131
00:07:21.330 --> 00:07:26.560
in one construct, we call it a class.

132
00:07:26.560 --> 00:07:33.110
We take the label of the function and
we make you the label of the class.

133
00:07:33.110 --> 00:07:36.527
As soon as you declare a class,
what do we think we get people?

134
00:07:39.370 --> 00:07:40.310
&gt;&gt; Will Sentance: Dan?
&gt;&gt; Dan: An object.

135
00:07:40.310 --> 00:07:41.889
&gt;&gt; Will Sentance: We get
a function object combo.

136
00:07:45.078 --> 00:07:46.040
&gt;&gt; Will Sentance: We get an object, yes.

137
00:07:46.040 --> 00:07:49.100
We get an object ready to receive
a function and an object.

138
00:07:49.100 --> 00:07:51.770
As soon as we do it we're gonna
deal with the first bit inside it.

139
00:07:51.770 --> 00:07:59.320
So as soon as we declare it,
we get a functional object combo.

140
00:07:59.320 --> 00:08:08.670
If not,
we've got a functional object combo.

141
00:08:08.670 --> 00:08:13.710
And the first bit of the function object
combo, we give the subtitle constructor,

142
00:08:13.710 --> 00:08:20.190
and that's the function bit, or
the function object combo there it is.

143
00:08:20.190 --> 00:08:20.800
We don't know.

144
00:08:20.800 --> 00:08:24.792
We give it a subtitle, constructor.

145
00:08:28.277 --> 00:08:31.266
&gt;&gt; Will Sentance: And of course it gets
on it in the function object combo in

146
00:08:31.266 --> 00:08:35.400
the object bit, a prototype property,
which is an object full of function,

147
00:08:35.400 --> 00:08:38.390
well not yet,
what do we immediately store though, and

148
00:08:38.390 --> 00:08:42.880
no longer do we manually have to assign
them look we just list them out.

149
00:08:42.880 --> 00:08:45.430
Not even commas in between,
we just list them out.

150
00:08:45.430 --> 00:08:48.340
We can list as many out as we want and
they're all gonna be taken one by one and

151
00:08:48.340 --> 00:08:50.230
behind the scenes what's
JavaScript running?

152
00:08:50.230 --> 00:08:54.377
It saying user
creator.prototype.increment, and

153
00:08:54.377 --> 00:08:57.382
it's sticking them into that object.

154
00:08:57.382 --> 00:09:00.754
People, nothing has changed
under the hood here.

155
00:09:00.754 --> 00:09:06.971
We have as soon as we declare a class
before we did it by declaring a function.

156
00:09:06.971 --> 00:09:11.047
Which implicitly created an object
attached to it a function object combo

157
00:09:11.047 --> 00:09:14.880
into which had a prototype property
which was an object itself.

158
00:09:14.880 --> 00:09:17.320
Into which we stored our shared functions.

159
00:09:17.320 --> 00:09:24.090
Now, we create a clause which
is a function object combo.

160
00:09:25.490 --> 00:09:28.650
And the first bit of it,
we give a subtitle constructor and

161
00:09:28.650 --> 00:09:30.620
you can see it's identical.

162
00:09:30.620 --> 00:09:34.300
That first thing we pass into this other
constructor first in your path, sorry.

163
00:09:34.300 --> 00:09:35.920
First thing we store in it.

164
00:09:35.920 --> 00:09:41.510
And give ourselves a constructor is the
function bit of the function object combo.

165
00:09:41.510 --> 00:09:43.640
And then all the functions
we list out below,

166
00:09:43.640 --> 00:09:45.850
we're just gonna literally
list them out by name.

167
00:09:45.850 --> 00:09:48.020
Behind the scenes George,
we're taking the first one and

168
00:09:48.020 --> 00:09:53.040
we're going up, off we go to our
function object combo that is the class.

169
00:09:53.040 --> 00:09:57.110
And look on the object bit of it and
look on its prototype property and

170
00:09:57.110 --> 00:10:00.910
look at that object and
story method, called increment.

171
00:10:00.910 --> 00:10:04.530
And then the next slide it goes login.

172
00:10:04.530 --> 00:10:07.380
Off we go to a user creator class,

173
00:10:07.380 --> 00:10:12.350
which is really just a function object
combo and look on the prototype property.

174
00:10:12.350 --> 00:10:15.860
We insert a login property on it and
assign a function.

175
00:10:15.860 --> 00:10:17.240
And after that it's the same.

176
00:10:17.240 --> 00:10:20.510
When we run user creates I've done
the upper case here no change.

177
00:10:20.510 --> 00:10:24.350
When we run user creator with the key word
knew which bit do we run of the function

178
00:10:24.350 --> 00:10:25.715
object combo, Dan?

179
00:10:25.715 --> 00:10:30.767
When we run user creator with either a
nine with the keyword new in front of it,

180
00:10:30.767 --> 00:10:33.974
which bit of the function
object combo do we run.

181
00:10:33.974 --> 00:10:34.788
&gt;&gt; Dan: The constructor.

182
00:10:34.788 --> 00:10:37.295
&gt;&gt; Will Sentance: The function,
yeah we call it constructor now but

183
00:10:37.295 --> 00:10:39.860
it's really just the same function, yeah.

184
00:10:39.860 --> 00:10:42.100
And when out returns from it an object,

185
00:10:42.100 --> 00:10:45.020
it's gonna link to which bit of
the function object combo Dan?

186
00:10:45.020 --> 00:10:47.000
&gt;&gt; Dan: The prototype.

187
00:10:47.000 --> 00:10:52.550
&gt;&gt; Will Sentance: Prototype object
exactly, nothing has changed.

188
00:10:52.550 --> 00:10:57.500
But it does look a lot
more like other languages.

189
00:10:57.500 --> 00:11:00.720
But that to me, I don't even know,

190
00:11:00.720 --> 00:11:03.900
because is it doing what other
languages are doing under the hood?

191
00:11:03.900 --> 00:11:05.210
No, it's definitely not.

192
00:11:05.210 --> 00:11:11.540
And that's almost more, I don't know,
it makes again more legible.

193
00:11:11.540 --> 00:11:14.550
It makes it more apparently readable.

194
00:11:14.550 --> 00:11:17.520
But behind the scenes, nothing's changed.

195
00:11:17.520 --> 00:11:22.041
Meaning if we wanna really understand and
debug and

196
00:11:22.041 --> 00:11:26.456
use these techniques,
it's even more pertinent

197
00:11:26.456 --> 00:11:31.409
that we now understand what's
going on under the hood.

198
00:11:31.409 --> 00:11:35.413
Going on under the hood because even
more now it looks like other languages.

199
00:11:35.413 --> 00:11:39.324
Meaning will bring all our views of
how those other languages implement

200
00:11:39.324 --> 00:11:43.300
these features, but ain't doing
in real life behind the scenes.

201
00:11:43.300 --> 00:11:47.640
It's exactly the same model by the way,
as we saw all the way back and solution 2.

202
00:11:48.850 --> 00:11:51.940
It's just been wrapped by
the automation the new key well,

203
00:11:51.940 --> 00:11:54.188
it's a lot of the codes been
automated by the new key word.

204
00:11:54.188 --> 00:11:59.011
And now wrapped the setting up of
our starting point of our function

205
00:11:59.011 --> 00:12:01.692
which when run returns out objects.

206
00:12:01.692 --> 00:12:06.281
And has act lose objects have access
to the shares or functions there now,

207
00:12:06.281 --> 00:12:11.166
we now through the process of setting this
up in one go In the class constructs,

208
00:12:11.166 --> 00:12:12.910
in the class setup.

209
00:12:12.910 --> 00:12:17.070
But it ain't changing anything under the
hood, it just makes us write less code.

210
00:12:17.070 --> 00:12:20.180
It's what's called a syntactic sugar,
makes it look prettier,

211
00:12:20.180 --> 00:12:23.830
I'm assuming it's like icing
sugar on a cake, I have no idea.

212
00:12:23.830 --> 00:12:26.260
Syntactically you're like,
makes it look prettier, but

213
00:12:26.260 --> 00:12:29.070
it ain't changing anything under the hood.

214
00:12:29.070 --> 00:12:33.410
All right folk, benefits emerging
as a new standard no doubt

215
00:12:33.410 --> 00:12:36.190
feels more like the start of
other languages Python and Java.

216
00:12:36.190 --> 00:12:39.970
It looks a lot like the style of
other languages, languages, problems.

217
00:12:39.970 --> 00:12:47.210
I say 95 for solution 3, 99% of
developers have no idea how it works.

218
00:12:47.210 --> 00:12:48.500
Again, why it's fail interviews?

219
00:12:48.500 --> 00:12:51.540
I don't know this is a very but

220
00:12:51.540 --> 00:12:55.520
can't solve the problems that they want
to solve the way they want to solve them.

221
00:12:55.520 --> 00:12:58.490
But you will not be one of those people.

