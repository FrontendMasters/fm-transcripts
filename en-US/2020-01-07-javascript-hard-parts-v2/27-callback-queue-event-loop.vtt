WEBVTT

1
00:00:00.150 --> 00:00:01.470
&gt;&gt; Will Sentance: We have our printHello.

2
00:00:01.470 --> 00:00:02.510
We have our blockFor1Sec.

3
00:00:02.510 --> 00:00:04.610
We're going to call this setTimeout.

4
00:00:04.610 --> 00:00:08.054
Is setTimeout doing anything in
JavaScript of interest, Kayla?

5
00:00:08.054 --> 00:00:09.688
&gt;&gt; off screen female: No.

6
00:00:09.688 --> 00:00:11.120
&gt;&gt; Will Sentance: No,
nothing in JavaScript.

7
00:00:11.120 --> 00:00:12.937
Then we're gonna call out blockFor1Sec.

8
00:00:12.937 --> 00:00:14.687
And then we're gonna, let's see,

9
00:00:14.687 --> 00:00:17.634
well maybe we're not gonna call
out blockFor1Sec for next.

10
00:00:17.634 --> 00:00:20.020
Who knows, we shall see.

11
00:00:20.020 --> 00:00:23.920
So, there's our global memory.

12
00:00:23.920 --> 00:00:27.637
Line one, Kayla, what are we up to?

13
00:00:27.637 --> 00:00:29.449
&gt;&gt; off screen female: We're
defining the printHello function.

14
00:00:29.449 --> 00:00:34.540
&gt;&gt; Will Sentance: Very nice,
we're defining the printHello function.

15
00:00:34.540 --> 00:00:37.788
Excellent, next line over to Jeff.

16
00:00:37.788 --> 00:00:40.405
&gt;&gt; off screen male: We define a function,
blockFor1Second.

17
00:00:40.405 --> 00:00:44.408
&gt;&gt; Will Sentance: blockFor1Sec,
exactly, there it is.

18
00:00:44.408 --> 00:00:46.738
We don't know how it's, I mean,
we know how it's gonna work.

19
00:00:46.738 --> 00:00:48.838
We're not writing its code out,
but if we ran it,

20
00:00:48.838 --> 00:00:51.540
you would run some sort of for
loop, or something like that.

21
00:00:51.540 --> 00:00:53.450
Definitely not a timer, just be clear.

22
00:00:53.450 --> 00:00:55.010
It's an easy trap to fall into.

23
00:00:55.010 --> 00:00:57.730
Now, things get interesting.

24
00:00:57.730 --> 00:01:02.935
Now, we hit our first facade function for

25
00:01:02.935 --> 00:01:08.446
a feature of the web browser, setTimeout.

26
00:01:08.446 --> 00:01:15.354
And we're going to invite Ethan, no, no,
no [LAUGH] Ethan's line was excellent.

27
00:01:15.354 --> 00:01:18.255
We're not gonna put even
through that again.

28
00:01:18.255 --> 00:01:20.680
printHello, and this time is 0.

29
00:01:20.680 --> 00:01:22.737
I mean, the second wait.

30
00:01:22.737 --> 00:01:28.388
Okay, I should give
them to you from there.

31
00:01:28.388 --> 00:01:31.772
setTimeout, do we have anything
in JavaScript of any interest?

32
00:01:31.772 --> 00:01:35.120
No, what instead is in a command to

33
00:01:35.120 --> 00:01:37.816
which part of our-
&gt;&gt; off screen male: It's gonna send

34
00:01:37.816 --> 00:01:39.640
a message to the web browser?

35
00:01:39.640 --> 00:01:44.857
&gt;&gt; Will Sentance: Very nicely put,
it's gonna trigger in the web browser,

36
00:01:44.857 --> 00:01:48.700
the switching on of the timer, of a timer.

37
00:01:48.700 --> 00:01:52.826
And what information does it need here,
Mark, to be an effective timer?

38
00:01:52.826 --> 00:01:53.611
&gt;&gt; off screen male: The actual time.

39
00:01:53.611 --> 00:01:54.478
&gt;&gt; Will Sentance: Yeah, right?

40
00:01:54.478 --> 00:01:59.183
0 milliseconds, and also, Ethan?

41
00:01:59.183 --> 00:02:01.760
&gt;&gt; off screen male: The function
definition printHello?

42
00:02:01.760 --> 00:02:04.470
&gt;&gt; Will Sentance: Yeah, that's what we're
gonna run on the completion of the timer.

43
00:02:04.470 --> 00:02:06.375
Perfect, very nice.

44
00:02:06.375 --> 00:02:09.140
And this is all happening
at roughly what time?

45
00:02:09.140 --> 00:02:13.699
Maybe 0 milliseconds or something like
that, roughly 0 milliseconds, there it is.

46
00:02:15.000 --> 00:02:21.410
Now, we need everything below
here to be our Web Browser.

47
00:02:21.410 --> 00:02:24.517
So there it is,

48
00:02:24.517 --> 00:02:29.303
Web Browser features.

49
00:02:32.495 --> 00:02:36.776
&gt;&gt; Will Sentance: Web Browser
features Timer in the web browser.

50
00:02:36.776 --> 00:02:42.004
So we'd say the feature we're

51
00:02:42.004 --> 00:02:46.030
gonna use is the Timer.

52
00:02:46.030 --> 00:02:50.959
Turn on a timer, set its time to
completion to be 0 milliseconds.

53
00:02:52.200 --> 00:02:56.420
On its completion, just remind us,
again, Matt, on completion.

54
00:02:56.420 --> 00:02:57.900
What do we want to have happen?

55
00:02:57.900 --> 00:03:00.100
&gt;&gt; off screen male: You want
it to run the printHello.

56
00:03:00.100 --> 00:03:03.560
&gt;&gt; Will Sentance: Perfect,
run the printHello function.

57
00:03:03.560 --> 00:03:07.560
So we're going to pass into
the web browser a reference,

58
00:03:07.560 --> 00:03:09.370
a link back to the function
we want to run in JavaScript.

59
00:03:09.370 --> 00:03:14.020
But think of it as being the function is
now, so just be outside of JavaScript or

60
00:03:14.020 --> 00:03:16.203
at least it's sitting there ready,

61
00:03:16.203 --> 00:03:19.671
hopefully to be run back inside
JavaScript at some point.

62
00:03:19.671 --> 00:03:24.442
Now question,
I wanna turn to Kayla on this one.

63
00:03:24.442 --> 00:03:28.980
Kayla, is at 0 milliseconds,

64
00:03:28.980 --> 00:03:34.532
is our 0 millisecond timer complete?

65
00:03:34.532 --> 00:03:36.037
&gt;&gt; off screen female: No.

66
00:03:36.037 --> 00:03:40.054
&gt;&gt; Will Sentance: 0 minute timer at
0 milliseconds, what do you think?

67
00:03:40.054 --> 00:03:45.171
Is that kinda,
&gt;&gt; Will Sentance: Is it complete?

68
00:03:45.171 --> 00:03:47.374
How would it take any
longer than 0 milliseconds?

69
00:03:47.374 --> 00:03:49.298
Todd, you didn't complete.

70
00:03:49.298 --> 00:03:51.714
&gt;&gt; off screen male: Okay,
so my question would be,

71
00:03:51.714 --> 00:03:56.221
is that 0 milliseconds the same
as that 0 milliseconds?

72
00:03:56.221 --> 00:03:57.530
&gt;&gt; Will Sentance: Yeah, 0 milliseconds,

73
00:03:57.530 --> 00:03:59.974
our 0 millisecond timer is complete,
people.

74
00:03:59.974 --> 00:04:01.017
There you go, good job.

75
00:04:01.017 --> 00:04:05.935
0 milliseconds, our 0 millisecond
timer is definitely complete, right?

76
00:04:05.935 --> 00:04:07.831
I don't know how many more than
milliseconds it would take.

77
00:04:07.831 --> 00:04:11.290
It's like, yeah,
0 millisecond is a complete timer.

78
00:04:11.290 --> 00:04:14.403
Because crazily, it's like done.

79
00:04:14.403 --> 00:04:15.266
It's done, it's all it is.

80
00:04:15.266 --> 00:04:18.167
It's a 0 millisecond timer.

81
00:04:18.167 --> 00:04:22.033
So I presume printHello gets grabbed and

82
00:04:22.033 --> 00:04:27.562
put on to the,
&gt;&gt; Will Sentance: Call Stack.

83
00:04:29.391 --> 00:04:30.607
&gt;&gt; Will Sentance: What do we think people?

84
00:04:33.444 --> 00:04:35.742
&gt;&gt; Will Sentance: And yet,
it is complete and so it's time for

85
00:04:35.742 --> 00:04:37.804
the function to go onto the Call Stack.

86
00:04:40.960 --> 00:04:44.120
&gt;&gt; Will Sentance: I'm making
sure I stand on my best foot.

87
00:04:44.120 --> 00:04:45.480
Turner told me this is my best angle.

88
00:04:46.950 --> 00:04:50.920
It is complete, so I guess you get, folk,

89
00:04:50.920 --> 00:04:54.230
there's another part to the puzzle
that we need to know about.

90
00:04:54.230 --> 00:04:55.831
And I'm not gonna beat
around the bush on it.

91
00:04:55.831 --> 00:04:58.450
I'm gonna talk about it right now,
which is this.

92
00:04:58.450 --> 00:05:01.710
It's called, it's a queue.

93
00:05:01.710 --> 00:05:04.414
I heard the word said from a few
people when you were talking about it.

94
00:05:04.414 --> 00:05:07.715
It's a queue of, what do we call these?

95
00:05:07.715 --> 00:05:10.964
What do we call baby functions that
get passed into other functions?

96
00:05:10.964 --> 00:05:13.569
Little functions that get passed
as inputs into other functions.

97
00:05:13.569 --> 00:05:14.087
&gt;&gt; off screen male: Callback.

98
00:05:14.087 --> 00:05:20.236
&gt;&gt; Will Sentance: Callback,
so it's a queue of callbacks.

99
00:05:20.236 --> 00:05:23.056
A callback queue.

100
00:05:23.056 --> 00:05:28.033
Do not by the way confuse it, or do not
confuse these callbacks with the ones

101
00:05:28.033 --> 00:05:32.820
we saw yesterday where they run
inside of the higher order function.

102
00:05:32.820 --> 00:05:36.130
No, no, no, this one is grabbed and
thrown right out of.

103
00:05:36.130 --> 00:05:37.255
This is just a command.

104
00:05:37.255 --> 00:05:40.988
At no point is printHello
run inside of setTimeout.

105
00:05:40.988 --> 00:05:42.966
They just grabbed that function,
set it and

106
00:05:42.966 --> 00:05:45.860
threw into the timer into the web
browser and it's stored here.

107
00:05:47.750 --> 00:05:50.162
Or at least a link to where it was
originally defined is store there.

108
00:05:51.650 --> 00:05:52.525
At this moment,

109
00:05:52.525 --> 00:05:56.472
at 0 milliseconds, printHello ain't
going on the Call Stack directly.

110
00:05:56.472 --> 00:06:01.570
It's gonna have to queue itself up
here into the callback queue it goes,

111
00:06:01.570 --> 00:06:04.860
at 0 milliseconds, ready to run.

112
00:06:04.860 --> 00:06:07.840
There's our friend printHello, and

113
00:06:07.840 --> 00:06:11.850
it's gonna sit in the callback
queue ready to run.

114
00:06:15.910 --> 00:06:19.671
&gt;&gt; Will Sentance: But
it's still ready so I guess now,

115
00:06:19.671 --> 00:06:25.250
as we complete the setTimeout,
we're gonna pile on,

116
00:06:25.250 --> 00:06:31.942
accelerated on to our next line which,
Dan, at 1 millisecond.

117
00:06:31.942 --> 00:06:33.964
&gt;&gt; off screen male: We're
going to call blockFor1Sec?

118
00:06:33.964 --> 00:06:35.840
&gt;&gt; Will Sentance: But, little
printHello is sitting there waiting.

119
00:06:37.400 --> 00:06:38.370
Who thinks Dan's right?

120
00:06:39.380 --> 00:06:40.444
Dan is spot on.

121
00:06:40.444 --> 00:06:44.393
We are gonna call blockFor1Sec.

122
00:06:44.393 --> 00:06:46.913
Most interesting.

123
00:06:46.913 --> 00:06:51.020
blockFor1Sec.

124
00:06:51.020 --> 00:06:52.800
Brand new execution context.

125
00:06:52.800 --> 00:06:56.328
We're not gonna sort of
go through its details.

126
00:06:56.328 --> 00:07:00.970
But, I'm adding so much detail for
it, brand new execution context.

127
00:07:00.970 --> 00:07:02.690
There it is.

128
00:07:02.690 --> 00:07:05.980
And our thread of execution
is gonna weave in.

129
00:07:05.980 --> 00:07:07.290
It's going on the call stack.

130
00:07:08.710 --> 00:07:17.373
blockFor1Sec, we go into
it at 1 millisecond.

131
00:07:17.373 --> 00:07:20.860
It's gonna take 1,000 milliseconds inside.

132
00:07:23.008 --> 00:07:24.830
&gt;&gt; Will Sentance: Now
we have the question.

133
00:07:26.600 --> 00:07:31.304
At any moment, do we think, while we
are in blockFor1Sec, it's doing for loop,

134
00:07:31.304 --> 00:07:32.930
lots and lots of iteration.

135
00:07:32.930 --> 00:07:34.059
At any moment there,

136
00:07:34.059 --> 00:07:38.150
do we think printHello is allowed out of
that queue to be run on the call stack?

137
00:07:39.480 --> 00:07:40.130
It's not.

138
00:07:41.360 --> 00:07:44.319
But my goodness,
it's been waiting for 0 milliseconds.

139
00:07:46.170 --> 00:07:53.328
We're gonna come out of
blockFor1Sec at 1001 milliseconds.

140
00:07:53.328 --> 00:07:59.854
And our little printHello is gonna say,
okay, finally, you finish your function.

141
00:07:59.854 --> 00:08:03.363
You popped it off the call stack,
let's pop it off the call stack.

142
00:08:03.363 --> 00:08:07.470
Okay, finally, I'm allowed out.

143
00:08:07.470 --> 00:08:14.122
And it's been waiting there quite eagerly,
very excited, say, I wanna come out.

144
00:08:14.122 --> 00:08:18.410
I wanna [LAUGH] be out of
the queue into the call stack.

145
00:08:19.990 --> 00:08:22.630
And finally at 1001 milliseconds,
what do we think happens?

146
00:08:22.630 --> 00:08:23.230
Is it allowed out?

147
00:08:23.230 --> 00:08:23.922
&gt;&gt; off screen male: Yes.

148
00:08:23.922 --> 00:08:25.889
&gt;&gt; Will Sentance: No,
it's still not allowed out.

149
00:08:25.889 --> 00:08:26.953
[LAUGH]
&gt;&gt; [LAUGH]

150
00:08:26.953 --> 00:08:27.667
&gt;&gt; Will Sentance: Instead,

151
00:08:27.667 --> 00:08:33.309
our poor little printHello is gonna sit
there and what's gonna run instead, Todd?

152
00:08:33.309 --> 00:08:34.053
&gt;&gt; off screen male: The console.log
me first.

153
00:08:34.053 --> 00:08:38.051
&gt;&gt; Will Sentance: console.log me first,
exactly right.

154
00:08:38.051 --> 00:08:40.761
Our console.log me first.

155
00:08:40.761 --> 00:08:45.169
There it is into our console will be

156
00:08:45.169 --> 00:08:50.038
logged at 1,001 milliseconds.

157
00:08:50.038 --> 00:08:51.632
Me first.

158
00:08:51.632 --> 00:08:54.387
Exactly right.

159
00:08:54.387 --> 00:08:56.343
My goodness.

160
00:08:56.343 --> 00:09:00.145
Now at 1002 milliseconds,

161
00:09:00.145 --> 00:09:04.379
you're all nervous to even say it.

162
00:09:04.379 --> 00:09:10.185
At 1002 milliseconds, now surely, okay,
that's my voice, I'll do Mile's yes voice.

163
00:09:10.185 --> 00:09:13.743
Now, Brayden, what do you think
is gonna be allowed to run and

164
00:09:13.743 --> 00:09:15.189
be put on the call stack?

165
00:09:15.189 --> 00:09:15.722
&gt;&gt; off screen male: printHello.

166
00:09:15.722 --> 00:09:18.283
&gt;&gt; Will Sentance: printHello,
exactly right.

167
00:09:18.283 --> 00:09:23.271
At 1002 milliseconds,
printHello grabbed out

168
00:09:23.271 --> 00:09:28.367
of the queue, put on the call stack,
and there it is,

169
00:09:28.367 --> 00:09:33.604
printHello is executed
at 1,002 milliseconds.

170
00:09:33.604 --> 00:09:36.308
Therefore, Brayden,
we see in our console, what?

171
00:09:36.308 --> 00:09:36.839
&gt;&gt; off screen male: Hello.

172
00:09:36.839 --> 00:09:40.560
&gt;&gt; Will Sentance: Hello, exactly.

173
00:09:40.560 --> 00:09:44.438
My god, there we go.

174
00:09:44.438 --> 00:09:46.706
So folk, can you try and ascertain.

175
00:09:51.205 --> 00:09:55.539
&gt;&gt; Will Sentance: Yes, can you try and
ascertain what is our fundamental,

176
00:09:55.539 --> 00:09:59.980
that was my low point trying
to use a word I just learned.

177
00:09:59.980 --> 00:10:06.025
Can we try and
ascertain what was our rule for

178
00:10:06.025 --> 00:10:09.840
when a function in the queue that's being

179
00:10:09.840 --> 00:10:14.540
thrown out by using one of these facade
functions, out into the web browser.

180
00:10:14.540 --> 00:10:16.760
setTimeout ain't really doing
anything in JavaScript.

181
00:10:16.760 --> 00:10:19.732
Instead, it's just grabbing that function,
[SOUND], throwing it out here.

182
00:10:19.732 --> 00:10:24.368
What is the rule by which after it's
been sitting in the queue, queued up,

183
00:10:24.368 --> 00:10:29.280
ready to run, by which it's allowed
out of that queue onto the call stack.

184
00:10:29.280 --> 00:10:30.181
Can anyone take a guess?

185
00:10:30.181 --> 00:10:31.224
There's sort of two parts to it.

186
00:10:31.224 --> 00:10:32.472
Yeah, go ahead, Matt.

187
00:10:32.472 --> 00:10:34.941
&gt;&gt; off screen male: When the execution
context currently running is complete.

188
00:10:34.941 --> 00:10:41.750
&gt;&gt; Will Sentance: Absolutely, so if you've
got any on the call stack, gotta be gone.

189
00:10:41.750 --> 00:10:43.350
But it's more than that.

190
00:10:43.350 --> 00:10:44.750
It's so strict.

191
00:10:44.750 --> 00:10:45.800
Yeah, Kayla.

192
00:10:45.800 --> 00:10:48.050
&gt;&gt; off screen female: The global
execution context has to be done.

193
00:10:48.050 --> 00:10:52.560
&gt;&gt; Will Sentance: It's in fact all
synchronous code, all regular execution.

194
00:10:52.560 --> 00:10:57.155
Meaning you could have,
which is exactly what Kayla's saying,

195
00:10:57.155 --> 00:11:01.344
you could literally have
a million console.logs in a row.

196
00:11:01.344 --> 00:11:05.157
You could have an infinite
while loop of console.log, and

197
00:11:05.157 --> 00:11:08.270
the queue would never dequeue printHello.

198
00:11:08.270 --> 00:11:11.890
It would never even grab it and
put it on the call stack.

199
00:11:11.890 --> 00:11:15.613
And that, to me, I will admit,
when I first realized that,

200
00:11:15.613 --> 00:11:17.224
I had to go and check that.

201
00:11:17.224 --> 00:11:22.300
I couldn't believe you could literally,
literally have a million console.logs.

202
00:11:22.300 --> 00:11:24.980
And they would all run before
anything was out of the queue.

203
00:11:24.980 --> 00:11:26.390
That seems insane, but

204
00:11:26.390 --> 00:11:32.660
it actually allows us to be certain of
when our code will run out of a queue.

205
00:11:32.660 --> 00:11:38.420
It may not be the certain in
the sense of I know the moment.

206
00:11:38.420 --> 00:11:39.250
But I do know the order.

207
00:11:40.260 --> 00:11:44.970
All regular code will run first until
I ever touch anything from the queue,

208
00:11:44.970 --> 00:11:46.430
until I ever put anything
out of the queue.

209
00:11:47.720 --> 00:11:50.890
So, how does JavaScript implement that?

210
00:11:50.890 --> 00:11:54.880
Well, it has a little tiny feature,
very profound feature.

211
00:11:54.880 --> 00:11:57.240
But really, it just does this one thing,

212
00:11:57.240 --> 00:12:01.340
which says I'm gonna check before
every single line of code run.

213
00:12:01.340 --> 00:12:03.580
Is the call stack empty?

214
00:12:03.580 --> 00:12:05.190
Is the call stack empty?

215
00:12:05.190 --> 00:12:06.390
Is there something in the queue?

216
00:12:06.390 --> 00:12:09.460
If the call stack is not empty, if there's
still further global code to run, if

217
00:12:09.460 --> 00:12:13.930
there's still further global code to run,
then I will not even go look at the queue.

218
00:12:13.930 --> 00:12:15.910
But if the call stack's empty or

219
00:12:15.910 --> 00:12:20.790
if I head down to the queue, I grab
the function, I put it on the call stack.

220
00:12:20.790 --> 00:12:24.040
And what is that known
as that little feature?

221
00:12:24.040 --> 00:12:27.270
That little feature that does the very,
very fast checking

222
00:12:27.270 --> 00:12:30.030
every single line before it runs
any line of code, it checks.

223
00:12:30.030 --> 00:12:31.610
Is there anything on the call stack?

224
00:12:31.610 --> 00:12:32.868
If there is, just do it.

225
00:12:32.868 --> 00:12:34.910
Is there anything left running global,
do it.

226
00:12:34.910 --> 00:12:38.720
If it's all finished,
head down to the queue.

227
00:12:38.720 --> 00:12:44.882
And that feature is known as the Event,
&gt;&gt; Will Sentance: Loop.

228
00:12:44.882 --> 00:12:48.434
And it's job is simply to very
quickly be checking constantly.

229
00:12:48.434 --> 00:12:49.267
Is the call stack empty?

230
00:12:49.267 --> 00:12:50.132
Is there anything in the queue?

231
00:12:50.132 --> 00:12:50.983
Is the call stack empty?

232
00:12:50.983 --> 00:12:51.832
Is there anything in the queue?

233
00:12:51.832 --> 00:12:53.256
Is there any global code to run?

234
00:12:53.256 --> 00:12:56.290
No, finally I get to go down.

235
00:12:56.290 --> 00:13:00.841
So my event loop throughout goes,
is the call stack empty at blockFor1Sec,

236
00:13:00.841 --> 00:13:01.617
everybody?

237
00:13:01.617 --> 00:13:02.384
&gt;&gt; off screen male: No.
&gt;&gt; Will Sentance: No,

238
00:13:02.384 --> 00:13:05.671
we stil got to run in blockFor1Sec.

239
00:13:05.671 --> 00:13:09.972
At 1,001 milliseconds,
is there further global code still to run?

240
00:13:09.972 --> 00:13:10.845
&gt;&gt; off screen male: Yes.
&gt;&gt; Will Sentance: Yeah, so

241
00:13:10.845 --> 00:13:12.660
the event loop goes, no, you can't.

242
00:13:13.690 --> 00:13:18.340
Finally, when all global code is
finished running, what happens?

243
00:13:18.340 --> 00:13:23.660
It heads down to the queue, it goes, yes,
I'm ready to head down into the queue.

244
00:13:23.660 --> 00:13:27.028
It grabs printHello, and
it sits on the call stack and executes it.

245
00:13:27.028 --> 00:13:31.939
It puts the parenthesis on for us,
no problem and runs printHello.

246
00:13:31.939 --> 00:13:39.280
And for that until he has six was the
entire model of Asynchronous JavaScript.

247
00:13:39.280 --> 00:13:42.926
So let's have thumbs on this notion
that we have saved our functions for

248
00:13:42.926 --> 00:13:44.278
another blockFor1Sec.

249
00:13:44.278 --> 00:13:47.374
We use setTimeout to trigger a timer,

250
00:13:47.374 --> 00:13:52.140
an associated printHello
function was passed to it.

251
00:13:52.140 --> 00:13:55.020
Yes, it said 0 milliseconds until
that function could be run.

252
00:13:55.020 --> 00:13:57.210
But what do we now know that really means?

253
00:13:57.210 --> 00:14:00.720
It means that it's 0 milliseconds
until that function is put into the,

254
00:14:00.720 --> 00:14:04.490
exactly as Peter's hinting,
into the callback queue.

255
00:14:04.490 --> 00:14:08.161
And then all our global code's gonna
continue running, however long it takes.

256
00:14:08.161 --> 00:14:14.159
And when it's all done,
then the event loop goes,

257
00:14:14.159 --> 00:14:18.077
hooray, the Call Stack is done.

258
00:14:18.077 --> 00:14:21.798
All global coast finish running, and
we grab from the Callback Queue and

259
00:14:21.798 --> 00:14:23.570
put printHello in the Call Stack.

