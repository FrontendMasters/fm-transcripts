WEBVTT

1
00:00:00.330 --> 00:00:01.267
&gt;&gt; Will Sentance: Dan, go ahead.

2
00:00:01.267 --> 00:00:06.133
&gt;&gt; Dan: Kind of two, the first one
is if you had a secondary execution

3
00:00:06.133 --> 00:00:11.298
context wrapping, can you have
a back pack of the second level?

4
00:00:11.298 --> 00:00:11.837
&gt;&gt; Will Sentance: Yeah, absolutely yes.

5
00:00:11.837 --> 00:00:14.423
So, I would say that,
go experiment, but it is a chain.

6
00:00:14.423 --> 00:00:18.803
This is what's called, well, we're gonna
learn the name of this in a moment, but

7
00:00:18.803 --> 00:00:22.259
yeah, it is, absolutely,
you can go play with that, for sure.

8
00:00:22.259 --> 00:00:25.158
But yes, it is a chain,
yeah, second question?

9
00:00:25.158 --> 00:00:30.798
&gt;&gt; Dan: Can you have a callback
that accesses the data?

10
00:00:30.798 --> 00:00:33.946
&gt;&gt; Will Sentance: Wow, so you're saying,
could we pass into here a function that,

11
00:00:33.946 --> 00:00:35.331
is that what you're-
&gt;&gt; Dan: Yeah,

12
00:00:35.331 --> 00:00:37.014
that would then access the variables?

13
00:00:37.014 --> 00:00:39.712
&gt;&gt; Will Sentance: Yeah, so
this is what's called function decoration.

14
00:00:39.712 --> 00:00:42.389
Many of the techniques enclosed in a,
sorry,

15
00:00:42.389 --> 00:00:46.509
in functional programming use this
principle, where you would pass,

16
00:00:46.509 --> 00:00:51.402
one knows a to detail, I want to do like a
half, sort of half-baked version of this.

17
00:00:51.402 --> 00:00:55.663
Go watch the functional programming Hall
parts where we do this in absolute full,

18
00:00:55.663 --> 00:00:57.468
but we can take a function in here.

19
00:00:57.468 --> 00:01:00.576
We can define a brand new function
in here, so she gets a backpack.

20
00:01:00.576 --> 00:01:05.170
That function will then have
access to the argument function

21
00:01:05.170 --> 00:01:09.420
passed into outer,
when we return out in its backpack.

22
00:01:09.420 --> 00:01:13.013
I mean, we can store code in
the backpack and run the function.

23
00:01:13.013 --> 00:01:16.983
Meaning that that returned-out function
will be, we could make it behave pretty

24
00:01:16.983 --> 00:01:20.388
similarly to the function that got
passed in, but with some changes.

25
00:01:20.388 --> 00:01:23.189
It's behaving similar,
because it's in the, behind the scenes,

26
00:01:23.189 --> 00:01:25.229
gonna be running the function
from its backpack.

27
00:01:25.229 --> 00:01:26.960
That's a half-baked answer.

28
00:01:26.960 --> 00:01:31.194
But absolutely, you can literally
store code in the backpack as well.

29
00:01:31.194 --> 00:01:34.455
And that's what enables carrying,
partial application and

30
00:01:34.455 --> 00:01:36.342
function decoration techniques.

31
00:01:36.342 --> 00:01:40.664
All of them sit on this, but sit on us
passing a function in which ends up

32
00:01:40.664 --> 00:01:43.980
in the brand new returned
out function's backpack.

33
00:01:43.980 --> 00:01:45.924
And that is the decoration process,

34
00:01:45.924 --> 00:01:48.629
different to other languages
handle decoration.

35
00:01:48.629 --> 00:01:51.183
Decoration's where you edit a function or
appear to,

36
00:01:51.183 --> 00:01:54.792
in reality what you're doing, brand
new function that uses the decorated,

37
00:01:54.792 --> 00:01:56.694
the change function from his backpack.

38
00:01:56.694 --> 00:02:01.270
That's something that, don't worry if
you're going what the hell does that mean?

39
00:02:01.270 --> 00:02:04.623
But if you want to learn more about it go
watch the functional programming hotpots.

40
00:02:04.623 --> 00:02:07.392
Could be the, be the only person.

41
00:02:07.392 --> 00:02:08.991
I'm sure it can be very popular.

42
00:02:08.991 --> 00:02:10.108
I'm sure it's gonna blow up.

43
00:02:10.108 --> 00:02:10.615
Excellent.

44
00:02:10.615 --> 00:02:11.373
All right, thank you, Dan.

45
00:02:11.373 --> 00:02:13.302
Great questions, Peter.

46
00:02:13.302 --> 00:02:16.666
&gt;&gt; Peter: Very similarly, you called
the counter data private within there, and

47
00:02:16.666 --> 00:02:20.489
then you could store a function there, and
then that would be a private function.

48
00:02:20.489 --> 00:02:22.194
&gt;&gt; Will Sentance: Yes, the term private.

49
00:02:22.194 --> 00:02:26.710
I gotta be careful on that because all
these terms are general terms that have

50
00:02:26.710 --> 00:02:31.028
many competing definitions in
different languages, so is it private?

51
00:02:31.028 --> 00:02:35.912
Well, as long as we can do certain
things with it then probably not.

52
00:02:35.912 --> 00:02:39.390
Is it private in the sense that we're not
able to suddenly randomly override to

53
00:02:39.390 --> 00:02:40.401
the global memory,?

54
00:02:40.401 --> 00:02:41.143
Sure.

55
00:02:41.143 --> 00:02:42.782
So just be careful with
any of these terms,

56
00:02:42.782 --> 00:02:45.248
they're all a little bit elusive
across different languages.

57
00:02:45.248 --> 00:02:47.029
Yeah, go ahead [INAUDIBLE].

58
00:02:47.029 --> 00:02:50.599
&gt;&gt; Speaker 4: There's a question
from online about scope and

59
00:02:50.599 --> 00:02:54.089
is basically where does
scope come into play?

60
00:02:54.089 --> 00:02:56.625
&gt;&gt; Will Sentance: You'll see it
in one second, absolutely, yeah.

61
00:02:56.625 --> 00:02:58.166
Yeah, go ahead, Jason.

62
00:02:58.166 --> 00:03:01.974
&gt;&gt; Jason: Error propagation,
we're nesting a bunch of calls,

63
00:03:01.974 --> 00:03:04.716
we're nesting a bunch of operations.

64
00:03:04.716 --> 00:03:07.639
I can still make an access
error on those variables,

65
00:03:07.639 --> 00:03:10.839
I can still ask for
an MSE in an array that doesn't exist.

66
00:03:10.839 --> 00:03:16.466
But now we've got a chain of references
to propagate our error through.

67
00:03:16.466 --> 00:03:21.121
&gt;&gt; Will Sentance: Yeah, I mean this is
this is one of the interesting challenges

68
00:03:21.121 --> 00:03:25.330
is that when we all using
traditional console logging,

69
00:03:25.330 --> 00:03:28.030
I find console log my new function.

70
00:03:28.030 --> 00:03:33.525
It's got a bunch of state data attached to
it that I don't get to see on my console.

71
00:03:33.525 --> 00:03:35.899
That's gonna be pretty hard to debug.

72
00:03:35.899 --> 00:03:37.782
Unless we know what's happening,
of course.

73
00:03:37.782 --> 00:03:42.780
Now, kindly the chrome dev
tools do give us the ability

74
00:03:42.780 --> 00:03:46.377
to pause our execution at this moment.

75
00:03:46.377 --> 00:03:50.456
And if we do, we'll see the contents
of the backpack on the right-hand side.

76
00:03:50.456 --> 00:03:53.019
They give it the official name,
which I'll tell you in a second.

77
00:03:53.019 --> 00:03:56.609
There's one thing I did, nobody raised,
but I do want to bring up.

78
00:03:56.609 --> 00:03:57.579
Yeah, go ahead, Mark.

79
00:03:57.579 --> 00:04:01.654
&gt;&gt; Mark: If in outer-
&gt;&gt; Mark: You created another variable-

80
00:04:01.654 --> 00:04:02.819
&gt;&gt; Will Sentance: There's the question,

81
00:04:02.819 --> 00:04:03.654
go ahead, Mark.

82
00:04:03.654 --> 00:04:05.437
&gt;&gt; Mark: If incrementCounter doesn't call.

83
00:04:05.437 --> 00:04:06.628
&gt;&gt; Will Sentance: Doesn't reference,
doesn't reference.

84
00:04:06.628 --> 00:04:08.009
&gt;&gt; Mark: Doesn't reference,
does he get it?

85
00:04:08.009 --> 00:04:12.267
&gt;&gt; Will Sentance: There it is perfect,
as in question Mark is about to give.

86
00:04:12.267 --> 00:04:13.383
Yes, fantastic question, Mark.

87
00:04:13.383 --> 00:04:15.416
We'll be clear everyone
got that question by Mark.

88
00:04:15.416 --> 00:04:16.461
Mark said hold on.

89
00:04:16.461 --> 00:04:21.893
But what if, in this local
memory I created, let's call it,

90
00:04:21.893 --> 00:04:26.703
I don't know, Mark's counter and
the year and this.

91
00:04:26.703 --> 00:04:30.155
Mark's counter is seven,
the returned out function,

92
00:04:30.155 --> 00:04:32.584
can I edit this returned out function?

93
00:04:32.584 --> 00:04:39.596
No, therefore, that,
Mark's counter goes in the backpack.

94
00:04:39.596 --> 00:04:41.117
Can I get anything on a backpack directly?

95
00:04:41.117 --> 00:04:43.252
No, I can only get it by
running the function.

96
00:04:43.252 --> 00:04:47.592
So I know exactly, or Java knows exactly
the moment of returning out what could

97
00:04:47.592 --> 00:04:49.580
ever be accessed in that backpack.

98
00:04:49.580 --> 00:04:53.892
And so in modern versions of,
the implementations of JavaScript in

99
00:04:53.892 --> 00:04:58.063
the chrome engine and
other engines as well, I think for 39 on.

100
00:04:58.063 --> 00:05:02.897
JavaScript optimizes,
what is put into the backpack.

101
00:05:02.897 --> 00:05:06.910
The link is made the entire local memory,
and it's just a link to where that stops.

102
00:05:06.910 --> 00:05:10.346
Yeah, this isn't if we declare Mark's
counter inside of outer is gonna be

103
00:05:10.346 --> 00:05:13.019
stored, it's just when we're
finished running outer,

104
00:05:13.019 --> 00:05:14.560
normally it will all be deleted.

105
00:05:14.560 --> 00:05:19.712
Instead, anything that the function ever
makes reference to when it would get

106
00:05:19.712 --> 00:05:25.271
run eventually, gets pulled out with the
function on its back into my new function.

107
00:05:25.271 --> 00:05:30.225
But if that thing, Mark's counter is
never referenced, never referred to,

108
00:05:30.225 --> 00:05:33.827
never used by the function and
it gets returned out jobs,

109
00:05:33.827 --> 00:05:38.578
you can literally look into this
function and go, does it ever reference?

110
00:05:38.578 --> 00:05:42.866
Nope, no reference made to Mark's counter,
only to counter.

111
00:05:42.866 --> 00:05:46.855
And so there's no point in being in the
backpack cuz that would be what's called

112
00:05:46.855 --> 00:05:47.638
a memory leak.

113
00:05:47.638 --> 00:05:51.566
That is a say specifically,
use space in the computer's memory.

114
00:05:51.566 --> 00:05:54.052
With a label,
you've got data used with a label,

115
00:05:54.052 --> 00:05:56.429
where we can't ever act
as that label anymore.

116
00:05:56.429 --> 00:05:58.613
And so
that data is completely inaccessible,

117
00:05:58.613 --> 00:06:01.695
as it is literally just wasting
space in the computer's memory.

118
00:06:01.695 --> 00:06:03.018
That's what a memory leak is.

119
00:06:03.018 --> 00:06:04.763
And that would be the case here.

120
00:06:04.763 --> 00:06:07.539
That would be stored,
we'd have Mark's counter is 7, and yet,

121
00:06:07.539 --> 00:06:10.119
if we ran myNewFunction,
it never makes reference to it, and

122
00:06:10.119 --> 00:06:12.417
we can't get to directly so
it's just waste of space.

