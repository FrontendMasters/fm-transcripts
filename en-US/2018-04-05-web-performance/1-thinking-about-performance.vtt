WEBVTT

1
00:00:00.230 --> 00:00:01.125
&gt;&gt; Steve Kinney: Cool,
so let's get started.

2
00:00:01.125 --> 00:00:05.970
Talk a little bit about what do
we mean by the work performance?

3
00:00:05.970 --> 00:00:10.570
And why it matters, except that seemed
good on the slide, I'm actually

4
00:00:10.570 --> 00:00:14.420
gonna answer the why it matters and then
we'll talk about how to think about it.

5
00:00:14.420 --> 00:00:19.260
Mostly it's a self pitch to keep
you interested over the next few

6
00:00:19.260 --> 00:00:23.000
hours it's kind of like giving you
the pitch on why it's important and

7
00:00:23.000 --> 00:00:25.290
then we'll talk about what to do about it.

8
00:00:25.290 --> 00:00:28.090
So why does performance matter?

9
00:00:28.090 --> 00:00:32.150
I think the industry
standard at this point is

10
00:00:32.150 --> 00:00:37.340
to go through a bunch of slides of
statistics as a large appeal to authority,

11
00:00:37.340 --> 00:00:43.210
like this stuff is really important also
you're already watching this course.

12
00:00:43.210 --> 00:00:46.260
Si it's fair to say that I
am preaching to the choir.

13
00:00:46.260 --> 00:00:51.177
But it is not unlikely that you have a
product manager or an engineering manager

14
00:00:51.177 --> 00:00:55.955
that would also need to be, [LAUGH] that
would benefit from this sales pitch.

15
00:00:55.955 --> 00:00:57.482
So we'll do it together, and

16
00:00:57.482 --> 00:01:00.508
arm ourselves in kind of some
of the research behind this.

17
00:01:00.508 --> 00:01:06.420
Jakob Nielsen did a bunch of research
on User interfaces and performance.

18
00:01:06.420 --> 00:01:08.890
A lot of it was really
kind of interesting.

19
00:01:08.890 --> 00:01:15.900
At about a tenth of a second, users feel
that the system is instantaneous, right?

20
00:01:15.900 --> 00:01:18.570
They take an action and
the application has responded.

21
00:01:18.570 --> 00:01:20.310
They don't notice any kind of lag.

22
00:01:20.310 --> 00:01:21.952
That is the ideal.

23
00:01:21.952 --> 00:01:25.620
So a 10th of a second, 100 milliseconds
is kind of what we aim for.

24
00:01:25.620 --> 00:01:27.080
Now is that always possible?

25
00:01:27.080 --> 00:01:30.430
Do we need to make a network
request to do the thing, right?

26
00:01:30.430 --> 00:01:33.080
There's a lot of
considerations to think about.

27
00:01:33.080 --> 00:01:36.680
But we know that users
can not tell anything,

28
00:01:36.680 --> 00:01:41.340
I think Microsoft has done research where
they make that even faster and faster.

29
00:01:41.340 --> 00:01:45.780
And there are imperceptible,
users can notice, but for our purposes,

30
00:01:45.780 --> 00:01:48.589
100 milliseconds is the gold standard.

31
00:01:50.080 --> 00:01:51.800
After about a second,

32
00:01:51.800 --> 00:01:56.610
user's flow of thought is interrupted,
they notice it, right?

33
00:01:56.610 --> 00:01:59.540
They could get distracted, they can
lose the feeling that the application

34
00:01:59.540 --> 00:02:03.590
is responsive and
doing the things that they're asking for.

35
00:02:03.590 --> 00:02:06.410
And then after about ten seconds

36
00:02:06.410 --> 00:02:10.110
it's almost impossible to
keep a user's attention.

37
00:02:10.110 --> 00:02:10.660
Right?

38
00:02:10.660 --> 00:02:16.730
At that point, a shiny object in the
corner has appeared and the user is gone.

39
00:02:16.730 --> 00:02:17.550
Right?
Now granted,

40
00:02:17.550 --> 00:02:21.070
if you have interactions on your
page that take more than ten seconds

41
00:02:21.070 --> 00:02:22.520
we should talk, right?

42
00:02:22.520 --> 00:02:24.700
Ten seconds is a very long period of time.

43
00:02:24.700 --> 00:02:28.910
But it's also not outrageous for
how long it takes a page to load, right?

44
00:02:28.910 --> 00:02:31.900
In a lot of cases if we are writing
JavaScript applications, right?

45
00:02:31.900 --> 00:02:35.090
We not only have to get those
bits to the browser, but

46
00:02:35.090 --> 00:02:38.340
we also then have to build
the application on their machines.

47
00:02:38.340 --> 00:02:41.680
And so that ten seconds is both for
an interaction but going and

48
00:02:41.680 --> 00:02:46.710
visiting the page in the beginning, is
also an interaction with the page, right?

49
00:02:46.710 --> 00:02:48.960
So we want to keep that in mind as well.

50
00:02:48.960 --> 00:02:52.320
Because we know that with a lot of
research that if our page takes too long

51
00:02:52.320 --> 00:02:56.010
to load it will have
impacts on user engagement.

52
00:02:56.010 --> 00:02:56.890
Cool.
So I'm going to show

53
00:02:56.890 --> 00:02:59.710
you some more statistics that
make myself seem smart but

54
00:02:59.710 --> 00:03:03.410
really, collecting other
people's really smart work.

55
00:03:03.410 --> 00:03:08.172
The Aberdeen Group found that a 1
second slow down resulted in 11%

56
00:03:08.172 --> 00:03:11.510
fewer page views and 7% less conversion.

57
00:03:11.510 --> 00:03:12.150
Right?

58
00:03:12.150 --> 00:03:16.240
Page views and conversions for a lot of
applications turn into dollars and cents.

59
00:03:16.240 --> 00:03:16.878
Right?
And,

60
00:03:16.878 --> 00:03:20.028
I write software because I really
enjoy writing software but

61
00:03:20.028 --> 00:03:22.942
I also really enjoy getting paid for
writing software.

62
00:03:22.942 --> 00:03:25.080
So I don't have to do other things.

63
00:03:25.080 --> 00:03:28.927
And I also enjoy the company I work for
making enough money to pay me.

64
00:03:28.927 --> 00:03:33.078
So a lot of times, the performance and
our care about that stuff directly

65
00:03:33.078 --> 00:03:37.859
translates into the work that we do and
it's also about delighting users, right?

66
00:03:37.859 --> 00:03:42.521
Akamai found that a 2 second delay
in web page load time increased

67
00:03:42.521 --> 00:03:44.510
bounce rates by 103%.

68
00:03:44.510 --> 00:03:47.087
So double the amount of people are leaving

69
00:03:47.087 --> 00:03:49.743
if your page is two
seconds slower to load.

70
00:03:49.743 --> 00:03:54.342
A 400 millisecond improvement in
performance resulted in a 9% increase in

71
00:03:54.342 --> 00:03:55.929
traffic at Yahoo, right?

72
00:03:55.929 --> 00:03:59.262
So we can see that there is this
correlation between the performance

73
00:03:59.262 --> 00:04:02.720
of our application and
effectively paying the bills.

74
00:04:02.720 --> 00:04:08.010
Google found that a 2% slower page
resulted in 2% fewer searches,

75
00:04:08.010 --> 00:04:13.380
which given Google's business
model means 2% fewer ads shown and

76
00:04:13.380 --> 00:04:18.830
you can see how that kind of fike
trickles down the entire thing.

77
00:04:18.830 --> 00:04:22.330
100 millisecond improvement in
performance results in a 1%

78
00:04:22.330 --> 00:04:24.808
increase in the overall revenue at Amazon.

79
00:04:24.808 --> 00:04:28.556
Now 1%,
normally doesn't seem like a big impact,

80
00:04:28.556 --> 00:04:33.316
but when you're operating at Amazon scale,
1% is a lot, right?

81
00:04:33.316 --> 00:04:35.958
So there's definitely, we can trace,

82
00:04:35.958 --> 00:04:40.168
the care about performance to
a lot of times business outcomes.

83
00:04:40.168 --> 00:04:45.741
53% of users will leave a mobile site if
it takes more than 3 seconds to load,

84
00:04:45.741 --> 00:04:46.334
right?

85
00:04:46.334 --> 00:04:48.862
So we put all this work and
care into building this website, and

86
00:04:48.862 --> 00:04:51.210
they're not even going to see
it because it took too long.

87
00:04:51.210 --> 00:04:56.469
And I think the one general one
makes a lot of sense in the research

88
00:04:56.469 --> 00:05:01.733
is that if you want your application or
your site to feel faster,

89
00:05:01.733 --> 00:05:07.200
you need to be about 20% faster
than your competitors, right?

90
00:05:07.200 --> 00:05:10.630
So you need to keep that,
we know that that now makes a difference.

91
00:05:12.070 --> 00:05:15.100
So being in fast is important, right?

92
00:05:15.100 --> 00:05:17.600
Yeah, let's do the thing, right?

93
00:05:17.600 --> 00:05:23.852
We have these tried and true things like
minify your assets and of things and

94
00:05:23.852 --> 00:05:30.300
send it across the wire and those have
been true since I started programming.

95
00:05:30.300 --> 00:05:30.860
Right?

96
00:05:30.860 --> 00:05:33.750
But things have changed from
out from under us as well.

97
00:05:33.750 --> 00:05:36.620
So at the same time while being
fast is really important,

98
00:05:36.620 --> 00:05:40.050
it's also a lot harder to
be a fast application.

99
00:05:41.820 --> 00:05:44.320
Applications keep getting bigger and
bigger and bigger.

100
00:05:44.320 --> 00:05:48.070
A few years ago,
the average web application

101
00:05:48.070 --> 00:05:51.625
hIt the point where it was bigger
than the video game Doom, right?

102
00:05:52.680 --> 00:05:56.650
So effectively,
we are sending an entire video game

103
00:05:56.650 --> 00:06:01.770
from a few decades ago every time
someone goes to visit our page.

104
00:06:01.770 --> 00:06:03.717
Not only is that a fun factoid, but

105
00:06:03.717 --> 00:06:07.410
I think looking at the graph is
kind of important to see it's not,

106
00:06:07.410 --> 00:06:11.850
it jumped off a few years ago and
here we are now in web application land.

107
00:06:11.850 --> 00:06:17.880
It's increasingly
increasing as time goes on.

108
00:06:17.880 --> 00:06:23.377
So this is beta.httparchive.org
actually has a bunch of

109
00:06:23.377 --> 00:06:31.575
data on the basic size of the average web
page traction from about 2010 on forward.

110
00:06:31.575 --> 00:06:37.120
And you can see that I hovered
around March 15, 2013.

111
00:06:37.120 --> 00:06:38.719
So five years ago today.

112
00:06:38.719 --> 00:06:45.080
And you can see that the average, the 50th
percentile was about 864 kilobytes, right?

113
00:06:45.080 --> 00:06:46.393
And there's a range there.

114
00:06:46.393 --> 00:06:50.351
But you can see that the average today
on desktop is almost double that.

115
00:06:50.351 --> 00:06:54.531
More than double that and on mobile,
ten times that size, right?

116
00:06:54.531 --> 00:06:57.910
So as, yeah phones are getting faster and
stuff like that.

117
00:06:57.910 --> 00:07:02.190
Not at the same rate that we are shipping
more and more code to the browser.

118
00:07:02.190 --> 00:07:05.669
So it means that we need to start caring
about performance if we hope to keep up.

119
00:07:06.970 --> 00:07:13.090
At the same time, LTE is getting slower,
on two networks in particular.

120
00:07:13.090 --> 00:07:15.310
But in general, as more and
more people get LTE,

121
00:07:15.310 --> 00:07:20.590
the networks are getting more and
more increasingly bogged down.

122
00:07:20.590 --> 00:07:25.167
Which means that as we ship more and
more code, the time to get that code is

123
00:07:25.167 --> 00:07:29.315
taking longer and longer,
which can get a little out of control.

124
00:07:29.315 --> 00:07:33.795
So, we need to, again we need to
be dealing with this stuff because

125
00:07:33.795 --> 00:07:36.919
it's not going to just
magically get better.

126
00:07:36.919 --> 00:07:39.863
The browser is gonna get faster and
the next iPhone is gonna be way better,

127
00:07:39.863 --> 00:07:41.494
I don't have to worry about any of this.

128
00:07:41.494 --> 00:07:45.748
While those things are true,
they don't necessarily,

129
00:07:45.748 --> 00:07:49.690
the rate, is kind of a bigger issue here.

130
00:07:49.690 --> 00:07:52.840
So all right, performance is important,
have I made that point?

131
00:07:52.840 --> 00:07:54.430
Feel good about that?

132
00:07:54.430 --> 00:07:55.510
Convinced?
Sweet.

133
00:07:55.510 --> 00:07:59.030
So the big question is how do we
think about performance, right?

134
00:07:59.030 --> 00:08:01.955
I joked before that you
can gzip your assets and

135
00:08:01.955 --> 00:08:04.580
minify them and stuff along those lines.

136
00:08:04.580 --> 00:08:06.180
Right?
And that's great.

137
00:08:06.180 --> 00:08:09.130
But I think it's really interesting,
I think it's important

138
00:08:09.130 --> 00:08:13.220
to think about the application that
you're working on and what are its needs.

139
00:08:13.220 --> 00:08:15.760
A really great example is if you
think about a content website like

140
00:08:15.760 --> 00:08:17.600
the New York Times or
the Huffington Post or

141
00:08:17.600 --> 00:08:20.110
anything along those lines,
what do they need to do?

142
00:08:20.110 --> 00:08:21.329
What is their biggest priority?

143
00:08:22.490 --> 00:08:23.921
Showing you content, right?

144
00:08:23.921 --> 00:08:26.940
And they need to do that as
instantaneously as possible.

145
00:08:26.940 --> 00:08:29.844
One would argue that's true for
Twitter, or Facebook as well.

146
00:08:29.844 --> 00:08:32.170
Is, you logged in to see your timeline,
and

147
00:08:32.170 --> 00:08:35.920
they need to show it to you as
quickly as they possibly can.

148
00:08:35.920 --> 00:08:39.225
Showing you a load bar is not acceptable.

149
00:08:39.225 --> 00:08:39.870
Right?

150
00:08:39.870 --> 00:08:40.620
You will leave.

151
00:08:40.620 --> 00:08:44.630
You'll be like I should be doing something
else rather than checking on the news.

152
00:08:44.630 --> 00:08:46.610
I'm gonna go back to that real work.

153
00:08:46.610 --> 00:08:48.110
I don't need to do this, right?

154
00:08:48.110 --> 00:08:50.770
And that's kind of what we're
talking about with those like

155
00:08:50.770 --> 00:08:53.185
noticeable percentages, right?

156
00:08:53.185 --> 00:08:56.369
That's when people go, I don't actually
need to be doing this right now.

157
00:08:56.369 --> 00:08:57.390
There is my boss coming.

158
00:08:57.390 --> 00:08:59.837
Command+Tab back to my text editor, right?

159
00:08:59.837 --> 00:09:02.151
But Gmail if you think about it,

160
00:09:02.151 --> 00:09:06.715
we tolerate a loading bar every
time we log into Gmail, right?

161
00:09:06.715 --> 00:09:08.050
Because there is a difference.

162
00:09:08.050 --> 00:09:11.057
On a content set you might be
jumping from page to page to page.

163
00:09:11.057 --> 00:09:13.777
On a site like Gmail on the other hand,

164
00:09:13.777 --> 00:09:18.197
you open up Gmail and you live in it for
the majority of the day.

165
00:09:18.197 --> 00:09:22.724
Maybe you're switching to another tab,
but we're willing to pay that cost once,

166
00:09:22.724 --> 00:09:27.252
because we know that once we pay the cost
for loading the application it's there and

167
00:09:27.252 --> 00:09:30.730
it's alive so
it's more of the of single page app feel.

168
00:09:30.730 --> 00:09:35.510
But for Gmail they need to be a much more
concerned about like memory links, right?

169
00:09:35.510 --> 00:09:38.470
Because if it get slower over time
as the application exist as they're

170
00:09:38.470 --> 00:09:42.500
adding more and more to the so and
so forth, that becomes untenable.

171
00:09:42.500 --> 00:09:45.950
While a page like The New York Times
someone's bouncing from page to page to

172
00:09:45.950 --> 00:09:46.675
page, right?

173
00:09:46.675 --> 00:09:50.541
The priorities are very different for
the applications, right?

174
00:09:50.541 --> 00:09:53.781
So we can tolerate this, but
we would not tolerate from New York Times.

175
00:09:53.781 --> 00:09:55.685
We have to, manage those.

176
00:09:55.685 --> 00:10:01.548
So I'm gonna argue today that there
are three different kinds of performance.

177
00:10:01.548 --> 00:10:04.968
And we're gonna talk about each one
individually rather than just say,

178
00:10:04.968 --> 00:10:08.909
performance do these things that could
have been a blog post of 20 items, right?

179
00:10:08.909 --> 00:10:12.070
We're going to turn,
figure out how we think about performance.

180
00:10:12.070 --> 00:10:14.700
How some of these things
work under the hood and

181
00:10:14.700 --> 00:10:18.100
then use that to inform
what we do about it.

182
00:10:18.100 --> 00:10:22.450
So the three types of performance
that I want to argue exist

183
00:10:22.450 --> 00:10:23.790
are network load performance.

184
00:10:23.790 --> 00:10:27.312
So, okay,
we build client side applications.

185
00:10:27.312 --> 00:10:31.978
Which is a unique problem insofar that,
you would like this application?

186
00:10:31.978 --> 00:10:34.762
Let me send you the source
code to the application and

187
00:10:34.762 --> 00:10:36.412
you can deal with everything.

188
00:10:36.412 --> 00:10:39.580
So we need to get that to the user
before they see anything.

189
00:10:39.580 --> 00:10:42.020
So that's obviously important and
we need to deal with that.

190
00:10:42.020 --> 00:10:45.780
And that is normally when people talk
about performance they're talking about

191
00:10:45.780 --> 00:10:47.400
caching headers and all those kinds and

192
00:10:47.400 --> 00:10:49.540
how do I get you to this
page as fast as possible?

193
00:10:49.540 --> 00:10:51.030
And that's important.

194
00:10:51.030 --> 00:10:55.790
But I also think that especially in the
world of modern single page applications,

195
00:10:55.790 --> 00:10:59.800
that we need to think about okay,
you have the application, now what?

196
00:10:59.800 --> 00:11:00.320
Right?

197
00:11:00.320 --> 00:11:03.850
So we're also gonna talk about parsing and
JavaScript, and

198
00:11:03.850 --> 00:11:05.356
compilation performance, right?

199
00:11:05.356 --> 00:11:08.000
Because again, especially in
the case of a single page app,

200
00:11:08.000 --> 00:11:11.630
we are sending you this entire
application, you go ahead and compile it.

201
00:11:11.630 --> 00:11:15.240
You go ahead and parse the entire source
code, and figure out what it all means and

202
00:11:15.240 --> 00:11:16.830
then build the application.

203
00:11:16.830 --> 00:11:20.390
If we send code that is very
hard to parse and compile.

204
00:11:20.390 --> 00:11:22.960
We wrote it on a $3,000 MacBook.

205
00:11:22.960 --> 00:11:27.246
This is not a $3,000 MacBook,
but my work one,

206
00:11:27.246 --> 00:11:31.832
I didn't pay for it, but
I assume that it's expensive.

207
00:11:31.832 --> 00:11:35.512
We have these expensive machines that
have these high-powered computers.

208
00:11:35.512 --> 00:11:40.603
But we then can send it to a mobile device
that is a lot slower at parsing and

209
00:11:40.603 --> 00:11:42.117
compiling, right?

210
00:11:42.117 --> 00:11:44.347
But we can't do that on our side.

211
00:11:44.347 --> 00:11:47.123
We have to then send it to the user and
hope that they can also parse and

212
00:11:47.123 --> 00:11:48.030
compile it quickly.

213
00:11:48.030 --> 00:11:51.760
So learning how that stuff works under the
hood allows us to kind of one analyze and

214
00:11:51.760 --> 00:11:56.340
make some decisions and see where
the hurt is, and two refactor our code in

215
00:11:56.340 --> 00:12:00.910
such a way that it is easier on the parser
and compiler and all those things.

216
00:12:00.910 --> 00:12:03.110
Finally, we have rendering performance.

217
00:12:03.110 --> 00:12:04.630
So we have it on the page.

218
00:12:04.630 --> 00:12:08.980
Our JavaScript is not just simply a no JS
program that runs in their browser, but

219
00:12:08.980 --> 00:12:13.375
also it is manipulating the page,
it's displaying a user interface.

220
00:12:13.375 --> 00:12:15.990
Right?
Our JavaScript does not live in a vacuum,

221
00:12:15.990 --> 00:12:19.110
but instead has to deal with the dom and
the browser and

222
00:12:19.110 --> 00:12:21.010
all of these other components.

223
00:12:21.010 --> 00:12:23.600
So figuring out how that
entire system works and

224
00:12:23.600 --> 00:12:26.200
how to make sure we don't
hit large roadblocks there.

225
00:12:26.200 --> 00:12:30.670
So three different kinds of performance,
are they equally as important?

226
00:12:30.670 --> 00:12:33.326
I would argue yes, but
the real answer is no, right?

227
00:12:33.326 --> 00:12:37.240
Because again, it matters what your
application needs to do, right?

228
00:12:37.240 --> 00:12:39.710
And where the pinpoints
in your application.

229
00:12:39.710 --> 00:12:41.640
So we'll also talk a little
bit about measuring and

230
00:12:41.640 --> 00:12:43.610
how to figure those things out.

231
00:12:43.610 --> 00:12:44.930
All right, very cool.

232
00:12:44.930 --> 00:12:48.080
So we're gonna talk a little bit about
some numbers to just think about.

233
00:12:48.080 --> 00:12:50.890
We're not gonna obsessed to much about
numbers today, because I think it's

234
00:12:50.890 --> 00:12:54.310
really hard to, okay, every interaction
need to be 100 milliseconds.

235
00:12:54.310 --> 00:12:56.740
You fire up your app and then you've
a got a two second interaction.

236
00:12:56.740 --> 00:13:00.890
I give up, I'm going home for the day.

237
00:13:00.890 --> 00:13:04.210
But having some goals in mind is,
I think really useful.

238
00:13:04.210 --> 00:13:08.140
So Google has this acronym called RAIL.

239
00:13:08.140 --> 00:13:11.800
I guess they could have had other ones
like liar, or anything along those lines,

240
00:13:11.800 --> 00:13:14.200
but RAIL is the one they went for.

241
00:13:14.200 --> 00:13:18.840
And it's basically a set of benchmarks
to think about performance,

242
00:13:18.840 --> 00:13:19.739
effectively goals.

243
00:13:21.550 --> 00:13:27.380
So, RAIL stands for
Response Animation Idle and Load.

244
00:13:27.380 --> 00:13:29.160
And we'll look at those again in a second.

245
00:13:29.160 --> 00:13:31.650
But here's that response part again.

246
00:13:31.650 --> 00:13:34.370
This is how humans perceive interactions.

247
00:13:34.370 --> 00:13:35.510
We saw it before.

248
00:13:35.510 --> 00:13:37.830
0 to 100 milliseconds, instantaneous.

249
00:13:37.830 --> 00:13:40.590
After ten seconds,
I'm going somewhere else, but

250
00:13:40.590 --> 00:13:43.290
even after a second there's
a mental context switch.

251
00:13:43.290 --> 00:13:46.230
Which again is that maybe I
should be doing something else.

252
00:13:46.230 --> 00:13:46.936
So we wanna aim for

253
00:13:46.936 --> 00:13:51.326
under 100 milliseconds.
&gt;&gt; Steve Kinney: Animations,

254
00:13:51.326 --> 00:13:55.343
most screens, I think the new iPad
Pro is a little bit different, but

255
00:13:55.343 --> 00:13:58.390
most of our screens refresh
at 60 frames a second,

256
00:13:58.390 --> 00:14:02.375
which turns into about 16
milliseconds in between every frame.

257
00:14:02.375 --> 00:14:05.595
So that's how often the screen refreshes,
so you go any faster than that,

258
00:14:05.595 --> 00:14:08.020
it doesn't matter,
the screen's not gonna show anything.

259
00:14:08.020 --> 00:14:09.390
But you get slower than that,

260
00:14:09.390 --> 00:14:12.300
and users can start to know that
the scrolling is getting a little janky.

261
00:14:12.300 --> 00:14:13.090
Or the dragging and

262
00:14:13.090 --> 00:14:16.280
dropping, the editor that I worked
on is getting a little weird.

263
00:14:16.280 --> 00:14:20.700
So it's like 16 milliseconds is really
kind of important to think about,

264
00:14:20.700 --> 00:14:23.050
is that you wanna get
a new frame to the screen,

265
00:14:23.050 --> 00:14:25.980
if you're trying to animate anything and
have it look good.

266
00:14:25.980 --> 00:14:29.190
But all those 16
milliseconds are not yours.

267
00:14:29.190 --> 00:14:32.260
The browser's doing other stuff,
some Chrome extensions that are running

268
00:14:32.260 --> 00:14:36.110
are doing other stuff, so
you have to share that time.

269
00:14:36.110 --> 00:14:39.890
Idle is another part of it which is
basically anything that doesn't need to be

270
00:14:39.890 --> 00:14:42.740
done immediately, try to do when
the user's not doing anything.

271
00:14:42.740 --> 00:14:47.560
Okay, now they're reading the article, now
go get whatever creepy tracking software

272
00:14:47.560 --> 00:14:50.240
that you wanna put on there to figure
out what they are doing, right?

273
00:14:50.240 --> 00:14:51.960
Don't do that for the initial page load or

274
00:14:51.960 --> 00:14:55.020
else there is gonna be nothing
to track because they're gone.

275
00:14:55.020 --> 00:14:59.820
And if you can get that done in
15 millisecond chunks, great,

276
00:14:59.820 --> 00:15:04.250
because then if they do do something,
you're ready to deal with that.

277
00:15:04.250 --> 00:15:04.940
Finally, Load.

278
00:15:04.940 --> 00:15:07.880
It would be great if we could get
the entire page under a second,

279
00:15:07.880 --> 00:15:10.850
but otherwise it's ideal for
first meaningful paint.

280
00:15:10.850 --> 00:15:12.130
So what is a first meaningful paint?

281
00:15:12.130 --> 00:15:13.930
It really depends on your application.

282
00:15:13.930 --> 00:15:18.890
If you are Twitter maybe it's that middle
timeline, or mentions or whatever first,

283
00:15:18.890 --> 00:15:22.740
and then you can get the little sidebars
and the search and all of those things.

284
00:15:22.740 --> 00:15:26.170
Trying to get to the first very
important thing in under a second.

285
00:15:27.290 --> 00:15:28.580
Those are important to think about.

286
00:15:28.580 --> 00:15:31.370
We're not going to, like I said before,

287
00:15:31.370 --> 00:15:35.847
obsess over them because I can tell
you I took the whole rail model.

288
00:15:35.847 --> 00:15:39.713
I looked at the application I
worked on and almost cried, right?

289
00:15:39.713 --> 00:15:44.677
Because like those were not anywhere near
the way that I like large desktop apps in

290
00:15:44.677 --> 00:15:47.290
the web browser was working, right?

291
00:15:47.290 --> 00:15:52.590
So I would argue it's about progressively
getting a little better, right?

292
00:15:52.590 --> 00:15:56.520
Figuring out where the areas of
hurt are in your application.

293
00:15:56.520 --> 00:15:58.850
Figuring out how to, okay,
I know this is slow.

294
00:15:58.850 --> 00:16:00.260
That's step one, right?

295
00:16:00.260 --> 00:16:05.640
Step two is figuring out, okay I know how
to read the performance timeline in Chrome

296
00:16:05.640 --> 00:16:09.720
and figure out, come up with some
hypothesis of what to do about it.

297
00:16:09.720 --> 00:16:13.003
And then step three is having some ideas
of what to do, and four is then measuring

298
00:16:13.003 --> 00:16:15.551
to see if it got better or worse,
and stuff along those lines.

299
00:16:15.551 --> 00:16:18.805
So when I was preparing this workshop,
I wrote this blurb of

300
00:16:18.805 --> 00:16:22.398
originally what it was about and
sent it to some of my colleagues.

301
00:16:22.398 --> 00:16:26.971
And one of my former co workers, Romeeka,
came up with an alternative title for

302
00:16:26.971 --> 00:16:31.276
this workshop called, Strategies for
Optimizing Web Performance When,

303
00:16:31.276 --> 00:16:33.940
Honestly, You Have Like
5 Meetings Today and

304
00:16:33.940 --> 00:16:37.790
Have to Choose the Correct Hills
upon Which to Strategically Die.

305
00:16:37.790 --> 00:16:39.390
[LAUGH] Right?

306
00:16:39.390 --> 00:16:45.585
It's very easy for, to watch some
Google IO presentation where it's like,

307
00:16:45.585 --> 00:16:50.830
yes we rewrote the entire application
as a progressive web app and

308
00:16:50.830 --> 00:16:52.663
now it's super fast.

309
00:16:52.663 --> 00:16:55.310
Progressive web apps are actually cool you
should totally watch my course on them.

310
00:16:55.310 --> 00:16:59.138
But it's like that is usually not
something the big rewrite is not

311
00:16:59.138 --> 00:17:02.420
something you're gonna be
able to do tomorrow right?

312
00:17:02.420 --> 00:17:05.380
So the goal here is, given the current
world, given the current state of

313
00:17:05.380 --> 00:17:07.870
the thing that you're working on,
how do we make it faster?

314
00:17:07.870 --> 00:17:08.983
How do we make it better?

315
00:17:08.983 --> 00:17:11.397
And how do we repeat that until slowly but

316
00:17:11.397 --> 00:17:14.312
surely we start approaching
those benchmarks?

317
00:17:14.312 --> 00:17:16.669
So it's important to think
about what matters to you.

318
00:17:16.669 --> 00:17:19.827
And then figuring out how to measure it,
right?

319
00:17:19.827 --> 00:17:24.962
So I talked about, maybe showing
content versus not leaking memory,

320
00:17:24.962 --> 00:17:30.030
that's cool, but it's also hard to
express as a known thing, right?

321
00:17:30.030 --> 00:17:34.780
So figure out in your application what
is actually the important thing, right?

322
00:17:34.780 --> 00:17:37.840
So again, New York Times might care
about the time to first headline.

323
00:17:37.840 --> 00:17:41.160
Twitter might care about how long it
takes you to be able to write a tweet.

324
00:17:41.160 --> 00:17:43.674
Maybe that should be longer for
me some other time, right?

325
00:17:43.674 --> 00:17:46.338
Maybe I need a delay to think about
what I'm tweeting before I type it

326
00:17:46.338 --> 00:17:46.960
into that box.

327
00:17:46.960 --> 00:17:52.190
But for Twitter they wanna probably
get me to tweet as fast as possible.

328
00:17:52.190 --> 00:17:55.530
Whatever the application is, so
I work on a big email editor, right?

329
00:17:55.530 --> 00:17:58.110
Time for the editor to load up so
you can start dragging and

330
00:17:58.110 --> 00:18:00.500
dropping in the modules that you
use to create the email, right?

331
00:18:00.500 --> 00:18:02.970
That might be the important part for
us, how long does it take

332
00:18:02.970 --> 00:18:06.700
between log in to get to the point where
you're creating a new marketing campaign?

333
00:18:06.700 --> 00:18:09.440
That would be an example of something
that would be important for

334
00:18:09.440 --> 00:18:10.220
the application that I work on.

