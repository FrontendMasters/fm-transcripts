WEBVTT

1
00:00:00.150 --> 00:00:03.191
So I believe now we're going
on to the best part of this,

2
00:00:03.191 --> 00:00:08.190
which is going to be question time, blah,
blah, blah, blah, blah, on to victory.

3
00:00:08.190 --> 00:00:09.941
That's right,
cuz we're into the final stage.

4
00:00:09.941 --> 00:00:13.235
All right, I actually, it looks like
I pre-planned some questions and

5
00:00:13.235 --> 00:00:14.264
which I forgot about.

6
00:00:14.264 --> 00:00:15.299
So let's do them.

7
00:00:15.299 --> 00:00:19.314
All right, if you've only done TypeScript,
what do you think about GoLang?

8
00:00:20.556 --> 00:00:22.409
All right just was think about it for
a moment.

9
00:00:22.409 --> 00:00:24.002
What are some things you liked about it?

10
00:00:24.002 --> 00:00:26.775
What are some things you hated about it?

11
00:00:26.775 --> 00:00:32.614
What are some things you wish
TypeScript had, that it doesn't?

12
00:00:32.614 --> 00:00:33.788
Or do you think there's nothing?

13
00:00:33.788 --> 00:00:37.462
You think there's nothing that's needed.

14
00:00:38.772 --> 00:00:43.520
&gt;&gt; TypeScript's totally happy to let
you just pass wrong values around.

15
00:00:43.520 --> 00:00:47.248
Go was right on top of, I mean, especially
the LSP was right on top of letting me

16
00:00:47.248 --> 00:00:51.376
know that I've mistyped something, or the
thing was referencing the wrong thing, or

17
00:00:51.376 --> 00:00:51.959
whatever.

18
00:00:51.959 --> 00:00:55.590
&gt;&gt; Yeah, I find the LSP to
be the best in class LSP.

19
00:00:55.590 --> 00:00:58.586
If you're using it, it just constantly
puts you in the right position.

20
00:00:58.586 --> 00:01:03.043
Even using API's, it will prefill in
the arguments with a huge amount of

21
00:01:03.043 --> 00:01:04.880
the default values you need.

22
00:01:04.880 --> 00:01:06.356
It's extremely impressive.

23
00:01:06.356 --> 00:01:07.524
It just makes it super easy.

24
00:01:07.524 --> 00:01:09.738
That's one thing I love about it, too,

25
00:01:09.738 --> 00:01:14.180
is just I find that any one of any skill
level can use Go mostly effective, right?

26
00:01:14.180 --> 00:01:15.441
You're gonna write a service,

27
00:01:15.441 --> 00:01:17.784
it's gonna perform better
than your TypeScript version.

28
00:01:17.784 --> 00:01:20.448
You're probably gonna
be correct more often.

29
00:01:20.448 --> 00:01:21.571
It's very easy, right?

30
00:01:21.571 --> 00:01:23.343
It's a very easy language.

31
00:01:23.343 --> 00:01:25.589
And so
I kinda wish that TypeScript had that.

32
00:01:25.589 --> 00:01:29.884
Cuz the problem I see about TypeScript
is allows you to, or JavaScript, really,

33
00:01:29.884 --> 00:01:33.323
is it allows you to indefinitely abstract,
and always, right?

34
00:01:33.323 --> 00:01:36.056
You can do extends, you can do
all sorts of you know OOP stuff.

35
00:01:36.056 --> 00:01:39.505
But on top of that you can keep on
abstracting in all sorts of kind of

36
00:01:39.505 --> 00:01:40.087
fun ways.

37
00:01:40.087 --> 00:01:44.550
Which just allows code to get further and
further complicated, is what I find.

38
00:01:44.550 --> 00:01:47.662
And I just find that a lot of distractions
just kinda like leaking, right?

39
00:01:47.662 --> 00:01:48.829
What about error handling?

40
00:01:48.829 --> 00:01:52.287
[INAUDIBLE], let's recall all the Go
error handling that we've done.

41
00:01:52.287 --> 00:01:52.999
How do you feel about it?

42
00:01:52.999 --> 00:01:59.166
Do you wish it was a little bit less
verbose, a little less in your face?

43
00:01:59.166 --> 00:02:01.149
Yeah, we got a question from the back.

44
00:02:01.149 --> 00:02:04.533
&gt;&gt; Yeah, there was a comment,
it's a bit abstract, but

45
00:02:04.533 --> 00:02:09.476
Go feels like it has fewer tricks and
is more straightforward than TypeScript.

46
00:02:09.476 --> 00:02:13.686
Where, in TypeScript, you can kinda
shoot yourself in the foot, I guess.

47
00:02:13.686 --> 00:02:19.690
&gt;&gt; Yeah, another thing just kinda going
on that, like converting a number, right?

48
00:02:19.690 --> 00:02:22.080
You know that it wasn't successful.

49
00:02:22.080 --> 00:02:25.470
Instead, you have to be reactive.

50
00:02:25.470 --> 00:02:28.056
You have to be proactive in TypeScript and
reactive in Go.

51
00:02:28.056 --> 00:02:31.684
So, Go lets you have to react to it,
whereas TypeScript you have to go and

52
00:02:31.684 --> 00:02:33.479
check, is this thing a gnat or not?

53
00:02:33.479 --> 00:02:36.163
All right, so it's kinda has that
reactive, proactive type thing.

54
00:02:36.163 --> 00:02:40.170
I think I prefer the reactive
because it's always in your face.

55
00:02:40.170 --> 00:02:43.252
I'm gonna always write a service
that's a bit more robust cuz

56
00:02:43.252 --> 00:02:45.100
I found all the errors along the way.

57
00:02:46.980 --> 00:02:49.320
Good feels, all right,
I think error handling is great.

58
00:02:50.620 --> 00:02:51.534
What about Rust?

59
00:02:51.534 --> 00:02:55.980
How do you feel about Rust if you're
primarily familiar with TypeScript?

60
00:02:55.980 --> 00:02:59.939
It's probably kind of a hard transition,
maybe it feels a little arcane.

61
00:03:02.780 --> 00:03:05.102
Yeah, nothing, any positives?

62
00:03:05.102 --> 00:03:08.349
&gt;&gt; It seems more complicated,
the language, but

63
00:03:08.349 --> 00:03:11.200
to write it's much more legible than Go?

64
00:03:11.200 --> 00:03:16.950
It feels like there's just less typing
going on, and then it's pretty concise.

65
00:03:16.950 --> 00:03:20.525
&gt;&gt; Yeah, the in-betweens aren't filled
with a bunch of does not equal, nil,

66
00:03:20.525 --> 00:03:21.957
checks, and all that, yeah.

67
00:03:23.889 --> 00:03:24.667
I agree with that.

68
00:03:24.667 --> 00:03:29.150
It's definitely harder, in some sense that
you always are thinking about your types.

69
00:03:29.150 --> 00:03:30.480
Are you consuming your types?

70
00:03:30.480 --> 00:03:33.460
Remember, I still have a pre-planned
explosion about to happen.

71
00:03:33.460 --> 00:03:37.844
And so, we're gonna run into
a problem where we didn't pre-plan

72
00:03:37.844 --> 00:03:41.990
our types far enough ahead and
things aren't gonna work out.

73
00:03:41.990 --> 00:03:45.195
And so, Go or Rust can be very
complicated in that matter.

74
00:03:45.195 --> 00:03:50.396
We're gonna have to really rethink
about what we're doing, all right?

75
00:03:50.396 --> 00:03:54.533
&gt;&gt; All right, on the chat someone says,
I love the error messages in Rust.

76
00:03:54.533 --> 00:03:55.710
&gt;&gt; Yeah.

77
00:03:55.710 --> 00:03:59.689
&gt;&gt; But it probably wouldn't be worth
it if there weren't a performance

78
00:03:59.689 --> 00:04:01.688
just difference, in my opinion.

79
00:04:01.688 --> 00:04:05.487
&gt;&gt; Yeah there's a, I mean,
it depends of course on the operation,

80
00:04:05.487 --> 00:04:08.470
if you're heavily Internet trafficked,
right?

81
00:04:08.470 --> 00:04:11.524
If you're setting out
large quantities of data,

82
00:04:11.524 --> 00:04:15.960
obviously you're likely gonna run
into a system overhead problem where

83
00:04:15.960 --> 00:04:20.300
the performance of your program
is not gonna be that important.

84
00:04:20.300 --> 00:04:21.669
But for the most part, I mean,

85
00:04:21.669 --> 00:04:24.950
Rust is gonna perform significantly
faster than JavaScript.

86
00:04:24.950 --> 00:04:29.173
And then larger amounts of stuff
that it's solely focused on just

87
00:04:29.173 --> 00:04:32.949
the language doing calculations,
the larger Rust wins.

88
00:04:32.949 --> 00:04:34.497
And so it's pretty nice.

89
00:04:34.497 --> 00:04:39.796
And if you write it properly using Tokyo
or whatever runtime you want to use for

90
00:04:39.796 --> 00:04:44.215
asynchronicity, you can just give
it another core and it runs.

91
00:04:44.215 --> 00:04:47.025
Whereas with TypeScript,
you can't just give it another core.

92
00:04:47.025 --> 00:04:49.184
You have to go and create another process.

93
00:04:49.184 --> 00:04:53.590
If there's state that needs to be shared
you've added a whole complication that

94
00:04:53.590 --> 00:04:54.898
just can't be undone.

95
00:04:54.898 --> 00:04:56.526
&gt;&gt; And so it's pretty interesting.

96
00:04:59.127 --> 00:05:00.827
What do people primarily use Rust for?

97
00:05:00.827 --> 00:05:03.086
That's a question from Twitch chat.

98
00:05:03.086 --> 00:05:06.418
As far as I can tell you rewrite
everything in Rust, RIIR,

99
00:05:06.418 --> 00:05:07.714
that's the classic.

100
00:05:07.714 --> 00:05:12.330
What you really want to do is you find
a great tool and then you rewrite it,

101
00:05:12.330 --> 00:05:14.235
GREP, RG, find FT, right?

102
00:05:14.235 --> 00:05:17.549
Always rewrite, but
Rust really is just, I mean,

103
00:05:17.549 --> 00:05:21.183
I think it's real spot is
gonna be in CLI applications.

104
00:05:21.183 --> 00:05:23.287
And embedded I think
is gonna be a big win.

105
00:05:23.287 --> 00:05:26.742
Because if you're using hydraulics,
you really wanna make sure you got

106
00:05:26.742 --> 00:05:29.812
the thing right so
you don't actually crush your hand, right?

107
00:05:29.812 --> 00:05:33.803
You're gonna want, so I think Rust is
gonna play a good part in embedded.

108
00:05:33.803 --> 00:05:35.151
I'm curious about the web world.

109
00:05:35.151 --> 00:05:39.997
I am not 100% convinced Rust is
gonna be the web world language.

110
00:05:39.997 --> 00:05:43.144
But I think it has a good chance,
especially with things like macros and

111
00:05:43.144 --> 00:05:45.097
being able to create
HTML inside your Rust.

112
00:05:45.097 --> 00:05:49.887
So you can create a JSX-like experience,
and have a really high performance,

113
00:05:49.887 --> 00:05:52.329
very awesome server-side rendering.

114
00:05:52.329 --> 00:05:53.129
And so there you go.

115
00:05:53.129 --> 00:05:54.392
Also now you're using Wasm,

116
00:05:54.392 --> 00:05:57.587
if Wasm gains more steam, you're
starting to really see some wins there.

117
00:05:57.587 --> 00:06:02.077
But there's a lot of bets
on making that all happen.

118
00:06:02.077 --> 00:06:07.011
That's my personal, it's my personal take.

119
00:06:07.011 --> 00:06:10.936
I also find it just more enjoyable
to program the trade system,

120
00:06:10.936 --> 00:06:14.269
being able to just make
things work really seamlessly

121
00:06:14.269 --> 00:06:18.136
into a lot of their standard library,
it's very fantastic.

122
00:06:18.136 --> 00:06:21.630
All right, yeah, and this is awesome.

123
00:06:21.630 --> 00:06:27.744
Just like, if you come from every now and
then I have to print out stuff in C++.

124
00:06:27.744 --> 00:06:30.996
You just wanna print out a struct and
it's just like, man, this sucks.

125
00:06:30.996 --> 00:06:35.064
But it's just so glorious that this is
just available and it just works, right?

126
00:06:35.064 --> 00:06:36.620
That just makes me really, really happy.

