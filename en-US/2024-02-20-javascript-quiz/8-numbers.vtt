WEBVTT

1
00:00:00.350 --> 00:00:03.029
This one is an easy one,
should be an easy one, while it's locked,

2
00:00:03.029 --> 00:00:03.976
when we have number 0.

3
00:00:03.976 --> 00:00:08.028
We increment it, we increment it again,
and then we log number again.

4
00:00:08.028 --> 00:00:12.881
Is it 1 1 2, 1 2 2,
0 2 2, 0 1 2, or 1 1 0?

5
00:00:19.704 --> 00:00:22.091
And the right answer here is 022,

6
00:00:22.091 --> 00:00:26.571
because first we have the number
plus plus, so we post increment it.

7
00:00:26.571 --> 00:00:30.692
So it will first return the value and
then increment it, so that's still 0, but

8
00:00:30.692 --> 00:00:34.282
it has incremented in the background,
it just doesn't log that yet.

9
00:00:34.282 --> 00:00:37.931
Then we have plus plus number,
in which case it will increment it and

10
00:00:37.931 --> 00:00:41.016
then return it, so
it goes from 1 to 2 and then we log it.

11
00:00:41.016 --> 00:00:44.390
And then on the fourth line, we just
log it again without doing anything, so

12
00:00:44.390 --> 00:00:45.086
it's 0 to 2.

13
00:00:45.086 --> 00:00:49.331
Just important to remember that using plus
plus after a value will return the current

14
00:00:49.331 --> 00:00:51.006
value before incrementing it and

15
00:00:51.006 --> 00:00:54.143
using it before it will already
return that increment value.

16
00:00:56.938 --> 00:00:57.684
Yeah.

17
00:00:59.754 --> 00:01:00.337
Hello.

18
00:01:03.514 --> 00:01:07.881
Okay, just pretend you didn't see that,
my laptop is just crashing.

19
00:01:07.881 --> 00:01:10.871
All right, well, what gets logged?

20
00:01:10.871 --> 00:01:15.785
So we have a is 3, b is a new number 3,
and then c is 3 again.

21
00:01:15.785 --> 00:01:19.945
And then a == b, b == c, and

22
00:01:19.945 --> 00:01:24.113
a.toString = b.toString.

23
00:01:27.945 --> 00:01:30.848
And our answer here is true,
false, false, true.

24
00:01:30.848 --> 00:01:35.066
So whenever we have a number,
or like the two equal signs is,

25
00:01:35.066 --> 00:01:40.545
not strictly equal, so in that case,
it kind of coerces it to that new number.

26
00:01:40.545 --> 00:01:44.381
What's it called?

27
00:01:44.381 --> 00:01:47.735
Constructor to equalize it,
in which case, it's true.

28
00:01:47.735 --> 00:01:51.725
The second one, there's a difference
between using the new number constructor

29
00:01:51.725 --> 00:01:53.262
and having an actual integer.

30
00:01:53.262 --> 00:01:55.897
So in this case, we have 3 and
that new number 3.

31
00:01:55.897 --> 00:02:00.721
Well, they aren't strictly equal, so
that is false, b shouldn't be equal to c.

32
00:02:00.721 --> 00:02:03.408
I think that one should be false as well.

33
00:02:03.408 --> 00:02:06.053
But what is true is d.

34
00:02:06.053 --> 00:02:10.748
We can use methods on numbers to string
and everything that's usually only

35
00:02:10.748 --> 00:02:15.295
available on a new number constructor
because JavaScript quickly wraps

36
00:02:15.295 --> 00:02:19.632
the number in a new number constructor
when we use methods like that.

37
00:02:19.632 --> 00:02:23.218
But after using it,
it gets rid of that constructor again.

38
00:02:23.218 --> 00:02:25.794
Not that this is super important, but
that's just something to remember.

39
00:02:25.794 --> 00:02:29.292
When you're using numbers, we can use all
the methods of the new number constructor

40
00:02:29.292 --> 00:02:32.345
as well, because JavaScript just
quickly wraps it in the constructor and

41
00:02:32.345 --> 00:02:33.244
then omits it again.

42
00:02:33.244 --> 00:02:35.272
So we're using a set of number, and

43
00:02:35.272 --> 00:02:38.393
we have a couple of values
here that we're analyzing.

44
00:02:38.393 --> 00:02:40.988
And what is the, or what gets logged?

45
00:02:40.988 --> 00:02:42.329
Is it all true?
Is it all false?

46
00:02:42.329 --> 00:02:43.864
Or is it a combination?

47
00:02:48.645 --> 00:02:52.130
All right, the right answer here is false,
true, true, true.

48
00:02:52.130 --> 00:02:56.376
So what's happening here is that we
have the is not a number function, and

49
00:02:56.376 --> 00:03:00.704
that just checks if the argument that we
pass to it is the value not a number.

50
00:03:00.704 --> 00:03:07.724
So first, we have 5.2 plus 2 is 5.22,
so it's not a number, it's false.

51
00:03:07.724 --> 00:03:12.120
But then we do parseInt a, so
parseInt false, but we cannot parseInt,

52
00:03:12.120 --> 00:03:14.333
something that's not an integer.

53
00:03:14.333 --> 00:03:17.619
So then parseInt throws not a number,
we can't do that, so

54
00:03:17.619 --> 00:03:19.144
it's not a number is true.

55
00:03:19.144 --> 00:03:20.354
Same with parseFloat.

56
00:03:20.354 --> 00:03:24.059
That's the same for parseInt, we cannot
do that because it's not a number,

57
00:03:24.059 --> 00:03:24.804
so it's true.

58
00:03:24.804 --> 00:03:30.011
isNaN is not a number,
we have the string 1 times 2 times 2.

59
00:03:30.011 --> 00:03:34.844
Well, we cannot, 1 times 2 is not a
number, and we're trying to multiply that

60
00:03:34.844 --> 00:03:39.479
by 2, so that will also throw not
a number, it's not a number, it's true.

61
00:03:39.479 --> 00:03:43.157
Just important to remember here that
is not a number checks if it's actually

62
00:03:43.157 --> 00:03:45.920
the value not a number and
not just a string or something.

63
00:03:49.033 --> 00:03:50.645
All right, match the equivalent values.

64
00:03:50.645 --> 00:03:55.678
So we have ff, we have 101, we have
SyntaxError and 255, and then some two

65
00:03:55.678 --> 00:04:00.503
string methods that will all return or
some of them will return these values.

66
00:04:00.503 --> 00:04:02.831
Which of them will match
the equivalent values?

67
00:04:07.435 --> 00:04:12.318
All right, the answer here is already A,
B, C, D, it was correct as it was.

68
00:04:12.318 --> 00:04:17.799
So first, we have the two stringing 16.

69
00:04:17.799 --> 00:04:21.783
So the two stringing method can or
accepts a radix argument,

70
00:04:21.783 --> 00:04:26.327
and that just tells us the base with
which one a string of five number.

71
00:04:26.327 --> 00:04:30.884
And we have binary, we have octal,
we have decimal, and then hexadecimal.

72
00:04:30.884 --> 00:04:35.599
And this just changes how that string or
how that number is made into a string.

73
00:04:35.599 --> 00:04:40.200
So with the hexadecimal,
we get the x value.

74
00:04:40.200 --> 00:04:44.956
So in this case, 255 is ff,
it's like on the 16th value.

75
00:04:44.956 --> 00:04:48.816
Then we have binary and 255 and
binary is just a times 1.

76
00:04:48.816 --> 00:04:53.787
255.toString, it throws a syntax
error because we're using a dot.

77
00:04:53.787 --> 00:04:57.568
And then you will see that we
cannot do that, it's unexpected,

78
00:04:57.568 --> 00:05:00.026
because it thinks that this is a decimal.

79
00:05:00.026 --> 00:05:03.552
So it needs to add another dot here,
and then it'll be 255.

80
00:05:03.552 --> 00:05:07.503
And that's essentially what we did here,
right, two dots.

81
00:05:07.503 --> 00:05:12.201
But you can just invoke the two string
method with the bracket notation and

82
00:05:12.201 --> 00:05:15.093
use 10, and 10 is just like the default.

83
00:05:15.093 --> 00:05:17.967
Yeah, that's just the normal base.

84
00:05:17.967 --> 00:05:20.573
So in this case,
255 is just turned into toString.

85
00:05:20.573 --> 00:05:24.657
We didn't have to specify the 10 here,
it could have just been without 10 and

86
00:05:24.657 --> 00:05:26.537
would have returned the same value.

87
00:05:26.537 --> 00:05:30.594
But just remember that you have to
use double dots if we wanna stringify

88
00:05:30.594 --> 00:05:31.228
a number.

