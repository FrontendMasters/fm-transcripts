WEBVTT

1
00:00:00.250 --> 00:00:05.650
&gt;&gt; Bianca Gandolfo: So we are going to
switch gears a little bit, not too much.

2
00:00:05.650 --> 00:00:09.046
We're going to keep searching.

3
00:00:09.046 --> 00:00:11.879
I feel like just reflecting
on this class today,

4
00:00:11.879 --> 00:00:14.930
it's like we've been going
through this journey.

5
00:00:14.930 --> 00:00:18.426
It all started with
waking up in the morning,

6
00:00:18.426 --> 00:00:23.302
trying to be better, and
finding things, exploring things.

7
00:00:23.302 --> 00:00:27.140
Doesn't this is feel like
the hero's journey or something?

8
00:00:27.140 --> 00:00:28.680
Anyone else feeling that?

9
00:00:28.680 --> 00:00:29.882
No, just me?

10
00:00:29.882 --> 00:00:31.007
[LAUGH].

11
00:00:31.007 --> 00:00:34.747
But anyway, it's like we've been
searching a lot for things, and

12
00:00:34.747 --> 00:00:36.460
we're gonna keep searching.

13
00:00:36.460 --> 00:00:38.769
[LAUGH] That's life.

14
00:00:39.800 --> 00:00:43.606
So we're gonna look for
something specific, and

15
00:00:43.606 --> 00:00:48.510
let's just take a look,
different strategies for searching.

16
00:00:50.050 --> 00:00:55.690
So we have a linear search,
which is what you'd expect,

17
00:00:55.690 --> 00:00:59.465
you start at the beginning,
and we're looking for eggs.

18
00:00:59.465 --> 00:01:08.313
Because that was
the recommendation from the graph.

19
00:01:08.313 --> 00:01:12.039
So we're looking look for eggs,
we start at the beginning, and

20
00:01:12.039 --> 00:01:15.430
then we loop through until we find it,
and then we find it.

21
00:01:15.430 --> 00:01:16.510
So that's linear search.

22
00:01:17.880 --> 00:01:20.171
What's the time complexity for
linear search?

23
00:01:20.171 --> 00:01:22.183
&gt;&gt; Speaker 2: Linear.

24
00:01:22.183 --> 00:01:24.782
&gt;&gt; Bianca Gandolfo: Linear, yeah, great.

25
00:01:26.641 --> 00:01:28.960
&gt;&gt; Bianca Gandolfo: Well,
let's talk about binary search.

26
00:01:28.960 --> 00:01:33.830
So we're still dealing with an array,
but we have a first index and

27
00:01:33.830 --> 00:01:36.520
a last index that we keep track of.

28
00:01:36.520 --> 00:01:39.169
First index is gonna be 0,
last is gonna be 5.

29
00:01:40.290 --> 00:01:43.890
And the first thing we wanna
do is find the midline.

30
00:01:43.890 --> 00:01:47.610
Because what we're gonna do with binary
search is we're going to cut the problem

31
00:01:47.610 --> 00:01:49.870
down in half every time.

32
00:01:49.870 --> 00:01:52.450
The reason we can do this,
and this is important,

33
00:01:52.450 --> 00:01:56.430
is because it's sorted, right,
it's in alphabetical order, hopefully.

34
00:01:58.460 --> 00:02:03.302
Because it's sorted,
at the midpoint we can derive if

35
00:02:03.302 --> 00:02:07.523
the value is gonna be on the left or
on the right.

36
00:02:07.523 --> 00:02:11.374
And so we're gonna continuously
cut our problem in half and

37
00:02:11.374 --> 00:02:14.170
look both left and right each time.

38
00:02:14.170 --> 00:02:15.850
So what does that look like?

39
00:02:15.850 --> 00:02:19.694
So first we have the start and
the end as 0 and 5.

40
00:02:19.694 --> 00:02:26.410
So the entire data structure,
we find the middle, which is 2.

41
00:02:26.410 --> 00:02:32.080
So we are going to look,
is it gonna be less?

42
00:02:32.080 --> 00:02:36.250
Is eggs gonna be less than c,
like is e less than c?

43
00:02:36.250 --> 00:02:39.130
No, but it would be greater.

44
00:02:39.130 --> 00:02:44.141
So then we wanna increment our midpoint,

45
00:02:44.141 --> 00:02:48.299
or we need to update our midpoint.

46
00:02:48.299 --> 00:02:55.594
And add it as, we update our midpoint,
so the one after cereal,

47
00:02:55.594 --> 00:03:00.880
we want that to be our new search area,
right?

48
00:03:00.880 --> 00:03:03.600
Cuz we already know it's
not gonna be on the left.

49
00:03:03.600 --> 00:03:06.304
So we wanna only look here, right?

50
00:03:06.304 --> 00:03:07.415
&gt;&gt; Speaker 2: How did we take out Apple?

51
00:03:07.415 --> 00:03:08.109
&gt;&gt; Bianca Gandolfo: What's that?

52
00:03:08.109 --> 00:03:09.260
&gt;&gt; Speaker 2: How did we remove apple?

53
00:03:09.260 --> 00:03:11.590
&gt;&gt; Bianca Gandolfo: We don't remove it, we
don't actually change the data structure.

54
00:03:11.590 --> 00:03:14.250
We're just not gonna look there anymore.

55
00:03:14.250 --> 00:03:16.222
&gt;&gt; Speaker 2: Yeah, sorry,
that's not what I meant.

56
00:03:16.222 --> 00:03:18.620
How did we decide not to look for apple?

57
00:03:18.620 --> 00:03:21.870
&gt;&gt; Bianca Gandolfo: Because we know
that since this is all in alphabetical

58
00:03:21.870 --> 00:03:22.960
order-
&gt;&gt; Speaker 2: Yeah.

59
00:03:22.960 --> 00:03:24.110
&gt;&gt; Bianca Gandolfo: We're at c.

60
00:03:24.110 --> 00:03:24.660
&gt;&gt; Speaker 2: I see, okay.

61
00:03:24.660 --> 00:03:26.855
&gt;&gt; Bianca Gandolfo: We know
that e is after, right?

62
00:03:26.855 --> 00:03:27.362
&gt;&gt; Speaker 2: Right.

63
00:03:27.362 --> 00:03:30.466
&gt;&gt; Bianca Gandolfo: So I mean,
we're not actually checking left or right,

64
00:03:30.466 --> 00:03:32.720
we're just basing it off of this value.

65
00:03:32.720 --> 00:03:37.816
The arrows are kinda just
of just demonstrative.

66
00:03:37.816 --> 00:03:43.660
Yeah, and so
we wanna update our first index to 3.

67
00:03:43.660 --> 00:03:45.630
So this part,
we know it's not gonna be there.

68
00:03:45.630 --> 00:03:49.130
So now our problem is half as
big as when we started, right?

69
00:03:49.130 --> 00:03:53.180
And all we had to do is
look in the middle, and

70
00:03:53.180 --> 00:03:55.590
then we know that we
need to look over here.

71
00:03:55.590 --> 00:03:58.420
So then we need to calculate
our next midpoint,

72
00:03:58.420 --> 00:04:00.080
which is just simple math, right?

73
00:04:00.080 --> 00:04:05.136
We subtract the first
index from the last index,

74
00:04:05.136 --> 00:04:07.978
and then we divide it by 2.

75
00:04:10.184 --> 00:04:11.561
&gt;&gt; Bianca Gandolfo: So that gives us 4,

76
00:04:11.561 --> 00:04:15.133
which actually lands us
where we need to be, right?

77
00:04:15.133 --> 00:04:19.045
Cuz it's 0, 1, 2, 3, 4, and we found it.

78
00:04:19.045 --> 00:04:22.545
But you could imagine that
this could be really big.

79
00:04:22.545 --> 00:04:27.478
And we would have to keep doing
this step where we figure out if

80
00:04:27.478 --> 00:04:32.435
it's before or after, and
then you cut the problem in half.

81
00:04:32.435 --> 00:04:37.947
And then you keep cutting the problem in
half until you land on your solution.

82
00:04:37.947 --> 00:04:42.177
&gt;&gt; Speaker 2: What if the what
you're looking for is bread?

83
00:04:42.177 --> 00:04:45.506
Because it's a c, then you'll go that way,
and then that's how you're gonna continue,

84
00:04:45.506 --> 00:04:46.240
all right, cool.

85
00:04:46.240 --> 00:04:47.930
&gt;&gt; Bianca Gandolfo: Exactly, exactly.

86
00:04:47.930 --> 00:04:51.093
&gt;&gt; Speaker 2: But that's only if it's
alphabetical, but what if it's just by,

87
00:04:51.093 --> 00:04:53.990
if it was by index,
then it would be something else, or okay.

88
00:04:53.990 --> 00:04:56.500
&gt;&gt; Bianca Gandolfo: Yeah,
it has to be sorted, and it has to be.

89
00:04:56.500 --> 00:05:02.530
And because for something to be sorted,
you have to be able to compare it, right?

90
00:05:02.530 --> 00:05:07.620
So easy things for
us to compare are numbers and letters.

91
00:05:09.230 --> 00:05:11.884
That's like has an explicit ordering.

92
00:05:11.884 --> 00:05:17.579
So I just got tired of all
these data structures and

93
00:05:17.579 --> 00:05:23.240
algorithm stuff with just
numbers all the time.

94
00:05:23.240 --> 00:05:25.705
I have to do it, cuz it does simplify.

95
00:05:25.705 --> 00:05:28.169
But when I can sneak in some words, and

96
00:05:28.169 --> 00:05:31.029
I think I was hungry
while I was making this.

97
00:05:31.029 --> 00:05:34.929
So I always find,
these are all breakfast foods by the way,

98
00:05:34.929 --> 00:05:38.140
fudge included,
just thought you should know.

99
00:05:38.140 --> 00:05:39.240
So that's binary search.

100
00:05:40.930 --> 00:05:46.960
So binary search, the time complexity
is something called O (log n).

101
00:05:46.960 --> 00:05:48.990
Who's familiar with this?

102
00:05:48.990 --> 00:05:53.120
This is a little trickier than
constant and linear, right?

103
00:05:54.680 --> 00:05:55.464
Let's hear it, Sonny.

104
00:05:57.669 --> 00:05:58.739
&gt;&gt; Speaker 3: What,
do you want me to tell you?

105
00:05:58.739 --> 00:05:59.860
&gt;&gt; Bianca Gandolfo: Yeah.

106
00:05:59.860 --> 00:06:02.719
&gt;&gt; Speaker 3: So
every time you split the range,

107
00:06:02.719 --> 00:06:07.660
you're looking into half, so
it becomes 2 to the power n.

108
00:06:07.660 --> 00:06:08.521
&gt;&gt; Bianca Gandolfo: Yeah, so

109
00:06:08.521 --> 00:06:14.375
whenever you're seeing a problem
that gets halved every time.

110
00:06:14.375 --> 00:06:19.355
So how we know this is halved is because,
we need to identify n.

111
00:06:19.355 --> 00:06:22.500
So n is the length of this array, right?.

112
00:06:22.500 --> 00:06:26.085
So every time we get closer to our goal,

113
00:06:26.085 --> 00:06:31.312
we're only looking through
half of the data structure.

114
00:06:31.312 --> 00:06:35.100
I mean, each look,
we only look once, right?

115
00:06:35.100 --> 00:06:39.749
So,
&gt;&gt; Bianca Gandolfo: When we get here,

116
00:06:39.749 --> 00:06:43.100
we look at cereal, and
we know it's to the right.

117
00:06:43.100 --> 00:06:45.020
So we don't look at apple or bread.

118
00:06:45.020 --> 00:06:49.850
So we're halving the amount of
work that we need to do, etc, etc.

119
00:06:49.850 --> 00:06:53.611
So you keep doing that over time.

120
00:06:53.611 --> 00:06:58.440
And so if n is 6, or yeah, n is 6,

121
00:06:58.440 --> 00:07:02.441
then the first time we look,

122
00:07:02.441 --> 00:07:07.442
there's only gonna be 3 left, and

123
00:07:07.442 --> 00:07:11.960
then 2, and 1, for example.

124
00:07:13.100 --> 00:07:14.390
So that is,

125
00:07:14.390 --> 00:07:18.720
anything that's gonna be halved every
time is gonna be logarithmic time.

126
00:07:20.560 --> 00:07:24.360
And it's kind of like
the opposite of an exponent,

127
00:07:24.360 --> 00:07:25.990
I guess you could think
about it like that.

128
00:07:25.990 --> 00:07:28.980
But I don't like to get too
much into the mathy stuff.

129
00:07:28.980 --> 00:07:34.700
I just see okay, this problem set is
being halved each time, logarithmic.

130
00:07:34.700 --> 00:07:38.301
When you get into like sorting
kind of stuff, then it's n log n,

131
00:07:38.301 --> 00:07:40.314
cuz it's linear and logarithmic.

132
00:07:40.314 --> 00:07:41.908
And that's pretty interesting, and

133
00:07:41.908 --> 00:07:44.258
something to look into if
you're not familiar with it.

134
00:07:44.258 --> 00:07:48.553
I have other courses on
Frontend Masters that talk about that.

135
00:07:48.553 --> 00:07:54.800
All right, so let's talk about binary
versus linear search really quickly.

136
00:07:54.800 --> 00:07:56.860
So we have our binary search as log n.

137
00:07:56.860 --> 00:08:00.470
It's gonna be faster, especially for
really large data sets.

138
00:08:00.470 --> 00:08:04.140
And then we have linear for
our linear search.

139
00:08:04.140 --> 00:08:05.190
I guess that makes sense, right?

140
00:08:06.510 --> 00:08:09.170
The nice thing about linear search,
though,

141
00:08:09.170 --> 00:08:13.180
is that it doesn't have to be sorted.

142
00:08:13.180 --> 00:08:16.750
But for binary search,
it definitely has to be sorted.

143
00:08:16.750 --> 00:08:22.270
Whenever you get thrown a problem
that's here's a list of things,

144
00:08:22.270 --> 00:08:26.050
you need to search for it,
always ask, is it sorting?

145
00:08:26.050 --> 00:08:29.630
Cuz if it's sorted, then you know
that they're probably going for

146
00:08:29.630 --> 00:08:31.690
a binary search type question.

147
00:08:33.170 --> 00:08:39.150
And if not, you can always ask,
can I sort it?

148
00:08:39.150 --> 00:08:44.973
So you can take into consideration the
amount of time it takes to sort an input,

149
00:08:44.973 --> 00:08:47.630
which is O(n log(n)) usually.

150
00:08:47.630 --> 00:08:52.990
There's a little asterisk with
a link to big O cheat sheet,

151
00:08:52.990 --> 00:08:58.760
which will talk about different sorting
methods and their big O notation.

152
00:08:58.760 --> 00:09:02.062
But in general, you could say n log n,
and people will believe you.

153
00:09:02.062 --> 00:09:07.332
They're not gonna really
want to ask you specifics.

154
00:09:07.332 --> 00:09:10.338
Do you mean quick sort,
do you mean merge sort, etc, etc.

155
00:09:10.338 --> 00:09:13.500
You can say either one and
it would be right enough for this case.

