WEBVTT

1
00:00:00.140 --> 00:00:04.710
&gt;&gt; Bianca: Binary search trees, they
are pretty exciting, they are a hot topic

2
00:00:04.710 --> 00:00:09.471
in the interview questions circuit.

3
00:00:09.471 --> 00:00:13.020
A binary search tree is just a binary
tree, we were working with binary trees

4
00:00:13.020 --> 00:00:15.990
before the decision tree with yes and
no, except that

5
00:00:17.790 --> 00:00:23.960
the sub-tree has to be less than the node.

6
00:00:23.960 --> 00:00:27.454
So here's 19, everything in
the sub-tree is gonna be less, and

7
00:00:27.454 --> 00:00:30.780
everything in the right sub-tree
is gonna be greater than.

8
00:00:30.780 --> 00:00:33.950
And that's gonna be true recursively
through the tree because that's sort of

9
00:00:33.950 --> 00:00:35.600
the nature of these trees.

10
00:00:35.600 --> 00:00:40.320
So everything to the left
of 11 is gonna be smaller,

11
00:00:40.320 --> 00:00:44.040
everything to the right
of 11 is gonna be larger.

12
00:00:44.040 --> 00:00:49.320
I always think like left lower and
then right gr, with an R,

13
00:00:49.320 --> 00:00:54.560
capital, greater to help me remember
which one's less and which one's more.

14
00:00:54.560 --> 00:00:59.440
&gt;&gt; Speaker 2: And this is only,
you would use this if your indexes then or

15
00:00:59.440 --> 00:01:00.070
something like that?

16
00:01:00.070 --> 00:01:01.445
Or you're-
&gt;&gt; Bianca: You will use-

17
00:01:01.445 --> 00:01:02.341
&gt;&gt; Speaker 2: Storing something

18
00:01:02.341 --> 00:01:03.966
relationships move the indexes?

19
00:01:03.966 --> 00:01:06.852
&gt;&gt; Bianca: Basically,
this is a way to search quickly.

20
00:01:06.852 --> 00:01:10.305
&gt;&gt; Speaker 2: Okay
&gt;&gt; Bianca: It has dynamic, so

21
00:01:10.305 --> 00:01:14.831
you can add and
remove nodes versus an array adding

22
00:01:14.831 --> 00:01:19.585
something into sort of
an array can be slow, right?

23
00:01:23.269 --> 00:01:24.087
&gt;&gt; Bianca: Cool.

24
00:01:26.068 --> 00:01:28.250
&gt;&gt; Speaker 2: So they're created,
when are they created then,

25
00:01:28.250 --> 00:01:30.100
like when would they be created?

26
00:01:30.100 --> 00:01:34.683
After you've done like
let's say to organize some

27
00:01:34.683 --> 00:01:37.914
data to make it easily searchable.

28
00:01:37.914 --> 00:01:41.170
Is why you would do while you
have it like this or what?

29
00:01:41.170 --> 00:01:44.472
&gt;&gt; Bianca: Yeah, yeah, so
usually out of the box,

30
00:01:44.472 --> 00:01:47.873
it doesn't come as a binary search tree so

31
00:01:47.873 --> 00:01:52.830
would need to decide if that's
an optimization that need and

32
00:01:52.830 --> 00:01:58.293
it's nice if you need to add more
data later you can really easily.

33
00:01:58.293 --> 00:02:02.335
So you have a list of numbers and

34
00:02:02.335 --> 00:02:10.888
you need to see if this integer
exists in that list super quickly,

35
00:02:10.888 --> 00:02:15.553
and also have it be dynamic as well,

36
00:02:15.553 --> 00:02:21.020
when you wanna insert and delete, cool.

37
00:02:23.120 --> 00:02:26.180
So here we have a binary search tree.

38
00:02:26.180 --> 00:02:30.336
Here is the code for it right,

39
00:02:30.336 --> 00:02:35.822
we have a root and each node has a value,

40
00:02:35.822 --> 00:02:39.500
a left and a right, cool.

41
00:02:39.500 --> 00:02:44.050
So that's just the binary tree except
that we have to follow some rules, right?

42
00:02:44.050 --> 00:02:47.822
So the left has to be lower and
the right has to be greater.

