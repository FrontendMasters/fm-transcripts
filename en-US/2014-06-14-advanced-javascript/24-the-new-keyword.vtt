WEBVTT

1
00:00:00.551 --> 00:00:04.348
[MUSIC]

2
00:00:04.348 --> 00:00:07.930
&gt;&gt; Kyle Simpson: All right, so
we have learned three of our four rules.

3
00:00:07.930 --> 00:00:10.450
Let's go to the fourth of our four rules.

4
00:00:10.450 --> 00:00:15.070
Again, I'm gonna have to ask you to
set aside any preconceptions that you

5
00:00:15.070 --> 00:00:17.620
have about what the new key word means.

6
00:00:17.620 --> 00:00:18.510
Because many of you,

7
00:00:18.510 --> 00:00:21.160
especially those of you coming
from other programming languages,

8
00:00:21.160 --> 00:00:26.350
are accustomed to the new keyword having
something to do with instatiating classes.

9
00:00:26.350 --> 00:00:29.980
And what I will tell you is that
B Java Script does not have classes

10
00:00:29.980 --> 00:00:34.350
regardless of what you've been told and
B, the new keyword has absolutely

11
00:00:34.350 --> 00:00:37.240
nothing to do with instantiation classes
regardless of what you've been told.

12
00:00:37.240 --> 00:00:40.350
So, you've got to set all
those preconceptions aside.

13
00:00:40.350 --> 00:00:42.500
I promise we'll come
back to the class topic.

14
00:00:42.500 --> 00:00:45.530
That's our next big thing that
we'll spend time on today.

15
00:00:45.530 --> 00:00:48.720
We'll come back to that, but right now
we'll just have to set that aside and

16
00:00:48.720 --> 00:00:51.850
let me explain to you what
the new key word actually does.

17
00:00:51.850 --> 00:00:52.620
Okay?

18
00:00:52.620 --> 00:00:57.660
When we put the new keyword in front
of any function call, it magically

19
00:00:57.660 --> 00:01:02.910
turns that function call into what
you might call a constructor call,

20
00:01:02.910 --> 00:01:05.160
still has nothing to do with classes.

21
00:01:05.160 --> 00:01:09.270
But it turns a function call into what the
spec might refer to as a constructor call.

22
00:01:10.870 --> 00:01:15.360
And so what we see here is that the new
keyword put in front of any function,

23
00:01:15.360 --> 00:01:19.870
the function isn't a constructor function,
it's that a function call becomes

24
00:01:19.870 --> 00:01:22.760
a constructor call when a new
keyword is stuck in front of it.

25
00:01:22.760 --> 00:01:25.880
So essentially you can put the new keyword
in front of any function that you ever

26
00:01:25.880 --> 00:01:29.370
have in your whole language, and
it will act as a constructor call.

27
00:01:30.660 --> 00:01:32.310
Okay?
So it's a modification to the way

28
00:01:32.310 --> 00:01:33.590
the function is being called.

29
00:01:33.590 --> 00:01:36.690
When we put the new keyword in
front of that function call

30
00:01:36.690 --> 00:01:38.150
It's going to do four things.

31
00:01:38.150 --> 00:01:40.990
And if you're in the process of writing
down notes, because I don't have these

32
00:01:40.990 --> 00:01:44.420
explicitly in a slide, this is something
you would want to write some notes on.

33
00:01:44.420 --> 00:01:47.440
There are four things that occur when
the new keyword is put in front of

34
00:01:47.440 --> 00:01:47.970
a function call.

35
00:01:47.970 --> 00:01:49.745
The first thing that occurs.

36
00:01:49.745 --> 00:01:50.902
A brand new object.

37
00:01:50.902 --> 00:01:54.373
A brand new empty object will
be created out of thin air.

38
00:01:54.373 --> 00:01:56.610
Just poof, creates it out of thin air.

39
00:01:56.610 --> 00:01:58.186
That's the first thing.

40
00:01:58.186 --> 00:02:02.390
The second thing; you're going to want
to put an asterisk next to this item,

41
00:02:02.390 --> 00:02:05.580
because I'm going to say what it is,
but it's not going to make sense.

42
00:02:05.580 --> 00:02:06.940
And I'm going to have to come back later,
and

43
00:02:06.940 --> 00:02:08.740
explain to you what the second item is.

44
00:02:08.740 --> 00:02:12.270
The second thing that occurs to our
brand new, poof, out of thin air object,

45
00:02:12.270 --> 00:02:15.540
is that object gets linked
to a different object.

46
00:02:16.810 --> 00:02:18.570
And, again, what is that linkage?

47
00:02:18.570 --> 00:02:20.120
What is that all about?

48
00:02:20.120 --> 00:02:21.280
You're just gonna have to hold off and

49
00:02:21.280 --> 00:02:24.070
I'm gonna have to explain it later,
cuz we're gonna come back to it, okay.

50
00:02:24.070 --> 00:02:27.010
But that's the second thing that occurs,
is our poof brand new object,

51
00:02:27.010 --> 00:02:28.370
it's linked somewhere.

52
00:02:28.370 --> 00:02:32.100
The third thing that occurs,
this is important to our discussion,

53
00:02:32.100 --> 00:02:36.760
that brand new poof object gets
bound as the this keyword for

54
00:02:36.760 --> 00:02:38.299
the purposes of that function call.

55
00:02:41.720 --> 00:02:45.790
And the fourth thing that occurs when a
new keyword put in front a function call,

56
00:02:45.790 --> 00:02:49.700
is that if that function does
not otherwise return anything,

57
00:02:50.820 --> 00:02:54.840
then it will implicitly insert
between lines three and four,

58
00:02:54.840 --> 00:03:00.505
like at line three and a half,
it will implicitly insert a return this.

59
00:03:00.505 --> 00:03:05.290
So that brand-new poof object
will be implicitly returned for

60
00:03:05.290 --> 00:03:07.470
us, from the purposes of the call.

61
00:03:07.470 --> 00:03:10.140
What this should mean to you is
you could take any function,

62
00:03:10.140 --> 00:03:12.090
I don't care what the function does.

63
00:03:12.090 --> 00:03:14.290
It doesn't even have to
reference a this keyword.

64
00:03:14.290 --> 00:03:17.850
Take any old function in your program and
put the new keyword in front of it, and

65
00:03:17.850 --> 00:03:21.650
you have hijacked that function
call as the constructor call.

66
00:03:21.650 --> 00:03:24.890
It will also do all the stuff
that it's supposed to do.

67
00:03:24.890 --> 00:03:27.860
But, in addition to doing all the stuff
that it's normally supposed to do,

68
00:03:27.860 --> 00:03:30.640
it will also do those four
things that I just said.

69
00:03:30.640 --> 00:03:34.910
Just by virtue of you putting
the new key word in front of it.

70
00:03:34.910 --> 00:03:36.220
Okay?

71
00:03:36.220 --> 00:03:40.680
So it's kind of this side channel, create
an object, link him, implicitly bind him,

72
00:03:40.680 --> 00:03:42.450
and send then send him back to me.

73
00:03:42.450 --> 00:03:42.950
Ok?

74
00:03:44.400 --> 00:03:45.830
So we see that here.

75
00:03:45.830 --> 00:03:49.240
When I do new foo I'm going to
create a new object out of thin air,

76
00:03:49.240 --> 00:03:50.600
then linkage will ignore.

77
00:03:50.600 --> 00:03:52.130
It's going to pass it in as a this.

78
00:03:52.130 --> 00:03:56.850
When I say this I have a brand new
object I can add a property to it.

79
00:03:56.850 --> 00:04:00.930
I can say on line two object out baz and
I can add a string to it.

80
00:04:00.930 --> 00:04:04.720
In fact when I do this console statement,
I'm asking for this.bar.

81
00:04:04.720 --> 00:04:09.090
There is no this.bar because
it was a brand new MT object.

82
00:04:09.090 --> 00:04:13.640
So we're going to get undefined printed
here, and at the moment, the bass

83
00:04:13.640 --> 00:04:17.120
variable exists but it has no value so
we're going to print undefined again.

84
00:04:17.120 --> 00:04:21.620
So this console statement's
undefined undefined on purpose, but

85
00:04:21.620 --> 00:04:23.580
the final thing that occurs.

86
00:04:23.580 --> 00:04:26.160
Is that there's an implicitly return this,
so

87
00:04:26.160 --> 00:04:29.500
that newly created object gets
assigned back to our baz variable.

88
00:04:30.830 --> 00:04:34.927
If you were to try this code by clicking
the code me icon in the bottom left, and

89
00:04:34.927 --> 00:04:37.952
I encourage you to do so,
you could make your own line 8,

90
00:04:37.952 --> 00:04:42.176
that you could say then say baz.baz, and
you'll see this string value as it was

91
00:04:42.176 --> 00:04:46.058
assigned on line 2 cuz you got the object
back and he has a property on it.

92
00:04:50.335 --> 00:04:55.578
&gt;&gt; Kyle Simpson: That's the fourth and
final way that if this keyword gets bound,

93
00:04:55.578 --> 00:04:59.866
it can be bound to a brand new
object that it was created

94
00:04:59.866 --> 00:05:03.630
as part of a constructor
called hi-jacking.

95
00:05:03.630 --> 00:05:04.959
Questions about the new binding?

96
00:05:08.780 --> 00:05:11.950
Now I've been mentioning to you all along
as we've been going there were four roles.

97
00:05:11.950 --> 00:05:13.340
Now we have the four roles.

98
00:05:13.340 --> 00:05:16.890
And I mentioned to you that there
was actually an order of precedence.

99
00:05:16.890 --> 00:05:20.480
Because depending on how construct things,
you could have a call sight that might

100
00:05:20.480 --> 00:05:24.260
match two or
three different rules at the same time.

101
00:05:24.260 --> 00:05:26.390
So which one takes precedence?

102
00:05:26.390 --> 00:05:28.360
Which one is the most important rule?

103
00:05:28.360 --> 00:05:33.040
Let me present to you in order the four
questions to ask about your this keyword.

104
00:05:33.040 --> 00:05:36.210
These are the four things that you
should write down on a post it note, and

105
00:05:36.210 --> 00:05:39.890
stick that on your monitor next to the
post it note that has your password, and

106
00:05:39.890 --> 00:05:42.800
you will never be concerned again
about how the this binding works.

107
00:05:42.800 --> 00:05:43.690
Because it's very simple.

108
00:05:43.690 --> 00:05:46.560
You find the call site,
you ask these questions in order.

109
00:05:46.560 --> 00:05:47.550
Okay?

110
00:05:47.550 --> 00:05:51.080
The first question, I'm sorry, I forgot.

111
00:05:51.080 --> 00:05:53.490
This code proves the order of precedence.

112
00:05:53.490 --> 00:05:54.390
I'm not gonna belabor it.

113
00:05:54.390 --> 00:05:55.560
You can go back if you want.

114
00:05:55.560 --> 00:05:57.120
You can try the code yourself.

115
00:05:57.120 --> 00:05:58.650
You can type this kinda
stuff in if you want.

116
00:05:58.650 --> 00:06:01.180
It will prove the precedence to you,
but I won't belabor it,

117
00:06:01.180 --> 00:06:03.150
cuz I'm just gonna tell you
what the precedence is.

118
00:06:05.430 --> 00:06:08.630
First rule, was the function
called with the new keyword?

119
00:06:08.630 --> 00:06:09.760
If so, use that object.

120
00:06:11.210 --> 00:06:14.480
That means that the new keyword is able
to overwrite any of the other rules,

121
00:06:14.480 --> 00:06:16.520
because it's the most
precedent of the rules.

122
00:06:17.540 --> 00:06:20.970
That could be a surprising result,
which I'll explain here in just a moment.

123
00:06:20.970 --> 00:06:21.810
Second rule.

124
00:06:21.810 --> 00:06:24.320
If there wasn't a new keyword,
the second rule.

125
00:06:24.320 --> 00:06:25.890
Was it called with call or apply?

126
00:06:25.890 --> 00:06:27.300
Was there an explicit binding?

127
00:06:27.300 --> 00:06:28.270
If so, use that object.

128
00:06:30.320 --> 00:06:30.980
Third rule.

129
00:06:30.980 --> 00:06:32.320
Was it implicit binding role.

130
00:06:32.320 --> 00:06:35.280
Was there an owning or containing
context object at the call site.

131
00:06:35.280 --> 00:06:36.820
If so use that object.

132
00:06:36.820 --> 00:06:40.401
And fourth and final, we default to
the global object except in strict mode,

133
00:06:40.401 --> 00:06:42.448
in which we default to
the undefined value.

134
00:06:45.669 --> 00:06:50.950
&gt;&gt; Kyle Simpson: These four rules in order
now let me show you a surprising result.

135
00:06:50.950 --> 00:06:53.280
At least is was surprising to me.

136
00:06:53.280 --> 00:06:55.250
Remember how we talked
about hardbound functions?

137
00:06:56.340 --> 00:07:00.450
Hardbound functions were basically
a variation of the explicit binding rule.

138
00:07:00.450 --> 00:07:04.090
Remember we wrapped the function around
it, and we put some special stuff into it

139
00:07:04.090 --> 00:07:06.750
to make sure that it would be
forcibly calling a particular disk.

140
00:07:07.850 --> 00:07:09.460
Where does that fall in
the order of precedence?

141
00:07:11.460 --> 00:07:14.114
Any guesses where the hard
binding rule falls?

142
00:07:14.114 --> 00:07:14.957
&gt;&gt; Speaker 1: Number two.

143
00:07:14.957 --> 00:07:15.987
&gt;&gt; Kyle Simpson: At number two.

144
00:07:15.987 --> 00:07:20.158
Which means that the new
key word is even able

145
00:07:20.158 --> 00:07:25.140
to override hard binding,
subtle but weird point.

146
00:07:25.140 --> 00:07:28.800
Which I can prove by going back here,
I won't explain how the code works, but

147
00:07:28.800 --> 00:07:32.330
there is a trick here and you can see
the evidence of the trick right here,

148
00:07:32.330 --> 00:07:34.570
inside of the polyfil for it.

149
00:07:34.570 --> 00:07:38.675
It's checking to figure out if the this
keyword came as the result of a new call

150
00:07:38.675 --> 00:07:41.978
or not and if so it uses an otherwise
it uses what you pre bound.

151
00:07:48.881 --> 00:07:52.365
&gt;&gt; Kyle Simpson: It took me about three
hours to figure out how that code works,

152
00:07:52.365 --> 00:07:54.710
so I don't have time to go over it now,
but

153
00:07:54.710 --> 00:07:57.000
you'll just have to take my word for it.

154
00:07:57.000 --> 00:08:00.530
All right, so those are our four rules in
order of precedence, learn those rules,

155
00:08:00.530 --> 00:08:01.920
remember those rules.

156
00:08:01.920 --> 00:08:04.510
That's all you ever need to know and
you have no more excuses for

157
00:08:04.510 --> 00:08:08.720
ever being confused about
the this keyword again.

158
00:08:08.720 --> 00:08:10.780
Find the call site, ask those four rules.

