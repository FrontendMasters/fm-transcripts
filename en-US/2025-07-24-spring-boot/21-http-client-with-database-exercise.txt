[00:00:00]
>> Josh Long: We covered a few things. Now that you have got like some meat you can chew in a little bit, I was hoping we could pull something together. Just a trivial app talking to a database. And since you've got Docker and since you've got Start Spring IO and it'll give you a Docker Compose file, you know, and you've learned a little bit about data access.

[00:00:19]
I'm talking about SQL and postgres, but I'm sure you can figure out something and then just build a simple hello world HTTP endpoint. It doesn't matter which one I showed you. It could be HTTP, it could be rest, it could be hypermedia, it could be GRPC, it could be GraphQL, whatever.

[00:00:34]
Can we do that? Just a simple read a record from a database and then return it from an endpoint kind of thing. Just end to end, right. We're going to do a very simple thing, kind of pulling together some of the things we learned yesterday. We're going to choose GraalVM, choose Web, choose Postgres, choose Docker Compose.

[00:00:52]
You also want to add JDBC. How do I not have that? Actually? There you go. Add Spring Data jdbc. That's the important bit if you want to do live reloads, which you should. Dev tools are great, but since we're just doing a one Endpoint. Yep, this will pay dividends in anything longer than a 5 minute project.

[00:01:13]
Great point. DevTools, Docker Compose, these are all quality of life improvements. The core of the application is just the web, postgres and the jdbc. Everything else is to make the code worthy of production and make the experience worthy of you. Hit Enter, open this up. This is just.

[00:01:31]
I'm going to. Here's the long form, right? Unzip CD E2E idea Palm XML. Okay, if that does. If you don't have idea, you should, but if you don't, you can just go to File Open and then point to the Palm xml. That'll be the same result if you're in Intellij or in Eclipse as far as I remember.

[00:01:50]
And we're going to talk to a database. The database is provided for us by Docker Compose here. So make sure you don't have Postgres running in another Docker image somewhere. So I'll do that and then just. I'm going to have a little domain. I expect my domain will be around a customer of some sort.

[00:02:08]
I'm going to signal that this is the primary key by using id. I'll create a repository to make Data access, trivial customer integer. Let's see. Record. There you go and then finally a controller. So response body class customer controller. Get mapping customers. Customer, customer and then one of my favorite features here, customerepositoryfindall.

[00:02:48]
Okay, so that's the code that'll work but of course you need a database. So who's going to initialize the database? Well, you can ask spring boot to create. To initialize a schema on startup by creating a file called schema SQL and create table if not exists customer, ID, serial primary key name text.

[00:03:12]
There's that and then you need some sample data, right? So data SQL insert into customer name values. Josh Dushan. Okay, there's two. Now you want to tell spring boot to make sure to run those SQL files because it's a postgres and you don't necessarily want it running against your production database.

[00:03:40]
And then start, that's going to run Docker for you, which you may or may not want. It takes a long time. So local host 8080 customers. There we go. Okay, any question like, I can do that again? Yes.
>> Speaker 2: Would there be a reason you'd want to enable virtual threads for this project?

[00:04:04]

>> Josh Long: Yes, I would enable them by default, and that's extra points, but you get yes, please do that. Good idea.
>> Speaker 3: One follow up to that virtual threads question is why would you want to enable them?
>> Josh Long: Because anytime you do IO, in this case talking to a SQL database, when you go to your browser and open up localhost 8084 customers, this method gets invoked inside of a thread, of which there are precious few in a given system.

[00:04:34]
So you want to make sure that when you're doing things that don't need to be executing on a thread, such as just waiting for bytes to come back from a socket, that you do that work while not sitting on a thread. So virtual threads will automatically detect that you're talking to a SQL database or to another network socket of any kind, and that therefore you're not doing anything on the thread, you're just waiting.

[00:04:56]
And it'll move that waiting operation off to the side. And then as soon as that waiting operation is finished, it'll signal, hey, I've got some bytes. It's time to continue execution. It'll reconstruct the stack and allow you to complete. So basically, virtual threads make the inefficient wait time that we spend talking to other network services not so problematic in terms of our ability to scale and handle more requests.

[00:05:23]
Because we need one thread per request, and if those threads are busy, just waiting for bytes, then that's a waste. Sorry. All the pop ups. Does anybody need to see this schema? There you go and then there's the data.
>> Speaker 4: When you declared the id, which extension does that come from?

[00:05:48]

>> Josh Long: Spring Data jdbc. Actually, Spring Data JDBC is a module in the Spring Data project, and the ID annotation is common to all Spring Data projects. So you can use it for MongoDB, you can use it for Neo4J, you can use it for Cassandra, you can use it for Redis, you can use it for SQL databases, you can use it for elasticsearch and Couchbase.

