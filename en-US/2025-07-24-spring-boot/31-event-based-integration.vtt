WEBVTT

1
00:00:00.240 --> 00:00:01.072
&gt;&gt; Josh Long: So that works.

2
00:00:01.072 --> 00:00:03.760
But don't you see the problem with this,
right?

3
00:00:03.760 --> 00:00:07.665
We've got a Java object that we've
injected into our controller and

4
00:00:07.665 --> 00:00:11.520
whose result we need to happen,
but we don't depend on the result.

5
00:00:11.520 --> 00:00:13.120
In fact, it's void, right?

6
00:00:13.120 --> 00:00:15.365
Dr.schedule is void.

7
00:00:15.365 --> 00:00:16.240
Why do I do that, right?

8
00:00:16.240 --> 00:00:17.920
Like why do I need this dependency?

9
00:00:17.920 --> 00:00:21.382
This is a problem because it means
that this controller, this service,

10
00:00:21.382 --> 00:00:25.243
rather starts to run the risk of becoming
overly complex, overly muddled with,

11
00:00:25.243 --> 00:00:28.810
with too many distinct concerns that
have no business being in one type.

12
00:00:28.810 --> 00:00:30.210
So I want this, I need this to happen.

13
00:00:30.210 --> 00:00:33.530
I need the scheduling of the appointment
to go see the vet to happen.

14
00:00:33.530 --> 00:00:36.090
But I don't want that code to
complicate this controller.

15
00:00:36.090 --> 00:00:37.050
It's a different concern.

16
00:00:37.050 --> 00:00:38.970
Okay, so let's back out that change.

17
00:00:38.970 --> 00:00:42.330
Let's think about how
we can do this instead.

18
00:00:42.330 --> 00:00:43.802
And we'll do that.

19
00:00:43.802 --> 00:00:44.450
We're gonna back that out.

20
00:00:44.450 --> 00:00:46.410
Okay, I'm not going to
inject the dog tour there.

21
00:00:46.410 --> 00:00:47.370
There we go.

22
00:00:47.370 --> 00:00:50.490
And I want to move to
a different way of integration.

23
00:00:50.490 --> 00:00:53.050
I'm going to use asynchronous
event based integration.

24
00:00:53.050 --> 00:00:55.065
We talked about this a lot so far, but

25
00:00:55.065 --> 00:00:58.970
again, I think this is a much more
natural way to sort of build systems.

26
00:00:58.970 --> 00:01:05.170
So this is a great blog by Martin Fowler
from 2017 before the COVID pandemic or BC.

27
00:01:05.170 --> 00:01:08.756
And in this blog he posits that there
are four different kinds of messaging and

28
00:01:08.756 --> 00:01:12.970
integration styles, right, that are really
interesting that we should all know about.

29
00:01:12.970 --> 00:01:15.330
The first of which is event notification.

30
00:01:15.330 --> 00:01:19.966
And here you're using an event to tell one
system or one module about the fact of

31
00:01:19.966 --> 00:01:24.290
a change, that something has changed,
not what, right?

32
00:01:24.290 --> 00:01:27.330
And so,
this is a very common example, right?

33
00:01:27.330 --> 00:01:30.690
Like if you're using like JavaScript.

34
00:01:30.690 --> 00:01:35.289
I'm sorry, but in the onload listener,
there's only one onload, right?

35
00:01:35.289 --> 00:01:37.850
I mean, ignoring frames for
a moment here, right?

36
00:01:37.850 --> 00:01:39.610
There's only one really
interesting onload.

37
00:01:39.610 --> 00:01:43.741
So when you say onload, you don't need to
inspect the event to know what document

38
00:01:43.741 --> 00:01:45.970
was loaded, it's just the one, right?

39
00:01:45.970 --> 00:01:48.050
That's an event notification.

40
00:01:48.050 --> 00:01:51.290
The fact that the event listener
got called is fact enough to give

41
00:01:51.290 --> 00:01:53.810
you actionable details
about what's happened.

42
00:01:53.810 --> 00:01:56.850
Okay, but sometimes you need details.

43
00:01:56.850 --> 00:01:59.607
And in that case, when the event gets
sent from one module to another,

44
00:01:59.607 --> 00:02:02.610
from one system to another,
it's called event carried state transfer.

45
00:02:02.610 --> 00:02:07.132
Event carried state transfer is the idea
that each message, each event has

46
00:02:07.132 --> 00:02:12.250
actionable details that the consumer can
use to then proceed and work on something.

47
00:02:12.250 --> 00:02:16.623
And this avoids coupling the consumer with
the producer because I don't need to know

48
00:02:16.623 --> 00:02:19.764
the origin of the message to
query it to ask for more details,

49
00:02:19.764 --> 00:02:23.690
because all the details I need are in
the body of the message itself.

50
00:02:23.690 --> 00:02:25.930
So event carried state transfer,
very useful.

51
00:02:25.930 --> 00:02:30.366
If you communicate all detail changes,
all system changes in the system via event

52
00:02:30.366 --> 00:02:34.170
carried state transfer,
then something very interesting happens.

53
00:02:34.170 --> 00:02:36.010
What becomes a source of
truth in your system?

54
00:02:37.130 --> 00:02:41.781
If you have postgres, even in a so called
monolith, modular, monolithic application,

55
00:02:41.781 --> 00:02:44.534
even in that scenario,
you still have, it's very,

56
00:02:44.534 --> 00:02:48.520
very reasonable to have a lot
of different databases, right?

57
00:02:48.520 --> 00:02:51.908
So you might have Postgres for
your data for your writes,

58
00:02:51.908 --> 00:02:55.437
you might have Redis to support
constant time read access,

59
00:02:55.437 --> 00:03:00.120
you might have elasticsearch to support
full text search access of the data.

60
00:03:00.120 --> 00:03:03.168
So these are two different, these are
three different data structures optimized

61
00:03:03.168 --> 00:03:04.760
for read and write modalities, right?

62
00:03:04.760 --> 00:03:07.748
And in that case,
what's the source of truth?

63
00:03:07.748 --> 00:03:12.736
What single database do you need to be
able to reconstitute everything else,

64
00:03:12.736 --> 00:03:13.280
right?

65
00:03:13.280 --> 00:03:14.538
If you lost Postgres,

66
00:03:14.538 --> 00:03:18.720
could you reconstitute what's in
postgres from elasticsearch or Redis?

67
00:03:18.720 --> 00:03:20.640
Probably not, right?

68
00:03:20.640 --> 00:03:23.480
Likewise, could you reconstitute
what's in Redis from elasticsearch?

69
00:03:23.480 --> 00:03:24.080
Probably not.

70
00:03:24.080 --> 00:03:25.040
You get the idea, right?

71
00:03:25.040 --> 00:03:29.600
The only thing you can reconstitute
the entire system with is the messages.

72
00:03:29.600 --> 00:03:33.095
As long as you've got all the messages
that were ever delivered to the system and

73
00:03:33.095 --> 00:03:36.693
you can replay them in the order they were
delivered and you can rebuild the state of

74
00:03:36.693 --> 00:03:39.700
the system at the time that you,
that you lost everything, right?

75
00:03:39.700 --> 00:03:44.660
So you can RMRF your Postgres,
your elasticsearch, and your Redis.

76
00:03:44.660 --> 00:03:47.096
And as long as you've got the messages,
as long as you can replay them,

77
00:03:47.096 --> 00:03:49.100
you have everything you need
to get back to where you were.

78
00:03:49.100 --> 00:03:50.460
And that's called event sourcing.

79
00:03:50.460 --> 00:03:52.100
And it gives you an audit log as well.

80
00:03:52.100 --> 00:03:53.700
It's very, very powerful, right?

81
00:03:53.700 --> 00:03:57.957
So let's say you have some like
Sam Bankman fried thing where you're like,

82
00:03:57.957 --> 00:04:00.483
you've got a little back
door in the thing and

83
00:04:00.483 --> 00:04:04.790
you've got derivations happening
in some profit thing, right?

84
00:04:04.790 --> 00:04:05.910
What's the office space?

85
00:04:05.910 --> 00:04:07.110
Remember that office space scheme?

86
00:04:07.110 --> 00:04:09.496
Like a fraction of a penny
every transaction.

87
00:04:09.496 --> 00:04:13.030
Well, okay, let's say they
finally uncover the thing, right?

88
00:04:13.030 --> 00:04:14.710
Okay, this happened two years ago.

89
00:04:14.710 --> 00:04:18.310
Fine, go back to when
the thing was introduced.

90
00:04:18.310 --> 00:04:20.496
In the code replay, null out the values,

91
00:04:20.496 --> 00:04:24.618
replay the events ever since then with
the new algorithm in place, to arrive at

92
00:04:24.618 --> 00:04:28.890
the correct derivation Today you can do
that because you have all the messages.

93
00:04:28.890 --> 00:04:30.090
That's called event sourcing.

94
00:04:30.090 --> 00:04:33.816
And there are data structures that are
really good at preserving every message

95
00:04:33.816 --> 00:04:35.530
you've ever gotten in order.

96
00:04:35.530 --> 00:04:38.687
In fact, for smaller systems, you can
even use Kafka for that kind of thing,

97
00:04:38.687 --> 00:04:40.730
which is why it's kind of nice.

98
00:04:40.730 --> 00:04:42.490
You could also use a SQL database for
that kind of thing.

99
00:04:42.490 --> 00:04:44.810
Again, it's just a matter
of preserving history.

100
00:04:44.810 --> 00:04:49.450
If you understand the example I just gave,
we have read and write modalities, Redis,

101
00:04:49.450 --> 00:04:51.370
Elasticsearch, Postgres, etc.

102
00:04:51.370 --> 00:04:54.044
The idea that there are different
data structures optimized for

103
00:04:54.044 --> 00:04:57.066
different kinds of read and
write modalities, that's called CQRS, or

104
00:04:57.066 --> 00:04:59.010
Command Query responsibility Segregation.

105
00:04:59.010 --> 00:05:01.897
Okay, all of these patterns,
if you understand them, congratulations,

106
00:05:01.897 --> 00:05:02.810
you're an architect.

107
00:05:02.810 --> 00:05:04.330
Collect your promotion at the door.

108
00:05:04.330 --> 00:05:06.650
These are all part and
parcel of messaging.

109
00:05:06.650 --> 00:05:10.188
So again, we've talked about messaging
before, but remember, there's a whole

110
00:05:10.188 --> 00:05:13.130
world of things you can do with them
even if you're in the same dayvm.

