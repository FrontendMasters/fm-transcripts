[00:00:00]
>> Josh Long: Okay, so I've got data in the database. Let's build some mapping to talk to it. I'm going to use. We're going to do this the old fashioned way. First we'll say interface, person, repository. We're just gonna create a repository actually, an interface, okay? And we'll create an entity here.

[00:00:18]
I'm using records. You've seen me use records a lot here. Person string. It'll be int id. Okay. Records are nice, but they're not. These are supported in every project in Spring Data except for jpa. So Spring Data is an umbrella project. It is your one stop shop for all things orm.

[00:00:40]
If you want to persist things to a database, no matter what the nature of the database, there's a module here for you. So we have spring data, JDBC or JPA. Those both work with any SQL database, right? You have spring data Neo4j for a graph database, you have spring data.

[00:00:56]
MongoDB for MongoDB. You have spring data Redis for Redis. You get the idea. There's dozens of different modules. Some of these modules are maintained by the spring team proper or the spring team at other companies. Like for example the Spring Cloud Spanner support. The Google Spanner on Google Cloud is maintained by Google.

[00:01:13]
The Couchbase support is maintained by Couchbase, right? So we have. It doesn't matter which teams you're talking about here. Cosmos DB is maintained by Microsoft. These are all spring data modules that are maintained by different vendors, but they all work basically the same. And one of the things that's really nice about these different spring data modules is that they provide a couple things.

[00:01:32]
First, they provide this idea of a template object which is a fluid, very convenient, one liner friendly style way to interact with a lot of these different underlying data stores. They all provide spring idiomatic declarative transaction demarcation so you can annotate a method with transactional. And if the underlying data source supports transactions and you've configured the transaction manager accordingly, it'll automatically start and stop those transactions for you.

[00:01:58]
And it provides this concept of a repository. We're going to do a repository the hard way here. This is a design pattern, but we're going to do it the wrong way here. We're going to do it by hand. We're gonna say, find by id, int id. Okay, and now I'll say wrong way.

[00:02:15]
Person repository implements person repository. I'll implement that type. This is a new thing that added. Why do I want to make it abstract? This is who Needs that button. This is new. This didn't used to exist. My muscle memory is alt, enter, hit enter, but now it's making it abstract.

[00:02:36]
I want implement methods. That's all I want. It's the second one now on the list. I have to ping the people at Intellij. So, okay, I've got a repository. And remember we talked about those marker annotations? These marker annotations are stereotypical annotations. They are stereotypes in the UML sense.

[00:02:51]
They identify the role of the thing in the system. Okay, so repository. It has some runtime semantics, but it's still just add component. It's a meta annotation. Anything that has at component on it gets managed by spring. So this annotation in turn is annotated with component. Okay, so repository, functionally is just a component.

[00:03:14]
It's just that it's cleaner and more understandable to logically identify it as such. Okay, okay, so now how do we implement that thing? Well, I'm going to use this spring JDBC client, right? You saw me use this earlier. The JDBC client makes it trivial to talk to an online SQL database in raw SQL.

[00:03:31]
So I'll say this.db. sQL select all from person and then. And we wanna do by id, right? So where ID actually maybe we want to do all of them. Let's just do all the customers, all the people, person. Okay, find all, there we go, that's even easier to kind of work through here.

[00:03:58]
Okay, so we have the select all and we're gonna create a row mapper. And the row mapper, its job is to take a result set that comes back from the SQL database and map it to the domain of our. Of our code here. Okay. List. Okay, and then we want to do collection of.

[00:04:18]
There you go. So we've got the row mapper. And you know, this can be a lambda, obviously. Get rid of that, get rid of this. And the contract is given the result set. Create the person. So person name int id. Pretty straightforward. And then why is this unhappy there?

[00:04:43]
Same thing. Good, so we don't need the where id since that's no longer domain, good. So now let's try this out. I want to just enumerate all the people there. @Controller @responds body, I don't have that. Let's do a spring bean that will get run when the application starts up.

[00:05:02]
I'll use the application runner here and I'll inject the person repository. Okay, good. And then restart that. Restart that. Okay, so you can see it found the one person. Okay, so it's obviously worked. It's a trivial example, but it does work. But even this trivial example was just a lot of code.

[00:05:25]
So spring data has this declarative interface concept and it kind of reminds me of the best of Active Directory in Ruby and Rails, right? It's imagine if that was done correctly. So you take that type, delete this code. Okay, there you go. So now I have a person repository.

[00:05:48]
I'll delete that and I can do two different ways. I can extend list of code repository for person whose primary key is of type integer, right? That's the easiest. And in that case the code doesn't change at all. Okay, there you go. So I got the same exact result.

[00:06:06]
There's my id, there's my customer. But behind the scenes that method is being inherited from this base class. There's methods here like find all, saveall, etc. Crude repository in turn has other methods like save, delete, find by id and it gives you an optional check and see if something exists, do a count, etc.

[00:06:25]
And spring data has these CRUD repositories all throughout the code base. There's different CRUD repositories for Redis, MongoDB, Neo4j, whatever. But obviously you don't want to have the lowest common denominator. That seems like a waste, right? So there's other sub interfaces that are more specific. In this case I'm using a list of CRUD repository.

[00:06:44]
If you're using Mongo, there might be a Mongo repository that has extra features in there. And also you can create your own methods. So if I say collection person, find by name and then let me just use that instead, I'll say find by name is J long. Okay, so now I'm asking it to find by name.

[00:07:05]
And yeah, it's giving me that one result back. Okay, so it's a declarative query. Obviously if I want to exert even more control, I can say select all from person where name equals name and whatever. And whatever and whatever. Maybe you could do some check to check to see if they're the current authenticated user and they have access to this data table or whatever, right?

[00:07:24]
And you can also do spring expression language queries. You can put in templated values from the current environment, for example, the security context and so on. So let's try this one out. Suctol from person where p.name equals this, okay? And of course, it's gonna return the right one, right, because, of course, it would.

[00:07:51]
So I can have as much or as little control as I need to to work with my back end data store. Spring data, I'm using JDBC, which is very, very expressive. But we also support custom where it's appropriate. So, for example, if you're using MongoDB or PostGIS and Postgres, they both support geospatial primitives, right?

[00:08:08]
So there's actually a point concept. So you could say find by name and location string name and then you put in a point. Org springframeworkdata GL point, right? And it'll create a query that looks at that correct type in the underlying backing thing.

