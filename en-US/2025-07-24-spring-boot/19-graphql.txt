[00:00:00]
>> Josh Long: GraphQL. Anybody here using GraphQL? I love graphql. Okay, well, so we're gonna use GraphQL here, let's try that. So I have a folder here called GraphQL. GraphQL is schema first. So I'll create this users graphqls there. I'll create a type in there called user. And I'm not gonna bother mapping all of this, but basically, where's my web application?

[00:00:28]
Okay, and user. So let's say I want to keep some of this data. Okay, so I'll comment that out. So it's id, int name string, username string, email string. Now what about the address? Well, I can actually create a type called address and then I don't know what's in the address type.

[00:00:56]
It's a string suite, okay? So street:String suite, :String, okay?. Now in GraphQL, I can describe this, I can say address address. Now in graphql you have only three verbs. You have queries, which are read options. So queries, you have mutations which are writes, and you have subscriptions, which are long lived, ongoing streaming reads, right?

[00:01:31]
And if you want GraphQL to export a certain endpoint, you need to hang an attribute. These are attributes right here off of some of these well known types. So type Query. Okay, Query. And then, let's just call it users. And if I wanted to return a single user, I would do that.

[00:01:52]
If I want to do multiple, I do that. The array syntax is how you do multiples, okay? Okay, so let's build a controller that exports that GraphQL endpoint, okay? So @Controller class GraphqlController. And instead of using Git mapping for HTTP Git, I'm going to use query mapping and it'll be collection of users and same thing as before, I'll say return declarative users.

[00:02:27]
Okay, and I also want to try this stuff out. That's the other thing is I want a console I can use to inspect my GraphQL. There's a nice graphical graphic, Graph IQL that you can use there. So I go here graphiql and hit enter and you get this.

[00:02:44]
Okay, so now I can say query, ID name, username, right? So there you go. So I've got those three fields. That's nice. One of the things I love about GraphQL is that you can get as much or as little data as you need. So I've asked for the id, the name and the username.

[00:03:01]
I got just that. If I ask for the address, well, it's going to say, hey, you can't just select all you need to tell us what you specifically want. So I go over here and I say, I want the street, great. I want the suite great. Okay, so I get as much or as little as I need.

[00:03:21]
One of the things that's really nice about GraphQL is of course you can do. It's a graph. It creates a graph, right? So imagine in this case that I was not actually all just in memory. I imagine I had another microservice that was called the address service and that's actually serving up address details.

[00:03:37]
Maybe it's some sort of, I don't know, phone book or something, I don't know. Okay, so in that case I would want some way to resolve the address for the user. Okay, so, and in this case I already happen to have the address, but let's imagine I didn't.

[00:03:51]
Let's suppose I needed to call another service to get that. Okay, so I'm going to override this. I'm going to create a schema mapping endpoint here, going to return a type of Java object of type address given the user object and I'll print this out. So I'll say system out, returning address for user.id, whatever.

[00:04:23]
Okay, so we go back over here and you can see that it actually called schema mapping for each one of those users. So in this case I'm just returning the object, this is spring, GraphQL is using the batch. It's using the fact that it knows the root of the domain object, which is user and it's given me a chance to given the user to load an object of type address.

[00:04:51]
In this case I'm cheating because the user already had the address. I'm just returning it. But the point is this could be a network call. I could todo call address service, right? Now this would work. But the problem of course is now I've got an N plus one big problem.

[00:05:05]
For every user, I need to call the address endpoint. If I've just got one user, it's a call. But that's a big problem. So I don't want that. So how do I, how do I get the best of both worlds? Well, what If I have one user or if I have 10 users, you know, if I have to call the address service 10 times, that's not good.

[00:05:24]
It'll cost, it's one request to get all the users and then 10 more requests to get all the addresses for these users. That's very inefficient. So Instead, I want to do this in batch. So again, the schema has not changed. The schema is address, suite, suite, right, suite and street.

[00:05:37]
So that's all there and it's all well and good, but I'm going to use batch mapping instead. Batch mapping. The contract is pretty simple. Given a list of collections of users, return a mapping of user to address. So var users, sorry, addresses, okay, and this will just be a hashmap.

[00:06:02]
Now you can imagine having some sort of backend endpoint you can do select all from address where you user ID in and then a range of IDs or something like that. Right? So there you go, the AI is doing it for me. So for each of the users put the.

[00:06:16]
Yeah, okay, that's exactly right. So now I'm going to comment out the one that I had before so that this one is more logical and then we'll say address. Okay, now I go back over here and yeah, let me print out address. What is the issue with this one?

[00:06:39]
Okay, system out, getting all addresses. So it'll be addresses. Okay, there you go. So you can see, it says, in that case I get a chance to return all the responses at once. Now, in theory, if this was actually a network call, it'd be one call for the users and another one for all the addresses by doing this batching.

[00:07:15]
So this method gets invoked just one time. That's much better. So GraphQL allows me to hide the fact that I started with the thing locally, then I refactored to another service, then I optimize the service to support batching and the client hasn't changed anything. They depend on an address being resolved for each of the users.

[00:07:33]
The contract is exactly the same. But how I've implemented that behind the scenes is transparent, right? So I can get the most efficient call graph possible. So GraphQL, really, really powerful.

