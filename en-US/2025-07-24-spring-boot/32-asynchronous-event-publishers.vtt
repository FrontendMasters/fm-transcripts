WEBVTT

1
00:00:00.400 --> 00:00:03.264
&gt;&gt; Josh Long: And so what I'm going to do
is I'm going to use the spring Framework

2
00:00:03.264 --> 00:00:06.180
application event publisher,
which we've looked at before, and

3
00:00:06.180 --> 00:00:08.480
we're going to publish an event.

4
00:00:08.480 --> 00:00:13.040
I'm going to publish an event from the
adoption service to the dog tour module.

5
00:00:13.040 --> 00:00:17.241
So I'm going to create my
first purposefully public

6
00:00:17.241 --> 00:00:20.080
type dog adoption event public.

7
00:00:20.080 --> 00:00:21.520
And it's going to have the dog id.

8
00:00:23.920 --> 00:00:26.920
That's my first type that I've
intentionally made public.

9
00:00:26.920 --> 00:00:31.551
I'm now going to go back over here to
my dog tour, sorry, my service, and

10
00:00:31.551 --> 00:00:37.160
I'll say application event publisher,
publish new dog adoption event.

11
00:00:37.160 --> 00:00:41.787
So now that that's public, that the event
is public, I can go back to the dog tour

12
00:00:41.787 --> 00:00:45.160
and just turn it into a listener for
that event, Right?

13
00:00:45.160 --> 00:00:49.080
So event listener, dog adoption event.

14
00:00:49.080 --> 00:00:52.770
Now, of course, because that's public,
these don't need to be anymore.

15
00:00:52.770 --> 00:00:55.170
These can be packaged private again,
which is nice.

16
00:00:55.170 --> 00:00:55.970
So let's see.

17
00:00:55.970 --> 00:00:58.050
Actually, that should just run.

18
00:00:58.050 --> 00:00:58.690
Here we go.

19
00:00:59.810 --> 00:01:03.730
Okay, run that command five.

20
00:01:03.730 --> 00:01:04.370
There you go.

21
00:01:04.370 --> 00:01:05.090
Scheduling.

22
00:01:05.090 --> 00:01:07.970
And we can see scheduling for
the dog adoption event,

23
00:01:07.970 --> 00:01:09.970
not the int that I had before.

24
00:01:09.970 --> 00:01:10.850
So it's worked.

25
00:01:10.850 --> 00:01:12.930
I've got these two modules
integrated with each other.

26
00:01:12.930 --> 00:01:15.090
They're talking to each other,
but they're decoupled.

27
00:01:15.090 --> 00:01:16.170
One doesn't know about the other.

28
00:01:16.170 --> 00:01:18.370
They don't need to know about each other,
except.

29
00:01:20.070 --> 00:01:22.070
Except they're kind of coupled,
aren't they?

30
00:01:22.070 --> 00:01:25.110
Remember we talked about how you can
publish events from one module to another?

31
00:01:25.110 --> 00:01:29.270
Those events are published
synchronously in the same thread.

32
00:01:29.270 --> 00:01:30.791
So if I go over here and

33
00:01:30.791 --> 00:01:37.270
I say thread sleep throws exception
because thread sleep throws an exception.

34
00:01:37.270 --> 00:01:39.110
And then I run the same request.

35
00:01:39.110 --> 00:01:43.590
Notice that even though I'm calling the
dog adoption service, it's not returning.

36
00:01:43.590 --> 00:01:44.110
There you go.

37
00:01:44.110 --> 00:01:48.740
It took five seconds to get that response
because another component in the system

38
00:01:48.740 --> 00:01:52.770
somewhere else that I have no idea about,
did a thread sleep, right?

39
00:01:52.770 --> 00:01:55.017
Can you imagine how frustrating
that would be to debug?

40
00:01:55.017 --> 00:01:58.021
I'm working on the adoption code and
for some reason now,

41
00:01:58.021 --> 00:02:00.980
somewhere along the lines
where there wasn't an issue.

42
00:02:00.980 --> 00:02:04.695
Now there's a five second delay, somebody
added something that took a long time and

43
00:02:04.695 --> 00:02:05.650
I have to wait for it.

44
00:02:05.650 --> 00:02:06.810
My SLA is in trouble.

45
00:02:06.810 --> 00:02:08.770
So this is not what you want
when you want messaging.

46
00:02:08.770 --> 00:02:11.424
A lot of people think about
asynchronous fire and forget and

47
00:02:11.424 --> 00:02:13.290
you can get that after a fashion, right?

48
00:02:13.290 --> 00:02:15.020
It's pretty easy in spring to.

49
00:02:15.020 --> 00:02:16.620
By the way, a service is just a component.

50
00:02:16.620 --> 00:02:18.100
Remember, it's a meta annotation.

51
00:02:18.100 --> 00:02:20.860
So I'm using service because
it makes it clear what it is.

52
00:02:20.860 --> 00:02:23.420
I could get asynchronicity.

53
00:02:23.420 --> 00:02:26.060
I could just make it at async like that.

54
00:02:26.060 --> 00:02:29.050
And what that does is it wraps
the invocation in a thread and

55
00:02:29.050 --> 00:02:30.940
then launches the thread.

56
00:02:30.940 --> 00:02:34.380
So I publish that message,
returns immediately,

57
00:02:34.380 --> 00:02:38.540
then five seconds later you'll
see it print out scheduling.

58
00:02:39.580 --> 00:02:41.840
Now it's invoking that
method on a separate thread.

59
00:02:41.840 --> 00:02:44.800
But now I've got the risk of losing state,
don't I?

60
00:02:44.800 --> 00:02:46.880
Because imagine if I
got the adoption thing.

61
00:02:46.880 --> 00:02:51.280
I'm updating the database table
that's happening in one transaction.

62
00:02:51.280 --> 00:02:55.441
Publish the message,
it goes to another module and

63
00:02:55.441 --> 00:02:59.520
it gets to the dog tour that runs for
five seconds.

64
00:02:59.520 --> 00:03:01.357
And then before the five seconds lapses,

65
00:03:01.357 --> 00:03:04.160
somebody pulls the power
out of the machine.

66
00:03:04.160 --> 00:03:05.080
Transaction lost.

67
00:03:05.080 --> 00:03:06.244
Right.
I've got my system in

68
00:03:06.244 --> 00:03:07.710
an inconsistent state.

69
00:03:07.710 --> 00:03:09.390
Right, which we want to avoid.

70
00:03:09.390 --> 00:03:10.910
So how do we get the best of both worlds?

71
00:03:10.910 --> 00:03:15.390
How can we have our asynchronous, you
know, fire and forget cake and eat it too?

72
00:03:15.390 --> 00:03:18.030
Well, we can use the outbox pattern.

73
00:03:18.030 --> 00:03:20.710
Okay, so spring modulus to the rescue.

74
00:03:20.710 --> 00:03:23.710
Here we're going to use
a application module listener.

75
00:03:23.710 --> 00:03:28.830
This pairs like fine wine with
cheese with this property here.

76
00:03:28.830 --> 00:03:31.750
Say, initialize the schema and moduleth.

77
00:03:31.750 --> 00:03:34.540
Republish outstanding events on restart.

78
00:03:34.540 --> 00:03:35.420
This is the important bit.

79
00:03:37.580 --> 00:03:38.860
Then go over here.

80
00:03:38.860 --> 00:03:40.540
I'm going to publish it again.

81
00:03:40.540 --> 00:03:42.700
It's instantaneous, it returns instantly.

82
00:03:42.700 --> 00:03:44.460
So it's still asynchronous.

83
00:03:44.460 --> 00:03:45.380
Wait for it to finish.

84
00:03:45.380 --> 00:03:46.060
Good.

85
00:03:46.060 --> 00:03:48.140
Now you go over here.

86
00:03:48.140 --> 00:03:49.819
Refresh the tables.

87
00:03:49.819 --> 00:03:51.980
We have this new table
called event publication.

88
00:03:53.100 --> 00:03:57.130
This event publication table has the id,
has a listener id,

89
00:03:57.130 --> 00:04:01.556
has the event type, the serialized
representation of the event,

90
00:04:01.556 --> 00:04:05.130
the publication date and
the completion date.

91
00:04:05.130 --> 00:04:06.890
Let's try this again.

92
00:04:06.890 --> 00:04:07.610
Refresh.

93
00:04:07.610 --> 00:04:09.210
Notice that there's no
completion date yet.

94
00:04:10.810 --> 00:04:12.130
I'm waiting, waiting, waiting.

95
00:04:12.130 --> 00:04:12.650
Refresh.

96
00:04:12.650 --> 00:04:13.210
There it is.

97
00:04:14.570 --> 00:04:18.537
That completion date only gets filled
in once the event listener has been

98
00:04:18.537 --> 00:04:21.370
dispatched and completed successfully.

99
00:04:21.370 --> 00:04:24.290
What happens if I don't complete
something successfully?

100
00:04:24.290 --> 00:04:25.300
Publish.

101
00:04:25.300 --> 00:04:28.220
Stop the Java process, Refresh that.

102
00:04:28.220 --> 00:04:29.606
You'll see that there's null and

103
00:04:29.606 --> 00:04:32.580
there's no chance of it ever becoming
non null until something happens.

104
00:04:33.860 --> 00:04:35.460
I'm going to restart the JVM now.

105
00:04:35.460 --> 00:04:39.756
You can see that missedmessage was
asynchronously redelivered and

106
00:04:39.756 --> 00:04:41.380
reprocessed.

107
00:04:41.380 --> 00:04:44.180
And so that happened on restart.

108
00:04:44.180 --> 00:04:45.580
So this is the outbox pattern.

109
00:04:45.580 --> 00:04:48.320
You use the outbox pattern to reconcile

110
00:04:48.320 --> 00:04:52.480
non transactional state against
a transactional ledger.

111
00:04:52.480 --> 00:04:55.400
In this case a SQL table or whatever.

112
00:04:55.400 --> 00:04:56.960
I mean, there's A bunch of
different integrations here.

113
00:04:56.960 --> 00:04:59.120
I think we have an integration
from MongoDB and so on.

114
00:04:59.120 --> 00:05:02.000
So let's imagine you're
writing to Amazon S3, right?

115
00:05:02.000 --> 00:05:03.160
S3 is a nice API.

116
00:05:03.160 --> 00:05:05.120
It's up most of the time,
sometimes it's not.

117
00:05:05.120 --> 00:05:07.560
Sometimes you have faulty networks,
sometimes you have latency.

118
00:05:07.560 --> 00:05:10.560
Whatever, whatever that is,
the write might fail.

119
00:05:10.560 --> 00:05:11.120
Okay?

120
00:05:11.120 --> 00:05:13.920
It's not unusual, it's just
the nature of the cloud, any cloud.

121
00:05:15.040 --> 00:05:16.960
And so I want to make sure it gets done.

122
00:05:18.300 --> 00:05:23.100
I write an item into a ledger saying, hey,
you're supposed to put this file in S3.

123
00:05:23.100 --> 00:05:26.641
And then you keep trying until it's done
and then you update the database saying,

124
00:05:26.641 --> 00:05:27.580
it's been done.

125
00:05:27.580 --> 00:05:29.580
Now I guarantee that it got finished.

126
00:05:29.580 --> 00:05:31.173
That reconciliation is the important bit,

127
00:05:31.173 --> 00:05:34.060
like we were talking about earlier about
saga patterns and things like that.

128
00:05:34.060 --> 00:05:38.340
So this outbox pattern is a great for
one shot request.

129
00:05:38.340 --> 00:05:39.820
This is a great way to get that effect.

130
00:05:41.020 --> 00:05:44.580
Right now I'm using the republish
Outstanding events on restart.

131
00:05:44.580 --> 00:05:45.580
You can do this yourself, though.

132
00:05:45.580 --> 00:05:47.380
You can actually republish
the events whenever you want.

133
00:05:47.380 --> 00:05:54.180
Right, so let's say I wrote some code
here, application runner, right?

134
00:05:54.180 --> 00:06:00.698
You incomplete me, I'm going to inject
the incomplete event publications,

135
00:06:00.698 --> 00:06:05.736
new application runner and
we'll say event publications,

136
00:06:05.736 --> 00:06:08.820
Resubmit event publications.

137
00:06:08.820 --> 00:06:11.610
We are nothing if nothing graded
names in the Java community.

138
00:06:11.610 --> 00:06:15.730
Okay, so ep.

139
00:06:15.730 --> 00:06:17.027
Is it completed?

140
00:06:17.027 --> 00:06:18.908
Get the application event
that triggered the thing,

141
00:06:18.908 --> 00:06:21.490
which would be in this case
a dog adoption event, right?

142
00:06:21.490 --> 00:06:25.090
Get the completion date, get the
identifier, get the event itself, right?

143
00:06:25.090 --> 00:06:28.330
This event identifier is going
to be pretty interesting.

144
00:06:28.330 --> 00:06:31.490
You can do consistent hashing and
do load balancing, Right?

145
00:06:31.490 --> 00:06:34.252
You could use Spring Cloud's
discovery client support,

146
00:06:34.252 --> 00:06:38.500
which we'll talk about in a minute here,
and do kind of load balancing that way.

147
00:06:38.500 --> 00:06:41.620
You might want to also make sure,
because this does bring.

148
00:06:41.620 --> 00:06:43.780
If you can resubmit whenever you want,
right?

149
00:06:43.780 --> 00:06:45.460
Like let's say I just did that.

150
00:06:45.460 --> 00:06:47.429
That means that all messages,

151
00:06:47.429 --> 00:06:52.740
all missed messages will get resubmitted
when any JVM that has this code restarts.

152
00:06:52.740 --> 00:06:53.240
Right?

153
00:06:54.740 --> 00:06:58.793
Well, what happens if you have
10 instances of the same node of

154
00:06:58.793 --> 00:07:00.260
the same code?

155
00:07:00.260 --> 00:07:01.940
They all restart at the same time.

156
00:07:01.940 --> 00:07:04.470
You have version 1.0 and
then you deploy 1.1.

157
00:07:04.470 --> 00:07:05.844
Now they all start up and

158
00:07:05.844 --> 00:07:09.430
they all have this resubmit
incomplete publications Right?

159
00:07:09.430 --> 00:07:10.230
Now you've got a problem.

160
00:07:10.230 --> 00:07:12.939
Now you're going to
inadvertently publish or

161
00:07:12.939 --> 00:07:17.430
republish rather all the same
messages 10 different times.

162
00:07:17.430 --> 00:07:21.952
So then you get into, okay, well, even in
the world of the monolith, you still have

163
00:07:21.952 --> 00:07:26.096
synchronization issues because you have
to worry about your sibling nodes,

164
00:07:26.096 --> 00:07:27.390
which are the trouble.

165
00:07:27.390 --> 00:07:29.510
So there's some solutions for that.

166
00:07:29.510 --> 00:07:32.220
I just showed you Spring integration.

167
00:07:32.220 --> 00:07:35.340
Spring integration has this really
convenient thing which is beyond the scope

168
00:07:35.340 --> 00:07:39.020
of what I'm going to show you here,
but it's called a lock registry.

169
00:07:39.020 --> 00:07:41.940
So you can configure a JDBC lock registry,
a Mongo lock registry.

170
00:07:41.940 --> 00:07:47.565
There's a bunch of implementations and you
can say lock registry.tryacquire mylock,

171
00:07:47.565 --> 00:07:52.460
and then you have a runnable that
runs in here, a callback, basically.

172
00:07:52.460 --> 00:07:58.483
And whatever you do inside of this will
only be run once per cluster, tight.

173
00:07:58.483 --> 00:08:02.859
Whichever node manages to acquire
that lock will run this code and

174
00:08:02.859 --> 00:08:04.380
nobody else, right.

175
00:08:04.380 --> 00:08:08.120
So you can enforce serialization and
linearity as best as possible, in a way,

176
00:08:08.120 --> 00:08:10.710
in a distributed system., okay.

177
00:08:10.710 --> 00:08:12.110
And of course you have the.

178
00:08:12.110 --> 00:08:15.230
The last option, which is just
write your code to be idempotent.

179
00:08:15.230 --> 00:08:17.347
I know it's cheeky,
I know it's not nice to say that,

180
00:08:17.347 --> 00:08:19.710
but sometimes that's just
the best of medicine, you know?

181
00:08:19.710 --> 00:08:21.110
Make your code edempotent if you can.

182
00:08:21.110 --> 00:08:22.358
It's not always easy.

183
00:08:22.358 --> 00:08:25.496
Like, if you're going to
charge people's credit cards,

184
00:08:25.496 --> 00:08:29.600
you want to make darn sure that
this is just warning once, right?

185
00:08:29.600 --> 00:08:32.880
Okay, so
now we've got our decoupled system.

186
00:08:34.000 --> 00:08:35.140
What happened here?

187
00:08:35.140 --> 00:08:35.640
It's.

188
00:08:38.160 --> 00:08:39.572
Why is this unhappy?

189
00:08:39.572 --> 00:08:40.821
Yeah, there we go.

190
00:08:40.821 --> 00:08:42.116
Intellij was spazzing.

191
00:08:42.116 --> 00:08:42.654
Okay.
So

192
00:08:42.654 --> 00:08:44.640
I published the event from
one module to another.

193
00:08:44.640 --> 00:08:45.920
I've used a decoupling and

194
00:08:45.920 --> 00:08:48.880
event driven architecture to
write the code to be more robust.

