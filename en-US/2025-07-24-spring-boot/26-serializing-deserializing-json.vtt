WEBVTT

1
00:00:00.320 --> 00:00:01.600
&gt;&gt; Josh Long: Okay, so configuration.

2
00:00:01.600 --> 00:00:02.729
What do we got to do?

3
00:00:02.729 --> 00:00:04.040
Well, we've got the group ID already here.

4
00:00:04.040 --> 00:00:06.320
I'm not sure if we need to specify it,
but we can.

5
00:00:06.320 --> 00:00:08.379
We want to specify the deserializer.

6
00:00:08.379 --> 00:00:11.102
So Spring Kafka deserializer, right.

7
00:00:11.102 --> 00:00:13.423
So when you get messages for the key.

8
00:00:13.423 --> 00:00:16.447
Right, the key we talked about,
that has to be deserialized and

9
00:00:16.447 --> 00:00:17.960
the value has to be serialized.

10
00:00:17.960 --> 00:00:23.920
So I'm going to specify
a generic Kafka deserializer.

11
00:00:23.920 --> 00:00:24.463
That'll do, I think.

12
00:00:24.463 --> 00:00:26.801
JSON or maybe it's bytes or something.

13
00:00:26.801 --> 00:00:27.745
It's pretty smart.

14
00:00:27.745 --> 00:00:30.974
But the point is you have to like JSON.

15
00:00:30.974 --> 00:00:31.876
Let's just do JSON.

16
00:00:31.876 --> 00:00:36.651
Okay, so there's the key deserializer,
and here is the value deserializer.

17
00:00:36.651 --> 00:00:37.850
Okay, simple.

18
00:00:37.850 --> 00:00:40.130
That was pretty simple and
then what about the producer?

19
00:00:40.130 --> 00:00:42.885
Remember, we're not just
reading values from Kafka,

20
00:00:42.885 --> 00:00:44.770
we're also writing values to Kafka.

21
00:00:44.770 --> 00:00:47.530
So the producer has to
also serialize the data.

22
00:00:47.530 --> 00:00:51.550
So I'm giving it just a regular Java
object somewhere between once I've handed

23
00:00:51.550 --> 00:00:55.040
it a Java object and it reaching
the network wire protocol for Kafka.

24
00:00:55.040 --> 00:00:58.471
Somewhere along the lines that
value needs to be serialized.

25
00:00:58.471 --> 00:01:03.838
So we say producer serializer, okay.

26
00:01:03.838 --> 00:01:06.840
Key serializer and
same thing, right, JSON.

27
00:01:06.840 --> 00:01:13.140
I'm going to use the JSON serializer
instead of deserializer, okay.

28
00:01:13.140 --> 00:01:17.800
Okay and then same thing over here for
the value, okay.

29
00:01:19.890 --> 00:01:20.810
Looks fine, I guess.

30
00:01:20.810 --> 00:01:22.210
I don't know.
We'll try it out.

31
00:01:22.210 --> 00:01:23.356
Let's see if that works.

32
00:01:23.356 --> 00:01:30.818
Having started up a brand new
Kafka in my Docker image,

33
00:01:30.818 --> 00:01:34.882
I don't have the web, okay.

34
00:01:34.882 --> 00:01:38.012
Since I'm using JSON,
it needs the JSON marshalling,

35
00:01:38.012 --> 00:01:42.930
which in turn implies that I need the web
stack, which is a bit unfortunate.

36
00:01:42.930 --> 00:01:45.820
So I added spring boot
start a web to my build.

37
00:01:45.820 --> 00:01:49.938
That'll give me the JSON support,
which is a function of that.

38
00:01:49.938 --> 00:01:53.154
So there we go.

39
00:01:53.154 --> 00:01:54.700
My group partitions assigned.

40
00:01:57.500 --> 00:01:58.620
Did we get a message?

41
00:02:02.860 --> 00:02:07.260
When the Kafka driver starts up,
you get all this very verbose output.

42
00:02:07.260 --> 00:02:09.180
So it's very hard to know.

43
00:02:09.180 --> 00:02:10.309
Did it work?

44
00:02:10.309 --> 00:02:11.029
Did it connect?

45
00:02:12.549 --> 00:02:15.029
Do I need to specify
the same consumer group?

46
00:02:15.029 --> 00:02:16.909
You might have to specify
the consumer group.

47
00:02:16.909 --> 00:02:22.469
Yeah, consumer client id, Group id.

48
00:02:22.469 --> 00:02:26.069
No, group ID is my group.

49
00:02:27.669 --> 00:02:29.509
Okay, try that over here.

50
00:02:29.509 --> 00:02:31.189
Try that there.

51
00:02:31.189 --> 00:02:38.025
Restart this.

52
00:02:38.025 --> 00:02:38.888
Okay, now we got the.

53
00:02:38.888 --> 00:02:43.970
Okay, we got something, so stop it.

54
00:02:43.970 --> 00:02:45.210
So now we got the next error,

55
00:02:45.210 --> 00:02:47.600
which is that this type is
not in the trusted packages.

56
00:02:49.200 --> 00:02:50.080
This is another thing.

57
00:02:50.080 --> 00:02:53.797
So remember we are receiving a JSON
payload over the Wire and the payload has

58
00:02:53.797 --> 00:02:57.440
information about the class that
we're trying to deserialize it to.

59
00:02:57.440 --> 00:03:01.750
Would you trust random unscrutinized
packets over the network to

60
00:03:01.750 --> 00:03:03.638
serialize into Java types?

61
00:03:03.638 --> 00:03:06.641
Right to actually result in
Java types being created.

62
00:03:06.641 --> 00:03:09.450
So you need to actually
allow Kafka to do that.

63
00:03:10.810 --> 00:03:13.610
I think there's a property, let me see.

64
00:03:13.610 --> 00:03:16.260
So consumer properties.

65
00:03:16.260 --> 00:03:19.160
Okay, and then there's this magic string.

66
00:03:19.160 --> 00:03:23.290
JSON.trusted packages equals *.

67
00:03:23.290 --> 00:03:27.760
Okay, so what that's saying is I want to
implicitly trust every message coming in.

68
00:03:27.760 --> 00:03:28.547
Don't do that.

69
00:03:28.547 --> 00:03:31.360
You can also give it a commons,
a limited list to be very specific.

70
00:03:31.360 --> 00:03:35.066
But for now, for this demo to succeed,
make sure you add that property.

71
00:03:35.066 --> 00:03:38.933
Okay, properties spring dot.

72
00:03:38.933 --> 00:03:39.548
There you go.

73
00:03:44.976 --> 00:03:45.834
There we go.

74
00:03:45.834 --> 00:03:48.956
Okay, so once I've done that, all the
three messages that were delivered before

75
00:03:48.956 --> 00:03:52.186
that errantly didn't get delivered,
they finally got delivered retroactively.

76
00:03:52.186 --> 00:03:54.767
So I was able to,
with a fair bit of configuration,

77
00:03:54.767 --> 00:03:58.922
actually there's more configuration
arguably than there's actual Java code.

78
00:03:58.922 --> 00:04:00.450
The producer is this bit.

79
00:04:00.450 --> 00:04:03.781
I'm injecting the Kafka template and
I'm calling kafkatemplate send,

80
00:04:03.781 --> 00:04:05.370
sending it to a well known topic.

81
00:04:05.370 --> 00:04:07.608
On the consumer side,
I have a Kafka listener.

82
00:04:07.608 --> 00:04:11.430
This could be two different JVMs and
as long as they have the same host and

83
00:04:11.430 --> 00:04:14.051
port for the Kafka broker,
then they will work.

84
00:04:14.051 --> 00:04:18.533
On the consumer side, I need to make sure
I trust all packages for deserialization.

85
00:04:18.533 --> 00:04:22.121
I need to specify and care about what
serializers are used for production and

86
00:04:22.121 --> 00:04:23.019
consumption.

87
00:04:23.019 --> 00:04:25.293
But then at the end of it,
I have a working service, so

88
00:04:25.293 --> 00:04:26.819
I'm not even sure if I needed this.

89
00:04:26.819 --> 00:04:29.171
Actually, let's get rid of that,
try it one more time and

90
00:04:29.171 --> 00:04:30.379
see if we can do without that.

91
00:04:33.579 --> 00:04:34.384
Yep, I could have.

92
00:04:34.384 --> 00:04:35.360
So there you go.

93
00:04:35.360 --> 00:04:39.136
Just specify the producer and the consumer
serializers for the key and the value,

94
00:04:39.136 --> 00:04:42.379
specify that you want to support all
JSON types and then you're done.

95
00:04:42.379 --> 00:04:43.784
Okay, that's Kafka.

96
00:04:43.784 --> 00:04:47.773
And if you want to do pulsar while
you add that to the class path,

97
00:04:47.773 --> 00:04:52.088
specify the equ equivalent
configuration and you do this, right?

98
00:04:52.088 --> 00:04:55.370
If I want to do rabbit rabbitmq,
you do this.

99
00:04:55.370 --> 00:04:57.247
You get the idea, right?

100
00:04:57.247 --> 00:04:58.410
It's as easy as it can be.

