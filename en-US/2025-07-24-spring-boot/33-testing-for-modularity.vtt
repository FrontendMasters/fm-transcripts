WEBVTT

1
00:00:01.440 --> 00:00:03.920
&gt;&gt; Josh Long: At this point
I'm entirely in the same jvm.

2
00:00:03.920 --> 00:00:05.454
What happens if I want
to have another jvm?

3
00:00:05.454 --> 00:00:07.618
Well, you have this mechanism,

4
00:00:07.618 --> 00:00:13.680
you have these modules in spring modulus
to support messaging and externalization.

5
00:00:13.680 --> 00:00:17.407
So in addition to publishing the messages
from one component to another in

6
00:00:17.407 --> 00:00:18.137
the same jvm.

7
00:00:18.137 --> 00:00:22.781
You can add externalized to this and
you put in there the scheme for

8
00:00:22.781 --> 00:00:25.920
whatever messaging module you're using.

9
00:00:25.920 --> 00:00:29.360
So, so if you're using Kafka,
you'd put a topic name, right?

10
00:00:29.360 --> 00:00:30.480
Topic name.

11
00:00:30.480 --> 00:00:33.510
Or if you're using RabbitMQ,
it'd be the exchange name, right.

12
00:00:33.510 --> 00:00:37.556
I contributed my favorite module, which is
the spring integration messaging module

13
00:00:37.556 --> 00:00:40.044
which can in turn talk to
anything you want, right.

14
00:00:40.044 --> 00:00:43.389
You saw how you create a channel and
you create an integration flow.

15
00:00:43.389 --> 00:00:45.312
Well, here you put the channel name and

16
00:00:45.312 --> 00:00:47.706
this message will get
published into a channel.

17
00:00:47.706 --> 00:00:51.465
And from there you can talk to anything
that spring integration can talk to,

18
00:00:51.465 --> 00:00:52.296
including SQS.

19
00:00:52.296 --> 00:00:56.328
And Pulsar and Kafka and JMS and file
systems and FTP and email and tcp, IP and

20
00:00:56.328 --> 00:00:57.840
whatever you want, right?

21
00:00:57.840 --> 00:01:01.145
So I'm not going to set this up, but
you should know this is available.

22
00:01:01.145 --> 00:01:04.836
You just make sure to add externalized and
then set up the right dependency, right?

23
00:01:04.836 --> 00:01:10.478
So for example, dependency,
spring modulate events, messaging,

24
00:01:10.478 --> 00:01:15.459
that's the one that does spring
integration, for example.

25
00:01:15.459 --> 00:01:17.669
And there'll be one for events.

26
00:01:17.669 --> 00:01:21.386
Is it sqs, I think and Kafka and
you know, you get the idea.

27
00:01:21.386 --> 00:01:25.295
Okay, so now we've got
externalization in the system and

28
00:01:25.295 --> 00:01:29.460
we've got our decoupled code and
it's modular and all that.

29
00:01:29.460 --> 00:01:30.820
How do I know if it's modular?

30
00:01:30.820 --> 00:01:32.318
What does modular mean?

31
00:01:32.318 --> 00:01:34.020
How do I know if I am modular?

32
00:01:34.020 --> 00:01:35.431
Right well, let's write a test.

33
00:01:35.431 --> 00:01:37.819
As with all things in life,
you just, you write a test.

34
00:01:37.819 --> 00:01:41.992
So var am application modules of and

35
00:01:41.992 --> 00:01:47.287
we'll say adoption applications.class.

36
00:01:47.287 --> 00:01:50.430
I'm going to say am Verify.

37
00:01:50.430 --> 00:01:51.874
Is my code modular?

38
00:01:51.874 --> 00:01:53.150
Let's just see what that means.

39
00:01:54.830 --> 00:01:56.110
So this is my test.

40
00:01:56.110 --> 00:01:57.150
It's junit.

41
00:01:57.150 --> 00:02:00.070
I've got a test method here and
I'm saying, is it modular?

42
00:02:00.070 --> 00:02:01.030
Looks like it's modular.

43
00:02:01.030 --> 00:02:02.350
It's green.
Okay, great.

44
00:02:02.350 --> 00:02:03.310
What does that mean?

45
00:02:03.310 --> 00:02:04.390
What modules do I have?

46
00:02:04.390 --> 00:02:05.310
Well, let's ask.

47
00:02:05.310 --> 00:02:08.402
Am I just going to print out the modules?

48
00:02:08.402 --> 00:02:10.030
I'll say system out, print line, am.

49
00:02:11.139 --> 00:02:14.259
Okay, go down here.

50
00:02:14.259 --> 00:02:16.659
Looks like I've got two modules.

51
00:02:16.659 --> 00:02:20.179
One's called adoptions, one's called vet.

52
00:02:20.179 --> 00:02:23.499
These are the logical beans
inside of each module.

53
00:02:23.499 --> 00:02:24.739
Here are the dependencies.

54
00:02:24.739 --> 00:02:31.080
One package is Injecting
types from the other one.

55
00:02:31.080 --> 00:02:34.001
If my spring module knows about
the structure of my modules,

56
00:02:34.001 --> 00:02:37.625
then maybe I can articulate that for
the, for the architects in the crowd.

57
00:02:37.625 --> 00:02:38.540
Right, great.

58
00:02:38.540 --> 00:02:40.300
So let's write it out.

59
00:02:40.300 --> 00:02:41.340
Go over here.

60
00:02:41.340 --> 00:02:46.300
And that generates a spring
module doc folder.

61
00:02:46.300 --> 00:02:49.740
And I go here, sorry.

62
00:02:49.740 --> 00:02:51.820
And it gives me this nice
architecture diagram.

63
00:02:51.820 --> 00:02:54.700
This is a C4 component diagram.

64
00:02:54.700 --> 00:02:58.620
This is a way to model
components in system boundaries.

65
00:02:58.620 --> 00:03:00.999
Not like uml, but like system boundaries.

66
00:03:00.999 --> 00:03:03.920
And this is using platuml,
which is a text format.

67
00:03:03.920 --> 00:03:07.967
So you can check it into version control
and then use something like graphviz or

68
00:03:07.967 --> 00:03:10.370
plantuml, whatever to generate this image.

69
00:03:10.370 --> 00:03:14.560
Okay, so this is a nice image that
will evolve with the code base.

70
00:03:14.560 --> 00:03:16.640
This is much better than the status quo.

71
00:03:16.640 --> 00:03:21.489
How many of you have logged into some wiki
page to find a diagram, checked into that

72
00:03:21.489 --> 00:03:26.080
wiki from some well intentioned architect
from like the Mosaic age, Right?

73
00:03:26.080 --> 00:03:27.840
Like, it's just a totally different thing.

74
00:03:27.840 --> 00:03:32.080
This is, this is actually up to date with
the code and with the state of the code.

75
00:03:32.080 --> 00:03:34.560
So, good.
So we've got modular code, right?

76
00:03:34.560 --> 00:03:35.118
We got.

77
00:03:35.118 --> 00:03:38.640
We're able to see what's happening, we're
able to observe it, we're able to write

78
00:03:38.640 --> 00:03:41.452
our code in such a way that it's
decoupled and we're able to test it.

79
00:03:41.452 --> 00:03:42.800
This is spring modulus.

80
00:03:42.800 --> 00:03:46.669
It's support for writing code that
is modular and I say modular and

81
00:03:46.669 --> 00:03:48.200
I say that you can test it.

82
00:03:48.200 --> 00:03:49.200
What does it look for?

83
00:03:49.200 --> 00:03:53.537
Well, behind the scenes,
spring modulus is packing up or

84
00:03:53.537 --> 00:03:58.951
packaging rather up something called
arch unit or arc unit or whatever.

85
00:03:58.951 --> 00:04:01.210
You know what my favorite word
in French is, by the way?

86
00:04:02.650 --> 00:04:05.434
Architecture.

87
00:04:05.434 --> 00:04:07.570
Come on,
don't tell me that doesn't sound great.

88
00:04:07.570 --> 00:04:08.374
That's a great word.

89
00:04:08.374 --> 00:04:10.730
Anyway, arch unit is a.

90
00:04:10.730 --> 00:04:13.130
It's a way of testing architectural
constraints in your system.

91
00:04:13.130 --> 00:04:15.970
And we're using that behind the scenes.

92
00:04:15.970 --> 00:04:17.250
And there are several
things we're looking for.

93
00:04:17.250 --> 00:04:21.799
First of all, if you created a like,
this is a module, Adoptions and

94
00:04:21.799 --> 00:04:25.189
vet are both modules for
our purposes here.

95
00:04:25.189 --> 00:04:26.775
And if I created a new module and

96
00:04:26.775 --> 00:04:31.049
I created a new package within that root
package, that root package is the module.

97
00:04:31.049 --> 00:04:33.574
If I create a new package in
here called validation, and

98
00:04:33.574 --> 00:04:37.189
then I create a new class in there which
is meant to support validation, right.

99
00:04:38.229 --> 00:04:39.989
Well, this has to be public.

100
00:04:39.989 --> 00:04:41.109
Naturally, it has to be public.

101
00:04:41.109 --> 00:04:43.989
I have to make it public in
order to use it from my service.

102
00:04:45.029 --> 00:04:49.076
So in this case it's a limitation
of the language proper,

103
00:04:49.076 --> 00:04:53.620
not my design that this type is Public,
but I have to use it.

104
00:04:53.620 --> 00:04:58.180
It's clearly meant to be an implementation
detail for my dog adoption service.

105
00:04:58.180 --> 00:05:02.129
Let's restart this test and
see if I've broken anything.

106
00:05:02.129 --> 00:05:02.740
Nope.

107
00:05:02.740 --> 00:05:03.836
So far so good.

108
00:05:03.836 --> 00:05:06.011
Now let's go back to the vet and

109
00:05:06.011 --> 00:05:11.460
we're going to inject this root type
validation into this module, right?

110
00:05:11.460 --> 00:05:13.220
Add that to the constructor.

111
00:05:13.220 --> 00:05:13.998
Here you go.

112
00:05:13.998 --> 00:05:15.120
I'm going to restart the test again.

113
00:05:15.120 --> 00:05:16.885
So remember, this is a detail.

114
00:05:16.885 --> 00:05:20.325
It's a nested package in another
adjacent root package and

115
00:05:20.325 --> 00:05:22.680
I'm injecting it into another module.

116
00:05:22.680 --> 00:05:24.405
I'm injecting it into
another root package.

117
00:05:24.405 --> 00:05:27.000
Well, that broke the test, didn't it?

118
00:05:27.000 --> 00:05:28.030
It's saying, hey,

119
00:05:28.030 --> 00:05:32.160
you've inadvertently leaked implementation
details about one module to another.

120
00:05:32.160 --> 00:05:36.871
And so if you go down here, it says
module vet depends on a non exposed

121
00:05:36.871 --> 00:05:40.440
type called validation
within module adoptions.

122
00:05:41.440 --> 00:05:43.212
So basically, even though that's public.

123
00:05:43.212 --> 00:05:44.710
It's not actually meant for

124
00:05:44.710 --> 00:05:49.019
everybody in the code base to consume the
nested type validation under the package

125
00:05:49.019 --> 00:05:52.156
Validation was clearly meant
to be a concern of adoptions.

126
00:05:52.156 --> 00:05:54.164
Not the other package called vet.

127
00:05:54.164 --> 00:05:58.466
So if I have a root type in adoptions and
it's adoptions foo and

128
00:05:58.466 --> 00:06:00.880
I inject it into vet, that works.

129
00:06:00.880 --> 00:06:03.336
We saw that earlier.
I injected Dr into the dog adoption

130
00:06:03.336 --> 00:06:05.413
service across two root packages.

131
00:06:05.413 --> 00:06:07.110
But this nested package is.

132
00:06:07.110 --> 00:06:08.630
It's meant to be an implementation detail.

133
00:06:08.630 --> 00:06:10.630
So the tests bark at me.

134
00:06:10.630 --> 00:06:14.470
They say, hey,
you're off the rails here, right?

135
00:06:14.470 --> 00:06:15.670
This is what we want.

136
00:06:15.670 --> 00:06:20.863
And speaking of which, this reminds me of
my least favorite anti pattern in like for

137
00:06:20.863 --> 00:06:26.150
the ages, basically, which is the thing
you get when you do Ruby on Rails, right?

138
00:06:26.150 --> 00:06:33.920
So imagine you have app.models.customer,
okay?

139
00:06:33.920 --> 00:06:35.960
And then in order for
me to use that, I have to create a.

140
00:06:35.960 --> 00:06:36.533
What did I create?

141
00:06:36.533 --> 00:06:38.022
What is it?
Repositories, right.

142
00:06:38.022 --> 00:06:40.320
And that's customer repository.

143
00:06:41.440 --> 00:06:44.160
And then I have to do app services.

144
00:06:45.200 --> 00:06:46.687
Customer service, right?

145
00:06:46.687 --> 00:06:49.655
And then in order to that I
have to do controllers and

146
00:06:49.655 --> 00:06:52.080
then that becomes customercontroller.

147
00:06:53.520 --> 00:06:55.360
In order for this to work,
this has to be public.

148
00:06:55.360 --> 00:06:56.320
That has to be public.

149
00:06:56.320 --> 00:06:57.080
That has to be public.

150
00:06:57.080 --> 00:06:58.023
And maybe that does you.

151
00:06:58.023 --> 00:07:00.146
You probably will just for consistency.

152
00:07:00.146 --> 00:07:02.860
This is a terrible,
terrible way to arrange your code.

153
00:07:02.860 --> 00:07:07.260
It's based on the role of the thing
in the technical architecture, right?

154
00:07:07.260 --> 00:07:10.401
This is a model and
this is a repository and that's a service.

155
00:07:10.401 --> 00:07:13.274
It has nothing to do with the feature
that you're implementing.

156
00:07:13.274 --> 00:07:18.685
A much more natural way to organize
your code is to say app customers and

157
00:07:18.685 --> 00:07:23.655
then have your customer type
customer controller etc, right?

158
00:07:23.655 --> 00:07:27.338
If you do it this way,
nothing needs to be public.

159
00:07:27.338 --> 00:07:29.623
You can be very deliberate
about what is public.

160
00:07:29.623 --> 00:07:33.385
You can keep the concerns that
are related to each other together and

161
00:07:33.385 --> 00:07:35.302
you can test this slice by itself.

162
00:07:35.302 --> 00:07:37.504
You can test just the functionality
related to customers.

163
00:07:37.504 --> 00:07:40.728
And you know where the component
boundary is, because it's the events or

164
00:07:40.728 --> 00:07:42.550
the public types that you've exported.

