WEBVTT

1
00:00:00.400 --> 00:00:02.948
&gt;&gt; Josh Long: The other thing
is that in Integration world,

2
00:00:02.948 --> 00:00:05.120
I might want to reuse this flow.

3
00:00:05.120 --> 00:00:08.360
This flow is pretty silly,
but it does do a thing.

4
00:00:08.360 --> 00:00:11.680
And I might want to make that available
via multiple channels, right?

5
00:00:11.680 --> 00:00:14.640
So the way you do that is you create
what's called a message channel.

6
00:00:14.640 --> 00:00:18.800
A message channel, let's call this
Inbound is a logical concept.

7
00:00:18.800 --> 00:00:24.080
It's the pipe through which messages flow,
right, .direct.

8
00:00:24.080 --> 00:00:28.029
And I'm going to say that all requests
going into this flow must originate

9
00:00:28.029 --> 00:00:29.790
in that channel.

10
00:00:29.790 --> 00:00:32.030
So message channel inbound.

11
00:00:32.030 --> 00:00:36.190
And I'm going to move all this file
handling logic outside of that.

12
00:00:36.190 --> 00:00:38.510
So now I'm going to have
another integration flow.

13
00:00:39.550 --> 00:00:42.270
So this will be a file inbound flow.

14
00:00:42.270 --> 00:00:45.990
And the whole point of this flow is to
do the file stuff that we just saw and

15
00:00:45.990 --> 00:00:50.590
then once it's converted it to a string,
to send it into this second flow, right?

16
00:00:50.590 --> 00:00:51.255
So here we go.

17
00:00:51.255 --> 00:00:52.670
We're gonna take that back over here.

18
00:00:54.570 --> 00:00:55.530
Okay.
File.

19
00:00:55.530 --> 00:00:57.770
And then here's the directory.

20
00:00:59.530 --> 00:01:00.410
Put that there.

21
00:01:01.850 --> 00:01:02.570
Good.

22
00:01:02.570 --> 00:01:03.370
Directory.

23
00:01:07.770 --> 00:01:08.730
Good, okay?

24
00:01:10.490 --> 00:01:15.082
So now instead of looking at the inbound
channel adapter, we're going to look at

25
00:01:15.082 --> 00:01:19.335
a channel itself and we're going to
send the data after we've converted it

26
00:01:19.335 --> 00:01:24.220
into a string onward to this other flow
by sending it into the channel, okay?

27
00:01:24.220 --> 00:01:27.420
So file inbound adapter.

28
00:01:27.420 --> 00:01:33.260
And then we're going to send it off to
the channel, okay, .channel(inbound).

29
00:01:33.260 --> 00:01:35.260
And we can actually inject
the channel here as well.

30
00:01:36.620 --> 00:01:38.060
Message channel inbound.

31
00:01:38.060 --> 00:01:38.780
There you go.

32
00:01:41.020 --> 00:01:44.390
Okay, so this thing will
look at the file system and.

33
00:01:44.390 --> 00:01:47.022
And then whenever it gets some data,
it's gonna take the data,

34
00:01:47.022 --> 00:01:50.285
turn it into a string, and then take the
string, turn it into a JSON object, and

35
00:01:50.285 --> 00:01:52.270
then send it off into a channel,
another pipe.

36
00:01:52.270 --> 00:01:56.190
And that pipe we're gonna listen to over
here in this other flow downstream, right?

37
00:01:56.190 --> 00:01:59.336
And that pipe will take the purchase
order and we're gonna print it out and

38
00:01:59.336 --> 00:02:01.510
we're gonna split it and
aggregate it and so on.

39
00:02:01.510 --> 00:02:02.430
What does that mean for us?

40
00:02:02.430 --> 00:02:04.172
Well, it means I can also send,

41
00:02:04.172 --> 00:02:07.990
like let's imagine I also
created a controller, right.

42
00:02:07.990 --> 00:02:14.069
Response body class purchase
order controller, right?

43
00:02:14.069 --> 00:02:16.149
I'm going to post some data.

44
00:02:16.149 --> 00:02:21.349
Right.
Post or I can say void.

45
00:02:21.349 --> 00:02:22.869
There you go, purchase order.

46
00:02:22.869 --> 00:02:29.829
And the payload is gonna be
request body multipart file.

47
00:02:29.829 --> 00:02:30.629
Okay.

48
00:02:30.629 --> 00:02:33.269
If I want to do file uploads,
this is how you do it.

49
00:02:33.269 --> 00:02:35.823
So now I'm going to inject the channel,

50
00:02:35.823 --> 00:02:38.990
which is the thing I use
to start the flow, right?

51
00:02:38.990 --> 00:02:41.537
I put messages in this channel here.

52
00:02:41.537 --> 00:02:45.468
So once I've got the file,
so I can do file.get bytes,

53
00:02:45.468 --> 00:02:51.070
get input stream, I guess, get bytes,
that's probably fine, right?

54
00:02:51.070 --> 00:02:53.150
So var content.

55
00:02:53.150 --> 00:02:55.622
Let's just make sure this works.

56
00:02:55.622 --> 00:02:59.310
New string, okay?

57
00:02:59.310 --> 00:03:04.219
And I'm gonna say this.inbound.send

58
00:03:04.219 --> 00:03:10.723
Message Builder with payload
content build, okay?

59
00:03:10.723 --> 00:03:13.784
So unless I miss my mark,
which is entirely possible,

60
00:03:13.784 --> 00:03:18.199
what you have here is a string that has
the content of the file, which is JSON.

61
00:03:18.199 --> 00:03:21.838
I'm sending that as a message,
wrapping it in this message envelope, and

62
00:03:21.838 --> 00:03:25.592
I'm putting that in the pipe and then
that pipe is being delivered to the first

63
00:03:25.592 --> 00:03:29.610
integration flow, which will, you know,
the second integration flow rather.

64
00:03:29.610 --> 00:03:31.700
So I have two genesis, two origins,

65
00:03:31.700 --> 00:03:34.690
two things that will produce the message,
right?

66
00:03:34.690 --> 00:03:37.987
Either the message comes from the embedded
adapter looking at the file system and

67
00:03:37.987 --> 00:03:39.199
it gets put in the channel, or

68
00:03:39.199 --> 00:03:42.770
it comes from this rest controller that we
just built and it gets put in the channel.

69
00:03:42.770 --> 00:03:46.459
Either way, all roads lead to
the purchase order integration flow,

70
00:03:46.459 --> 00:03:50.370
which is expecting as its input
an object of type purchase order.

71
00:03:50.370 --> 00:03:51.050
So far, so good.

72
00:03:51.050 --> 00:03:54.338
So actually I need to do
that conversion here.

73
00:03:54.338 --> 00:03:58.180
Maybe I should do that here, there.

74
00:03:58.180 --> 00:04:01.180
So the contract for this is now
that I expect a JSON string and

75
00:04:01.180 --> 00:04:03.340
I'm gonna convert it to a purchase order.

76
00:04:03.340 --> 00:04:06.945
Whether that JSON string comes from
a file system or from a file upload,

77
00:04:06.945 --> 00:04:08.700
either way the result is the same.

78
00:04:08.700 --> 00:04:10.300
Okay, so let's try that.

79
00:04:12.940 --> 00:04:19.379
And did I do something smart enough
to read data from the file to post?

80
00:04:22.499 --> 00:04:23.859
Yes, I did.

81
00:04:23.859 --> 00:04:25.379
Okay, so here we go.

82
00:04:25.379 --> 00:04:26.019
We're going to do this.

83
00:04:26.019 --> 00:04:30.028
We're going to do HTTP form post,

84
00:04:30.028 --> 00:04:35.299
8080 forward slash, what did I call it?

85
00:04:35.299 --> 00:04:36.899
Post.
Yeah, and then.

86
00:04:38.198 --> 00:04:40.419
Boy, we're going to call it,
it's called file.

87
00:04:40.419 --> 00:04:47.400
So file at Tilde Desktop.

88
00:04:47.400 --> 00:04:49.240
Purchase orders.

89
00:04:51.480 --> 00:04:53.400
Purchase orders.

90
00:04:53.400 --> 00:04:58.760
I just need 1001.json, 1001.json.

91
00:04:58.760 --> 00:05:01.440
And that should do it.

92
00:05:01.440 --> 00:05:03.797
So that got sent into here.

93
00:05:03.797 --> 00:05:11.790
So if I clear this, the whole flow
happened, so every fall, that.

94
00:05:11.790 --> 00:05:14.350
So we got a channel.

95
00:05:14.350 --> 00:05:18.350
I've used this channel to create a little
bit of indirection between the two.

96
00:05:18.350 --> 00:05:21.390
The origin of the message and
the processing of the message.

97
00:05:21.390 --> 00:05:24.110
There's two sources of the message.

98
00:05:24.110 --> 00:05:27.950
As long as I have the channel, I can send
any message I want into the channel.

99
00:05:27.950 --> 00:05:30.910
And so I have a controller, just a REST
controller like we looked at yesterday.

100
00:05:30.910 --> 00:05:34.590
Could have been GraphQL, could have
been GRPC, could have been whatever.

101
00:05:34.590 --> 00:05:37.770
And I'm doing a post.

102
00:05:37.770 --> 00:05:39.870
I'm using some spring
negation to create a message.

103
00:05:39.870 --> 00:05:41.390
I put the message into the channel.

104
00:05:41.390 --> 00:05:42.990
Great.
It goes off somewhere.

105
00:05:42.990 --> 00:05:47.037
Or alternatively, I drop a new file in
this folder and this folder looks at

106
00:05:47.037 --> 00:05:51.630
the new file and it turns it into
a string and it puts it in this channel.

107
00:05:51.630 --> 00:05:55.726
Either way, messages go into the channel
and they end up here in the integration

108
00:05:55.726 --> 00:05:59.350
flow, which has injected the inbound
channel and is reading from it.

109
00:05:59.350 --> 00:06:02.450
So as soon as a message enters that
channel, it comes out the other side and

110
00:06:02.450 --> 00:06:04.360
this flow kicks into action.

111
00:06:04.360 --> 00:06:08.320
Yeah, so that's just basic integration,
kind of 101.

112
00:06:08.320 --> 00:06:11.320
And from this I've been
using file inbound adapters.

113
00:06:11.320 --> 00:06:14.040
But this could be Kafka,
this could be Pulsar.

114
00:06:14.040 --> 00:06:14.760
It's the same.

115
00:06:14.760 --> 00:06:15.840
It'll be almost the same, right?

116
00:06:15.840 --> 00:06:20.200
If you're using RabbitMQ,
you do amqp.inboundadapter instead, right?

117
00:06:20.200 --> 00:06:22.120
It's a convention, basically.

118
00:06:22.120 --> 00:06:24.200
Okay, that's it.

119
00:06:24.200 --> 00:06:28.520
I know it's a lot, but
any questions on this stuff?

120
00:06:28.520 --> 00:06:32.980
&gt;&gt; Speaker 2: What happens if there's
failures at certain points in the flow?

121
00:06:32.980 --> 00:06:34.917
&gt;&gt; Josh Long: Yes, so we have, by default,

122
00:06:34.917 --> 00:06:39.100
there's a spring integration
creates an error channel, right?

123
00:06:39.100 --> 00:06:40.140
And you can listen for that.

124
00:06:40.140 --> 00:06:43.060
You can actually write
an integration flow like this.

125
00:06:43.060 --> 00:06:44.740
Integration flow.

126
00:06:44.740 --> 00:06:47.300
Error integration flow.

127
00:06:47.300 --> 00:06:49.260
And you can qualify.

128
00:06:49.260 --> 00:06:54.180
I think it's literally just called error
channel, message channel, error channel.

129
00:06:54.180 --> 00:06:56.878
And you can respond to it from that,
basically.

130
00:06:56.878 --> 00:06:58.370
Actually you don't even need to do this.

131
00:06:58.370 --> 00:06:58.882
Looks like.

132
00:06:58.882 --> 00:07:02.370
Yeah, you can just use the string name of
the bean if you don't have it on hand.

133
00:07:02.370 --> 00:07:03.090
So that will work.

134
00:07:03.090 --> 00:07:07.690
But if you don't want to do the string
name, this would work as well, right?

135
00:07:07.690 --> 00:07:08.970
And then you can process that.

136
00:07:08.970 --> 00:07:11.010
You can redeliver,
you can do whatever you want.

137
00:07:11.010 --> 00:07:11.890
That's a great question.

138
00:07:13.090 --> 00:07:13.890
There are also.

139
00:07:13.890 --> 00:07:15.144
These channels,

140
00:07:15.144 --> 00:07:20.170
they're the connective tissue of
your enterprise integration flow.

141
00:07:20.170 --> 00:07:24.230
So you can actually have those
channels backed by a database.

142
00:07:24.230 --> 00:07:26.754
You can actually have every message
that enters a channel be written to

143
00:07:26.754 --> 00:07:27.990
a SQL table, for example.

144
00:07:27.990 --> 00:07:29.790
You can also add filters
to those channels.

145
00:07:29.790 --> 00:07:34.662
So, for example, if you're doing security,
as we'll look at later, right, you might

146
00:07:34.662 --> 00:07:38.910
wanna like validate that the person who
sent the request has the right to do so.

147
00:07:38.910 --> 00:07:42.753
So you can pack a JWT token,
a JWT token in the body of the message and

148
00:07:42.753 --> 00:07:46.048
then unpack that in a filter
in the channel and go, okay,

149
00:07:46.048 --> 00:07:49.710
let me call the OAUTH issuer to
make sure this is valid, right?

150
00:07:49.710 --> 00:07:50.870
And if it doesn't, it's not valid.

151
00:07:50.870 --> 00:07:52.580
I can refuse to process the request.

152
00:07:52.580 --> 00:07:53.368
Another question?

153
00:07:53.368 --> 00:07:56.180
&gt;&gt; Speaker 3: Do you have any tips for
how to test these channels?

154
00:07:56.180 --> 00:07:57.420
&gt;&gt; Josh Long: Yeah, they're just beans.

155
00:07:57.420 --> 00:08:01.974
So you can just, you can do, you can
inject them in any test code, but they're

156
00:08:01.974 --> 00:08:07.540
also, if you downcast them, like there's a
bunch of different downcast able versions.

157
00:08:07.540 --> 00:08:13.060
So message channel here, right.

158
00:08:13.060 --> 00:08:15.940
You can do,
you can get the subscribable ones.

159
00:08:15.940 --> 00:08:19.888
And that if you do that, you can actually
programmatically call, subscribe and

160
00:08:19.888 --> 00:08:21.746
affix a message handler after that and

161
00:08:21.746 --> 00:08:24.550
then assert whatever you want
to assert in that handler.

162
00:08:26.630 --> 00:08:29.990
The other thing is there's a great
library called Awaitility.

163
00:08:29.990 --> 00:08:34.271
It's not part of Spring, it's just
a really great third party library,

164
00:08:34.271 --> 00:08:35.110
awaitility.

165
00:08:36.630 --> 00:08:40.230
And it's just a set of tools for
testing asynchronous stuff.

166
00:08:40.230 --> 00:08:42.590
I want to wait five seconds and
then check something.

167
00:08:42.590 --> 00:08:45.600
This gives you very nice clean
dislike to do that kind of stuff.

168
00:08:47.040 --> 00:08:50.013
And by the way, you mentioned another
thing, you didn't exactly ask about this,

169
00:08:50.013 --> 00:08:53.760
but it does remind me your question about
error handling and Spring integration.

170
00:08:53.760 --> 00:08:56.409
By default, the dispatch from one
component to another in the same

171
00:08:56.409 --> 00:08:58.480
integration flow is synchronous.

172
00:08:58.480 --> 00:09:02.560
You can put an executor in there and
have them be all asynchronous, right?

173
00:09:02.560 --> 00:09:04.960
And it's very expected
that you would do that.

174
00:09:04.960 --> 00:09:09.258
And by definition, when you talk to Kafka
or whatever, it's out of your hands.

175
00:09:09.258 --> 00:09:11.000
It's no longer synchronous anyway, right?

176
00:09:11.000 --> 00:09:15.059
So it's fine if the code like the handoff
between these different steps is all

177
00:09:15.059 --> 00:09:16.040
synchronous.

178
00:09:16.040 --> 00:09:19.400
It's all happening at the same time, which
means that they're all in the same thread.

179
00:09:19.400 --> 00:09:24.057
So if you have transactions,
if you in your controller over here

180
00:09:24.057 --> 00:09:29.235
started a database transaction and
then you needed that all to happen,

181
00:09:29.235 --> 00:09:34.257
that flow would actually get
dispatched in the same thread, right?

182
00:09:34.257 --> 00:09:36.898
And maybe that's what you want,
maybe that's convenient,

183
00:09:36.898 --> 00:09:38.130
maybe it's not, you know.

184
00:09:40.530 --> 00:09:41.570
Any other questions?

185
00:09:43.490 --> 00:09:45.570
Do you see potential here?

186
00:09:45.570 --> 00:09:47.490
Okay, good, some of you at least,
that's good.

187
00:09:47.490 --> 00:09:48.930
Not everybody's doing messaging.

188
00:09:48.930 --> 00:09:50.290
I would argue that you should be.

189
00:09:50.290 --> 00:09:54.198
I would argue that REST is actually a
really bad way to build decoupled systems

190
00:09:54.198 --> 00:09:55.250
at scale, right?

191
00:09:55.250 --> 00:09:59.170
The web is the existence proof of
the contrary, obviously, right?

192
00:09:59.170 --> 00:10:03.160
But systems, everybody that's ever
built a system at scale moves away from

193
00:10:03.160 --> 00:10:06.290
synchronous blocking RPC style
interactions by default.

194
00:10:06.290 --> 00:10:07.090
They have to.

195
00:10:07.090 --> 00:10:11.650
This is why Google created GRPC
this is why LinkedIn created Kafka.

196
00:10:11.650 --> 00:10:15.010
This is why Amazon has so
many other things besides this, you know.

