[00:00:00]
>> Josh Long: Okay, so that's pretty straightforward if you want to call another REST API and you want to make sure you're dividing the work across a bunch of clients, right. This is a pattern that Netflix uses a lot because again, services come and go. You want to have control over how you do load balancing.

[00:00:14]
This is, again, in this case, it's kind of. I'm just proxying the data though, aren't I? I'm going to 8081 hello and I'm calling a downstream service and I'm calling hello. The idea is that normally you'd be doing something interesting with it, but if all you want to do is proxy it, well, we have an even better story for you there.

[00:00:34]
There's something called Spring Cloud Gateway. Spring Cloud Gateway is a microproxy. It's like nginx, think nginx or Apache with the mod rewrite thing or something like that, right. It's a micro proxy and it's super fast. So we're going to use Spring Cloud Gateway here in the client. And do you remember I showed you, I think briefly, but let's just rehash.

[00:00:59]
You've seen me use controller. This style of my controller, I can create like this. I can say string bar. I can do that kind of thing all day long. That's a controller. It's a component. People who've come from the other communities, Maybe in the JavaScript world or the Sinatra in the Ruby world.

[00:01:20]
Or Express JS in the JavaScript world, or Flask in the Python world or whatever, they all have this. There's a different component model which is more of like predicate lambda, predicate lambda, predicate lambda, right. So you can do that as well in spring, right. And so the way you do that is you do router functions.

[00:01:38]
Router functions, okay. Okay, Add that .build. I think I've done this with you all today or recently, but let's just be sure. Okay, so there's my router function style. Okay, and I'm registering one predicate. You can register as many as you want for verbs. For all the different verbs, obviously.

[00:02:07]
Get rid of that. Good. So if I go to. Actually, I don't know what would happen if there's duplicate predicates. But let's say hello one. You go here to hello one. Hello, it's still starting. There you go. So that's hello one. That's the second endpoint that I created with the functional style.

[00:02:30]
So in this case, all I'm doing is I'm using this functional style to produce a Response. But, but Spring Cloud Gateway is a micro proxy and it allows you to compose to proxy other endpoints, right. So here we go. I'm gonna do that. And you can do like adobe.com, right, you can proxy that instead of.

[00:02:52]
This is a static import that will create a filter that is a server response, basically a handler function that produces a service response. Well, what if I want to do a load balanced proxied request? Okay, so let me. There's a particular filter that always escapes me because I'm.

[00:03:08]
My brain is not good. So here we go. Okay, here we go. So the way that one works is I'm going to go to hello and I'm going to just do HTTP like that dot filter, load balanced service. Okay, so really if you read it like that, it kind of makes more sense.

[00:03:29]
Go over here. Hello one. What's the error now? No instances available for Omar's local domain. What's the issue with that? You know what it is? Let's just try. I'm going to cheat a little bit here. What I'll do is I'm going to say, going to get rid of the path.

[00:03:55]
Okay, so what we got to do is get rid of the path here and then go back to the service and get rid of the path there. So it's just root for both. I think it's probably this bit right here. I don't think I need this. So open up the client.

[00:04:18]
There we go. There we go. That's what it was. I had two things trying to do load balancing. The gateway wants to do the load balancing. So I got rid of the rest client that fixed it. So now I'm going to localhost 8081. It in turn is proxying the request to 8080 behind the scenes.

[00:04:33]
Well, it's proxying it to the service, which is discovering from the load balancer from Eureka. I had to remove the path, remember I had to remove this like my. What if I wanted to get like everything to API forward slash? Well, I need to strip away the prefix then.

[00:04:54]
And the way you do that is by using a before filter function. Rewrite path, API just becomes forward slash. So now everything before API will get stripped away. So now let's try this again. So these are filters. You can act on the request before and after. So now if I go to forward slash, this is the client on 8081 API and it's going to rewrite the path, strip away API, send the request downstream without API in the path.

[00:05:29]
So now if I Go back to my service. Stop this over here. That's the client. Keep that going. Stop this over here. Yeah, stop that, stop that, stop that. Now if I go back over here and restore the path. Hello, now that's running. That's not running. Just run that now.

[00:05:56]
Now we go back to the client and I've restarted it, I think. Let me just make sure. Okay, so you go to API hello still works. It's stripping out API for us and it's sending that to the backend service. So that's some of the stuff that you can do with Spring Cloud and I didn't want to get too far into the details here.

[00:06:22]
One of the really nice patterns that you can enable, which I hope we'll look at very soon. What time is it? Yeah, we'll look at very soon, is, is using this gateway as the first port of call for all requests that go into your system. And this is the natural place to do oauth to secure your system, to restrict access to the downstream CDN JavaScript and to restrict access to the back end APIs.

[00:06:45]
And if your REACT app or Angular app or whatever is served via this gateway and your APIs are served via a different path in the same host and port in the same gateway, then guess what? It goes away, cors. Cors issues just disappear, right? And if your JWT token is being handled by the AUTH server and by the gateway itself, then dealing with JWT tokens in your JavaScript goes away.

[00:07:10]
Life becomes much easier by sticking a nice nimble gateway in front of your system. So we'll talk about that when we go to security. This stuff is being used by everybody. Spring Cloud is. It is the highest of accolades that we built Spring Cloud on some of the open source Netflix stuff and then Netflix rebuilt their stuff on top of us, right.

[00:07:31]
So their systems use Spring Cloud as a result and they use Spring boot and everything, right. They are a regular speaker at various Spring 1 conferences and the like. This is a very good stack for building stuff at scale and we've just seen some of the pieces here.

[00:07:45]
Spring Cloud has all sorts of other stuff, but obviously this is just a sampling of some of my favorite things. Centralized configuration, service registration and discovery, client side load balancing, the like. And then of course the Spring Cloud gateway and the client side load balancing with the rest client.

