WEBVTT

1
00:00:00.240 --> 00:00:00.805
&gt;&gt; Josh Long: This is important.

2
00:00:00.805 --> 00:00:02.640
Let's make sure we're all on
the same page on this, okay?

3
00:00:03.840 --> 00:00:07.984
I went to Start Touch Spring IO,
I chose here,

4
00:00:07.984 --> 00:00:12.768
I chose a bunch of different
infrastructure pieces,

5
00:00:12.768 --> 00:00:16.400
databases, Redis MongoDB.

6
00:00:16.400 --> 00:00:19.694
You can inspect the project that gets
created for you on Start Spring IO by

7
00:00:19.694 --> 00:00:22.934
going to the Explore button and
you can see the files that get created and

8
00:00:22.934 --> 00:00:26.180
you can even see what Docker
compose file was created for you.

9
00:00:26.180 --> 00:00:30.605
So if you want an easy way to bootstrap
your MongoDB Redis Neo 4J, Postgres,

10
00:00:30.605 --> 00:00:35.238
whatever, anything that spring supports,
which is everything, basically,

11
00:00:35.238 --> 00:00:38.820
you can often find an easy config file for
you there.

12
00:00:38.820 --> 00:00:40.340
Okay, so that's part one.

13
00:00:40.340 --> 00:00:42.780
What does that do at runtime
when you create a new project?

14
00:00:42.780 --> 00:00:45.724
Well, when I chose Docker Compose
on Start Spring IO,

15
00:00:45.724 --> 00:00:49.700
it added this dependency spring boot
Docker Compose that has the effect.

16
00:00:49.700 --> 00:00:53.570
Here's a brand new public static void
main, never touched, never changed.

17
00:00:53.570 --> 00:01:01.570
I run this and you can see it's taking its
sweet time to run the Docker image for me.

18
00:01:03.010 --> 00:01:07.170
So the project that we just looked at,
there's two distinct steps.

19
00:01:07.170 --> 00:01:12.290
One is you run Docker Compose up and
then two, you run the program.

20
00:01:12.290 --> 00:01:16.318
By default, though, if you choose
Docker Compose and Start Spring IO,

21
00:01:16.318 --> 00:01:18.310
Spring will do both things for you.

22
00:01:18.310 --> 00:01:21.910
It'll start up Docker for you, and
then it'll start up the Java code, right?

23
00:01:24.230 --> 00:01:28.390
It'll automatically detect the presence
of compose.YAML in the root product, yes?

24
00:01:28.390 --> 00:01:29.930
&gt;&gt; Student: So just out of curiosity,

25
00:01:29.930 --> 00:01:34.070
is that going to be problematic when
I go to deploy my enterprise app?

26
00:01:34.070 --> 00:01:36.490
&gt;&gt; Josh Long: No, because it only
happens in development mode.

27
00:01:36.490 --> 00:01:39.896
Yeah, so when you package it up
as a jar or as a native image,

28
00:01:39.896 --> 00:01:42.911
it doesn't include the code
that does that, okay?

29
00:01:42.911 --> 00:01:43.910
So that's a very good point.

30
00:01:43.910 --> 00:01:45.190
But what is the benefit of this?

31
00:01:45.190 --> 00:01:48.790
The benefit is that now if somebody took
this particular project, not the one that

32
00:01:48.790 --> 00:01:52.040
we looked at in the intro, I wanted to
keep those two things teased apart.

33
00:01:52.040 --> 00:01:55.381
If somebody wanted to take this
code in a brand new git repository,

34
00:01:55.381 --> 00:01:58.520
Git clone run,
just do maven Spring boot run.

35
00:01:58.520 --> 00:02:02.659
As long as they've got Docker and
a JRE, right, this will work.

36
00:02:02.659 --> 00:02:06.970
It'll have Postgres and
it'll have the code.

37
00:02:06.970 --> 00:02:08.520
It comes with it, right?

38
00:02:08.520 --> 00:02:11.763
So what it's doing is it's
actually shelling out.

39
00:02:11.763 --> 00:02:13.379
You can see it says Docker CLI, right?

40
00:02:13.379 --> 00:02:17.004
Behind the scenes, it's actually
shelling out and running whatever's

41
00:02:17.004 --> 00:02:20.463
in the Docker Compose file here,
which, in this case, is Postgres.

42
00:02:20.463 --> 00:02:21.521
It's running that for me.

43
00:02:21.521 --> 00:02:22.270
And you can see that here.

44
00:02:22.270 --> 00:02:27.390
If I go to the Command line,
Docker PS, there's Postgres.

45
00:02:27.390 --> 00:02:28.870
Now I'm going to stop the Java process.

46
00:02:28.870 --> 00:02:31.390
Okay, goodbye.

47
00:02:31.390 --> 00:02:35.710
Now, uh-oh, Docker's gone, right?

48
00:02:35.710 --> 00:02:38.190
It also shut down the container, which is.

49
00:02:39.900 --> 00:02:41.780
It's fine,
I understand why it's doing that.

50
00:02:41.780 --> 00:02:43.740
But also postgres doesn't really.

51
00:02:43.740 --> 00:02:44.540
It's not one of those.

52
00:02:44.540 --> 00:02:45.460
It's not serverless, right.

53
00:02:45.460 --> 00:02:48.060
You're supposed to keep that thing
running for more than a second.

54
00:02:48.060 --> 00:02:51.798
So if ever you're making changes and
you have to affect the restart,

55
00:02:51.798 --> 00:02:54.580
it'd be a shame to restart
that every single time.

56
00:02:54.580 --> 00:02:56.380
So Spring Boot gives you
some control over this.

57
00:02:56.380 --> 00:03:02.460
Okay, you get Spring Docker Compose
Lifecycle management, Start only.

58
00:03:03.580 --> 00:03:06.150
Okay, Start Only.

59
00:03:06.150 --> 00:03:10.947
So I start this now, and I do docker ps.

60
00:03:10.947 --> 00:03:13.032
It's fine.

61
00:03:13.032 --> 00:03:14.582
Stop it.

62
00:03:14.582 --> 00:03:17.227
By the way,
that one started up Docker, right?

63
00:03:17.227 --> 00:03:21.029
This is a web Server and
the Postgres support.

64
00:03:21.029 --> 00:03:23.270
So it took 1.7 seconds
with Docker Compose.

65
00:03:23.270 --> 00:03:26.510
If I go over here,
Postgres is still running.

66
00:03:26.510 --> 00:03:28.321
It didn't stop it this time, right?

67
00:03:28.321 --> 00:03:31.490
Now I go back and
I restart the program, okay?

68
00:03:33.090 --> 00:03:36.450
And that took 0.9 seconds.

69
00:03:36.450 --> 00:03:39.951
So 0.8 seconds saved by not
having to manually shell out and

70
00:03:39.951 --> 00:03:42.050
do Docker compose up on your behalf.

71
00:03:42.050 --> 00:03:43.010
And it's connected.

72
00:03:43.010 --> 00:03:47.870
Now that still is a lot slower than if you
didn't have this on the class path at all,

73
00:03:47.870 --> 00:03:48.370
right?

74
00:03:48.370 --> 00:03:52.368
Like if I just comment that
out as I've just done,

75
00:03:52.368 --> 00:03:56.091
now it's not in the class path at all,
right?

76
00:03:56.091 --> 00:03:59.630
So that's 0.5 seconds.

77
00:03:59.630 --> 00:04:02.886
It's almost half a second
just to start up,

78
00:04:02.886 --> 00:04:08.430
just to detect the presence of and
then not do anything about Compose YAML.

79
00:04:09.630 --> 00:04:10.710
So it's up to you.

80
00:04:10.710 --> 00:04:14.990
But I like to keep this in there,
especially if you have a large team.

81
00:04:14.990 --> 00:04:16.350
This can help people standardize.

82
00:04:16.350 --> 00:04:17.950
They can know exactly how to start it and
run it.

83
00:04:17.950 --> 00:04:20.715
If it's just you, maybe just comment
this out and run it yourself,

84
00:04:20.715 --> 00:04:21.550
docker compose up.

85
00:04:21.550 --> 00:04:25.006
Okay, now what else does Spring Boot
do with the presence of this on

86
00:04:25.006 --> 00:04:25.880
the classpath?

87
00:04:25.880 --> 00:04:29.137
Well, in addition to starting or
stopping the Docker image for you,

88
00:04:29.137 --> 00:04:32.920
every single time you restart the image,
it also automatically connects you.

89
00:04:32.920 --> 00:04:36.725
So let's say I am using Spring Boot.

90
00:04:36.725 --> 00:04:37.800
What did I do on the build?

91
00:04:37.800 --> 00:04:40.360
Did I choose a JDBC library?

92
00:04:40.360 --> 00:04:41.680
I don't have anything for JDBC.

93
00:04:41.680 --> 00:04:47.236
Let me just add here, and then this, and
I'll choose Spring Boot Starter JDBC.

94
00:04:47.236 --> 00:04:48.205
Cmd + Shift + I,

95
00:04:48.205 --> 00:04:51.980
this is going to be low-level
database connectivity stuff, okay?

96
00:04:51.980 --> 00:04:54.259
And the reason I care about that is
because I want to demonstrate that I

97
00:04:54.259 --> 00:04:55.180
am connected.

98
00:04:55.180 --> 00:04:59.380
So let me create an application runner.

99
00:04:59.380 --> 00:05:02.900
This is going to be a thing that runs
when the application starts up, okay?

100
00:05:02.900 --> 00:05:03.973
Jdbc, Sorry,

101
00:05:03.973 --> 00:05:09.100
Application runners are just ways to
run when the application starts up.

102
00:05:09.100 --> 00:05:10.620
It's a listener, a callback event.

103
00:05:10.620 --> 00:05:13.660
It's like onload for
your enterprise application.

104
00:05:13.660 --> 00:05:16.120
So there's the database, db.SQL.

105
00:05:16.120 --> 00:05:19.200
Select all from customer, right?

106
00:05:19.200 --> 00:05:22.480
Or even better yet, select one, okay?

107
00:05:22.480 --> 00:05:29.553
Query, integer, class,
dot, single, whatever.

108
00:05:29.553 --> 00:05:31.600
And I can get the int value, right?

109
00:05:31.600 --> 00:05:36.560
So var count system out there, okay?

110
00:05:36.560 --> 00:05:38.571
So when the application starts up,

111
00:05:38.571 --> 00:05:43.390
it's going to inject this nice fluid DSL
that I can use to talk to a SQL database.

112
00:05:43.390 --> 00:05:46.464
I'm going to issue a query against
my SQL database, get a response,

113
00:05:46.464 --> 00:05:48.750
turn it into an int value,
and then print that out.

114
00:05:50.990 --> 00:05:51.750
So that's worked.

115
00:05:51.750 --> 00:05:53.710
And that only works because
I'm connected to a database.

116
00:05:53.710 --> 00:05:57.630
So the question is how,
how is this thing connected to a database?

117
00:05:57.630 --> 00:05:59.550
I didn't specify the credential, right?

118
00:05:59.550 --> 00:06:03.129
You can see I've got compose YAML,
the Docker image has a username and

119
00:06:03.129 --> 00:06:04.430
password and all that.

120
00:06:04.430 --> 00:06:07.670
But Spring Boot,
how does Spring Boot know about that?

121
00:06:07.670 --> 00:06:09.430
How does Spring Boot
establish a connection?

122
00:06:09.430 --> 00:06:14.390
Especially since these are not
the default container credentials, right?

123
00:06:14.390 --> 00:06:17.366
And the way that it does that is it's
actually interacting with the Docker

124
00:06:17.366 --> 00:06:18.870
daemon behind the scenes.

125
00:06:18.870 --> 00:06:22.078
So if you have this
Docker Compose support here,

126
00:06:22.078 --> 00:06:26.390
then you don't need to specify
the normal credentials, right?

127
00:06:26.390 --> 00:06:32.763
Spring data source, secret username,
my user and URL jdbc,postgres,

128
00:06:32.763 --> 00:06:39.760
localhost this is what you would have
to do in your production environment.

129
00:06:39.760 --> 00:06:42.240
Obviously you would never put
that in production, right?

130
00:06:42.240 --> 00:06:43.120
That's your password.

131
00:06:43.120 --> 00:06:46.157
You'd put that in an environment
variable or HashiCorp Vault or

132
00:06:46.157 --> 00:06:48.360
something more sensible
than in source code.

133
00:06:48.360 --> 00:06:51.280
But my point is these three
things are specified here.

134
00:06:51.280 --> 00:06:55.014
And if I didn't have Spring Boot's
automatic starting up of Docker Compose

135
00:06:55.014 --> 00:06:57.125
and integration with Docker Compose, I.

136
00:06:57.125 --> 00:06:59.180
I'd have to specify those credentials.

137
00:07:00.300 --> 00:07:03.270
That's fine, but
just know that that's the cost.

138
00:07:03.270 --> 00:07:07.937
So as soon as I comment this out,
suddenly I need to both start up

139
00:07:07.937 --> 00:07:12.179
Docker Compose by myself and
specify this stuff, okay?

140
00:07:12.179 --> 00:07:15.463
So that git clone run life is easier when
you have the Docker Compose support.

141
00:07:15.463 --> 00:07:18.180
Now, Docker Compose is great.

142
00:07:18.180 --> 00:07:22.393
If you're like me some of the times,
I'll start up my main method and

143
00:07:22.393 --> 00:07:24.220
then I'll iterate, right?

144
00:07:24.220 --> 00:07:25.740
I'll make changes.

145
00:07:25.740 --> 00:07:29.572
I'll start my main method, write some
code, hit an endpoint, make sure it works.

146
00:07:29.572 --> 00:07:32.100
Some people, they're more sensible,
more logical.

147
00:07:32.100 --> 00:07:33.980
They write the tests first.

148
00:07:33.980 --> 00:07:36.375
In this case, they're not starting
up their production code and

149
00:07:36.375 --> 00:07:37.340
then iterating that way.

150
00:07:37.340 --> 00:07:41.980
They're starting up the test code and
cycling on that test driven development.

151
00:07:41.980 --> 00:07:45.100
For those people, we have test containers.

152
00:07:45.100 --> 00:07:50.470
So the Docker compose support gets run
if you run the main method in your ide.

153
00:07:50.470 --> 00:07:53.750
But there's also the test code
in the source test Java folder.

154
00:07:53.750 --> 00:07:58.618
You can see I've got a public
static void main entry point

155
00:07:58.618 --> 00:08:03.190
in the source test folder,
okay, source test main.

156
00:08:04.230 --> 00:08:08.715
So it's public static void main as opposed
to the actual public static void main in

157
00:08:08.715 --> 00:08:11.910
the root of my production code and
source main Java.

158
00:08:11.910 --> 00:08:16.304
Here's a test main method and
it says do everything that you do

159
00:08:16.304 --> 00:08:20.530
in the production code,
which is demo application main and

160
00:08:20.530 --> 00:08:25.687
extend what's possible by running
the test containers config that Test

161
00:08:25.687 --> 00:08:31.290
containers config in turn is using this
nice Java API called Test Containers.

162
00:08:31.290 --> 00:08:33.050
How many of you have
heard of test containers?

163
00:08:33.050 --> 00:08:37.231
It's a Java library that you can
use to talk to the Docker daemon.

164
00:08:37.231 --> 00:08:41.210
And there's some programmatic,
fluent DSLs that you can use to spin

165
00:08:41.210 --> 00:08:45.340
up a Postgres container, or Redis,
or Neo4j, or whatever, right?

166
00:08:45.340 --> 00:08:50.780
They have strongly typed objects that
you can use in Java to stand these up.

167
00:08:50.780 --> 00:08:55.137
So here I'm saying run the postgres
container when you create this object in

168
00:08:55.137 --> 00:08:58.405
Spring, it in turn results in
postgres being created and

169
00:08:58.405 --> 00:09:00.940
run on your local docker
behind the scenes.

170
00:09:02.380 --> 00:09:06.453
This is nice because now I can
run this test Java code and

171
00:09:06.453 --> 00:09:10.230
it'll also run the test container support.

172
00:09:10.230 --> 00:09:12.910
So do you need both Docker Compose and
test containers?

173
00:09:12.910 --> 00:09:13.910
Usually not.

174
00:09:13.910 --> 00:09:15.270
It's up to you, right?

175
00:09:15.270 --> 00:09:18.070
I added both so
you could see what would happen, right?

176
00:09:18.070 --> 00:09:21.457
You'll have one during your main code,
you'll have the other one during your

177
00:09:21.457 --> 00:09:24.449
test code, and you can run
the Docker Compose from test code as well.

178
00:09:24.449 --> 00:09:26.390
So really,
it's granularity of what you want.

179
00:09:26.390 --> 00:09:29.070
I could have a test that
only needs Postgres.

180
00:09:29.070 --> 00:09:31.350
I only create the Postgres container.

181
00:09:31.350 --> 00:09:33.070
I have another test that
only needs MongoDB.

182
00:09:33.070 --> 00:09:34.740
I only create that MongoDB.

183
00:09:34.740 --> 00:09:38.670
Whereas with Docker Compose,
you got to put them all in there, right?

184
00:09:38.670 --> 00:09:42.150
It's not usually convenient to have a
dozen different Docker Compose files with

185
00:09:42.150 --> 00:09:46.780
different permutations of your different
collaborating infrastructure services.

186
00:09:46.780 --> 00:09:50.361
Okay, all that to say git clone run,
that's what we want here, okay?

187
00:09:50.361 --> 00:09:52.060
Docker compose, test containers.

188
00:09:52.060 --> 00:09:55.420
You'll see I rely on Docker Compose
a lot because I want to.

189
00:09:55.420 --> 00:09:57.460
It's pretty straightforward
if you don't know what to do.

190
00:09:57.460 --> 00:09:59.580
Docker compose up, run the program.

191
00:09:59.580 --> 00:10:01.900
You can see I'm running
inside of DevTools here.

192
00:10:02.940 --> 00:10:03.900
And why is that valuable?

193
00:10:03.900 --> 00:10:08.425
Well, because let's say I go ahead and

194
00:10:08.425 --> 00:10:14.332
create AddController, @ResponseBody, okay?

195
00:10:14.332 --> 00:10:22.804
@GetMapping, String helloWorld, okay?

196
00:10:22.804 --> 00:10:26.455
And I'm gonna just, actually,
I've got the code running already.

197
00:10:26.455 --> 00:10:28.185
Localhost, what did I call it?

198
00:10:28.185 --> 00:10:29.977
Just forward slash?

199
00:10:29.977 --> 00:10:33.030
Okay, did I add DevTools retroactively?

200
00:10:33.030 --> 00:10:34.870
What am I running exactly?

201
00:10:34.870 --> 00:10:39.353
This is this.

202
00:10:39.353 --> 00:10:43.079
Sorry, let me, cd demo.

203
00:10:52.143 --> 00:10:56.145
&gt;&gt; Josh Long: Okay, pom.xml.

204
00:11:05.504 --> 00:11:09.440
&gt;&gt; Josh Long: Okay, go here,
localhost/helloworld.

205
00:11:09.440 --> 00:11:13.680
Now go back to the command line or
to the code, rather add this.

206
00:11:13.680 --> 00:11:14.880
Go back over here.

207
00:11:14.880 --> 00:11:15.520
Refresh.

208
00:11:15.520 --> 00:11:16.560
What is going on?

209
00:11:16.560 --> 00:11:17.720
Did I not add devtools?

210
00:11:17.720 --> 00:11:18.840
I did not add DevTools.

211
00:11:18.840 --> 00:11:21.260
Okay, you have that in the intro.

212
00:11:21.260 --> 00:11:22.860
I forgot to add it to this.

213
00:11:22.860 --> 00:11:24.460
So we go back over here.

214
00:11:24.460 --> 00:11:27.420
Got the web support dev tools.

215
00:11:27.420 --> 00:11:28.188
This is your friend.

216
00:11:28.188 --> 00:11:30.850
You wanna add DevTools to every
project whenever you can, right?

217
00:11:30.850 --> 00:11:32.180
So let's see.

218
00:11:32.180 --> 00:11:37.599
Postgres, docker, compose,

219
00:11:37.599 --> 00:11:42.460
enter, UAO, demo zip.

220
00:11:42.460 --> 00:11:44.380
I got too many demo zips.

221
00:11:47.270 --> 00:11:48.310
There we go.

222
00:11:48.310 --> 00:11:53.430
So DevTools now got the application.

223
00:11:53.430 --> 00:11:54.870
Create this simple controller.

224
00:12:00.150 --> 00:12:08.710
Okay, start that up.

225
00:12:12.480 --> 00:12:15.293
Okay, it's up and running.

226
00:12:15.293 --> 00:12:19.493
Localhost, hello.

227
00:12:19.493 --> 00:12:20.935
&gt;&gt; Student: Hi, you did-
&gt;&gt; Josh Long: Thank you.

228
00:12:20.935 --> 00:12:22.867
&gt;&gt; Student: Just 'Hi'.

229
00:12:22.867 --> 00:12:24.827
&gt;&gt; Josh Long: There you go.
Okay, so there's that, but

230
00:12:24.827 --> 00:12:27.473
that's not quite effusive or
ebullient enough.

231
00:12:27.473 --> 00:12:30.080
So I'll add a few of those and
refresh, right?

232
00:12:30.080 --> 00:12:34.040
I go over here and
I change the return type to be a map.

233
00:12:34.040 --> 00:12:36.000
So I can get it like a JSON structure.

234
00:12:36.000 --> 00:12:40.230
Go over here, map.of[message].

235
00:12:40.230 --> 00:12:45.270
Put that in here and then refresh.

236
00:12:45.270 --> 00:12:49.190
So what happens is the JVM
itself is very slow.

237
00:12:49.190 --> 00:12:50.790
Spring Boot, super fast.

238
00:12:50.790 --> 00:12:55.043
So if you want to get your application
cycled very quickly, keep the JVM warm and

239
00:12:55.043 --> 00:12:58.470
then throw away spring and
just recreate it anew each time.

240
00:12:58.470 --> 00:12:59.750
That's what it's doing here.

241
00:12:59.750 --> 00:13:04.420
So you can see changes in your source code
almost instantaneously for template files.

242
00:13:04.420 --> 00:13:08.762
If you're doing server-side HTML templates
and all that stuff, it's not cached, so

243
00:13:08.762 --> 00:13:10.710
it changes instantaneously, right?

244
00:13:10.710 --> 00:13:12.600
So you can move very, very quickly.

