WEBVTT

1
00:00:00.160 --> 00:00:00.928
&gt;&gt; Josh Long: We covered a few things.

2
00:00:00.928 --> 00:00:04.267
Now that you have got like some
meat you can chew in a little bit,

3
00:00:04.267 --> 00:00:07.200
I was hoping we could
pull something together.

4
00:00:07.200 --> 00:00:10.266
Just a trivial app talking to a database.

5
00:00:10.266 --> 00:00:14.023
And since you've got Docker and
since you've got Start Spring IO and

6
00:00:14.023 --> 00:00:16.936
it'll give you a Docker Compose file,
you know, and

7
00:00:16.936 --> 00:00:19.614
you've learned a little
bit about data access.

8
00:00:19.614 --> 00:00:24.238
I'm talking about SQL and postgres, but
I'm sure you can figure out something and

9
00:00:24.238 --> 00:00:27.160
then just build a simple
hello world HTTP endpoint.

10
00:00:27.160 --> 00:00:28.284
It doesn't matter which one I showed you.

11
00:00:28.284 --> 00:00:31.615
It could be HTTP, it could be rest,
it could be hypermedia, it could be GRPC,

12
00:00:31.615 --> 00:00:33.040
it could be GraphQL, whatever.

13
00:00:34.240 --> 00:00:34.920
Can we do that?

14
00:00:34.920 --> 00:00:37.391
Just a simple read a record
from a database and

15
00:00:37.391 --> 00:00:39.935
then return it from
an endpoint kind of thing.

16
00:00:39.935 --> 00:00:41.960
Just end to end, right.

17
00:00:41.960 --> 00:00:43.280
We're going to do a very simple thing,

18
00:00:43.280 --> 00:00:45.680
kind of pulling together some of
the things we learned yesterday.

19
00:00:45.680 --> 00:00:52.880
We're going to choose GraalVM, choose Web,
choose Postgres, choose Docker Compose.

20
00:00:52.880 --> 00:00:54.850
You also want to add JDBC.

21
00:00:54.850 --> 00:00:55.810
How do I not have that?

22
00:00:55.810 --> 00:00:56.930
Actually?
There you go.

23
00:00:56.930 --> 00:00:58.930
Add Spring Data jdbc.

24
00:00:58.930 --> 00:01:02.770
That's the important bit if you want
to do live reloads, which you should.

25
00:01:02.770 --> 00:01:05.635
Dev tools are great, but
since we're just doing a one Endpoint.

26
00:01:05.635 --> 00:01:09.810
Yep, this will pay dividends in anything
longer than a 5 minute project.

27
00:01:13.010 --> 00:01:14.610
Great point.

28
00:01:14.610 --> 00:01:19.250
DevTools, Docker Compose, these
are all quality of life improvements.

29
00:01:19.250 --> 00:01:22.930
The core of the application is just
the web, postgres and the jdbc.

30
00:01:22.930 --> 00:01:26.580
Everything else is to make
the code worthy of production and

31
00:01:26.580 --> 00:01:28.770
make the experience worthy of you.

32
00:01:28.770 --> 00:01:31.050
Hit Enter, open this up.

33
00:01:31.050 --> 00:01:32.210
This is just.
I'm going to.

34
00:01:32.210 --> 00:01:33.810
Here's the long form, right?

35
00:01:33.810 --> 00:01:40.468
Unzip CD E2E idea Palm XML.

36
00:01:40.468 --> 00:01:41.290
Okay, if that does.

37
00:01:41.290 --> 00:01:43.462
If you don't have idea,
you should, but if you don't,

38
00:01:43.462 --> 00:01:45.649
you can just go to File Open and
then point to the Palm xml.

39
00:01:45.649 --> 00:01:48.891
That'll be the same result
if you're in Intellij or

40
00:01:48.891 --> 00:01:50.889
in Eclipse as far as I remember.

41
00:01:50.889 --> 00:01:52.500
And we're going to talk to a database.

42
00:01:52.500 --> 00:01:55.540
The database is provided for
us by Docker Compose here.

43
00:01:55.540 --> 00:01:59.006
So make sure you don't have Postgres
running in another Docker image somewhere.

44
00:01:59.006 --> 00:02:02.729
So I'll do that and then just.

45
00:02:02.729 --> 00:02:04.220
I'm going to have a little domain.

46
00:02:04.220 --> 00:02:08.540
I expect my domain will be
around a customer of some sort.

47
00:02:08.540 --> 00:02:11.420
I'm going to signal that this
is the primary key by using id.

48
00:02:12.710 --> 00:02:20.421
I'll create a repository
to make Data access,

49
00:02:20.421 --> 00:02:25.057
trivial customer integer.

50
00:02:25.057 --> 00:02:26.102
Let's see.

51
00:02:26.102 --> 00:02:27.048
Record.

52
00:02:27.048 --> 00:02:30.570
There you go and
then finally a controller.

53
00:02:30.570 --> 00:02:34.811
So response body class
customer controller.

54
00:02:34.811 --> 00:02:40.275
Get mapping customers.

55
00:02:40.275 --> 00:02:46.083
Customer, customer and
then one of my favorite features here,

56
00:02:46.083 --> 00:02:48.885
customerepositoryfindall.

57
00:02:48.885 --> 00:02:52.933
Okay, so that's the code that'll work but
of course you need a database.

58
00:02:52.933 --> 00:02:55.060
So who's going to initialize the database?

59
00:02:55.060 --> 00:02:56.719
Well, you can ask spring boot to create.

60
00:02:56.719 --> 00:03:04.414
To initialize a schema on startup by
creating a file called schema SQL and

61
00:03:04.414 --> 00:03:08.955
create table if not exists customer, ID,

62
00:03:08.955 --> 00:03:12.251
serial primary key name text.

63
00:03:12.251 --> 00:03:14.450
There's that and
then you need some sample data, right?

64
00:03:14.450 --> 00:03:22.763
So data SQL insert into
customer name values.

65
00:03:22.763 --> 00:03:27.210
Josh Dushan.

66
00:03:28.730 --> 00:03:32.168
Okay, there's two.

67
00:03:32.168 --> 00:03:35.779
Now you want to tell spring boot to make
sure to run those SQL files because it's

68
00:03:35.779 --> 00:03:36.435
a postgres and

69
00:03:36.435 --> 00:03:40.190
you don't necessarily want it running
against your production database.

70
00:03:40.190 --> 00:03:47.710
And then start, that's going to run Docker
for you, which you may or may not want.

71
00:03:47.710 --> 00:03:48.648
It takes a long time.

72
00:03:48.648 --> 00:03:53.118
So local host 8080 customers.

73
00:03:53.118 --> 00:03:54.454
There we go.

74
00:03:54.454 --> 00:03:59.332
Okay, any question like,
I can do that again?

75
00:03:59.332 --> 00:04:00.440
Yes.

76
00:04:00.440 --> 00:04:03.398
&gt;&gt; Speaker 2: Would there be a reason
you'd want to enable virtual threads for

77
00:04:03.398 --> 00:04:04.280
this project?

78
00:04:04.280 --> 00:04:08.296
&gt;&gt; Josh Long: Yes, I would enable them
by default, and that's extra points, but

79
00:04:08.296 --> 00:04:10.040
you get yes, please do that.

80
00:04:11.720 --> 00:04:12.840
Good idea.

81
00:04:12.840 --> 00:04:16.223
&gt;&gt; Speaker 3: One follow up to that
virtual threads question is why would you

82
00:04:16.223 --> 00:04:17.960
want to enable them?

83
00:04:17.960 --> 00:04:22.593
&gt;&gt; Josh Long: Because anytime you do IO,
in this case talking to a SQL database,

84
00:04:22.593 --> 00:04:27.477
when you go to your browser and
open up localhost 8084 customers,

85
00:04:27.477 --> 00:04:30.622
this method gets invoked
inside of a thread,

86
00:04:30.622 --> 00:04:34.370
of which there are precious
few in a given system.

87
00:04:34.370 --> 00:04:38.417
So you want to make sure that when you're
doing things that don't need to be

88
00:04:38.417 --> 00:04:42.207
executing on a thread, such as just
waiting for bytes to come back from

89
00:04:42.207 --> 00:04:45.730
a socket, that you do that work
while not sitting on a thread.

90
00:04:45.730 --> 00:04:49.590
So virtual threads will automatically
detect that you're talking to a SQL

91
00:04:49.590 --> 00:04:52.407
database or
to another network socket of any kind, and

92
00:04:52.407 --> 00:04:56.970
that therefore you're not doing anything
on the thread, you're just waiting.

93
00:04:56.970 --> 00:05:00.330
And it'll move that waiting
operation off to the side.

94
00:05:02.170 --> 00:05:05.388
And then as soon as that waiting
operation is finished, it'll signal, hey,

95
00:05:05.388 --> 00:05:06.330
I've got some bytes.

96
00:05:06.330 --> 00:05:08.090
It's time to continue execution.

97
00:05:08.090 --> 00:05:11.264
It'll reconstruct the stack and
allow you to complete.

98
00:05:11.264 --> 00:05:16.243
So basically, virtual threads make
the inefficient wait time that we spend

99
00:05:16.243 --> 00:05:18.888
talking to other network services not so

100
00:05:18.888 --> 00:05:23.579
problematic in terms of our ability
to scale and handle more requests.

101
00:05:23.579 --> 00:05:28.679
Because we need one thread per request,
and if those threads are busy,

102
00:05:28.679 --> 00:05:32.395
just waiting for bytes,
then that's a waste.

103
00:05:32.395 --> 00:05:32.931
Sorry.

104
00:05:32.931 --> 00:05:36.023
All the pop ups.

105
00:05:36.023 --> 00:05:38.864
Does anybody need to see this schema?

106
00:05:38.864 --> 00:05:42.606
There you go and then there's the data.

107
00:05:42.606 --> 00:05:48.520
&gt;&gt; Speaker 4: When you declared the id,
which extension does that come from?

108
00:05:48.520 --> 00:05:51.531
&gt;&gt; Josh Long: Spring Data jdbc.

109
00:05:51.531 --> 00:05:56.246
Actually, Spring Data JDBC is a module
in the Spring Data project, and

110
00:05:56.246 --> 00:06:00.032
the ID annotation is common
to all Spring Data projects.

111
00:06:00.032 --> 00:06:03.525
So you can use it for MongoDB, you can
use it for Neo4J, you can use it for

112
00:06:03.525 --> 00:06:06.961
Cassandra, you can use it for Redis,
you can use it for SQL databases,

113
00:06:06.961 --> 00:06:09.320
you can use it for
elasticsearch and Couchbase.

