WEBVTT

1
00:00:00.160 --> 00:00:01.400
&gt;&gt; Josh Long: Let's
talk about Java itself.

2
00:00:01.400 --> 00:00:02.363
Java is, you know,

3
00:00:02.363 --> 00:00:05.560
I'm going to be using Java throughout
the balance of this course.

4
00:00:05.560 --> 00:00:07.160
I'm not sure how many people
are familiar with Java.

5
00:00:07.160 --> 00:00:08.758
If you've come from another language,

6
00:00:08.758 --> 00:00:10.880
then you might have some
misconceptions about Java.

7
00:00:10.880 --> 00:00:16.279
Java is marked by being sort of the
stalwart language of the ecosystem, right.

8
00:00:16.279 --> 00:00:20.383
It's the third most popular language these
days after arguably JavaScript or Python.

9
00:00:20.383 --> 00:00:23.553
Who knows which one is which, but
one of those two in the first and

10
00:00:23.553 --> 00:00:26.563
the second slot, and
then Java is usually the number three.

11
00:00:26.563 --> 00:00:31.685
And one of the criticisms people have
levied against Java is that it's sort

12
00:00:31.685 --> 00:00:37.390
of this anachronistic syntax that doesn't
sort of keep up with modern languages.

13
00:00:37.390 --> 00:00:40.190
And I would concede to
a point that's true.

14
00:00:40.190 --> 00:00:43.594
It is not known for having this
incredibly expressive syntax, but

15
00:00:43.594 --> 00:00:46.830
it is much nicer than I think
a lot of people really appreciate.

16
00:00:46.830 --> 00:00:50.699
And in particular in the last 10 years,
since Java 20, since Java 14,

17
00:00:50.699 --> 00:00:53.630
which came out in 2014,
there's just been a number.

18
00:00:53.630 --> 00:00:55.232
So Java 8 that came out in 2014,

19
00:00:55.232 --> 00:00:58.294
there's just been a number of amazing
improvements to the language.

20
00:00:58.294 --> 00:01:01.952
And one of the biggest single releases
was, in my estimation, Java 21,

21
00:01:01.952 --> 00:01:04.229
which came out now a couple years ago,
right.

22
00:01:04.229 --> 00:01:06.606
And in there they supported
not just virtual threads, but

23
00:01:06.606 --> 00:01:08.750
also something called data
oriented programming.

24
00:01:08.750 --> 00:01:11.807
So I wanted to talk to you about
what data oriented programming is,

25
00:01:11.807 --> 00:01:15.483
because it's a different way to think
about writing code and writing systems.

26
00:01:15.483 --> 00:01:17.570
Okay, so let's create a new project here.

27
00:01:17.570 --> 00:01:19.250
I'm going to use just Java 24.

28
00:01:19.250 --> 00:01:20.450
That's all I'm doing.

29
00:01:20.450 --> 00:01:24.760
I could be using just Java 21 and
later, but

30
00:01:24.760 --> 00:01:31.694
I'm going to use Java 24, hit enter
CD downloads and then there we go.

31
00:01:31.694 --> 00:01:34.739
Uao, zip.

32
00:01:34.739 --> 00:01:38.932
So briefly, there's a number of features
that are introduced in Java 21 and

33
00:01:38.932 --> 00:01:41.930
later that change or
at least support the new paradigm.

34
00:01:41.930 --> 00:01:46.737
Java is an object oriented language,

35
00:01:46.737 --> 00:01:51.101
obviously it's functional ish.

36
00:01:51.101 --> 00:01:54.798
It's not a pure functional language,
obviously, but it's got at least as

37
00:01:54.798 --> 00:01:58.670
much claim to that as JavaScript or
Python do at this point, right.

38
00:01:58.670 --> 00:02:01.150
It can support some idioms there.

39
00:02:01.150 --> 00:02:03.830
It's not a pure functional
language though.

40
00:02:03.830 --> 00:02:05.473
There are side effects everywhere, right.

41
00:02:05.473 --> 00:02:07.808
But it's got some of that, but
it's not really what it's known for.

42
00:02:07.808 --> 00:02:10.185
What's interesting is there's
a third paradigm here and

43
00:02:10.185 --> 00:02:12.913
the Java language team are calling
it data oriented programming.

44
00:02:12.913 --> 00:02:16.278
And the idea is that Java has historically
thrived in the world of large object

45
00:02:16.278 --> 00:02:17.540
oriented systems, right.

46
00:02:17.540 --> 00:02:19.300
You remember in the 90s
when Java first came out?

47
00:02:19.300 --> 00:02:22.740
Remember this year marks 30
years since Java came out.

48
00:02:22.740 --> 00:02:24.820
Java 1.0, 30 years of Java.

49
00:02:24.820 --> 00:02:27.620
So when it first came out,
it was the bee's knees, right?

50
00:02:27.620 --> 00:02:30.156
People were on CNN talking about
this new language called Java.

51
00:02:30.156 --> 00:02:32.020
It was people.

52
00:02:32.020 --> 00:02:33.420
Unless you were there, as I was.

53
00:02:33.420 --> 00:02:34.791
I was young but I was there.

54
00:02:34.791 --> 00:02:36.689
You don't remember the hysteria
that surrounded this language.

55
00:02:36.689 --> 00:02:42.330
It was like the second coming it was
such a big deal and I don't know why.

56
00:02:42.330 --> 00:02:46.217
It was just back then the idea of a
portable language that can run in bytecode

57
00:02:46.217 --> 00:02:47.610
wasn't new.

58
00:02:47.610 --> 00:02:49.580
I think it was a lot of
a function of marketing.

59
00:02:49.580 --> 00:02:52.641
And one of the things
that seemed to help buoy

60
00:02:52.641 --> 00:02:57.130
the noise that was being made
around it was object orientation.

61
00:02:57.130 --> 00:02:57.850
Right at the time.

62
00:02:57.850 --> 00:03:00.967
Do you remember in the early 90s C
was starting to become very popular.

63
00:03:00.967 --> 00:03:05.160
You could buy new software and on the box
it would say now in object oriented

64
00:03:05.160 --> 00:03:07.980
programming, now supporting OOP, right?

65
00:03:07.980 --> 00:03:09.931
Like this is a thing.

66
00:03:09.931 --> 00:03:13.700
Like I remember WordPerfect, Coral,
WordPerfect or Novell were perfect.

67
00:03:13.700 --> 00:03:17.257
They actually had some discussion
around how they were moving to oop.

68
00:03:17.257 --> 00:03:19.093
It's like a huge thing.

69
00:03:19.093 --> 00:03:21.100
It was a big deal reusable objects,
who cares?

70
00:03:21.100 --> 00:03:21.642
Nobody cares.

71
00:03:21.642 --> 00:03:24.466
Now you could never like sell your
software and say, by the way,

72
00:03:24.466 --> 00:03:25.744
it's written using objects.

73
00:03:25.744 --> 00:03:27.289
But back then this is a big deal.

74
00:03:27.289 --> 00:03:33.106
And I think it's a useful paradigm when
you have a large structured code base.

75
00:03:33.106 --> 00:03:36.447
Certainly useful when you have large
structured code bases with deep

76
00:03:36.447 --> 00:03:38.070
hierarchies of abstract types.

77
00:03:38.070 --> 00:03:42.199
But increasingly, the way we build systems
today is in terms of messages that get

78
00:03:42.199 --> 00:03:45.053
sent around over the wire or
from one module to another,

79
00:03:45.053 --> 00:03:46.465
one component to another.

80
00:03:46.465 --> 00:03:50.230
And in that world, objects aren't always.

81
00:03:50.230 --> 00:03:53.150
The language hasn't really kept up,
it just needs to do better.

82
00:03:53.150 --> 00:03:56.630
So in Java 21 they added
four new features.

83
00:03:56.630 --> 00:04:00.997
Sealed types, pattern matching,

84
00:04:00.997 --> 00:04:04.990
records and smart switch.

85
00:04:04.990 --> 00:04:06.550
So let's take a look at a simple example.

86
00:04:06.550 --> 00:04:09.151
Let's suppose I worked in a highly
regulated industry like a financial

87
00:04:09.151 --> 00:04:10.550
services one or something like that.

88
00:04:10.550 --> 00:04:12.791
And I've got a type here called a loan.

89
00:04:12.791 --> 00:04:14.394
Now I want to build a implementation.

90
00:04:14.394 --> 00:04:18.024
So I have a secured loan and
it implements loan and I have a class,

91
00:04:18.024 --> 00:04:20.350
unsecured loan and implements loan.

92
00:04:20.350 --> 00:04:23.022
Well, obviously these
are two different things and

93
00:04:23.022 --> 00:04:25.519
maybe the unsecured loan
has some variability.

94
00:04:25.519 --> 00:04:28.640
Maybe I have a float for
the interest rate, right?

95
00:04:28.640 --> 00:04:31.240
Okay, but how can I make this
code a little Bit cleaner.

96
00:04:31.240 --> 00:04:35.280
Well, first of all, if this is the only
state, then maybe this doesn't.

97
00:04:35.280 --> 00:04:38.199
If the only state in this unsecured
loan is the variable that it passed into

98
00:04:38.199 --> 00:04:41.600
the constructor, then maybe I could
use something called a record, right?

99
00:04:41.600 --> 00:04:43.880
And records are tuples.

100
00:04:43.880 --> 00:04:45.154
Other languages call them tuples.

101
00:04:45.154 --> 00:04:48.241
But remember, naming is important, right?

102
00:04:48.241 --> 00:04:49.560
Java is a nominal language.

103
00:04:49.560 --> 00:04:50.480
Everything has a name.

104
00:04:51.520 --> 00:04:54.390
Even our functional
programming support is nominal.

105
00:04:54.390 --> 00:04:57.208
Functional programming, that is to say,

106
00:04:57.208 --> 00:05:01.995
they thought about adding fully
unstructured lambdas to the language.

107
00:05:01.995 --> 00:05:05.975
Like in Kotlin, for example,

108
00:05:05.975 --> 00:05:12.097
you can have val,
my func int to string equals,

109
00:05:12.097 --> 00:05:17.011
and then you do the my int to like that.

110
00:05:17.011 --> 00:05:19.664
They thought about doing something like
that, which you can do in other languages.

111
00:05:19.664 --> 00:05:23.710
They decided against it because
what is a int to string?

112
00:05:23.710 --> 00:05:24.870
Well, you and I both know what that is.

113
00:05:24.870 --> 00:05:25.767
It's a function.

114
00:05:25.767 --> 00:05:29.130
But if you're working in a language
that makes a big deal out of names,

115
00:05:29.130 --> 00:05:33.150
then this just looks like random noise
into string, doesn't tell you what it is.

116
00:05:33.150 --> 00:05:37.230
So they said, okay, well, everything
in Java has to have an assigned type.

117
00:05:37.230 --> 00:05:42.433
So you might have a ID converter,
which is actually

118
00:05:42.433 --> 00:05:47.031
an interface which
returns a method given a.

119
00:05:47.031 --> 00:05:51.407
Sorry, it returns a tostring or
whatever, convert, int, id,

120
00:05:51.407 --> 00:05:53.325
that kind of thing, right?

121
00:05:53.325 --> 00:05:57.830
And they decided, okay, if you have a
class or an interface called ID converter,

122
00:05:57.830 --> 00:06:00.071
then you could create a lambda, right?

123
00:06:00.071 --> 00:06:04.130
You could say ID converter,
ID converter equals that, right?

124
00:06:04.130 --> 00:06:05.989
You could do something like that.

125
00:06:05.989 --> 00:06:08.760
That's valid Java, but
you have to have a name.

126
00:06:08.760 --> 00:06:12.814
You have to be able to assign it
to a type that you can refer to.

127
00:06:12.814 --> 00:06:14.611
And the same is true for these records.

128
00:06:14.611 --> 00:06:17.760
Records are tuples but
in Java everything has a name.

129
00:06:17.760 --> 00:06:22.275
Okay, so this is a tuple, in that the only
state that you have, it's a carrier for

130
00:06:22.275 --> 00:06:23.480
typed data.

131
00:06:23.480 --> 00:06:25.320
But the thing has a name.

132
00:06:25.320 --> 00:06:28.990
You can't just do bracket, bracket,
int, comma, string, comma, date, comma,

133
00:06:28.990 --> 00:06:31.680
boolean, whatever, like you can in,
for example, Python.

134
00:06:31.680 --> 00:06:34.208
Okay, so here's a record.

135
00:06:34.208 --> 00:06:36.400
The records are final by default, right?

136
00:06:36.400 --> 00:06:39.999
And the only state that you can pass
in comes from these constructors,

137
00:06:39.999 --> 00:06:42.220
these component constructors, right?

138
00:06:42.220 --> 00:06:44.205
And these are called
component fields here.

139
00:06:44.205 --> 00:06:47.260
These things right here,
this is an interest rate.

140
00:06:47.260 --> 00:06:49.860
I could have a string,
I could have an int, whatever.

141
00:06:49.860 --> 00:06:53.082
I can do all these different things,
but they get passed in there.

142
00:06:53.082 --> 00:06:56.951
So now I've got two different loans but
the problem is I could come along.

143
00:06:56.951 --> 00:06:58.780
I don't want to have
the Sam Bankman fried problem.

144
00:06:58.780 --> 00:07:04.260
I don't want to have backdoor loan,
implements loan.

145
00:07:04.260 --> 00:07:07.360
And then I just sidestep
the validation method.

146
00:07:07.360 --> 00:07:10.483
I do a no op on the validation or
something like that.

147
00:07:10.483 --> 00:07:15.162
You can imagine this having a void
validate that nobody listens to,

148
00:07:15.162 --> 00:07:17.803
or you just no op, but you stub it out.

149
00:07:17.803 --> 00:07:21.036
So what you want to do is make sure that
you be very explicit about which things

150
00:07:21.036 --> 00:07:22.160
can implement that type.

151
00:07:22.160 --> 00:07:27.025
You do that with sealed hierarchies,
sealed loan permits, secured loan,

152
00:07:27.025 --> 00:07:28.800
and unsecured loan.

153
00:07:28.800 --> 00:07:32.840
Okay, now here this is barking at me.

154
00:07:32.840 --> 00:07:35.090
It's saying, hey, I can still extend this.

155
00:07:35.090 --> 00:07:38.882
Somebody could come along and
backdoor this by then creating another.

156
00:07:38.882 --> 00:07:43.555
Not secured loan, but
extending secured loan.

157
00:07:43.555 --> 00:07:45.690
So the language is saying,
you're cheating.

158
00:07:45.690 --> 00:07:46.610
You can't do this.

159
00:07:46.610 --> 00:07:50.330
You need to actually either
mark this as final or

160
00:07:50.330 --> 00:07:53.221
explicitly permit this third type.

161
00:07:53.221 --> 00:07:54.290
So final works.

162
00:07:54.290 --> 00:07:56.860
Or if it's a record,
it's implicitly final.

163
00:07:56.860 --> 00:08:00.020
So now I've got two different
types of my code base.

164
00:08:00.020 --> 00:08:01.840
I want to create a message to display.

165
00:08:01.840 --> 00:08:06.880
I want to create a message to display
to the user given a type of loan.

166
00:08:06.880 --> 00:08:07.600
So loan.

167
00:08:08.960 --> 00:08:09.640
How do I do this?

168
00:08:09.640 --> 00:08:11.840
Well, I want to create a message
I'll create in a string.

169
00:08:11.840 --> 00:08:12.716
I'm going to look at the loan.

170
00:08:12.716 --> 00:08:15.263
I'll say if loan instance of secured loan.

171
00:08:15.263 --> 00:08:19.726
And the old way would have been to do
something like this, you'd have to cast

172
00:08:19.726 --> 00:08:24.070
it, cast it down, and you'd say,
message equals good job, nice loan.

173
00:08:24.070 --> 00:08:29.904
Okay, or you'd say if loan
instance of an unsecured loan.

174
00:08:29.904 --> 00:08:31.733
Var ul, there you go.

175
00:08:31.733 --> 00:08:33.090
Okay, you need to pay more.

176
00:08:33.090 --> 00:08:35.165
There you go.
So that can kind of work, but

177
00:08:35.165 --> 00:08:37.493
this is a little tedious, first of all.

178
00:08:37.493 --> 00:08:41.744
Well, down here, like I could put this.

179
00:08:41.744 --> 00:08:45.249
I can dereference the field, right.

180
00:08:45.249 --> 00:08:46.370
Is a lot, right?

181
00:08:46.370 --> 00:08:48.250
There you go.
So I can get rid of all that.

182
00:08:48.250 --> 00:08:49.330
Okay, so now I've got.

183
00:08:49.330 --> 00:08:51.039
I'm dereferencing
the instance variable there.

184
00:08:51.039 --> 00:08:52.362
I don't actually need
the instance variable there.

185
00:08:52.362 --> 00:08:55.140
But if I, if I did, it's very tedious
to have to do what I just did.

186
00:08:55.140 --> 00:08:56.460
This is tedious too, though.

187
00:08:56.460 --> 00:08:58.820
So now I'm actually
matching the pattern of.

188
00:08:58.820 --> 00:09:00.340
Is this type an unsecured loan?

189
00:09:00.340 --> 00:09:04.540
If it is, then I want to extract from
that pattern an attribute, a value.

190
00:09:04.540 --> 00:09:10.210
So I can do that by using this new syntax
in Java 21 later to do a pattern match and

191
00:09:10.210 --> 00:09:11.490
then an extract.

192
00:09:11.490 --> 00:09:13.617
Pattern match, extract, right.

193
00:09:13.617 --> 00:09:19.346
So I'm taking a pattern, I'm doing a smart
cast downcast to the thing in the scope,

194
00:09:19.346 --> 00:09:20.970
but still is this good.

195
00:09:20.970 --> 00:09:21.852
It doesn't feel like it's good.

196
00:09:21.852 --> 00:09:25.290
And the reason it's not good is because
I've only got two cases, right?

197
00:09:25.290 --> 00:09:26.673
It can only ever be.

198
00:09:26.673 --> 00:09:29.747
We know that it's a secured loan and
an unsecured loan, but

199
00:09:29.747 --> 00:09:33.890
the compiler doesn't actually stop
me from not caring about it, right?

200
00:09:33.890 --> 00:09:36.569
That code will still pass,
it'll still compile, everything is fine.

201
00:09:36.569 --> 00:09:40.610
And yet I've now failed to handle
one of the two possible cases there.

202
00:09:40.610 --> 00:09:45.010
50% of my code coverage is missing and
the compiler has nothing to offer me here.

203
00:09:45.010 --> 00:09:47.450
So how can I write this code in such
a way that I get that validation?

204
00:09:47.450 --> 00:09:49.940
Well, I can use a smart switch.

205
00:09:49.940 --> 00:09:54.758
So smart I can say loan case,
secured loan, good job, nice loan, and

206
00:09:54.758 --> 00:09:56.072
then there you go.

207
00:09:56.072 --> 00:09:58.020
Actually, that wrote it for me.

208
00:09:58.020 --> 00:10:03.720
So what it's doing is I've got a switch,
I'm doing pattern matching there.

209
00:10:03.720 --> 00:10:05.260
I'm not going to use that variable,
so I need to do that.

210
00:10:05.260 --> 00:10:06.922
I'm extracting out the ul.

211
00:10:06.922 --> 00:10:10.700
But the pattern matching is actually
smarter than just the type of the thing.

212
00:10:10.700 --> 00:10:12.820
You can actually look at
the shape of the thing as well.

213
00:10:12.820 --> 00:10:17.734
So since I only care about the interest,
let me just extract out the interest,

214
00:10:17.734 --> 00:10:20.950
in which case I only
reference the interest there.

215
00:10:22.470 --> 00:10:26.915
I'm saying match this unsecured loan and
that it has a component called interest,

216
00:10:26.915 --> 00:10:29.518
and if so,
extract out within the scope of this,

217
00:10:29.518 --> 00:10:32.138
block the float variable
into its own variable.

218
00:10:32.138 --> 00:10:33.710
So I'm doing pattern matching and
extraction.

219
00:10:33.710 --> 00:10:34.499
The same thing.

220
00:10:34.499 --> 00:10:37.360
Of course what happens if I
comment out one of the cases?

221
00:10:37.360 --> 00:10:42.081
Well, the compiler is saying, hey, that
doesn't cover all possible input values.

222
00:10:42.081 --> 00:10:47.110
So I'm getting the compiler to make sure
I don't miss something obvious here.

223
00:10:47.110 --> 00:10:50.710
Of course,
this could just be returned directly.

224
00:10:50.710 --> 00:10:52.185
There you go.

225
00:10:52.185 --> 00:10:55.616
So there's my pattern matching.

226
00:10:55.616 --> 00:10:59.568
I'm using smart switch expressions,
I'm using records and sealed types.

227
00:10:59.568 --> 00:11:02.992
These things play together to make it very
easy to deal with data as first class

228
00:11:02.992 --> 00:11:04.214
citizens in the language.

229
00:11:04.214 --> 00:11:08.582
Because remember, so much of what we do
is dealing with JSON or GRPC or Kafka or

230
00:11:08.582 --> 00:11:11.019
RabbitMQ or GraphQL or whatever, right?

231
00:11:11.019 --> 00:11:12.897
There's messages coming in from the wire.

232
00:11:12.897 --> 00:11:16.507
Our systems are delineated in
terms of the API boundaries and

233
00:11:16.507 --> 00:11:18.215
the data that they process.

234
00:11:18.215 --> 00:11:20.045
The language has to be better
at this kind of stuff and

235
00:11:20.045 --> 00:11:22.300
I think it's gotten a lot better
because of these new features.

