WEBVTT

1
00:00:00.240 --> 00:00:04.057
&gt;&gt; Josh Long: Now I think it's time to
build up a simple sort of HTTP controller,

2
00:00:04.057 --> 00:00:06.240
our own service based on that.

3
00:00:06.240 --> 00:00:08.640
And we've already seen some of this so
far.

4
00:00:10.560 --> 00:00:16.079
We've looked at Spring MVC so far,
but let's just rehash that point here.

5
00:00:16.079 --> 00:00:18.160
Class users controller.

6
00:00:18.160 --> 00:00:23.906
I'm going to inject the declarative user
client, add that to the constructor,

7
00:00:23.906 --> 00:00:28.520
and I'll just create
an endpoint here called users.

8
00:00:28.520 --> 00:00:32.480
And this feels like a bit of a waste, but
okay, I'm going to just call the client.

9
00:00:32.480 --> 00:00:34.920
It in turn is going to
call the other service.

10
00:00:34.920 --> 00:00:36.840
And by the way,
since I am calling another service,

11
00:00:36.840 --> 00:00:38.760
what's the first thing I should do?

12
00:00:38.760 --> 00:00:40.390
Virtual threads enabled is true.

13
00:00:40.390 --> 00:00:43.240
Always remember, do that first, okay?

14
00:00:45.160 --> 00:00:49.400
We don't need to rerun that
code that prints things out.

15
00:00:51.810 --> 00:00:58.850
Okay, so localhost 8080 users.

16
00:00:58.850 --> 00:01:00.050
There we go.

17
00:01:00.050 --> 00:01:04.517
This is my service, which in turn is
calling the other actual service and

18
00:01:04.517 --> 00:01:06.210
getting all the data back.

19
00:01:06.210 --> 00:01:09.343
It's a bit of a silly example, but
you can see how easy it is to do that.

20
00:01:09.343 --> 00:01:11.330
So I'm making an HTTP get request.

21
00:01:11.330 --> 00:01:12.980
You know how you can tell?

22
00:01:12.980 --> 00:01:17.550
It's because it says GetRequest or
GetMapping, okay?

23
00:01:17.550 --> 00:01:21.721
Now obviously if you're doing an HTTP
post, you can do post mapping.

24
00:01:21.721 --> 00:01:22.500
You get the idea, right?

25
00:01:22.500 --> 00:01:25.020
And there's all sorts of sort of,
create user.

26
00:01:26.700 --> 00:01:30.020
I can have a request parameter here,
right?

27
00:01:30.020 --> 00:01:31.980
Request parameter, string name.

28
00:01:31.980 --> 00:01:34.962
I can do a path variable,
you know, int id, and

29
00:01:34.962 --> 00:01:38.780
then that means I have to have
it in a template there as well.

30
00:01:38.780 --> 00:01:45.523
Okay, you can get access to
the underlying raw HTTP servlet request,

31
00:01:45.523 --> 00:01:51.710
servelet request if you want,
just inject that as a parameter.

32
00:01:51.710 --> 00:01:52.737
So these parameters,

33
00:01:52.737 --> 00:01:56.310
you can decorate your controller methods
with as many parameters as you want.

34
00:01:56.310 --> 00:01:58.300
For all these different kinds of verbs,

35
00:01:58.300 --> 00:02:01.350
their lowest level annotation
is actually request mapping.

36
00:02:03.270 --> 00:02:07.110
Request mapping in turn
has a field called method.

37
00:02:07.110 --> 00:02:12.262
So, this is semantically

38
00:02:12.262 --> 00:02:16.480
equivalent to this.

39
00:02:17.760 --> 00:02:18.720
These two are the same, okay?

40
00:02:20.880 --> 00:02:24.921
One is just a stereotype,
a meta annotation for the other.

41
00:02:24.921 --> 00:02:26.753
Okay, well, what else do we got?

42
00:02:26.753 --> 00:02:29.280
So that's basic Spring MVC.

43
00:02:29.280 --> 00:02:33.680
It says, I told you, we have this
meta annotation mechanism, right?

44
00:02:33.680 --> 00:02:36.320
You can compose annotations and
create your own annotations.

45
00:02:36.320 --> 00:02:39.695
Because the goal is for
the code to be idiomatic.

46
00:02:39.695 --> 00:02:44.642
To talk about an ubiquitous
language in domain modeling, right?

47
00:02:44.642 --> 00:02:45.800
And so we want that here.

48
00:02:45.800 --> 00:02:48.720
Spring is meant to be a framework for
building frameworks.

49
00:02:48.720 --> 00:02:51.800
It's meant to be a tool upon which
to address different verticals.

50
00:02:51.800 --> 00:02:54.640
And a big part of that is you,
it's your code, it's your domain, right?

51
00:02:54.640 --> 00:02:57.278
It's very natural then that you'd
create your own annotations and

52
00:02:57.278 --> 00:03:00.600
your own component model that would
be natural in expressing your domain.

53
00:03:00.600 --> 00:03:06.326
So you might wonder, if that's so easy,
then why, if I'm building a REST API,

54
00:03:06.326 --> 00:03:11.901
did I not use or why do we not have
a annotation called RestController, right?

55
00:03:11.901 --> 00:03:17.180
And we do, actually, so
RestController is that.

56
00:03:17.180 --> 00:03:21.489
And then that in turn is a meta annotation
of controller and response body, and

57
00:03:21.489 --> 00:03:24.860
that controller is a meta
annotation of component.

58
00:03:24.860 --> 00:03:27.660
So there's a train derivatives cascade.

59
00:03:27.660 --> 00:03:30.528
But I don't like calling things
restcontroller unless they're

60
00:03:30.528 --> 00:03:31.790
actually restful.

61
00:03:31.790 --> 00:03:36.326
And this gets into a little bit of
pedantic stuff here, which is to say that

62
00:03:36.326 --> 00:03:40.882
what I've been doing this entire time
is not REST, this is HTTP, right?

63
00:03:40.882 --> 00:03:47.549
It's not actually REST unless it's served
in the Champagne region of France.

64
00:03:47.549 --> 00:03:50.670
You need to adhere to hypermedia, right?

65
00:03:50.670 --> 00:03:51.886
The idea, when Dr.

66
00:03:51.886 --> 00:03:56.827
Roy Fielding talked about REST in his
doctoral dissertation back in 2001, or

67
00:03:56.827 --> 00:04:01.850
whatever it was, he talked about
the idea of hypermedia links, right?

68
00:04:01.850 --> 00:04:06.314
When you look at an HTML document and
you get a link, the link has a rel, and

69
00:04:06.314 --> 00:04:09.554
it has the rel tells you what
the nature of the link is,

70
00:04:09.554 --> 00:04:12.012
and then you have the actual URL itself.

71
00:04:12.012 --> 00:04:16.250
The rel is the important part, it tells
you why you would want to click on this.

72
00:04:16.250 --> 00:04:17.610
We don't use that very often.

73
00:04:17.610 --> 00:04:21.968
But for example, the link tag, when you
use that for CSS, it says rel equals

74
00:04:21.968 --> 00:04:25.921
whatever text, CSS or whatever
that tells the browser agent, hey,

75
00:04:25.921 --> 00:04:30.720
this resource at this URL is what you need
to style the document you're looking at.

76
00:04:30.720 --> 00:04:31.520
So it's an offshoot.

77
00:04:31.520 --> 00:04:35.880
It's saying to the browser, hey, you can
go to this URL to get styling information.

78
00:04:35.880 --> 00:04:36.411
You should.

79
00:04:36.411 --> 00:04:40.440
And the way a browser knows it's styling
information is by looking at the rel.

80
00:04:40.440 --> 00:04:42.760
Well, imagine if all of our APIs
were built that way, right?

81
00:04:43.800 --> 00:04:48.035
Imagine if all of our APIs had menus
of things that are germane to the thing

82
00:04:48.035 --> 00:04:49.160
at hand.

83
00:04:49.160 --> 00:04:51.808
So there's a great book called
REST in practice by Dr.

84
00:04:51.808 --> 00:04:55.623
Jim Weber that was written,
I don't know, 2011, something like that.

85
00:04:55.623 --> 00:04:58.447
And it was basically, it took the idea of,

86
00:04:58.447 --> 00:05:02.940
have you ever read
Enterprise Integration Patterns?

87
00:05:02.940 --> 00:05:06.155
Enterprise Integration Patterns it's
a page turner, It's a real page turn.

88
00:05:06.155 --> 00:05:09.724
It's 1,000 pages, I keep it under my
pillow, read it to the kid, it's amazing.

89
00:05:09.724 --> 00:05:13.340
And it defines a lingua franca of
enterprise application integration.

90
00:05:13.340 --> 00:05:17.843
And it was written in 2004 and
in that book, Gregor Hope,

91
00:05:17.843 --> 00:05:22.660
who's the Bobby Wolf and
Gregor Hobe Gregor talks about.

92
00:05:22.660 --> 00:05:25.576
He's got a great blog, he wrote in
response to that book called Starbucks

93
00:05:25.576 --> 00:05:27.940
does not use two phase commit, right?

94
00:05:27.940 --> 00:05:30.662
The idea there is when
you go to a Starbucks,

95
00:05:30.662 --> 00:05:35.519
this is not a distributed transaction,
it's a series of events that happen in

96
00:05:35.519 --> 00:05:39.660
succession based on inputs,
staged event driven architecture.

97
00:05:39.660 --> 00:05:45.402
So you go to the person at the till,
they write your order on a cup.

98
00:05:45.402 --> 00:05:48.080
It used to be they wrote it on a cup,
but now it's all these fancy labels.

99
00:05:48.080 --> 00:05:53.445
They write it on the cup, the cup gets
moved onto the bar where the person

100
00:05:53.445 --> 00:05:58.520
who makes drinks is, or
it gets moved to the blending station.

101
00:05:58.520 --> 00:06:00.555
And then those drinks with the cup and
the order and

102
00:06:00.555 --> 00:06:03.094
the name gets moved to the final
place where you collect them.

103
00:06:03.094 --> 00:06:04.280
There's multiple steps, right?

104
00:06:04.280 --> 00:06:06.507
The same order might go
into multiple places and

105
00:06:06.507 --> 00:06:10.400
at each step there's a possibility for
failure and having to go back.

106
00:06:10.400 --> 00:06:13.040
It's not one big transaction,
it's multiple steps in sequence.

107
00:06:13.040 --> 00:06:17.837
And it's obvious because of the contents
of the message where the message

108
00:06:17.837 --> 00:06:19.080
should be routed.

109
00:06:19.080 --> 00:06:21.680
The message in this case being the cup,
the order, okay?

110
00:06:21.680 --> 00:06:23.240
The same is true for hypermedia.

111
00:06:23.240 --> 00:06:24.400
The same is true for REST.

112
00:06:24.400 --> 00:06:25.714
When you go to an API,

113
00:06:25.714 --> 00:06:30.800
you should be able to go to forward slash
and get a menu of possible options.

114
00:06:30.800 --> 00:06:32.400
What can you do with this API?

115
00:06:34.160 --> 00:06:36.869
It makes no sense that I can
call a refund endpoint if

116
00:06:36.869 --> 00:06:38.970
I haven't bought anything, right?

117
00:06:38.970 --> 00:06:41.569
That makes the code for refunding orders

118
00:06:41.569 --> 00:06:46.410
a lot more complex because I have
to defend against an invalid state.

119
00:06:46.410 --> 00:06:49.939
But if I wrote my code in such a way that
I followed these menus and the menus were

120
00:06:49.939 --> 00:06:53.033
dynamic and they only showed me
possible navigable sort of states,

121
00:06:53.033 --> 00:06:55.770
then I would never get in that
situation in the first place.

122
00:06:55.770 --> 00:06:57.290
It makes my code a lot simpler, right?

123
00:06:58.490 --> 00:07:01.930
So this hypermedia idea was
talked about 20 plus years ago.

124
00:07:01.930 --> 00:07:03.450
Same thing for your client code, right?

125
00:07:04.530 --> 00:07:07.141
If I don't have an option
to refund an order,

126
00:07:07.141 --> 00:07:10.450
then I in my React app should
disable the button, right?

127
00:07:11.570 --> 00:07:12.690
I don't have to have constant.

128
00:07:12.690 --> 00:07:15.970
I don't have to have the business logic
on the client and on the server, right?

129
00:07:15.970 --> 00:07:19.170
The server controls the state,
it's where the state lives.

130
00:07:19.170 --> 00:07:20.110
The server says, hey,

131
00:07:20.110 --> 00:07:23.170
this order is not refundable because
it hasn't been purchased yet, right?

132
00:07:24.530 --> 00:07:25.970
So there's no link to refund.

133
00:07:25.970 --> 00:07:27.225
If there's no link in the response,

134
00:07:27.225 --> 00:07:29.980
then there's no button that could show it,
right?

135
00:07:29.980 --> 00:07:33.671
So this is a very, very powerful concept,
and it's all around this simple idea of I

136
00:07:33.671 --> 00:07:37.500
have links that help me understand where I
can navigate to, given the current state.

