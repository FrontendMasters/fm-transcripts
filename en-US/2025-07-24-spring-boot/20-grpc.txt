[00:00:00]
>> Josh Long: GraphQL is really good. I love GraphQL. But, you know, if you're doing really highly efficient kind of services, you probably care about something like grpc. And so we're going to build a GRPC service this time. The problem with GRPC is, I mean, it's not a problem, it's not a feature, it's not a bug, it's a feature.

[00:00:16]
Right? It's schema first. Very much like the GraphQL stuff we've just looked at here. It's schema first. And it's also, it's a little overbearing, if you ask me. It really requires you to change the way you write your code. So let's do this. We're going to go over here.

[00:00:33]
We went to start.spring today, we chose GRPC. That was nice enough to initialize us with a folder here called Proto. And in the build we have down here we have the GRPC dependencies and the spring GRPC project, Spring GRPC testing, and most importantly, a whole bunch of different maven plugins to support configuring that.

[00:00:55]
So let's do our last thing here. Okay, we're gonna say users.proto, okay? We're gonna create a GRPC file. The syntax will be Proto 3, we're going to say service users, and it'll be a RPC service that'll define a collection of users. Now, in grpc, if you want to have a collection of things, there's no like, array syntax.

[00:01:25]
You just have to define a thing that defines a collection of other things. Right? And in GRPC you also. What is happening with this? User service. Yeah. Okay, so in grpc, everything needs to be accounted for. So you need to tell the, the protocol what is the offset of a given type relative to the root of the type.

[00:01:47]
So int32id equals one string name equals two string description. Wait, no, what is the payload there? It's ID, name, username, okay? Equals 3, there we go. So I'm just going to return those three and we'll say users returns a collection of users. We'll have an endpoint here, RPC style, as opposed to fire and forget, whatever, rpc.

[00:02:16]
And we're gonna call this all, which returns this, right? So there's that. And it's going to take nothing in it. It's going to be a void. So there's no default syntax there. So I'm going to say Google protobuf empty. I'll pass that in here, okay? Google.protobuf.Empty, there you go.

[00:02:40]
So that's my service, my one endpoint called all. Maybe I'll just call it Users.
>> Speaker 2: Sure.
>> Josh Long: And user is the payload type and there's the collection of them. Now, because this is going to be transpiled into Java code, I need to provide some options. So what is the outer name?

[00:02:56]
What is the package? First of all, that I want the code generated to be the generated codes I live in. Well, com example.web.grpc sure, why not? Right. And then java_outer_classname, I'm gonna call this UsersProto, okay? And then finally Java multiple files is true. Okay, there's my schema. Now I need to compile that schema.

[00:03:26]
So maven package. Users is not a message type, I disagree. Let me just do all.
>> Speaker 2: Gosh, so tedious.
>> Josh Long: Okay, so that's done some code generation. If you look at the target directory, go to the generated sources. There's a folder called protobuf. There you'll find two subfolders, grpc, Java and Java.

[00:04:04]
In Intellij you need to mark them as source code roots, otherwise they won't get picked up by your editor. But in Eclipse and Visual Studio code, I'm told you wouldn't have that problem, so bully for you. Okay, now we actually have to implement that code. And the way it works is you take the code that was just generated for you and you subclass it.

[00:04:20]
Okay, so class UsersService extends, let's see, it's called UsersServiceGRPCBase, okay? And so I have to extend the one that's given to me by the GRPC compiler. It gives me a stub. The super class implementation does nothing, right? It says it does something. It'll actually actively blow up if you try and call it.

[00:04:53]
Because it doesn't do anything useful. That's what it's trying to say. So what I need to do is to implement it in terms of my own business logic. But remember, we've just had everything transpiled for us, right? So as a result, we can't use our domain, we have to use the transpiled code generated versions of our domain.

[00:05:10]
So we're going to say this usersclient Users get the collection of users. For each one, we're going to map through the results and we're going to turn it into the GRPC package user, right? So this is ours. This is what was code generated. We're going to use the builder and we'll say build and we're going to say set.

[00:05:31]
Username is u.username, setName is u.name. setID is u.id, okay, .toList. Okay, var all. And now I'm going to return that. I'll say response observer. Okay, do that. And then that. Okay, so that should be. Okay, let's see what that gives us.
>> Speaker 2: None public interface.
>> Josh Long: I don't know what that means.

[00:06:10]
When in doubt, delete target.
>> Speaker 2: Okay.
>> Josh Long: And then just do this. Wait. Non declarative. I don't know what this is some weird thing, but we can fix that by just ignoring it. That is interesting, though. So, okay, wait, comment this out. Okay. And then we'll use the one that I commented out earlier.

[00:07:10]

>> Speaker 2: And we'll inject that here.
>> Josh Long: So actually, I wonder if that. We can just leave the code.
>> Speaker 2: Here.
>> Josh Long: Inject that. Check that.
>> Speaker 2: Okay, let's see if that runs. This, staring me right in the face.
>> Josh Long: It's been a day. Okay, here we go. Take 512.

[00:07:38]

>> Speaker 2: Okay, I've got two different REST clients, yeah, that's fair.
>> Josh Long: Let's just comment at one of them.
>> Speaker 2: Get rid of that. Get rid of that.
>> Josh Long: Neato. Okay, so the service is up and running after all. Much ado about nothing. And you can see that the GRPC service is up and running as well.

[00:08:08]
So now we go to the console grpccurl, --plaintext, okay? And it's going to be called. What do we call it? User Service all. And then it's localhost8080. What did I do? That's because of the declarative client. It's not the GRPC stuff, it's the client itself. Where's the simple client?

[00:08:50]

>> Speaker 2: And it's that HTTP typee code. Okay, simple.
>> Josh Long: Client. Put that in there.
>> Speaker 2: Return.
>> Josh Long: There we go. So I called the GRPC endpoint. It was having trouble calling the backend HTTP service, but I'm getting the data now via GRPC Curl, which is talking to my GRPC service hosted in my Spring app, which is running on HTTP 2 because GRPC requires.

