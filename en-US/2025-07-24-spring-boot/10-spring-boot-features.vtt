WEBVTT

1
00:00:00.000 --> 00:00:03.554
&gt;&gt; Josh Long: But
now let's look at Spring boot.

2
00:00:03.554 --> 00:00:04.327
What does Spring boot do?

3
00:00:04.327 --> 00:00:07.763
Well, remember I told you about how
there's this configuration mechanism,

4
00:00:07.763 --> 00:00:09.488
this convention over configuration.

5
00:00:09.488 --> 00:00:11.544
Spring boot gives you
the best of both worlds.

6
00:00:11.544 --> 00:00:15.085
It gives you the ability to create as
expressive configuration as you want,

7
00:00:15.085 --> 00:00:17.537
just as I just did with all
those different objects.

8
00:00:17.537 --> 00:00:20.310
But it gives you some defaults,
some useful defaults.

9
00:00:20.310 --> 00:00:24.407
So here I've got my service,
my customer service, right?

10
00:00:24.407 --> 00:00:26.315
Just as before, nothing changed there.

11
00:00:26.315 --> 00:00:29.847
Got my LoggingBeanPostProcessor, right?

12
00:00:29.847 --> 00:00:35.529
And I've got my public static void
main spring boot application.

13
00:00:35.529 --> 00:00:36.982
Where's the database?

14
00:00:36.982 --> 00:00:40.310
Where's the schema initialization?

15
00:00:40.310 --> 00:00:41.663
Where's most of it?

16
00:00:41.663 --> 00:00:43.693
All that code I deleted,
I don't need it anymore.

17
00:00:43.693 --> 00:00:48.507
So if you go back to the test,
the test also gets a little bit easier cuz

18
00:00:48.507 --> 00:00:53.249
now I can use spring boot test
instead of using SpringJUnitConfig.

19
00:00:53.249 --> 00:00:58.086
So the same basically, and also I'm using
this nice extension to capture the output,

20
00:00:58.086 --> 00:00:59.412
this is standard out and

21
00:00:59.412 --> 00:01:02.477
I can do assertions against
the output there, right?

22
00:01:02.477 --> 00:01:07.339
So let's start
the Spring Boot application.

23
00:01:07.339 --> 00:01:11.343
And you can see the Spring boot
application has very importantly, very

24
00:01:11.343 --> 00:01:15.960
good ask get work banner as get work is
key to successful production deployments.

25
00:01:15.960 --> 00:01:20.405
It also has everything else,
shutting down customer service,

26
00:01:20.405 --> 00:01:23.297
the logability, all that kind of stuff.

27
00:01:23.297 --> 00:01:25.733
So everything is the same as before,
but I wrote much less code.

28
00:01:25.733 --> 00:01:29.075
And the reason that's true is
because I have auto configuration.

29
00:01:29.075 --> 00:01:31.805
The auto configuration is
the key to spring boot.

30
00:01:31.805 --> 00:01:36.308
This is why it's so consistent in
large organizations and small.

31
00:01:36.308 --> 00:01:40.370
If you wanna get something up and running
out the door in as few lines as possible,

32
00:01:40.370 --> 00:01:44.647
there's nothing more concise than your
typical Spring Boot application, right?

33
00:01:44.647 --> 00:01:48.352
I built an application that talks to
a SQL database, has observability,

34
00:01:48.352 --> 00:01:50.459
is production worthy, has a container.

35
00:01:50.459 --> 00:01:51.979
And I just went to starts out Spring I.O.

36
00:01:51.979 --> 00:01:54.514
and I wrote six lines of code or
whatever it was earlier, right?

37
00:01:54.514 --> 00:01:55.389
Ten lines of code.

38
00:01:55.389 --> 00:01:56.474
It's very, very concise.

39
00:01:56.474 --> 00:01:58.779
But it scales, that's the difference.

40
00:01:58.779 --> 00:02:00.038
That consistency scales and

41
00:02:00.038 --> 00:02:03.033
the way it scales is through this
thing called auto configuration.

42
00:02:03.033 --> 00:02:06.757
The auto configuration works,
when spring boot starts up,

43
00:02:06.757 --> 00:02:11.732
it looks on the class path and it finds
this text file called spring.factories.

44
00:02:11.732 --> 00:02:15.435
This is what makes Spring boot, Spring
boot and everything else Spring framework.

45
00:02:15.435 --> 00:02:20.161
So you look for spring.factories,
this is a service loader, okay?

46
00:02:20.161 --> 00:02:26.296
Spring will find this class in
the meta inf directory of your code.

47
00:02:26.296 --> 00:02:30.949
Where's my go over here,
where's my target?

48
00:02:30.949 --> 00:02:36.619
It looks for the meta inf/.

49
00:02:36.619 --> 00:02:37.932
Meta inf spring.factories.

50
00:02:37.932 --> 00:02:39.428
It'll find this class and

51
00:02:39.428 --> 00:02:43.380
it'll find a key followed by a common
delimited list of class names.

52
00:02:43.380 --> 00:02:46.892
And these keys get used for
different lifecycle pieces.

53
00:02:46.892 --> 00:02:50.537
There's another file that it looks for

54
00:02:50.537 --> 00:02:54.850
called autoconfiguration imports Imports.

55
00:02:54.850 --> 00:02:57.355
And this file lives in spring boot jars.

56
00:02:57.355 --> 00:03:02.350
You can see this one lives in
metainf spring Org springframework

57
00:03:02.350 --> 00:03:06.341
Boot auto configure
Autoconfiguration imports.

58
00:03:06.341 --> 00:03:07.111
That's a text file.

59
00:03:07.111 --> 00:03:11.279
The name of the file is called
autoconfiguration Imports, right?

60
00:03:11.279 --> 00:03:11.940
Actually, no,

61
00:03:11.940 --> 00:03:15.499
it's called org spring framework Boot auto
configure Auto configuration dot imports.

62
00:03:15.499 --> 00:03:18.888
And it's just a long list of Java classes.

63
00:03:18.888 --> 00:03:21.470
These classes get evaluated
when the program starts up.

64
00:03:21.470 --> 00:03:25.379
So if you look at rabbit auto
configuration for RabbitMQ,

65
00:03:25.379 --> 00:03:28.920
you can see it's got a lot of red here,
right?

66
00:03:28.920 --> 00:03:30.174
Look at that.

67
00:03:30.174 --> 00:03:32.731
Somebody I forgot about this class.

68
00:03:32.731 --> 00:03:35.583
This rabbit auto configuration
is a configuration class,

69
00:03:35.583 --> 00:03:37.073
it defines a bunch of objects.

70
00:03:37.073 --> 00:03:40.519
But it has these tests,
these tests, these conditions.

71
00:03:40.519 --> 00:03:44.275
This condition says run
the RabbitAutoConfiguration, but

72
00:03:44.275 --> 00:03:48.103
only if there is a Rabbit
template.class on the class path and

73
00:03:48.103 --> 00:03:50.768
only if channel class
is on the class path.

74
00:03:50.768 --> 00:03:53.366
It's like an if def macro in C, right?

75
00:03:53.366 --> 00:03:55.760
But it's happening at runtime,
it's when the program starts up.

76
00:03:55.760 --> 00:04:00.757
So we, we add the body of this
configuration to all the objects that

77
00:04:00.757 --> 00:04:04.873
are in play, but
only if this type is on the class path.

78
00:04:04.873 --> 00:04:06.503
If the library is on the class path.

79
00:04:06.503 --> 00:04:10.908
If it's not there, then don't bother
because we would surely get a no class def

80
00:04:10.908 --> 00:04:14.282
error or a class not found exception or
something like that.

81
00:04:14.282 --> 00:04:16.181
So this is very, very dynamic.

82
00:04:16.181 --> 00:04:19.141
What it means is that if you
wanna have a default experience,

83
00:04:19.141 --> 00:04:22.158
you go to start spring IO,
you choose some of those starters,

84
00:04:22.158 --> 00:04:25.253
those checkboxes that I showed
you earlier, those over here.

85
00:04:25.253 --> 00:04:30.323
If I go here, if I choose web,
that spring web is gonna

86
00:04:30.323 --> 00:04:35.410
give me spring boot starter web,
that's a starter.

87
00:04:35.410 --> 00:04:38.568
These starters are packaged
with auto configuration.

88
00:04:38.568 --> 00:04:42.981
You just add that to the classpath and
it automatically runs a web server for

89
00:04:42.981 --> 00:04:45.303
you and it installs spring MVC for you.

90
00:04:45.303 --> 00:04:49.368
And it sets up the servlet stack and
it installs JSON marshalling and

91
00:04:49.368 --> 00:04:53.447
XML marshaling and form handling
just by the presence of the build.

92
00:04:53.447 --> 00:04:54.906
I've done nothing to the code, right?

93
00:04:54.906 --> 00:04:57.092
Nothing has changed to get all of that.

94
00:04:57.092 --> 00:05:01.172
That's because of the presence of these
auto configured starters, that's very,

95
00:05:01.172 --> 00:05:01.981
very powerful.

96
00:05:01.981 --> 00:05:05.082
Now because these starters
are smart enough to be dynamic,

97
00:05:05.082 --> 00:05:06.890
there's also other conditions.

98
00:05:06.890 --> 00:05:09.586
I've got these conditional
on missing bean.

99
00:05:09.586 --> 00:05:12.559
These conditional on missing
bean say create this object,

100
00:05:12.559 --> 00:05:15.897
but only if the user hasn't provided
the same object themselves.

101
00:05:15.897 --> 00:05:22.300
So if I were to, in my own code over here,
create a bean of type blah, right?

102
00:05:22.300 --> 00:05:25.593
It's gonna fail cuz I don't have that
type in the classpath, I don't think.

103
00:05:25.593 --> 00:05:27.651
I do.
Why do I have that in the class path?

104
00:05:27.651 --> 00:05:28.289
Well, whatever.

105
00:05:28.289 --> 00:05:32.040
The point is, if I did this by myself,
then spring boot would defer to me,

106
00:05:32.040 --> 00:05:34.355
it would not bother creating this one for
me.

107
00:05:34.355 --> 00:05:37.531
So even though it provides one,
it provides this one right here,

108
00:05:37.531 --> 00:05:40.791
it's a bean method, just like we
saw in my own code back over here.

109
00:05:40.791 --> 00:05:44.048
This is an embedded database that
I've got a bean method on it.

110
00:05:44.048 --> 00:05:47.953
If I didn't provide this, it would give
me a default one, but if I do provide it,

111
00:05:47.953 --> 00:05:49.338
it backs away immediately.

112
00:05:49.338 --> 00:05:54.068
So this is a framework in the sense that
it's open for extension, but closed for

113
00:05:54.068 --> 00:05:55.561
modification, right?

114
00:05:55.561 --> 00:05:57.186
When we say closed for modification,

115
00:05:57.186 --> 00:06:00.246
we mean you don't have to fork Spring
to change the way Spring behaves.

116
00:06:00.246 --> 00:06:03.946
You can, it's open source, patch, it's
licensed, be our guest, but the point is,

117
00:06:03.946 --> 00:06:05.156
you don't need to, right?

118
00:06:05.156 --> 00:06:06.803
These are all little
cogs in the machine and

119
00:06:06.803 --> 00:06:08.321
you can swap them out the whole system.

120
00:06:08.321 --> 00:06:12.668
You don't have to unwind the whole stack
like you do with Rails to change one

121
00:06:12.668 --> 00:06:14.188
little part of it, okay?

122
00:06:14.188 --> 00:06:18.411
Okay, so there's lots of other conditions
you can do conditional on missing bean,

123
00:06:18.411 --> 00:06:20.970
conditional on class,
conditional on property,

124
00:06:20.970 --> 00:06:22.824
like a property in the environment.

125
00:06:22.824 --> 00:06:27.774
You can look for all sorts of different
conditions that make these dynamic auto

126
00:06:27.774 --> 00:06:30.776
configurations very, very, very powerful.

127
00:06:30.776 --> 00:06:35.469
Okay, so back to Readme here.

128
00:06:35.469 --> 00:06:38.039
So now we talked about
configuration before.

129
00:06:38.039 --> 00:06:40.096
When I talk about configuration,
it's a little confusing.

130
00:06:40.096 --> 00:06:44.153
I mean, there's Java config, which is
the class that has the bean methods, and

131
00:06:44.153 --> 00:06:46.315
there's also these properties, right?

132
00:06:46.315 --> 00:06:50.634
We talked about that as well, I just wanna
reiterate that you can get access to

133
00:06:50.634 --> 00:06:54.631
various properties in Spring that
come from the environment, right?

134
00:06:54.631 --> 00:06:59.304
So this environment thing is a dictionary,
it's a key in value dictionary, and

135
00:06:59.304 --> 00:07:03.085
it gives you access to properties
that you put in your application

136
00:07:03.085 --> 00:07:07.624
properties file into D command line
properties into environment variables,

137
00:07:07.624 --> 00:07:12.471
into things that are in HashiCorp vault or
your Google Cloud's vault or whatever.

138
00:07:12.471 --> 00:07:15.559
All these different things where
you can source keys and values,

139
00:07:15.559 --> 00:07:19.172
they can be added as a property source
to the Spring framework environment.

140
00:07:19.172 --> 00:07:24.719
And then that Spring framework environment
can make those things available to you for

141
00:07:24.719 --> 00:07:28.262
Injection directly like this,
beans, whatever, or

142
00:07:28.262 --> 00:07:30.585
bound it to a Java object like this.

143
00:07:30.585 --> 00:07:33.804
So property configuration,
beans properties.

144
00:07:33.804 --> 00:07:37.475
So here's the configuration,
property configuration, etc.

145
00:07:37.475 --> 00:07:38.431
Any questions on this?

146
00:07:38.431 --> 00:07:39.936
Why does this matter?

147
00:07:39.936 --> 00:07:44.816
Because one of the easiest ways to
impact the behavior of the program is to

148
00:07:44.816 --> 00:07:45.943
set a property.

149
00:07:45.943 --> 00:07:48.150
So you need to source them
from wherever you want.

150
00:07:48.150 --> 00:07:53.107
Environment variables, property files,
application YAML, application properties,

151
00:07:53.107 --> 00:07:54.535
d arguments, whatever.

152
00:07:54.535 --> 00:07:57.706
When they're sourced,
they're available via the environment.

153
00:07:57.706 --> 00:08:02.036
You can get them as values
injected into various places, or

154
00:08:02.036 --> 00:08:05.683
you can have them bound to
Java objects like this.

155
00:08:05.683 --> 00:08:10.669
I'm binding beans message to a strongly
typed object that I wrote called beans

156
00:08:10.669 --> 00:08:14.370
properties or beans properties and
the prefix is beans and

157
00:08:14.370 --> 00:08:16.877
the message the key is called message.

158
00:08:16.877 --> 00:08:20.969
This mechanism right here means that
if I want a strongly typed carrier for

159
00:08:20.969 --> 00:08:24.006
those configuration values
that the user specified,

160
00:08:24.006 --> 00:08:28.310
I can just inject bean's properties and
anywhere in my code and I'll get it.

161
00:08:28.310 --> 00:08:29.033
So that's what I'm doing here.

162
00:08:29.033 --> 00:08:34.017
This test is getting the same key directly
from the raw environment, injected as

163
00:08:34.017 --> 00:08:38.720
a value or bound to a type safe thing,
but the result is the exact same value.

164
00:08:38.720 --> 00:08:42.231
In all three cases,
we're expecting it to be hello world.

165
00:08:42.231 --> 00:08:49.845
If I run this, the test is green.

166
00:08:49.845 --> 00:08:51.079
It's not much to see.

167
00:08:51.079 --> 00:08:54.757
The point is, if I change,
if I set up an environment variable or

168
00:08:54.757 --> 00:08:59.271
a property on the command line dash d,
that'll override this inbuilt value.

169
00:08:59.271 --> 00:09:02.530
Right now it's sourcing
that value from here.

170
00:09:02.530 --> 00:09:03.436
So far, so good.

171
00:09:03.436 --> 00:09:08.076
Events Finally,
Spring emits a lot of events.

172
00:09:08.076 --> 00:09:11.961
These events tell you how the
application's behaving the lifecycle of

173
00:09:11.961 --> 00:09:12.939
various things.

174
00:09:12.939 --> 00:09:14.206
But it's not just pure infrastructure.

175
00:09:14.206 --> 00:09:16.788
It's like if you're using spring security,

176
00:09:16.788 --> 00:09:21.027
there's an event when somebody
authenticates these events get dispatched

177
00:09:21.027 --> 00:09:25.282
to any component in the spring context
that wants to listen to these events.

178
00:09:25.282 --> 00:09:30.346
So here I have an events application,
public, static, void, main I've got

179
00:09:30.346 --> 00:09:35.509
atomic thread safe variable to increment
and I'm incrementing the variable.

180
00:09:35.509 --> 00:09:40.342
Whenever the application is ready,
I have an event listener.

181
00:09:40.342 --> 00:09:43.533
I'm saying I want to listen for
the event called applicationready event.

182
00:09:43.533 --> 00:09:46.144
I have another event when
the context is refreshed and

183
00:09:46.144 --> 00:09:49.113
when somebody publishes a spring
is awesome event, right?

184
00:09:49.113 --> 00:09:52.393
So you can create your own events
as well and you can publish those.

185
00:09:52.393 --> 00:09:56.820
And these can be any component anywhere in
the code base can have event listener and

186
00:09:56.820 --> 00:09:57.407
a method.

187
00:09:57.407 --> 00:10:00.920
It can be called whatever on foo it
doesn't, you know, or just spring is

188
00:10:00.920 --> 00:10:05.009
awesome event, you know, whatever you can
call this method whatever you want, but

189
00:10:05.009 --> 00:10:07.849
as long as you have the type of
the event and the parameter.

190
00:10:07.849 --> 00:10:11.951
The other way around, the other way you
could do it is to do Spring is awesome

191
00:10:11.951 --> 00:10:14.512
event.class and then don't do a parameter.

192
00:10:14.512 --> 00:10:18.225
But that's only if you don't care
about the event type itself,

193
00:10:18.225 --> 00:10:19.616
which I do in this case.

194
00:10:19.616 --> 00:10:20.557
And all I'm doing is for

195
00:10:20.557 --> 00:10:23.442
each of these three different events,
these are all distinct, right?

196
00:10:23.442 --> 00:10:27.755
I'm gonna call this register method,
I'm incrementing the counter so

197
00:10:27.755 --> 00:10:32.150
there are three events we should expect
then, the counter will be three.

198
00:10:32.150 --> 00:10:36.236
I said, you can also publish your own
events, so application, event, publisher,

199
00:10:36.236 --> 00:10:37.336
I'm injecting that.

200
00:10:37.336 --> 00:10:40.957
I'm gonna publish event called Spring is
awesome event, and it'll get dispatched

201
00:10:40.957 --> 00:10:44.643
to all the components in my context, which
in this case is just this one class, okay?

202
00:10:44.643 --> 00:10:46.676
So if we run this.

203
00:10:46.676 --> 00:10:47.254
Here we go, and

204
00:10:47.254 --> 00:10:50.241
we should see that the value is three
cuz we've got three different listeners.

205
00:10:54.140 --> 00:10:58.265
All right, there we go, that's events,
we're gonna see events a lot.

206
00:10:58.265 --> 00:11:01.125
Events are how you communicate
state from one system to another,

207
00:11:01.125 --> 00:11:03.783
from one component to another,
from one module to another.

208
00:11:03.783 --> 00:11:07.805
They're useful for hooking into things
like, okay, the web server is initialized,

209
00:11:07.805 --> 00:11:08.475
I have a port.

210
00:11:08.475 --> 00:11:09.268
Now what?

211
00:11:09.268 --> 00:11:11.258
Right after the web server is initialized,

212
00:11:11.258 --> 00:11:13.263
I need to start warming
up some cache maybe.

213
00:11:13.263 --> 00:11:17.091
Or I can hook into somebody's
authenticator, or there's been somebody

214
00:11:17.091 --> 00:11:20.733
that didn't authenticate,
they had an authentication failure, or

215
00:11:20.733 --> 00:11:23.530
a customer checked out on
the shopping cart, right?

216
00:11:23.530 --> 00:11:27.730
You can asynchronously integrate things
into the lifecycle of these applications

217
00:11:27.730 --> 00:11:29.650
by publishing and consuming events.

