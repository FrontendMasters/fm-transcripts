WEBVTT

1
00:00:00.400 --> 00:00:03.890
&gt;&gt; Josh Long: Now,
Spring is a technology that was created,

2
00:00:03.890 --> 00:00:09.126
like I said back in early 2000s,
2001 was when the first author

3
00:00:09.126 --> 00:00:14.120
tag was written, right,
the first date for contribution in Java.

4
00:00:14.120 --> 00:00:17.262
And the core idea behind it is
that it supports this thing called

5
00:00:17.262 --> 00:00:18.520
dependency injection.

6
00:00:18.520 --> 00:00:19.280
What does that mean?

7
00:00:19.280 --> 00:00:20.560
Well, it's commonplace now.

8
00:00:20.560 --> 00:00:25.000
Even Angular has it, even the JavaScript
people understand dependency injection.

9
00:00:25.000 --> 00:00:27.890
But it was a big deal 25 years ago.

10
00:00:27.890 --> 00:00:32.774
And the reason it was such a big deal is
because compared to what was prevalent in

11
00:00:32.774 --> 00:00:37.890
the Java ecosystem at the time, which was
hideous, this is a breath of fresh air.

12
00:00:37.890 --> 00:00:41.023
I think that's one of the reasons why
the technology is called Spring is because

13
00:00:41.023 --> 00:00:42.770
it's just so much cleaner and nicer.

14
00:00:42.770 --> 00:00:47.201
And the dinosaurs that roamed the Earth
at the time were something called J2EE,

15
00:00:47.201 --> 00:00:50.600
which has changed its name three
different times since then.

16
00:00:50.600 --> 00:00:53.732
So it's now, there was Java EE,
and then Jakarta EE.

17
00:00:53.732 --> 00:00:57.708
Jakarta EE and Java EE are far,
far better than J2EE,

18
00:00:57.708 --> 00:01:00.640
which we can all agree was abhorrent.

19
00:01:00.640 --> 00:01:04.119
J2EE at the time was written,
I think, because remember,

20
00:01:04.119 --> 00:01:08.480
some of this stuff started
coming together in the late 90s.

21
00:01:08.480 --> 00:01:12.973
And one of the patterns that you
would have seen as a C programmer in

22
00:01:12.973 --> 00:01:15.680
the late 90s or a C programmer is RAI.

23
00:01:15.680 --> 00:01:17.440
Resource acquisition is initialization.

24
00:01:17.440 --> 00:01:21.450
How many of you have ever heard of
this pattern or anti pattern in Java?

25
00:01:21.450 --> 00:01:24.708
The idea is in C you want to allocate
some memory, do something with it, and

26
00:01:24.708 --> 00:01:26.330
then free it as quickly as possible.

27
00:01:27.370 --> 00:01:32.209
And so you have code where you have these
duplicative allocations of resources,

28
00:01:32.209 --> 00:01:37.119
and then the freeing up of that resource
so that it doesn't leak, which is again,

29
00:01:37.119 --> 00:01:38.614
I know smart pointers and

30
00:01:38.614 --> 00:01:43.405
the like from Boost and now in the C++
standard have come a long way since then.

31
00:01:43.405 --> 00:01:45.660
But at the time,
this is not the case, okay?

32
00:01:45.660 --> 00:01:49.841
And so you see a lot of code from that
time that was written in terms of RAII in

33
00:01:49.841 --> 00:01:53.698
Java and it doesn't make any sense
because Java has object orient.

34
00:01:53.698 --> 00:01:54.740
It has a garbage collection, rather.

35
00:01:54.740 --> 00:01:55.780
So let's look at this code here, right?

36
00:01:55.780 --> 00:01:57.620
I've got some sample code.

37
00:01:57.620 --> 00:01:58.460
You can just follow along.

38
00:01:58.460 --> 00:01:59.620
I'm not going to type anything here.

39
00:01:59.620 --> 00:02:03.060
It's in the beans folder there.

40
00:02:03.060 --> 00:02:05.024
We're going to go pretty quickly here,

41
00:02:05.024 --> 00:02:07.580
so let's make sure we're
all here on the same page.

42
00:02:07.580 --> 00:02:09.700
Here's some code you should not write.

43
00:02:09.700 --> 00:02:13.461
This is a customer service implementation
and I've got an embedded database and

44
00:02:13.461 --> 00:02:14.850
I'm creating the database.

45
00:02:14.850 --> 00:02:18.769
But imagine me creating a database
connection to a data source right in place

46
00:02:18.769 --> 00:02:21.649
Imagine me initializing it and
putting the username and

47
00:02:21.649 --> 00:02:25.210
the password in the class where
I'm using the data source.

48
00:02:25.210 --> 00:02:26.410
That's not a good idea.

49
00:02:26.410 --> 00:02:30.658
And then imagine me writing code using
the lowest level abstraction for

50
00:02:30.658 --> 00:02:34.490
talking to a SQL database in
Java using JDBC directly.

51
00:02:34.490 --> 00:02:38.430
This code is an embarrassment of awful,
right?

52
00:02:38.430 --> 00:02:40.430
It's just so
many things that could be better.

53
00:02:40.430 --> 00:02:41.334
So first of all,

54
00:02:41.334 --> 00:02:45.670
what if I have more than one object
that needs a pointer to the data source?

55
00:02:45.670 --> 00:02:48.710
Why would I create a new
data source per component?

56
00:02:48.710 --> 00:02:49.750
I wouldn't want to do that.

57
00:02:49.750 --> 00:02:51.470
It's a waste of memory.

58
00:02:51.470 --> 00:02:54.683
Especially when data sources typically
have thread pools, which in turn have,

59
00:02:54.683 --> 00:02:58.070
well, threads, which means that you
can't really scale that up efficiently.

60
00:02:58.070 --> 00:02:59.350
And then same thing over here.

61
00:02:59.350 --> 00:03:01.430
What is the business logic for this?

62
00:03:01.430 --> 00:03:05.208
I'm getting the ID and
the name from a table called Customer and

63
00:03:05.208 --> 00:03:08.640
I am mapping each result into
an object called Customer.

64
00:03:08.640 --> 00:03:09.160
That's it.

65
00:03:09.160 --> 00:03:10.600
Everything else is just boilerplate.

66
00:03:10.600 --> 00:03:13.567
Allocating a statement,
allocating a connection, clearing it,

67
00:03:13.567 --> 00:03:14.560
handling exception.

68
00:03:14.560 --> 00:03:17.094
I'm not even handling exceptions,
but I should be.

69
00:03:17.094 --> 00:03:21.080
So this is bad code, but this is RAII,
Resource Acquisition is Initialization.

70
00:03:21.080 --> 00:03:25.220
I'm doing everything in place and I'm not
letting the natural sort of elegance of

71
00:03:25.220 --> 00:03:28.440
object oriented programming shine through.

72
00:03:28.440 --> 00:03:32.020
So then you get to,
let me see, Readme here.

73
00:03:32.020 --> 00:03:34.662
Then you get to dependency injection,
which is just, you know,

74
00:03:34.662 --> 00:03:36.500
just means writing code with constructors.

75
00:03:36.500 --> 00:03:37.700
It's not a big idea, right?

76
00:03:37.700 --> 00:03:42.020
So here I take that awful code that
we had before and it's still verbose.

77
00:03:42.020 --> 00:03:45.694
I'm still doing the absolute least
pleasant thing I can do without

78
00:03:45.694 --> 00:03:50.288
the benefit of any technology at all,
basically, except for the core jdbc, spi,

79
00:03:50.288 --> 00:03:53.540
JDBC being the way that Java
talks to databases, right?

80
00:03:53.540 --> 00:03:57.310
Like I don't know what's the equivalent
in most of the languages, right?

81
00:03:57.310 --> 00:04:02.098
It's just, yeah,
imagine using straight ADL,

82
00:04:02.098 --> 00:04:06.734
or straight,
what is the Python equivalent?

83
00:04:06.734 --> 00:04:07.550
It'll come to me.

84
00:04:07.550 --> 00:04:10.190
Anyway, the point is I'm
injecting a data source here.

85
00:04:10.190 --> 00:04:13.958
So at least the data source is now
being defined somewhere else and

86
00:04:13.958 --> 00:04:17.107
I can reuse it so
I can pass around the pointer to the data

87
00:04:17.107 --> 00:04:21.790
source to multiple places and you can see
that that code is testable here in this.

88
00:04:23.310 --> 00:04:28.012
So, so I've got the data source extracted
out, I'm initializing the schema,

89
00:04:28.012 --> 00:04:32.371
I've got this little handy utility thing
here that will load schema SQL and

90
00:04:32.371 --> 00:04:35.720
data SQL and
it'll run the SQL data source initializer.

91
00:04:35.720 --> 00:04:36.697
And then finally,

92
00:04:36.697 --> 00:04:41.040
once that's confirmed, I actually have
a Valid object that I can then use, right?

93
00:04:41.040 --> 00:04:45.120
If I go back to my test over here,
the object, the database, is correct.

94
00:04:45.120 --> 00:04:49.160
And now I can create my customer service
passing in a pointer to the data source.

95
00:04:49.160 --> 00:04:53.679
And then I can confirm that there are two
records in the database by reading them

96
00:04:53.679 --> 00:04:55.480
from the database like that.

97
00:04:55.480 --> 00:04:56.680
So that works fine.

98
00:04:56.680 --> 00:04:59.520
It's a little bit better, but
it's still very, very verbose, right?

99
00:04:59.520 --> 00:05:03.080
I'm still writing a lot of JDBC code,
so what else can we do?

100
00:05:03.080 --> 00:05:06.520
Well, what's another thing that
Spring introduced at the time, right?

101
00:05:06.520 --> 00:05:08.920
So we had this,
we used to talk about the Spring triangle.

102
00:05:08.920 --> 00:05:12.775
So you've got dependency injection,
which works against,

103
00:05:12.775 --> 00:05:16.930
undoes the nastiness of things like raii,
right?

104
00:05:16.930 --> 00:05:19.490
But then you also have
portable service abstractions.

105
00:05:19.490 --> 00:05:23.443
Portable service abstractions are the
second leg of the three legs of the Spring

106
00:05:23.443 --> 00:05:24.450
triangle, right?

107
00:05:24.450 --> 00:05:25.130
There's three sides.

108
00:05:25.130 --> 00:05:30.014
And portable service abstractions
are basically utility abstractions that

109
00:05:30.014 --> 00:05:34.770
make working with these tedious lower
level APIs more pleasant, okay?

110
00:05:34.770 --> 00:05:38.507
And at the time we had something called
the JDBC template, which that was like

111
00:05:38.507 --> 00:05:41.990
a gateway for a lot of people who
wanted to get into using Spring, but.

112
00:05:41.990 --> 00:05:45.590
But they could only bring, they could
only treat it like a utility library.

113
00:05:45.590 --> 00:05:48.644
Maybe they didn't have the ability to
use it as a full on framework yet, but

114
00:05:48.644 --> 00:05:51.030
they had some utilities they
wanted to use, so portable.

115
00:05:51.030 --> 00:05:53.816
I could take that code now
that we just wrote and

116
00:05:53.816 --> 00:05:56.185
refactor it now to use the JDBC client.

117
00:05:56.185 --> 00:05:58.029
So here's the exact same code, right?

118
00:05:58.029 --> 00:06:01.350
But if I look at the where's
my customer service here?

119
00:06:01.350 --> 00:06:04.310
This is using the JDBC client, right?

120
00:06:04.310 --> 00:06:05.270
This is a newer.

121
00:06:05.270 --> 00:06:07.430
There's a JDBC template
which is from 20 years ago.

122
00:06:07.430 --> 00:06:10.180
There's the JDBC client, which is newer,
but the same idea, right?

123
00:06:10.180 --> 00:06:13.380
I've refactored that code to express
the essence of what I care about.

124
00:06:13.380 --> 00:06:17.954
So I'm injecting not the jdbc,
I'm not injecting the database itself,

125
00:06:17.954 --> 00:06:21.740
I'm injecting a JDBC client
which in turn has the database.

126
00:06:21.740 --> 00:06:22.380
I do that here.

127
00:06:22.380 --> 00:06:25.527
So I create that and then I pass
that into the customer service and

128
00:06:25.527 --> 00:06:26.820
look at the code, right?

129
00:06:26.820 --> 00:06:29.300
Select all from id,
select id name from customer.

130
00:06:29.300 --> 00:06:33.940
And then the essence is for
each row, map it to this object.

131
00:06:33.940 --> 00:06:35.820
I'm not writing boilerplate code anymore.

132
00:06:35.820 --> 00:06:38.790
This is just an object that will
return the records from the database.

133
00:06:38.790 --> 00:06:39.870
Pretty straightforward, okay?

134
00:06:39.870 --> 00:06:42.739
I'm not dealing with allocating
statements or connections or

135
00:06:42.739 --> 00:06:43.990
any of that stuff anymore.

136
00:06:43.990 --> 00:06:44.950
It's just much cleaner.

137
00:06:44.950 --> 00:06:47.070
So already I'm stripping Away noise.

138
00:06:47.070 --> 00:06:50.550
And I'm leaving behind
essential business logic.

139
00:06:50.550 --> 00:06:55.750
But still, there are some concerns
that are common to all my objects.

140
00:06:55.750 --> 00:06:58.330
And normally in object
oriented programming,

141
00:06:58.330 --> 00:07:01.510
you enforce these common
things by having common roots.

142
00:07:01.510 --> 00:07:06.046
But there are things that are sometimes
important to all objects,

143
00:07:06.046 --> 00:07:11.395
even if they're not in a hierarchical
sense the parent of that thing, right?

144
00:07:11.395 --> 00:07:14.390
You wouldn't say they don't
have that relationship.

145
00:07:14.390 --> 00:07:16.870
But these concerns need to be cared for.

146
00:07:16.870 --> 00:07:21.693
So, for example, transaction demarcation
or auditing, logging, right,

147
00:07:21.693 --> 00:07:23.190
things like that.

148
00:07:23.190 --> 00:07:24.830
So how would I do that?

149
00:07:24.830 --> 00:07:26.310
What if I wanted to do logging?

150
00:07:26.310 --> 00:07:29.630
What if I wanted to have timings
around each method invocation?

151
00:07:29.630 --> 00:07:34.250
Whenever somebody calls a service,
I want to emit telemetry to another thing.

152
00:07:34.250 --> 00:07:36.970
Well, that's the thing I
wanna do across all my code.

153
00:07:36.970 --> 00:07:39.210
Do I want to have a base
class that does this?

154
00:07:39.210 --> 00:07:43.130
Do I want to make everybody call
that superclass method, right?

155
00:07:43.130 --> 00:07:43.890
I don't want to do that.

156
00:07:43.890 --> 00:07:45.130
That seems very ugly.

157
00:07:45.130 --> 00:07:49.433
What if I had some way to transparently
using object orientation and

158
00:07:49.433 --> 00:07:52.010
information hiding and polymorphism.

159
00:07:52.010 --> 00:07:56.819
What if I had some way to add behavior to
a type in such a way that the consumer of

160
00:07:56.819 --> 00:08:00.010
that type doesn't know that they've been.

161
00:08:00.010 --> 00:08:08.170
They've in effect been duped,
they've had something swap out.

162
00:08:08.170 --> 00:08:09.690
So let's look at that example again.

163
00:08:09.690 --> 00:08:11.704
I've got my customer service, but

164
00:08:11.704 --> 00:08:15.850
I'm using this thing I wrote called
the loggable proxymaker proxy.

165
00:08:15.850 --> 00:08:17.170
And I'm passing this customer service.

166
00:08:17.170 --> 00:08:18.730
This is still customer service.

167
00:08:18.730 --> 00:08:20.730
The contract is still customer service.

168
00:08:20.730 --> 00:08:24.570
So anybody that was expecting a customer
service will still get a customer service.

169
00:08:24.570 --> 00:08:26.650
But they're not actually
getting a customer service.

170
00:08:26.650 --> 00:08:28.740
They're getting a proxy.

171
00:08:28.740 --> 00:08:32.500
They're getting a subclass of customer
service that adds extra behavior.

172
00:08:32.500 --> 00:08:34.820
And that subclass was
written programmatically.

173
00:08:34.820 --> 00:08:36.700
That is to say we did it at runtime.

174
00:08:36.700 --> 00:08:41.357
We created the subclass at runtime,
extending the class that we

175
00:08:41.357 --> 00:08:46.020
provided to add this extra
behavior because of polymorphism.

176
00:08:46.020 --> 00:08:48.810
Anybody that was expecting customer
service before will still be able to

177
00:08:48.810 --> 00:08:50.100
say they got a customer service.

178
00:08:50.100 --> 00:08:51.140
It's just a subclass.

179
00:08:51.140 --> 00:08:52.660
So let's look at this code here.

180
00:08:52.660 --> 00:08:53.900
This is a little low level.

181
00:08:53.900 --> 00:08:57.190
This is not stuff most people should have
to write, but it's not hard to do either.

182
00:08:57.190 --> 00:08:58.350
This is a capability.

183
00:08:58.350 --> 00:09:02.760
Well, this is a spring object
that is using two facilities,

184
00:09:02.760 --> 00:09:07.150
one of which was introduced
in Java 1.4 in 2001.

185
00:09:07.150 --> 00:09:10.670
So it's not a hard thing to understand or
whatever.

186
00:09:10.670 --> 00:09:14.637
Basically we are programmatically,
we're saying to Java,

187
00:09:14.637 --> 00:09:19.950
create an implementation of this
interface or of this type the target.

188
00:09:19.950 --> 00:09:23.640
And then, whenever somebody calls
a method, here's an event listener.

189
00:09:24.840 --> 00:09:28.124
When the method gets called,
call this event listener and

190
00:09:28.124 --> 00:09:32.600
give me a pointer to the on like as
the method is being invoked on the target.

191
00:09:32.600 --> 00:09:35.320
When somebody calls,
get customers or whatever.

192
00:09:35.320 --> 00:09:39.365
Give me a chance to look at
the invocation of the method and

193
00:09:39.365 --> 00:09:43.748
then I can start some clock,
I can capture the current time and

194
00:09:43.748 --> 00:09:48.470
the end time in the finally block
block and I get the result there and

195
00:09:48.470 --> 00:09:52.960
I can then log it out or
I can send it to Prometheus or something.

196
00:09:54.640 --> 00:09:55.280
Then that's it.

197
00:09:55.280 --> 00:09:57.200
So I'm using this thing.

198
00:09:57.200 --> 00:10:01.418
It's automatically adding this capability
to every method in that object that I

199
00:10:01.418 --> 00:10:02.480
pass in.

200
00:10:02.480 --> 00:10:05.840
But it's giving me back something
that is a customer service.

201
00:10:05.840 --> 00:10:09.911
But if you look at the actual type at
runtime, it's not customer service itself,

202
00:10:09.911 --> 00:10:12.330
it's actually customer
service dollar sign and

203
00:10:12.330 --> 00:10:15.070
then some inscrutable
string of characters.

204
00:10:15.070 --> 00:10:18.430
It's a dynamically generated
subclass at runtime.

205
00:10:18.430 --> 00:10:22.510
We are in effect compiling new
code when the program starts up.

206
00:10:24.270 --> 00:10:28.590
This is why it's very weird for
people who have never seen Java before.

207
00:10:28.590 --> 00:10:32.432
They don't realize that it's just as
dynamic as JavaScript, or Python, or

208
00:10:32.432 --> 00:10:33.030
whatever.

209
00:10:33.030 --> 00:10:37.750
You can do eval in effect in Java
in a roundabout circumlocutus way.

210
00:10:37.750 --> 00:10:38.670
But you can.

211
00:10:38.670 --> 00:10:39.943
That's a good thing,

212
00:10:39.943 --> 00:10:43.632
as we'll see later when we talk
about Graalvm a bad thing, okay?

213
00:10:43.632 --> 00:10:46.100
So let's see,
if I actually run this code, okay?

214
00:10:46.100 --> 00:10:50.220
Let's run this code up to this point and
we'll put our cursor and

215
00:10:50.220 --> 00:10:53.780
look at the actual generated class here.

216
00:10:53.780 --> 00:10:54.500
Customer service.

217
00:10:54.500 --> 00:10:55.100
You see that?

218
00:10:55.100 --> 00:10:58.272
That's not just customer service,
that's customer service.

219
00:10:58.272 --> 00:10:59.700
No, this one over here.

220
00:10:59.700 --> 00:11:02.820
Customer service $spring
CGLIB blah blah blah blah.

221
00:11:03.860 --> 00:11:06.649
The class name was clearly synthetic.

222
00:11:06.649 --> 00:11:08.891
It's not a real class, right?

223
00:11:08.891 --> 00:11:10.020
So run this.

224
00:11:11.940 --> 00:11:14.340
Okay, so that AOP is the third leg.

225
00:11:14.340 --> 00:11:16.140
So you've got Aspect Oriented programming.

226
00:11:16.140 --> 00:11:20.524
This idea of introducing aspects of
behavior that influence the form of a lot

227
00:11:20.524 --> 00:11:21.900
of different objects.

228
00:11:21.900 --> 00:11:23.220
That's called Aspect Oriented programming.

229
00:11:23.220 --> 00:11:25.399
There's actually a much higher
level abstraction in Spring for

230
00:11:25.399 --> 00:11:26.540
dealing with this kind of stuff.

231
00:11:26.540 --> 00:11:28.020
You don't ever have to
do something like this.

232
00:11:28.020 --> 00:11:30.164
But the point is it's there,
it's pervasive, and

233
00:11:30.164 --> 00:11:32.900
it's one of the ways that Spring is
able to do magic tricks for you.

234
00:11:34.430 --> 00:11:37.113
You create just a random class and
you add an annotation and

235
00:11:37.113 --> 00:11:38.990
suddenly you've got an HTTP endpoint.

236
00:11:38.990 --> 00:11:43.972
How it's because Spring is able to
add behavior to these objects, and

237
00:11:43.972 --> 00:11:46.670
it's able to do a bait and switch.

238
00:11:46.670 --> 00:11:50.270
You say, hey,
I'm advertising a customer service.

239
00:11:50.270 --> 00:11:52.910
Somebody else says, hey,
I want to inject a customer service.

240
00:11:52.910 --> 00:11:57.390
In between, the framework sits there and
it can do a swap.

241
00:11:57.390 --> 00:12:00.305
It takes your regular customer service and
adds this logging ability and

242
00:12:00.305 --> 00:12:02.870
then gives that to the thing
that depends upon it.

243
00:12:02.870 --> 00:12:07.510
That swap is the that indirection is so
key to so much of what Spring does.

244
00:12:07.510 --> 00:12:08.010
Okay.

