WEBVTT

1
00:00:00.320 --> 00:00:01.642
&gt;&gt; Josh Long: GraphQL.

2
00:00:01.642 --> 00:00:02.800
Anybody here using GraphQL?

3
00:00:05.040 --> 00:00:05.960
I love graphql.

4
00:00:05.960 --> 00:00:08.320
Okay, well, so we're gonna use
GraphQL here, let's try that.

5
00:00:08.320 --> 00:00:11.074
So I have a folder here called GraphQL.

6
00:00:11.074 --> 00:00:13.360
GraphQL is schema first.

7
00:00:13.360 --> 00:00:18.000
So I'll create this users graphqls there.

8
00:00:18.000 --> 00:00:20.320
I'll create a type in there called user.

9
00:00:20.320 --> 00:00:24.948
And I'm not gonna bother mapping
all of this, but basically,

10
00:00:24.948 --> 00:00:27.230
where's my web application?

11
00:00:28.830 --> 00:00:35.230
Okay, and user.

12
00:00:35.230 --> 00:00:37.430
So let's say I want to
keep some of this data.

13
00:00:37.430 --> 00:00:40.270
Okay, so I'll comment that out.

14
00:00:40.270 --> 00:00:44.500
So it's id, int name string,

15
00:00:44.500 --> 00:00:49.950
username string, email string.

16
00:00:49.950 --> 00:00:50.870
Now what about the address?

17
00:00:50.870 --> 00:00:53.690
Well, I can actually create
a type called address and

18
00:00:53.690 --> 00:00:56.210
then I don't know what's
in the address type.

19
00:00:56.210 --> 00:00:58.890
It's a string suite, okay?

20
00:00:58.890 --> 00:01:05.370
So street:String suite, :String, okay?.

21
00:01:05.370 --> 00:01:10.490
Now in GraphQL, I can describe this,
I can say address address.

22
00:01:12.650 --> 00:01:16.090
Now in graphql you have only three verbs.

23
00:01:16.090 --> 00:01:18.050
You have queries, which are read options.

24
00:01:18.050 --> 00:01:22.801
So queries,
you have mutations which are writes,

25
00:01:22.801 --> 00:01:27.661
and you have subscriptions,
which are long lived,

26
00:01:27.661 --> 00:01:31.790
ongoing streaming reads, right?

27
00:01:31.790 --> 00:01:35.283
And if you want GraphQL to
export a certain endpoint,

28
00:01:35.283 --> 00:01:37.310
you need to hang an attribute.

29
00:01:37.310 --> 00:01:40.292
These are attributes right here off
of some of these well known types.

30
00:01:40.292 --> 00:01:41.950
So type Query.

31
00:01:44.120 --> 00:01:45.320
Okay, Query.

32
00:01:45.320 --> 00:01:48.760
And then, let's just call it users.

33
00:01:49.880 --> 00:01:52.160
And if I wanted to return a single user,
I would do that.

34
00:01:52.160 --> 00:01:54.320
If I want to do multiple, I do that.

35
00:01:54.320 --> 00:01:57.400
The array syntax is how you do multiples,
okay?

36
00:01:57.400 --> 00:02:02.169
Okay, so let's build a controller that
exports that GraphQL endpoint, okay?

37
00:02:02.169 --> 00:02:08.040
So @Controller class GraphqlController.

38
00:02:08.040 --> 00:02:12.527
And instead of using Git mapping for
HTTP Git,

39
00:02:12.527 --> 00:02:19.085
I'm going to use query mapping and
it'll be collection of users and

40
00:02:19.085 --> 00:02:24.970
same thing as before,
I'll say return declarative users.

41
00:02:27.050 --> 00:02:31.090
Okay, and
I also want to try this stuff out.

42
00:02:31.090 --> 00:02:34.410
That's the other thing is I want a console
I can use to inspect my GraphQL.

43
00:02:34.410 --> 00:02:39.200
There's a nice graphical graphic,
Graph IQL that you can use there.

44
00:02:39.200 --> 00:02:44.680
So I go here graphiql and
hit enter and you get this.

45
00:02:44.680 --> 00:02:48.596
Okay, so now I can say query,

46
00:02:48.596 --> 00:02:52.520
ID name, username, right?

47
00:02:52.520 --> 00:02:53.040
So there you go.

48
00:02:53.040 --> 00:02:54.680
So I've got those three fields.

49
00:02:54.680 --> 00:02:55.440
That's nice.

50
00:02:55.440 --> 00:02:58.658
One of the things I love about
GraphQL is that you can get as much or

51
00:02:58.658 --> 00:03:00.040
as little data as you need.

52
00:03:00.040 --> 00:03:01.760
So I've asked for the id,
the name and the username.

53
00:03:01.760 --> 00:03:02.480
I got just that.

54
00:03:02.480 --> 00:03:05.960
If I ask for the address,
well, it's going to say, hey,

55
00:03:05.960 --> 00:03:10.940
you can't just select all you need to
tell us what you specifically want.

56
00:03:10.940 --> 00:03:16.940
So I go over here and I say,
I want the street, great.

57
00:03:16.940 --> 00:03:19.100
I want the suite great.

58
00:03:19.100 --> 00:03:21.740
Okay, so I get as much or
as little as I need.

59
00:03:21.740 --> 00:03:24.940
One of the things that's really nice
about GraphQL is of course you can do.

60
00:03:26.140 --> 00:03:26.740
It's a graph.

61
00:03:26.740 --> 00:03:27.700
It creates a graph, right?

62
00:03:27.700 --> 00:03:31.470
So imagine in this case that I was
not actually all just in memory.

63
00:03:31.470 --> 00:03:35.253
I imagine I had another microservice
that was called the address service and

64
00:03:35.253 --> 00:03:37.870
that's actually serving
up address details.

65
00:03:37.870 --> 00:03:41.270
Maybe it's some sort of, I don't know,
phone book or something, I don't know.

66
00:03:41.270 --> 00:03:46.910
Okay, so in that case I would want some
way to resolve the address for the user.

67
00:03:46.910 --> 00:03:50.370
Okay, so, and in this case I already
happen to have the address, but

68
00:03:50.370 --> 00:03:51.750
let's imagine I didn't.

69
00:03:51.750 --> 00:03:54.190
Let's suppose I needed to call
another service to get that.

70
00:03:54.190 --> 00:03:57.120
Okay, so I'm going to override this.

71
00:03:57.120 --> 00:04:02.848
I'm going to create a schema
mapping endpoint here,

72
00:04:02.848 --> 00:04:08.320
going to return a type of
Java object of type address

73
00:04:08.320 --> 00:04:13.429
given the user object and
I'll print this out.

74
00:04:13.429 --> 00:04:16.361
So I'll say system out,

75
00:04:16.361 --> 00:04:21.809
returning address for user.id, whatever.

76
00:04:23.729 --> 00:04:29.141
Okay, so we go back over here and
you can see that it actually

77
00:04:29.141 --> 00:04:34.129
called schema mapping for
each one of those users.

78
00:04:34.129 --> 00:04:39.130
So in this case I'm just
returning the object,

79
00:04:39.130 --> 00:04:43.889
this is spring,
GraphQL is using the batch.

80
00:04:43.889 --> 00:04:47.741
It's using the fact that it knows the root
of the domain object, which is user and

81
00:04:47.741 --> 00:04:51.270
it's given me a chance to given the user
to load an object of type address.

82
00:04:51.270 --> 00:04:53.590
In this case I'm cheating because
the user already had the address.

83
00:04:53.590 --> 00:04:54.430
I'm just returning it.

84
00:04:54.430 --> 00:04:56.950
But the point is this
could be a network call.

85
00:04:56.950 --> 00:04:59.190
I could todo call address service, right?

86
00:05:00.550 --> 00:05:01.350
Now this would work.

87
00:05:01.350 --> 00:05:05.350
But the problem of course is now
I've got an N plus one big problem.

88
00:05:05.350 --> 00:05:09.270
For every user,
I need to call the address endpoint.

89
00:05:11.030 --> 00:05:13.310
If I've just got one user, it's a call.

90
00:05:13.310 --> 00:05:14.270
But that's a big problem.

91
00:05:14.270 --> 00:05:14.990
So I don't want that.

92
00:05:14.990 --> 00:05:17.050
So how do I,
how do I get the best of both worlds?

93
00:05:17.050 --> 00:05:20.413
Well, what If I have one user or
if I have 10 users, you know,

94
00:05:20.413 --> 00:05:24.039
if I have to call the address
service 10 times, that's not good.

95
00:05:24.039 --> 00:05:26.644
It'll cost,
it's one request to get all the users and

96
00:05:26.644 --> 00:05:29.770
then 10 more requests to get all
the addresses for these users.

97
00:05:29.770 --> 00:05:30.810
That's very inefficient.

98
00:05:30.810 --> 00:05:32.730
So Instead, I want to do this in batch.

99
00:05:32.730 --> 00:05:34.490
So again, the schema has not changed.

100
00:05:34.490 --> 00:05:37.770
The schema is address, suite,
suite, right, suite and street.

101
00:05:37.770 --> 00:05:39.813
So that's all there and
it's all well and good, but

102
00:05:39.813 --> 00:05:41.450
I'm going to use batch mapping instead.

103
00:05:43.030 --> 00:05:43.550
Batch mapping.

104
00:05:43.550 --> 00:05:45.190
The contract is pretty simple.

105
00:05:45.190 --> 00:05:51.934
Given a list of collections of users,
return a mapping of user to address.

106
00:05:51.934 --> 00:05:56.185
So var users, sorry, addresses,

107
00:05:56.185 --> 00:06:00.870
okay, and this will just be a hashmap.

108
00:06:02.710 --> 00:06:07.111
Now you can imagine having some sort of
backend endpoint you can do select all

109
00:06:07.111 --> 00:06:11.670
from address where you user ID in and then
a range of IDs or something like that.

110
00:06:11.670 --> 00:06:12.310
Right?

111
00:06:12.310 --> 00:06:14.790
So there you go,
the AI is doing it for me.

112
00:06:14.790 --> 00:06:16.870
So for each of the users put the.

113
00:06:16.870 --> 00:06:18.390
Yeah, okay, that's exactly right.

114
00:06:18.390 --> 00:06:21.590
So now I'm going to comment out
the one that I had before so

115
00:06:21.590 --> 00:06:24.870
that this one is more logical and
then we'll say address.

116
00:06:26.310 --> 00:06:32.070
Okay, now I go back over here and
yeah, let me print out address.

117
00:06:33.600 --> 00:06:34.560
What is the issue with this one?

118
00:06:39.760 --> 00:06:46.960
Okay, system out, getting all addresses.

119
00:06:52.640 --> 00:06:54.160
So it'll be addresses.

120
00:06:58.720 --> 00:07:03.610
Okay, there you go.

121
00:07:03.610 --> 00:07:04.631
So you can see, it says,

122
00:07:04.631 --> 00:07:07.170
in that case I get a chance to
return all the responses at once.

123
00:07:07.170 --> 00:07:11.093
Now, in theory, if this was actually
a network call, it'd be one call for

124
00:07:11.093 --> 00:07:15.090
the users and another one for
all the addresses by doing this batching.

125
00:07:15.090 --> 00:07:17.650
So this method gets invoked just one time.

126
00:07:17.650 --> 00:07:18.690
That's much better.

127
00:07:18.690 --> 00:07:22.691
So GraphQL allows me to hide the fact
that I started with the thing locally,

128
00:07:22.691 --> 00:07:26.821
then I refactored to another service,
then I optimize the service to support

129
00:07:26.821 --> 00:07:29.800
batching and
the client hasn't changed anything.

130
00:07:29.800 --> 00:07:33.200
They depend on an address being
resolved for each of the users.

131
00:07:33.200 --> 00:07:34.800
The contract is exactly the same.

132
00:07:34.800 --> 00:07:39.040
But how I've implemented that behind
the scenes is transparent, right?

133
00:07:39.040 --> 00:07:41.560
So I can get the most
efficient call graph possible.

134
00:07:41.560 --> 00:07:43.480
So GraphQL, really, really powerful.

