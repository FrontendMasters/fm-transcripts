WEBVTT

1
00:00:00.400 --> 00:00:02.452
&gt;&gt; Josh Long: Okay, so
that's pretty straightforward if you want

2
00:00:02.452 --> 00:00:03.500
to call another REST API and

3
00:00:03.500 --> 00:00:06.659
you want to make sure you're dividing
the work across a bunch of clients, right.

4
00:00:06.659 --> 00:00:10.320
This is a pattern that Netflix uses a lot
because again, services come and go.

5
00:00:10.320 --> 00:00:12.560
You want to have control over
how you do load balancing.

6
00:00:14.320 --> 00:00:17.120
This is, again,
in this case, it's kind of.

7
00:00:17.120 --> 00:00:20.421
I'm just proxying the data though,
aren't I?

8
00:00:20.421 --> 00:00:27.233
I'm going to 8081 hello and I'm calling a
downstream service and I'm calling hello.

9
00:00:27.233 --> 00:00:31.083
The idea is that normally you'd be doing
something interesting with it, but if all

10
00:00:31.083 --> 00:00:34.610
you want to do is proxy it, well, we
have an even better story for you there.

11
00:00:34.610 --> 00:00:36.490
There's something called
Spring Cloud Gateway.

12
00:00:36.490 --> 00:00:38.331
Spring Cloud Gateway is a microproxy.

13
00:00:38.331 --> 00:00:41.276
It's like nginx, think nginx or

14
00:00:41.276 --> 00:00:47.179
Apache with the mod rewrite thing or
something like that, right.

15
00:00:47.179 --> 00:00:50.730
It's a micro proxy and it's super fast.

16
00:00:50.730 --> 00:00:54.680
So we're going to use
Spring Cloud Gateway here in the client.

17
00:00:54.680 --> 00:00:59.110
And do you remember I showed you,
I think briefly, but let's just rehash.

18
00:00:59.110 --> 00:01:01.736
You've seen me use controller.

19
00:01:01.736 --> 00:01:06.536
This style of my controller,
I can create like this.

20
00:01:06.536 --> 00:01:11.210
I can say string bar.

21
00:01:11.210 --> 00:01:12.480
I can do that kind of thing all day long.

22
00:01:12.480 --> 00:01:13.280
That's a controller.

23
00:01:13.280 --> 00:01:14.715
It's a component.

24
00:01:14.715 --> 00:01:17.448
People who've come from
the other communities,

25
00:01:17.448 --> 00:01:20.907
Maybe in the JavaScript world or
the Sinatra in the Ruby world.

26
00:01:20.907 --> 00:01:23.444
Or Express JS in the JavaScript world, or

27
00:01:23.444 --> 00:01:27.077
Flask in the Python world or
whatever, they all have this.

28
00:01:27.077 --> 00:01:30.624
There's a different component model
which is more of like predicate lambda,

29
00:01:30.624 --> 00:01:32.839
predicate lambda, predicate lambda, right.

30
00:01:32.839 --> 00:01:34.482
So you can do that as well in spring,
right.

31
00:01:34.482 --> 00:01:38.342
And so the way you do that
is you do router functions.

32
00:01:38.342 --> 00:01:45.091
Router functions, okay.

33
00:01:45.091 --> 00:01:53.201
Okay, Add that .build.

34
00:01:53.201 --> 00:01:56.690
I think I've done this with you all today
or recently, but let's just be sure.

35
00:01:56.690 --> 00:02:01.475
Okay, so there's my router function style.

36
00:02:01.475 --> 00:02:03.890
Okay, and I'm registering one predicate.

37
00:02:03.890 --> 00:02:06.074
You can register as many as you want for
verbs.

38
00:02:06.074 --> 00:02:07.770
For all the different verbs, obviously.

39
00:02:07.770 --> 00:02:08.490
Get rid of that.

40
00:02:08.490 --> 00:02:09.210
Good.

41
00:02:09.210 --> 00:02:12.319
So if I go to.

42
00:02:12.319 --> 00:02:16.187
Actually, I don't know what would
happen if there's duplicate predicates.

43
00:02:16.187 --> 00:02:20.172
But let's say hello one.

44
00:02:20.172 --> 00:02:23.319
You go here to hello one.

45
00:02:23.319 --> 00:02:25.360
Hello, it's still starting.

46
00:02:25.360 --> 00:02:26.239
There you go.

47
00:02:26.239 --> 00:02:27.200
So that's hello one.

48
00:02:27.200 --> 00:02:30.440
That's the second endpoint that I
created with the functional style.

49
00:02:30.440 --> 00:02:31.429
So in this case,

50
00:02:31.429 --> 00:02:35.828
all I'm doing is I'm using this
functional style to produce a Response.

51
00:02:35.828 --> 00:02:38.755
But, but
Spring Cloud Gateway is a micro proxy and

52
00:02:38.755 --> 00:02:42.810
it allows you to compose to
proxy other endpoints, right.

53
00:02:42.810 --> 00:02:43.770
So here we go.

54
00:02:44.890 --> 00:02:46.250
I'm gonna do that.

55
00:02:46.250 --> 00:02:51.210
And you can do like adobe.com,
right, you can proxy that instead of.

56
00:02:52.410 --> 00:02:55.703
This is a static import that will create
a filter that is a server response,

57
00:02:55.703 --> 00:02:58.597
basically a handler function that
produces a service response.

58
00:02:58.597 --> 00:03:02.479
Well, what if I want to do
a load balanced proxied request?

59
00:03:02.479 --> 00:03:03.999
Okay, so let me.

60
00:03:03.999 --> 00:03:08.120
There's a particular filter that
always escapes me because I'm.

61
00:03:08.120 --> 00:03:09.240
My brain is not good.

62
00:03:09.240 --> 00:03:10.303
So here we go.

63
00:03:10.303 --> 00:03:12.040
Okay, here we go.

64
00:03:12.040 --> 00:03:18.141
So the way that one works is
I'm going to go to hello and

65
00:03:18.141 --> 00:03:23.563
I'm going to just do HTTP
like that dot filter,

66
00:03:23.563 --> 00:03:26.421
load balanced service.

67
00:03:26.421 --> 00:03:29.530
Okay, so really if you read it like that,
it kind of makes more sense.

68
00:03:29.530 --> 00:03:30.677
Go over here.

69
00:03:30.677 --> 00:03:31.330
Hello one.

70
00:03:32.370 --> 00:03:35.677
What's the error now?

71
00:03:35.677 --> 00:03:41.250
No instances available for
Omar's local domain.

72
00:03:41.250 --> 00:03:42.914
What's the issue with that?

73
00:03:42.914 --> 00:03:45.570
You know what it is?

74
00:03:46.690 --> 00:03:48.091
Let's just try.

75
00:03:48.091 --> 00:03:49.940
I'm going to cheat a little bit here.

76
00:03:49.940 --> 00:03:55.403
What I'll do is I'm going to say,
going to get rid of the path.

77
00:03:55.403 --> 00:03:59.077
Okay, so what we got to do is
get rid of the path here and

78
00:03:59.077 --> 00:04:02.940
then go back to the service and
get rid of the path there.

79
00:04:02.940 --> 00:04:05.260
So it's just root for both.

80
00:04:05.260 --> 00:04:07.740
I think it's probably this bit right here.

81
00:04:07.740 --> 00:04:13.988
I don't think I need this.

82
00:04:13.988 --> 00:04:18.434
So open up the client.

83
00:04:18.434 --> 00:04:19.190
There we go.

84
00:04:19.190 --> 00:04:19.750
There we go.

85
00:04:19.750 --> 00:04:20.470
That's what it was.

86
00:04:20.470 --> 00:04:22.470
I had two things trying
to do load balancing.

87
00:04:22.470 --> 00:04:23.990
The gateway wants to
do the load balancing.

88
00:04:23.990 --> 00:04:25.990
So I got rid of the rest
client that fixed it.

89
00:04:25.990 --> 00:04:29.670
So now I'm going to localhost 8081.

90
00:04:29.670 --> 00:04:33.430
It in turn is proxying the request
to 8080 behind the scenes.

91
00:04:33.430 --> 00:04:35.625
Well, it's proxying it to the service,

92
00:04:35.625 --> 00:04:39.270
which is discovering from
the load balancer from Eureka.

93
00:04:39.270 --> 00:04:43.985
I had to remove the path,
remember I had to remove this like my.

94
00:04:43.985 --> 00:04:48.170
What if I wanted to get like
everything to API forward slash?

95
00:04:49.690 --> 00:04:54.970
Well, I need to strip
away the prefix then.

96
00:04:54.970 --> 00:04:57.734
And the way you do that is by
using a before filter function.

97
00:04:57.734 --> 00:05:02.122
Rewrite path,
API just becomes forward slash.

98
00:05:02.122 --> 00:05:06.625
So now everything before
API will get stripped away.

99
00:05:06.625 --> 00:05:07.850
So now let's try this again.

100
00:05:11.300 --> 00:05:12.140
So these are filters.

101
00:05:12.140 --> 00:05:14.740
You can act on the request before and
after.

102
00:05:16.500 --> 00:05:21.117
So now if I go to forward slash,
this is the client on 8081 API and

103
00:05:21.117 --> 00:05:24.519
it's going to rewrite the path,
strip away API,

104
00:05:24.519 --> 00:05:28.180
send the request downstream
without API in the path.

105
00:05:29.940 --> 00:05:32.704
So now if I Go back to my service.

106
00:05:32.704 --> 00:05:33.803
Stop this over here.

107
00:05:33.803 --> 00:05:35.095
That's the client.

108
00:05:35.095 --> 00:05:35.780
Keep that going.

109
00:05:35.780 --> 00:05:37.370
Stop this over here.

110
00:05:37.370 --> 00:05:43.290
Yeah, stop that, stop that, stop that.

111
00:05:43.290 --> 00:05:46.966
Now if I go back over here and
restore the path.

112
00:05:46.966 --> 00:05:52.650
Hello, now that's running.

113
00:05:53.930 --> 00:05:54.954
That's not running.

114
00:05:54.954 --> 00:05:56.780
Just run that now.

115
00:05:56.780 --> 00:06:00.450
Now we go back to the client and
I've restarted it, I think.

116
00:06:00.450 --> 00:06:01.290
Let me just make sure.

117
00:06:05.940 --> 00:06:09.860
Okay, so you go to API hello still works.

118
00:06:10.980 --> 00:06:15.620
It's stripping out API for us and
it's sending that to the backend service.

119
00:06:15.620 --> 00:06:19.368
So that's some of the stuff that
you can do with Spring Cloud and

120
00:06:19.368 --> 00:06:22.420
I didn't want to get too
far into the details here.

121
00:06:22.420 --> 00:06:24.476
One of the really nice
patterns that you can enable,

122
00:06:24.476 --> 00:06:25.980
which I hope we'll look at very soon.

123
00:06:25.980 --> 00:06:26.564
What time is it?

124
00:06:26.564 --> 00:06:31.366
Yeah, we'll look at very soon, is,
is using this gateway as the first port

125
00:06:31.366 --> 00:06:34.535
of call for
all requests that go into your system.

126
00:06:34.535 --> 00:06:40.297
And this is the natural place to do oauth
to secure your system, to restrict access

127
00:06:40.297 --> 00:06:45.738
to the downstream CDN JavaScript and
to restrict access to the back end APIs.

128
00:06:45.738 --> 00:06:50.950
And if your REACT app or Angular app or
whatever is served via this gateway and

129
00:06:50.950 --> 00:06:55.022
your APIs are served via a different
path in the same host and

130
00:06:55.022 --> 00:06:58.045
port in the same gateway, then guess what?

131
00:06:58.045 --> 00:06:59.934
It goes away, cors.

132
00:06:59.934 --> 00:07:01.760
Cors issues just disappear, right?

133
00:07:01.760 --> 00:07:06.572
And if your JWT token is being handled by
the AUTH server and by the gateway itself,

134
00:07:06.572 --> 00:07:10.400
then dealing with JWT tokens
in your JavaScript goes away.

135
00:07:10.400 --> 00:07:13.840
Life becomes much easier by sticking
a nice nimble gateway in front of

136
00:07:13.840 --> 00:07:14.880
your system.

137
00:07:14.880 --> 00:07:16.720
So we'll talk about that
when we go to security.

138
00:07:16.720 --> 00:07:18.287
This stuff is being used by everybody.

139
00:07:18.287 --> 00:07:20.077
Spring Cloud is.

140
00:07:20.077 --> 00:07:25.412
It is the highest of accolades that we
built Spring Cloud on some of the open

141
00:07:25.412 --> 00:07:31.196
source Netflix stuff and then Netflix
rebuilt their stuff on top of us, right.

142
00:07:31.196 --> 00:07:34.952
So their systems use Spring Cloud as
a result and they use Spring boot and

143
00:07:34.952 --> 00:07:36.149
everything, right.

144
00:07:36.149 --> 00:07:40.238
They are a regular speaker at various
Spring 1 conferences and the like.

145
00:07:40.238 --> 00:07:43.274
This is a very good stack for
building stuff at scale and

146
00:07:43.274 --> 00:07:45.590
we've just seen some of the pieces here.

147
00:07:45.590 --> 00:07:47.384
Spring Cloud has all sorts of other stuff,
but

148
00:07:47.384 --> 00:07:49.874
obviously this is just a sampling
of some of my favorite things.

149
00:07:49.874 --> 00:07:53.045
Centralized configuration,
service registration and discovery,

150
00:07:53.045 --> 00:07:54.880
client side load balancing, the like.

151
00:07:54.880 --> 00:07:56.843
And then of course
the Spring Cloud gateway and

152
00:07:56.843 --> 00:07:59.120
the client side load balancing
with the rest client.

