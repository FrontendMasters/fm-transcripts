WEBVTT

1
00:00:00.240 --> 00:00:02.560
&gt;&gt; Josh Long: So
what I wanna do is sub select the data.

2
00:00:02.560 --> 00:00:04.960
I want to get a sub selection
of the data that's available.

3
00:00:04.960 --> 00:00:09.680
Remember I went to start spring IO
over here and I chose PGvector.

4
00:00:09.680 --> 00:00:15.120
And if I had chosen Docker compose,
you would see this Docker compose YAML.

5
00:00:15.120 --> 00:00:18.320
It gives me this docker
image called pgvector.

6
00:00:18.320 --> 00:00:21.920
That's postgres plus one little
extension called vector.

7
00:00:21.920 --> 00:00:24.280
It's an extra type that has
been added to postgres.

8
00:00:24.280 --> 00:00:27.300
If you have a stock standard postgres,
you probably already have it installed.

9
00:00:27.300 --> 00:00:29.060
Maybe you don't, you can do it.

10
00:00:29.060 --> 00:00:29.900
It's not hard, right?

11
00:00:29.900 --> 00:00:35.020
You can just get your operator to install
it for you, your db, dba, they can do it.

12
00:00:35.020 --> 00:00:36.020
It's easy, or you can do it.

13
00:00:36.020 --> 00:00:37.740
It's not a big deal.

14
00:00:37.740 --> 00:00:40.780
Most postgres that are hosted
already have it, for example.

15
00:00:41.899 --> 00:00:44.100
So the vector type is very useful.

16
00:00:44.100 --> 00:00:47.500
And the reason is because we
can use it like a vector store.

17
00:00:47.500 --> 00:00:50.775
Vector stores are databases
that are optimized for

18
00:00:50.775 --> 00:00:53.224
semantic similarity search, okay?

19
00:00:53.224 --> 00:00:57.414
The idea is that you give them some data,
be it some strings or images or audio or

20
00:00:57.414 --> 00:00:59.764
whatever, they turn it into an embedding,

21
00:00:59.764 --> 00:01:03.079
which is just to say they turn
into a bunch of numbers, right?

22
00:01:03.079 --> 00:01:05.689
This is where the complexity
cost comes in, right?

23
00:01:05.689 --> 00:01:09.120
That process of turning data into
embeddings is very expensive.

24
00:01:09.120 --> 00:01:10.013
How can you do that?

25
00:01:10.013 --> 00:01:13.920
Well, you can turn and
create an embedding on your local machine.

26
00:01:13.920 --> 00:01:16.720
If you're using OpenAI,
they actually have a rest endpoint.

27
00:01:16.720 --> 00:01:18.160
You can send some data to them.

28
00:01:19.160 --> 00:01:23.082
It'll give you the bytes, it'll give you
a matrix array of numbers, basically, and

29
00:01:23.082 --> 00:01:25.080
then you store that in the database.

30
00:01:25.080 --> 00:01:26.920
So that's the embedding of the data.

31
00:01:26.920 --> 00:01:32.840
And then given that, you can do cosine
similarity math to find the similar data.

32
00:01:32.840 --> 00:01:34.120
Now do you have to do any of that?

33
00:01:34.120 --> 00:01:34.720
No, of course not.

34
00:01:34.720 --> 00:01:35.960
It's all provided for you by the box.

35
00:01:35.960 --> 00:01:38.815
But my point is vector storage and
embeddings and all that,

36
00:01:38.815 --> 00:01:40.080
it's not that big a deal.

37
00:01:40.080 --> 00:01:44.220
In fact,
we even have a simple vector store

38
00:01:44.220 --> 00:01:47.950
provided out of the box in Spring AI.

39
00:01:47.950 --> 00:01:48.990
It's just in memory.

40
00:01:48.990 --> 00:01:49.550
It's not.

41
00:01:49.550 --> 00:01:50.830
Do not use this in production.

42
00:01:50.830 --> 00:01:55.070
I think we even say don't use this
in production, simple imitation.

43
00:01:55.070 --> 00:01:58.489
Yeah, it's basically,
it's not production worthy, but

44
00:01:58.489 --> 00:02:02.176
you could run this, you don't
have to use PGvector or anything,

45
00:02:02.176 --> 00:02:06.350
you could just run it in memory and
the code is 300 lines of code.

46
00:02:06.350 --> 00:02:07.150
307.

47
00:02:07.150 --> 00:02:08.270
I stand corrected.

48
00:02:08.270 --> 00:02:11.249
And like I said,
most of the interesting stuff is here.

49
00:02:11.249 --> 00:02:15.609
Cosine similarity, just matrix
multiplication, things like that.

50
00:02:15.609 --> 00:02:19.529
This is why GPUs are such all
the rage these last few years, right?

51
00:02:19.529 --> 00:02:23.489
Is because this kind of stuff is
really beneficially done on GPUs.

52
00:02:23.489 --> 00:02:25.599
Okay, so we're going to use PGvector,

53
00:02:25.599 --> 00:02:29.209
that's an implementation of
the spring AI vector store interface.

54
00:02:29.209 --> 00:02:31.449
So PGvector store, there's this, right?

55
00:02:31.449 --> 00:02:36.500
And yeah, it in turn is going to use.

56
00:02:36.500 --> 00:02:37.780
I also happen to love this one as well.

57
00:02:37.780 --> 00:02:41.460
It in turn is going to use
the vector type behind the scenes.

58
00:02:41.460 --> 00:02:43.220
So how is that data gonna get there?

59
00:02:43.220 --> 00:02:44.900
Well, I'm going to initialize it.

60
00:02:44.900 --> 00:02:47.540
I'll go here, say PGvector,
initialize schema.

61
00:02:49.380 --> 00:02:50.292
Now that that's done,

62
00:02:50.292 --> 00:02:53.540
something needs to write the data that's
in our SQL database into the vector store.

63
00:02:53.540 --> 00:02:57.614
So when the application starts up here,
I'm going to do it just once,

64
00:02:57.614 --> 00:02:59.300
not per request.

65
00:02:59.300 --> 00:03:02.191
When the application starts up,
I'll inject the vector store and

66
00:03:02.191 --> 00:03:04.830
I'll inject the dog repository,
which we don't have yet.

67
00:03:04.830 --> 00:03:06.510
I'll recreate it here in a second.

68
00:03:08.270 --> 00:03:14.110
Okay, so interface dog repository,
extends list of CRUD repository.

69
00:03:15.310 --> 00:03:19.414
And we want this dog int id

70
00:03:19.414 --> 00:03:24.110
string description owner.

71
00:03:26.510 --> 00:03:28.750
Did I bring in spring data jdbc?

72
00:03:30.670 --> 00:03:31.230
See, I told you.

73
00:03:31.230 --> 00:03:33.390
I do this all the time,
it's telling somebody else right here.

74
00:03:33.390 --> 00:03:34.590
I forget the same thing.

75
00:03:34.590 --> 00:03:38.990
Spring boot starter data jdbc.

76
00:03:38.990 --> 00:03:39.590
Huzzah.

77
00:03:39.590 --> 00:03:44.990
Okay, okay, and there, and there,
good, so there's a repository.

78
00:03:44.990 --> 00:03:46.914
Now, when the application starts up,

79
00:03:46.914 --> 00:03:49.710
I'm gonna read the data
from the repository, okay?

80
00:03:49.710 --> 00:03:54.164
Nope, I'm gonna read it from
the repository repo.find, for

81
00:03:54.164 --> 00:03:59.807
each dog in the SQL database, I'm gonna
write it out to my vector store, okay?

82
00:03:59.807 --> 00:04:02.050
And I'm going to write it
out as a document, and

83
00:04:02.050 --> 00:04:05.880
I'm gonna use a spring AI document, and
I'm gonna put arbitrary text in there.

84
00:04:05.880 --> 00:04:08.920
It's really up to you what you want to put
in there, as long as you're consistent.

85
00:04:08.920 --> 00:04:10.480
Right?
So I'll put that in there.

86
00:04:10.480 --> 00:04:16.185
I'll say dog.id, dog.name,
dog.description,

87
00:04:16.185 --> 00:04:21.400
okay, I say vector store,
add list of document.

88
00:04:21.400 --> 00:04:26.330
Now this is a document about dogs,
and so I shall call it a document.

89
00:04:27.610 --> 00:04:28.730
Okay, here we go.

90
00:04:31.130 --> 00:04:31.930
Good.

91
00:04:31.930 --> 00:04:35.890
Now I need to tell my AI model
about this client as well.

92
00:04:35.890 --> 00:04:38.250
So I'll configure yet another advisor.

93
00:04:38.250 --> 00:04:42.930
And for this I need to bring in
the Spring AI Advisor module.

94
00:04:42.930 --> 00:04:46.810
This is not on the spring either,
spring AI Advisor Vector store.

95
00:04:48.410 --> 00:04:52.040
Add that in and I'll say,
new question, answer advisor,

96
00:04:52.040 --> 00:04:54.660
passing in the vector store.

97
00:04:54.660 --> 00:04:57.220
So that's a default advisor that
will apply to all requests.

98
00:04:58.340 --> 00:05:01.372
With this advisor, it's going to pre
process the request that we send to

99
00:05:01.372 --> 00:05:04.554
the model by looking at the text of the
model and then going to the vector store

100
00:05:04.554 --> 00:05:07.540
and saying, hey, do you have anything
that might match this query?

101
00:05:07.540 --> 00:05:10.511
It's going to look at the text
in this embedding and say, okay,

102
00:05:10.511 --> 00:05:13.300
I've got something that has
one of the keywords in there.

103
00:05:13.300 --> 00:05:14.660
And here it is.

104
00:05:14.660 --> 00:05:17.460
Hopefully that, that'll be our terrible,
terrible, terrible dog, Prancer.

105
00:05:17.460 --> 00:05:19.773
Let's go ahead and restart.

106
00:05:19.773 --> 00:05:20.380
Prancer.

107
00:05:22.380 --> 00:05:23.580
Okay, so this takes a little while.

108
00:05:23.580 --> 00:05:26.820
Remember I'm talking to OpenAI for
each one of these requests.

109
00:05:26.820 --> 00:05:29.329
So the program is not even started yet,
right?

110
00:05:29.329 --> 00:05:31.020
By the way, I'm using PGvector.

111
00:05:31.020 --> 00:05:33.375
I should say if you're not using Postgres,

112
00:05:33.375 --> 00:05:36.540
you probably still have
access to a vector store.

113
00:05:36.540 --> 00:05:37.980
There are many purpose built ones.

114
00:05:37.980 --> 00:05:41.710
There's Milvus, there's Pinecone,
there's weaviate, there's.

115
00:05:41.710 --> 00:05:42.509
Sure.
These are all

116
00:05:42.509 --> 00:05:45.350
purpose built vector stores that
you can find out in the wild.

117
00:05:45.350 --> 00:05:48.364
There are whole companies around
just doing vector storage, but

118
00:05:48.364 --> 00:05:52.145
there's a million different plug ins or
extensions for existing data stores that

119
00:05:52.145 --> 00:05:56.253
you've probably got in your organization,
like Neo4j, like Mariadb, like Oracle,

120
00:05:56.253 --> 00:06:00.390
like Redis, like Azure, AI, like Apache,
Cassandra, Chroma is a purpose built one.

121
00:06:00.390 --> 00:06:04.319
Elasticsearch, MongoDB, PGVector,
typesense, Azure, Cosmos, DB, et cetera,

122
00:06:04.319 --> 00:06:05.390
et cetera, et cetera.

123
00:06:06.670 --> 00:06:07.750
Okay, is that done?

124
00:06:07.750 --> 00:06:09.548
Yeah.
That took 11 seconds, right?

125
00:06:09.548 --> 00:06:13.180
That, that was me calling the OpenAI
endpoint many different times.

126
00:06:13.180 --> 00:06:15.571
So I'm going to comment that out so
that we don't run that again,

127
00:06:15.571 --> 00:06:16.660
because there's no need.

128
00:06:16.660 --> 00:06:21.460
And the result of that will be this new
table we have here called Vectorstore.

129
00:06:23.060 --> 00:06:27.860
It's got the content and
we've got these embeddings of the data.

130
00:06:27.860 --> 00:06:28.980
So now we go over here.

131
00:06:30.020 --> 00:06:31.700
Do you have any neurotic dogs?

132
00:06:33.780 --> 00:06:36.060
Yes, we do have a neurotic
dog available for adoption.

133
00:06:36.060 --> 00:06:37.800
Me, Prancer, yeah.

134
00:06:37.800 --> 00:06:39.877
Yes.
Described as a demonic neurotic dog that

135
00:06:39.877 --> 00:06:43.480
is not fond of people or other animals and
has a particular dislike for children.

136
00:06:43.480 --> 00:06:46.080
If you're interested in learning more
about Prancer, feel free to ask.

137
00:06:46.080 --> 00:06:47.720
Boy, am I?

138
00:06:47.720 --> 00:06:48.560
This is our dog.

139
00:06:48.560 --> 00:06:49.320
This is the one.

140
00:06:49.320 --> 00:06:53.267
I can feel it.

141
00:06:53.267 --> 00:06:56.760
By the way, this whole time I've
been getting strings back here.

142
00:06:56.760 --> 00:06:57.600
This is the content.

143
00:06:57.600 --> 00:06:58.680
It's a string variable.

144
00:06:58.680 --> 00:07:00.680
You can also get entities, right?

145
00:07:00.680 --> 00:07:05.230
Like if I wanted a strongly typed object,

146
00:07:05.230 --> 00:07:09.910
let's say I did this record dog adoption,

147
00:07:09.910 --> 00:07:15.760
suggestion id, string name,
string description.

148
00:07:17.600 --> 00:07:21.115
If I'm just doing a one shot request and
I know that the response can be made

149
00:07:21.115 --> 00:07:24.560
to comply with that,
well I can return that instead.

150
00:07:24.560 --> 00:07:25.440
So let's try that.

151
00:07:27.120 --> 00:07:30.760
So now, do you have any neurotic dogs?

152
00:07:37.710 --> 00:07:38.430
There you go.

153
00:07:38.430 --> 00:07:42.280
We have Prancer, whose ID is 45, his name
is Prancer and he's described as a demonic

154
00:07:42.280 --> 00:07:46.110
neurotic man hating animal, hating
children, hitting dogs like gremlins.

155
00:07:46.110 --> 00:07:52.150
So it conformed the data that we got back,
it said, yeah, it's Prancer.

156
00:07:52.150 --> 00:07:56.581
And then it said, you want me to give you
the response in terms of this Java object,

157
00:07:56.581 --> 00:07:58.200
A strongly typed job object.

158
00:07:58.200 --> 00:07:59.720
Great, I shall do that.

159
00:07:59.720 --> 00:08:01.560
It layered it on top and then we made it.

160
00:08:01.560 --> 00:08:02.520
So that works for you.

161
00:08:02.520 --> 00:08:04.200
Okay, isn't that nice?

162
00:08:04.200 --> 00:08:06.600
So now you have a foundation on
which to build an abstraction.

163
00:08:06.600 --> 00:08:09.721
This is a strongly typed thing you
can pass around your code base,

164
00:08:09.721 --> 00:08:13.320
not just some freeform text that you
have to parse to get a response, okay?

