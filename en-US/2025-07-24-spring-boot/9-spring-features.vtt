WEBVTT

1
00:00:00.240 --> 00:00:01.723
&gt;&gt; Josh Long: All this time
I haven't been using Spring.

2
00:00:01.723 --> 00:00:04.053
I mean, I use some types
from Spring's packages, but

3
00:00:04.053 --> 00:00:07.040
I'm not using Spring as a framework for
dependency injection.

4
00:00:07.040 --> 00:00:07.960
So let's talk about that.

5
00:00:07.960 --> 00:00:10.800
Let's look at our first Spring
framework example here.

6
00:00:13.440 --> 00:00:17.400
Here I've rewritten that same code to
use Spring to use dependency injection.

7
00:00:17.400 --> 00:00:20.219
And what Spring wants is it wants to
manage your objects in order to do

8
00:00:20.219 --> 00:00:23.440
the same magic trick I just told you
about, where it swaps things out for you.

9
00:00:23.440 --> 00:00:26.612
In order for that to happen,
you need to describe all the objects

10
00:00:26.612 --> 00:00:29.160
in the ecosystem and
how they relate to each other.

11
00:00:29.160 --> 00:00:33.258
So I've got a configuration class and
I've got methods annotated with each one

12
00:00:33.258 --> 00:00:36.160
of these is one of the objects
Spring will manage.

13
00:00:36.160 --> 00:00:39.840
So I've got the customer service,
it's got proxies in there.

14
00:00:39.840 --> 00:00:41.680
I've got my data source.

15
00:00:41.680 --> 00:00:44.960
Technically embedded data source
is a data source still, right?

16
00:00:44.960 --> 00:00:46.000
The code still works.

17
00:00:48.080 --> 00:00:50.160
I've got my embedded database.

18
00:00:50.160 --> 00:00:53.440
I'm using H2 instead of SQLite.

19
00:00:53.440 --> 00:00:55.445
So I go back to my test now and

20
00:00:55.445 --> 00:01:01.150
you can see I'm just creating
the application context in Spring.

21
00:01:01.150 --> 00:01:03.470
Spring has this concept of
an application context.

22
00:01:03.470 --> 00:01:06.879
It is the thing that hosts your
Bean configurations, your objects,

23
00:01:06.879 --> 00:01:09.150
which are the objects that Spring manages.

24
00:01:09.150 --> 00:01:13.791
Here I'm saying create a new application
context given this configuration class,

25
00:01:13.791 --> 00:01:17.580
and from there get a pointer to
the customer service, get a pointer to

26
00:01:17.580 --> 00:01:22.500
the data source, call initialize, and
then do the test just like before, right?

27
00:01:22.500 --> 00:01:27.112
And you can actually prove out.

28
00:01:27.112 --> 00:01:29.140
Here, you can actually
see I'm doing even nicer.

29
00:01:29.140 --> 00:01:32.860
This is a low level test that
is just written using junit.

30
00:01:32.860 --> 00:01:33.688
Over here though,

31
00:01:33.688 --> 00:01:37.220
there's some actual integration in
the testing hierarchy with Spring itself.

32
00:01:37.220 --> 00:01:41.316
And so you can actually tell Spring's
test support to decorate a junit test and

33
00:01:41.316 --> 00:01:45.060
it'll automatically start up
the application context for you.

34
00:01:45.060 --> 00:01:49.623
And you can actually even then ask it
to inject into the parameter list of

35
00:01:49.623 --> 00:01:51.230
the methods under test.

36
00:01:51.230 --> 00:01:54.110
You can inject beans from
the application context.

37
00:01:55.310 --> 00:01:59.003
So I don't have to call application
context getbean datasource class or

38
00:01:59.003 --> 00:02:01.070
getbean customer service class, etc.

39
00:02:01.070 --> 00:02:01.870
This is the same test.

40
00:02:01.870 --> 00:02:07.870
So let's run both of these if I can,
CustomerServiceTest.

41
00:02:07.870 --> 00:02:12.714
Can I run this?

42
00:02:12.714 --> 00:02:15.380
It's the same one,
I gotta run the other one.

43
00:02:15.380 --> 00:02:16.660
Let's just try running this one.

44
00:02:17.940 --> 00:02:18.440
Run.

45
00:02:20.900 --> 00:02:22.980
Okay, then what about this one?

46
00:02:26.020 --> 00:02:27.140
Okay, so you get the idea.

47
00:02:27.140 --> 00:02:30.020
Same results, very,
very fast using Spring.

48
00:02:30.020 --> 00:02:31.381
But it's also a little verbose.

49
00:02:31.381 --> 00:02:32.060
I think we can agree, right?

50
00:02:32.060 --> 00:02:33.380
That's a little bit verbose.

51
00:02:33.380 --> 00:02:37.820
So what things can we do to remove
some of the tedious reworking, right?

52
00:02:37.820 --> 00:02:40.278
We've got a lot of things that
are being duplicatively declared.

53
00:02:40.278 --> 00:02:44.039
So one thing we can do is we can have
Spring automatically discover things for

54
00:02:44.039 --> 00:02:44.700
us, right?

55
00:02:44.700 --> 00:02:46.780
And that's with component scanning.

56
00:02:46.780 --> 00:02:48.300
So rather than having a.

57
00:02:49.820 --> 00:02:54.793
Rather than having all the beans described
in this Java configuration class,

58
00:02:54.793 --> 00:02:57.140
the old one said add configuration.

59
00:02:57.140 --> 00:02:59.823
I can also tell Spring to scan
the current classpath for

60
00:02:59.823 --> 00:03:02.620
objects that have these
marker annotations on them.

61
00:03:02.620 --> 00:03:05.470
These marker annotations are @Component,

62
00:03:05.470 --> 00:03:09.840
so anything that has @Component
on it will itself be picked up.

63
00:03:09.840 --> 00:03:15.200
What that means is this configuration
class is add component.

64
00:03:15.200 --> 00:03:17.939
If I say class foo and I say addcomponent,

65
00:03:17.939 --> 00:03:23.680
then Spring will automatically discover
this type and manage it for you.

66
00:03:23.680 --> 00:03:26.400
You can create your own
meta annotations as well.

67
00:03:26.400 --> 00:03:31.920
So I can call this @FrontendMasterService.

68
00:03:31.920 --> 00:03:33.870
Let's say I have that annotation.

69
00:03:33.870 --> 00:03:35.310
So I'm going to do this.

70
00:03:35.310 --> 00:03:36.910
I'll create that.

71
00:03:36.910 --> 00:03:38.830
Put that there.

72
00:03:38.830 --> 00:03:44.216
Okay, and then now,
because this has add component on it,

73
00:03:44.216 --> 00:03:47.030
Spring will pick it up as well.

74
00:03:47.030 --> 00:03:53.310
So I can go here and
I can say my service, right?

75
00:03:53.310 --> 00:03:54.910
Spring will pick up this.

76
00:03:54.910 --> 00:03:56.872
It'll pick up this class and manage it for

77
00:03:56.872 --> 00:04:00.190
you just as well as it'll pick up
this one using the Spring framework.

78
00:04:02.160 --> 00:04:05.786
And the benefit is that now, on my
business logic, because I have Component

79
00:04:05.786 --> 00:04:08.800
scan here, I don't need to define
a bean method that returns.

80
00:04:11.040 --> 00:04:14.480
I don't need to construct the object for
Spring.

81
00:04:14.480 --> 00:04:18.037
It'll just figure out how to do it based
on whether there's no constructor or

82
00:04:18.037 --> 00:04:22.240
not, whether there is a constructor
that takes no parameters, etc.

83
00:04:22.240 --> 00:04:23.440
So that's a little bit better.

84
00:04:23.440 --> 00:04:26.970
Okay, that's using component scanning.

85
00:04:26.970 --> 00:04:27.930
Where's my readme?

86
00:04:27.930 --> 00:04:29.450
That's using component scanning.

87
00:04:29.450 --> 00:04:31.770
Life cycle is very important in Spring,
right?

88
00:04:31.770 --> 00:04:34.890
So in Spring you have, you know,
it manages your objects for you.

89
00:04:36.170 --> 00:04:38.250
And so if I look at my.

90
00:04:39.290 --> 00:04:41.770
This one, where's my production code?

91
00:04:42.970 --> 00:04:46.330
If I look at lifecycle over here,
there you go.

92
00:04:46.330 --> 00:04:50.010
You can see that Spring has
this concept of a life cycle.

93
00:04:50.010 --> 00:04:52.547
So normally if you have a dependency, you

94
00:04:52.547 --> 00:04:57.670
can express a dependency as a parameter
in the constructor or dependencies.

95
00:04:57.670 --> 00:04:59.510
Here I'm telling Spring I
have a constructor.

96
00:04:59.510 --> 00:05:02.150
I'm expecting a pointer to my JDBC client.

97
00:05:02.150 --> 00:05:02.990
It'll resolve that.

98
00:05:02.990 --> 00:05:08.789
It'll say, okay, I'm managing a bean
of type JDBC client right here.

99
00:05:08.789 --> 00:05:11.584
I'll inject that pointer in
the constructor here, and

100
00:05:11.584 --> 00:05:13.910
then I'll construct this customer service.

101
00:05:15.190 --> 00:05:19.231
But you can also do some validation
after the object has been set up and

102
00:05:19.231 --> 00:05:21.410
is about to be put into production.

103
00:05:21.410 --> 00:05:23.517
By implementing initializing Bean,

104
00:05:23.517 --> 00:05:27.890
this gives you a chance to do some final
validation of the state of the object.

105
00:05:27.890 --> 00:05:33.570
There's also a corresponding interface
called disposable bean, right, like that.

106
00:05:33.570 --> 00:05:35.330
And in that case, you would have a.

107
00:05:36.370 --> 00:05:38.130
What is the disposable bean?

108
00:05:44.210 --> 00:05:45.684
Did I already do it?

109
00:05:45.684 --> 00:05:48.340
I did.
It's called destroy, yeah, sorry.

110
00:05:48.340 --> 00:05:52.820
So you can do @Override
public void destroy, right?

111
00:05:52.820 --> 00:05:54.940
And that comes from that
disposable bean interface.

112
00:05:54.940 --> 00:05:57.491
If you add these,
these are like your final chances to do

113
00:05:57.491 --> 00:06:00.640
validation of the state of the object
before it gets put into use, and

114
00:06:00.640 --> 00:06:04.300
your final chance to clean up the state of
the object before it gets put into use.

115
00:06:04.300 --> 00:06:04.800
Okay.

116
00:06:07.220 --> 00:06:09.252
You don't have to use these interfaces,

117
00:06:09.252 --> 00:06:11.700
though there are annotations
you can use as well.

118
00:06:11.700 --> 00:06:16.390
So post construct and
pre destroy have the same effect.

119
00:06:17.430 --> 00:06:21.342
You annotate a method with these
annotations and Spring will automatically

120
00:06:21.342 --> 00:06:24.641
know to call them right after
the object has been constructed and

121
00:06:24.641 --> 00:06:26.550
right before it's been destroyed.

122
00:06:29.190 --> 00:06:30.790
Now, so we have Spring, right?

123
00:06:30.790 --> 00:06:32.950
Spring has all your objects.

124
00:06:32.950 --> 00:06:35.830
It is the keeper of all
these different objects.

125
00:06:35.830 --> 00:06:39.762
One of the things that's nice about Spring
is that it can visit, it can transform it,

126
00:06:39.762 --> 00:06:41.250
it can inspect all the objects.

127
00:06:41.250 --> 00:06:46.344
It's the single place you can go to effect
change across everything in the code base,

128
00:06:46.344 --> 00:06:46.850
right?

129
00:06:46.850 --> 00:06:48.610
You can ask Spring to do that for you.

130
00:06:48.610 --> 00:06:52.252
One of the natural ways to do that
are through two callback interfaces,

131
00:06:52.252 --> 00:06:54.690
one of which is called
the bean post processor.

132
00:06:54.690 --> 00:06:57.650
How many of you have heard
of bean post processors?

133
00:06:57.650 --> 00:07:00.290
This is a little, like I said,
this is a little in the weeds.

134
00:07:01.410 --> 00:07:03.170
And you're not going to need
to know this right now.

135
00:07:03.170 --> 00:07:04.698
But just, if you wanna understand Spring,

136
00:07:04.698 --> 00:07:06.530
it helps to understand
these two callbacks, okay?

137
00:07:06.530 --> 00:07:11.580
Okay, so
here's a logging bean post processor.

138
00:07:11.580 --> 00:07:16.334
So imagine I've got a scheme where in my
code base I might have objects that have

139
00:07:16.334 --> 00:07:18.940
this magical interface called loggable.

140
00:07:20.300 --> 00:07:24.562
So if any object in my code base, any
service in the system implements loggable,

141
00:07:24.562 --> 00:07:28.325
then I want to automatically turn them
into a proxy that has that logging

142
00:07:28.325 --> 00:07:30.460
instrumentation on it.

143
00:07:30.460 --> 00:07:34.850
So I can register an object of type,
logging of type, bean post processor.

144
00:07:34.850 --> 00:07:39.004
And the contract is I get a pointer to
every single object in the Spring context,

145
00:07:39.004 --> 00:07:40.313
I'm able to inspect it.

146
00:07:40.313 --> 00:07:45.204
And if it implements loggable, I transform
it into a loggable proxy that we saw

147
00:07:45.204 --> 00:07:50.130
earlier that has that Telemetry that
you can log out or send to Prometheus.

148
00:07:50.130 --> 00:07:52.210
Otherwise I just leave it alone.

149
00:07:52.210 --> 00:07:54.850
So I'm getting a chance to visit
every single object in the code base.

150
00:07:54.850 --> 00:07:58.295
So if you wanna administer something,
if you wanna deploy some new capability as

151
00:07:58.295 --> 00:08:00.690
an architect,
you do this in your Spring application.

152
00:08:00.690 --> 00:08:04.930
Register this bean one time,
it'll in turn transform every other bean.

153
00:08:04.930 --> 00:08:08.290
Okay, so let's see that in action.

154
00:08:10.930 --> 00:08:11.890
I'm not sure if we have.

155
00:08:14.850 --> 00:08:16.610
Here we go, this one.

156
00:08:18.290 --> 00:08:19.570
Let's see.

157
00:08:19.570 --> 00:08:20.210
Debug.

158
00:08:22.610 --> 00:08:23.250
There you go.

159
00:08:28.380 --> 00:08:30.457
There you go.
So you can see, I'm able to inspect and

160
00:08:30.457 --> 00:08:32.904
I'm able to discover that this
is a customer service and

161
00:08:32.904 --> 00:08:34.860
it's loggable and so on.

162
00:08:34.860 --> 00:08:37.740
So that all gets done in
this bean post processor.

163
00:08:37.740 --> 00:08:40.100
There's another interface
that runs even earlier.

164
00:08:40.100 --> 00:08:44.077
So the bean post processor gets run on all
the objects before the context is started,

165
00:08:44.077 --> 00:08:47.340
before it's officially ready
to start working for you.

166
00:08:47.340 --> 00:08:50.100
That other interface is called
a bean factory postprocessor.

167
00:08:50.100 --> 00:08:52.220
And that bean factory post processor is.

168
00:08:52.220 --> 00:08:54.551
Is the primordial soup.

169
00:08:54.551 --> 00:08:56.660
That's when Spring starts up.

170
00:08:56.660 --> 00:09:00.877
It looks at all the different objects that
you've got in your system that you tell

171
00:09:00.877 --> 00:09:04.971
it about via annotations, via xml,
via component scanning, via whatever,

172
00:09:04.971 --> 00:09:08.382
all these different channels by
which you can tell Spring, hey,

173
00:09:08.382 --> 00:09:10.460
I want you to manage this object.

174
00:09:10.460 --> 00:09:13.500
At that point,
Spring has a bunch of bean definitions.

175
00:09:13.500 --> 00:09:17.930
These are metamodel objects
that have information like the.

176
00:09:17.930 --> 00:09:20.639
The constructors, the properties,
the scopes, et cetera,

177
00:09:20.639 --> 00:09:22.250
of each of these objects.

178
00:09:22.250 --> 00:09:26.475
And from there, Spring will validate that
all these objects will wire up correctly,

179
00:09:26.475 --> 00:09:30.229
that the references to each other
are valid, that they're not going to be,

180
00:09:30.229 --> 00:09:32.341
that it's not going to
get down the line and

181
00:09:32.341 --> 00:09:36.095
start trying to instantiate all these
different objects and have an error,

182
00:09:36.095 --> 00:09:38.490
because one of these
objects doesn't exist.

183
00:09:38.490 --> 00:09:43.540
This will all get validated, and then
finally they will all be real objects.

184
00:09:43.540 --> 00:09:45.660
But before that happens,
you have bean definitions.

185
00:09:45.660 --> 00:09:46.419
Like I said,

186
00:09:46.419 --> 00:09:50.780
these bean definitions are very important
in the lifecycle of the object.

187
00:09:50.780 --> 00:09:54.780
So here I'm creating a bean
factory post processor.

188
00:09:54.780 --> 00:09:57.541
I'm getting a pointer to
something called the bean factory,

189
00:09:57.541 --> 00:10:00.500
which is the thing that
underpins all of Spring, right?

190
00:10:00.500 --> 00:10:02.464
Before you talk about
application contexts,

191
00:10:02.464 --> 00:10:05.900
before you talk about Spring boot,
you understand that there's a bean factor.

192
00:10:05.900 --> 00:10:08.332
That's the thing that
contains your objects,

193
00:10:08.332 --> 00:10:11.020
it controls the lifecycle
of your objects and so on.

194
00:10:11.020 --> 00:10:14.860
And you can actually inspect it,
you can modify it, you can mutate it.

195
00:10:14.860 --> 00:10:19.266
So here I'm saying, give me all the Beans
that have this interface loggable,

196
00:10:19.266 --> 00:10:22.820
that have this type in their
hierarchy somewhere, loggable.

197
00:10:22.820 --> 00:10:24.460
And it's gonna give me all the bean names.

198
00:10:24.460 --> 00:10:28.127
And I'm saying if this class and
I'm saying give me the class, the type,

199
00:10:28.127 --> 00:10:29.420
this is the type here.

200
00:10:29.420 --> 00:10:35.380
I'm saying if it has that type,
then print out bean blah is a loggable and

201
00:10:35.380 --> 00:10:40.150
is also whatever, scope, and
I can even see the scope.

202
00:10:40.150 --> 00:10:44.870
So in spring, scopes are how many objects,
how many instances of them are there?

203
00:10:44.870 --> 00:10:45.510
By default?

204
00:10:45.510 --> 00:10:48.469
In spring,
every object is created one time.

205
00:10:48.469 --> 00:10:50.630
We call that singleton scope, right?

206
00:10:50.630 --> 00:10:52.070
So it's not per request.

207
00:10:52.070 --> 00:10:53.510
It's not per.

208
00:10:53.510 --> 00:10:54.270
It's just one time.

209
00:10:54.270 --> 00:10:56.950
You have one shared object, which can be.

210
00:10:56.950 --> 00:10:58.390
It's normally just fine.

211
00:10:58.390 --> 00:11:01.601
But imagine you are doing something
where you're keeping a counter for

212
00:11:01.601 --> 00:11:04.070
every single web request that comes in.

213
00:11:04.070 --> 00:11:06.790
You've got one object,
got multiple threads coming in.

214
00:11:06.790 --> 00:11:07.510
What does that mean?

215
00:11:09.590 --> 00:11:12.976
You've got to make sure
that that counter variable,

216
00:11:12.976 --> 00:11:16.070
that int counter is mutated
in a thread safe way.

217
00:11:16.070 --> 00:11:21.270
You need to either use, synchronize or use
an atomic integer or something like that.

218
00:11:21.270 --> 00:11:24.710
So you have thread safety issues you
need to worry about in the weird cases.

219
00:11:24.710 --> 00:11:27.510
In the normal cases,
you're probably never going to hit this.

220
00:11:27.510 --> 00:11:28.550
But just be aware.

221
00:11:29.760 --> 00:11:33.190
Okay, so these interfaces,
basically the way they work,

222
00:11:33.190 --> 00:11:36.840
you have bean factory post processor and
bean post processor.

223
00:11:36.840 --> 00:11:37.720
They're just objects.

224
00:11:37.720 --> 00:11:41.200
You just register them in spring
just like you did everything else.

225
00:11:41.200 --> 00:11:43.520
So here is my configuration.

226
00:11:43.520 --> 00:11:48.137
You can see I registered a logging
bean factory post processor along

227
00:11:48.137 --> 00:11:51.539
with my embedded database and
my JDBC client, and

228
00:11:51.539 --> 00:11:55.620
I've also registered my
logging bean post processor.

229
00:11:55.620 --> 00:11:58.340
The only thing that's different is
that they both have the word static.

230
00:11:58.340 --> 00:12:01.658
Okay, because these things
need to be registered and

231
00:12:01.658 --> 00:12:06.900
running much earlier on in the lifecycle
of the program than these do.

232
00:12:06.900 --> 00:12:11.700
Because in effect these
are going to post process these.

233
00:12:11.700 --> 00:12:14.060
So they need to be spring needs to
know about them much earlier on.

234
00:12:14.060 --> 00:12:14.953
So you make them static.

235
00:12:14.953 --> 00:12:19.300
Okay, good, let's see here.

236
00:12:19.300 --> 00:12:25.230
Readme now, finally,
we just did a SpeedRun of Spring 101.

237
00:12:25.230 --> 00:12:29.106
I don't expect you're going to need
to know all this stuff right now,

238
00:12:29.106 --> 00:12:32.588
but you wouldn't believe how
many people look at spring boot,

239
00:12:32.588 --> 00:12:34.691
which is what I'm about to show you and

240
00:12:34.691 --> 00:12:40.030
don't understand that these underpinnings
have been there for decades before, right?

241
00:12:40.030 --> 00:12:43.130
And so if you want to understand spring
boot, it helps to understand spring,

242
00:12:43.130 --> 00:12:44.190
which is what we just did.

243
00:12:44.190 --> 00:12:46.510
We're looking at core spring
as a component model.

