WEBVTT

1
00:00:00.480 --> 00:00:01.197
&gt;&gt; Josh Long: That's data.

2
00:00:01.197 --> 00:00:04.043
Hopefully you understand data is a thing.

3
00:00:04.043 --> 00:00:05.120
You can do it.

4
00:00:05.120 --> 00:00:08.550
It's the blood of every
application you build, right.

5
00:00:08.550 --> 00:00:11.253
Without data,
there's no point to everything else.

6
00:00:11.253 --> 00:00:17.236
But nonetheless, I think the next natural
step after that will be building something

7
00:00:17.236 --> 00:00:22.903
on the web using HTTP or whatever we're
going to talk about is some of that stuff.

8
00:00:22.903 --> 00:00:23.720
Some of which you've already seen.

9
00:00:23.720 --> 00:00:24.974
You've already seen me
use the REST client.

10
00:00:24.974 --> 00:00:28.820
You saw me build a simple controller
earlier for HTTP endpoints.

11
00:00:28.820 --> 00:00:33.059
But I think there's so
much more to it than just that stuff.

12
00:00:33.059 --> 00:00:35.099
So let's build a new service here,
as always,

13
00:00:35.099 --> 00:00:38.217
going to my second favorite place on
the Internet, start at springreo.

14
00:00:38.217 --> 00:00:40.140
My first favorite place
obviously is production.

15
00:00:40.140 --> 00:00:40.780
I love production.

16
00:00:40.780 --> 00:00:41.592
You should love production.

17
00:00:41.592 --> 00:00:43.060
You should go as early and
often as possible.

18
00:00:43.060 --> 00:00:44.339
Bring the kids, bring the family.

19
00:00:44.339 --> 00:00:44.860
The weather's amazing.

20
00:00:44.860 --> 00:00:45.940
It's the happiest place on earth.

21
00:00:45.940 --> 00:00:47.380
It is better than Disneyland.

22
00:00:47.380 --> 00:00:49.407
But if you haven't been to production,

23
00:00:49.407 --> 00:00:52.158
obviously begin your journey
here at start Spring IO.

24
00:00:52.158 --> 00:00:53.795
And so what we're going to do is I'm
going to build a new application.

25
00:00:53.795 --> 00:00:58.910
I use GraalVM, I'll use the web support,
I use the, the GraphQL support.

26
00:00:58.910 --> 00:01:04.570
I'm going to use GRPC support,
I'm going to use the web support.

27
00:01:04.570 --> 00:01:05.189
Already got that.

28
00:01:05.189 --> 00:01:10.590
Add that, I'm going to add thymeleaf, I
guess maybe, I don't know if I have time.

29
00:01:10.590 --> 00:01:12.070
We'll add hypermedia support.

30
00:01:12.070 --> 00:01:19.590
We'll add dev tools,
obviously and we could add htmx.

31
00:01:19.590 --> 00:01:26.420
I'm not even sure what that addition does,
but you could, I guess that's it.

32
00:01:26.420 --> 00:01:27.460
Is that everything?

33
00:01:27.460 --> 00:01:30.870
Got dev tools, got htmx,

34
00:01:30.870 --> 00:01:35.987
got the GRPC bits, got the web server.

35
00:01:35.987 --> 00:01:36.780
I got hypermedia.

36
00:01:36.780 --> 00:01:40.569
I'm not sure if we'll have time for
that, but we'll try.

37
00:01:40.569 --> 00:01:47.806
Okay, here

38
00:01:47.806 --> 00:01:52.147
we go,

39
00:01:52.147 --> 00:01:55.772
web.

40
00:01:55.772 --> 00:01:57.671
So public, static, void main.

41
00:01:57.671 --> 00:02:01.705
And the first thing we're going to do
is going to build a simple HTTP client.

42
00:02:01.705 --> 00:02:05.950
Yeah and when we build this HTTP client,
we have the old.

43
00:02:05.950 --> 00:02:06.983
The REST client, right.

44
00:02:06.983 --> 00:02:08.150
So you saw me create that earlier.

45
00:02:08.150 --> 00:02:10.110
So let's say I build a.

46
00:02:10.110 --> 00:02:11.070
Let's go to a web service.

47
00:02:11.070 --> 00:02:13.934
We have a web service over here that
we can use for some sample data.

48
00:02:13.934 --> 00:02:17.294
It is called JSON

49
00:02:17.294 --> 00:02:26.654
placeholder.typecode.com users, okay.

50
00:02:26.654 --> 00:02:29.450
Just a nonsense resting
point on the Internet.

51
00:02:29.450 --> 00:02:31.130
Okay, so I'll take that.

52
00:02:31.130 --> 00:02:32.930
And that's going to be the first
thing we're going to do.

53
00:02:32.930 --> 00:02:37.422
We're going to Build a simple

54
00:02:37.422 --> 00:02:43.120
users client, and that's this.

55
00:02:43.120 --> 00:02:44.954
So we want to create a simple client.

56
00:02:44.954 --> 00:02:48.882
I'll build a, it's going to be
a spring bean managed by spring, and

57
00:02:48.882 --> 00:02:51.333
it's going to talk to that REST endpoint.

58
00:02:51.333 --> 00:02:52.840
What data do we want to return back?

59
00:02:52.840 --> 00:02:54.160
That's the real question.

60
00:02:54.160 --> 00:02:56.440
So we're going to have
a few different bits.

61
00:02:56.440 --> 00:03:00.080
Actually, I'll copy and paste this because
I've already done this mapping elsewhere.

62
00:03:02.160 --> 00:03:05.440
So here's the domain of the code.

63
00:03:05.440 --> 00:03:06.810
We've got a user.

64
00:03:06.810 --> 00:03:09.130
The user has an address
which is a rich type.

65
00:03:09.130 --> 00:03:14.073
The address has a string, street street
and then we have a GEO object, and

66
00:03:14.073 --> 00:03:17.363
the GEO has the Latin long,
which is a rich type.

67
00:03:17.363 --> 00:03:22.560
So I'm going to return
a collection of users.

68
00:03:22.560 --> 00:03:24.810
Okay, users.

69
00:03:26.490 --> 00:03:32.090
And when somebody invokes this client,
they'll get back this collection of users.

70
00:03:32.090 --> 00:03:33.658
So we'll say return.

71
00:03:33.658 --> 00:03:35.990
Now, of course, in order for
me to do that, I need the REST client.

72
00:03:35.990 --> 00:03:36.842
The REST client.

73
00:03:36.842 --> 00:03:39.625
You've seen me use the JDBC client.

74
00:03:39.625 --> 00:03:42.430
The REST client is just like that,
except it's for.

75
00:03:42.430 --> 00:03:43.870
Well, guess what, it's for rest.

76
00:03:43.870 --> 00:03:46.990
Actually, it's just for HTTP is,
I guess, the right thing to say.

77
00:03:46.990 --> 00:03:48.383
So I'm injecting the builder.

78
00:03:48.383 --> 00:03:49.462
I'll use that to create the bean.

79
00:03:49.462 --> 00:03:50.196
You could, and

80
00:03:50.196 --> 00:03:53.950
most people do actually centralize
that you can create a configuration.

81
00:03:53.950 --> 00:03:59.650
So you can say web configuration,
whatever, some name like that.

82
00:03:59.650 --> 00:04:04.445
And then you could have a single
bean of type REST client that you

83
00:04:04.445 --> 00:04:09.010
make available for
the entire application context.

84
00:04:09.010 --> 00:04:11.730
But it's useful to have a.

85
00:04:11.730 --> 00:04:12.330
Actually what.

86
00:04:12.330 --> 00:04:12.850
Let's just do that.

87
00:04:12.850 --> 00:04:13.610
I'll do that.
Like that.

88
00:04:13.610 --> 00:04:15.254
And that way when I create this bean,

89
00:04:15.254 --> 00:04:18.236
I can just inject the REST client
directly instead of building it.

90
00:04:18.236 --> 00:04:22.010
Okay, okay so
what does this implementation look like?

91
00:04:22.010 --> 00:04:22.730
This is the hard way.

92
00:04:22.730 --> 00:04:23.330
I don't want to write.

93
00:04:23.330 --> 00:04:26.380
This is not the code that I
would write most of the time.

94
00:04:26.380 --> 00:04:28.820
But at least you can see how
it's going to work, right?

95
00:04:28.820 --> 00:04:32.008
So remember, the base URL for
the REST client is right here.

96
00:04:32.008 --> 00:04:35.759
So what we need to specify at this
point is just the last mile, right?

97
00:04:35.759 --> 00:04:36.765
The users.

98
00:04:36.765 --> 00:04:42.820
Then we retrieve the data as the following
type of data and that's it, right?

99
00:04:42.820 --> 00:04:44.900
Body of that list.

100
00:04:46.980 --> 00:04:47.860
What is this then?

101
00:04:49.300 --> 00:04:54.212
Retrieve body.

102
00:04:54.212 --> 00:04:55.070
Okay, wait, wait, wait.

103
00:04:55.070 --> 00:04:55.782
It's a collection of.

104
00:04:55.782 --> 00:04:56.550
Okay, that's the other thing.

105
00:04:56.550 --> 00:04:58.388
So that's a great point.

106
00:04:58.388 --> 00:05:03.190
If this was a single user, I could
return a user class, but it's not right.

107
00:05:03.190 --> 00:05:05.870
This is a collection clearly of users.

108
00:05:07.070 --> 00:05:12.075
This gets us to a fundamental
limitation in Java's generics that

109
00:05:12.075 --> 00:05:18.183
you don't have in NET Land, which is
we don't have reified generics, right?

110
00:05:18.183 --> 00:05:23.112
Which means that the runtime,
at runtime, when you have a list

111
00:05:23.112 --> 00:05:27.949
of string at runtime,
there's no way using reflection to ask

112
00:05:27.949 --> 00:05:32.987
this instance variable what
the generic parameter is, right?

113
00:05:32.987 --> 00:05:34.220
That doesn't exist.

114
00:05:34.220 --> 00:05:39.066
So array, list of string,
come on, string, whatever, there.

115
00:05:39.066 --> 00:05:42.070
So that that instance variable has
no generic parameter at runtime.

116
00:05:42.070 --> 00:05:44.740
If I use Reflection, I will get just this.

117
00:05:46.500 --> 00:05:47.900
It looks like a list of objects.

118
00:05:47.900 --> 00:05:49.140
There's no generic type.

119
00:05:51.860 --> 00:05:58.420
This means that there's no such
thing as list of user class.

120
00:05:59.459 --> 00:06:00.300
That doesn't exist.

121
00:06:00.300 --> 00:06:01.860
It's not possible.

122
00:06:01.860 --> 00:06:06.623
So we need some way to capture that shape.

123
00:06:06.623 --> 00:06:11.581
Because what we're going to do is we want
to get the JSON data that comes back from

124
00:06:11.581 --> 00:06:16.317
this endpoint, and we need to tell this
client to turn it into something that

125
00:06:16.317 --> 00:06:18.616
conforms to this Java object shape.

126
00:06:18.616 --> 00:06:19.830
We got JSON coming back.

127
00:06:19.830 --> 00:06:24.270
We have a Java object, but the shape
is a collection, a list of users.

128
00:06:24.270 --> 00:06:25.669
It's not just a user.

129
00:06:25.669 --> 00:06:28.070
And there's no way for me to pass in this.

130
00:06:28.070 --> 00:06:29.430
That doesn't work.

131
00:06:29.430 --> 00:06:34.070
So how can I, at runtime capture
the idea of a collection of t?

132
00:06:34.070 --> 00:06:38.594
Well, turns out there's a bit of
a hack here, a bit of a gimmick,

133
00:06:38.594 --> 00:06:43.532
which is if you bake a generic parameter
into the super type hierarchy,

134
00:06:43.532 --> 00:06:47.650
I know of a class that
actually does get reified.

135
00:06:47.650 --> 00:06:48.570
So what do I mean by that?

136
00:06:48.570 --> 00:06:54.450
I can say user list
extends arraylist of user.

137
00:06:54.450 --> 00:06:57.030
Now, because I'm extending
a concrete type,

138
00:06:57.030 --> 00:06:59.553
then this type does have
a generic parameter.

139
00:06:59.553 --> 00:07:02.041
I can get that.

140
00:07:02.041 --> 00:07:04.715
It's a user, okay?

141
00:07:04.715 --> 00:07:05.863
And so if you understand that,

142
00:07:05.863 --> 00:07:09.370
then there's something called
the parameterized type token pattern.

143
00:07:09.370 --> 00:07:14.170
And basically like what I just did here,
I created a user list.

144
00:07:14.170 --> 00:07:18.940
This also works if I say user users,
new array list and

145
00:07:18.940 --> 00:07:24.650
then do that,
I'm creating an anonymous inner class.

146
00:07:24.650 --> 00:07:25.450
See that?

147
00:07:25.450 --> 00:07:27.050
Isn't that hideous?

148
00:07:27.050 --> 00:07:30.116
So I'm creating an anonymous inner class,
but because it's an anonymous,

149
00:07:30.116 --> 00:07:31.540
because I have this curly bracket.

150
00:07:31.540 --> 00:07:36.346
Curly bracket that's technically
a subclass of arraylist that I'm defining

151
00:07:36.346 --> 00:07:40.070
one place and it's never used again,
but that still works.

152
00:07:40.070 --> 00:07:43.790
If I inspect this type at
runtime via reflection,

153
00:07:43.790 --> 00:07:48.497
I can deduce that the generic
parameter is of type user, okay?

154
00:07:48.497 --> 00:07:53.355
So there is a way to smuggle in from
design time to runtime the generic

155
00:07:53.355 --> 00:07:55.140
parameter of a type.

156
00:07:55.140 --> 00:07:59.721
So we have that packaged up in a reusable
Format called a parameterized type

157
00:07:59.721 --> 00:08:00.530
reference.

158
00:08:03.010 --> 00:08:05.788
You can see it's a thing
that you parameterize and

159
00:08:05.788 --> 00:08:08.050
then you have to create a subclass of it.

160
00:08:09.890 --> 00:08:11.890
Those curly brackets
are doing a lot of work here.

161
00:08:12.930 --> 00:08:14.290
So you do private final.

162
00:08:14.290 --> 00:08:15.170
There you go.

163
00:08:15.170 --> 00:08:16.130
Get rid of all this.

164
00:08:17.410 --> 00:08:21.661
And now I'm going to ask it for this.

165
00:08:21.661 --> 00:08:25.777
I'll say instead of just giving it a class
literal, which I can totally do for

166
00:08:25.777 --> 00:08:29.591
single things, I'm going to give
it a parameterized type reference.

167
00:08:29.591 --> 00:08:30.752
Now let's try this.

168
00:08:30.752 --> 00:08:36.226
I'm going to inject this

169
00:08:36.226 --> 00:08:40.923
client here, okay.

170
00:08:40.923 --> 00:08:42.422
There you go.

171
00:08:42.422 --> 00:08:46.646
When the program starts up, I'll inject
the users client and call users and

172
00:08:46.646 --> 00:08:49.400
get all the data and then print it out.

173
00:08:49.400 --> 00:08:51.679
There we go.
See, it's worked.

174
00:08:51.679 --> 00:08:56.520
So now we have a nice type safe
reference to all the JSON data we got.

175
00:08:56.520 --> 00:09:01.240
The GEO was mapped to the geo
object there and not bad.

176
00:09:01.240 --> 00:09:04.846
But you have to understand that weird
thing with parameterized type references

177
00:09:04.846 --> 00:09:05.718
to make that work.

178
00:09:05.718 --> 00:09:08.000
In fact,
this is not even as bad as it looks.

179
00:09:08.000 --> 00:09:09.510
You can actually do that.

180
00:09:09.510 --> 00:09:11.043
So it means you're only
declaring the types once,

181
00:09:11.043 --> 00:09:12.520
which is still a little bit better.

182
00:09:12.520 --> 00:09:13.960
You can rerun that like this.

183
00:09:16.530 --> 00:09:18.367
Same thing.
Okay, so that does work, but

184
00:09:18.367 --> 00:09:19.406
it's a little ugly.

185
00:09:19.406 --> 00:09:20.650
So everybody clear on this?

186
00:09:20.650 --> 00:09:21.410
This is a weird thing.

187
00:09:21.410 --> 00:09:23.730
It's not spring, it's just Java itself.

188
00:09:23.730 --> 00:09:24.850
You have to do something like this.

189
00:09:24.850 --> 00:09:26.730
Every framework has something like this.

190
00:09:26.730 --> 00:09:28.584
But for the spring ecosystem,

191
00:09:28.584 --> 00:09:33.288
we support passing parameterized type
references around where it makes sense

192
00:09:33.288 --> 00:09:37.810
when you want to get a generic
thing whose parameter is typed.

193
00:09:37.810 --> 00:09:39.450
Okay, so this is a low level client.

194
00:09:39.450 --> 00:09:42.690
I'm using an HTTP client to make
a get request passing in the URL.

195
00:09:42.690 --> 00:09:44.039
I've already got a base URL.

196
00:09:44.039 --> 00:09:45.136
Right, that's up here.

197
00:09:45.136 --> 00:09:46.370
Right, I've defined this bean.

198
00:09:46.370 --> 00:09:47.559
It's got a base URL.

199
00:09:47.559 --> 00:09:50.992
I'm injecting that REST client here and
I'm going to the base URL users and

200
00:09:50.992 --> 00:09:52.530
I'm getting the response back.

201
00:09:52.530 --> 00:09:55.558
But this is a lot of work and if I had
to do this for every single endpoint and

202
00:09:55.558 --> 00:09:58.650
every single service, then things
would get out of hand pretty quickly.

203
00:09:58.650 --> 00:10:00.203
So there's actually
a nicer way to do this.

204
00:10:00.203 --> 00:10:02.208
There's declarative
interface based clients.

205
00:10:02.208 --> 00:10:05.885
Okay, so the way that works is
you create an interface and

206
00:10:05.885 --> 00:10:11.420
I'm going to call this user's client or
I'll call it declarative users client.

207
00:10:11.420 --> 00:10:16.035
And here you annotate not with gitmapping,
which is the component model that

208
00:10:16.035 --> 00:10:21.005
we'll look at in a minute for Exporting
HTTP endpoints, but rather Git Exchange,

209
00:10:21.005 --> 00:10:23.980
which is the client side analog to that.

210
00:10:23.980 --> 00:10:27.100
So here I'll say collection of user users.

211
00:10:28.700 --> 00:10:30.060
So now I've got this interface.

212
00:10:30.060 --> 00:10:30.980
One of the things that's.

213
00:10:30.980 --> 00:10:35.632
So remember Spring Framework 7 and
Spring Boot 4 come out later this year.

214
00:10:35.632 --> 00:10:40.100
One of the things that I helped work on,
and that has been a long time in coming,

215
00:10:40.100 --> 00:10:43.620
is to automate away the ceremony
I'm about to show you.

216
00:10:43.620 --> 00:10:46.386
So you can literally do something
like this with an annotation and

217
00:10:46.386 --> 00:10:47.380
that'll be enough.

218
00:10:47.380 --> 00:10:49.300
But at the moment it's not the case.

219
00:10:49.300 --> 00:10:51.220
I'm going to show you some ceremony.

220
00:10:51.220 --> 00:10:51.940
Don't cry.

221
00:10:51.940 --> 00:10:53.940
It'll be fine in just a few months.

222
00:10:55.940 --> 00:11:02.510
So what I'm going to do is I'm going to
create a declarative users client, okay.

223
00:11:02.510 --> 00:11:07.390
And I'll say return HTTP
service proxy factory.

224
00:11:07.390 --> 00:11:08.990
Great.
With names.

225
00:11:08.990 --> 00:11:10.230
Create the Exchange adapter.

226
00:11:10.230 --> 00:11:17.076
So it'll be a REST
client.adapter.create passing

227
00:11:17.076 --> 00:11:22.254
in the HTTP client build dot That I know.

228
00:11:22.254 --> 00:11:26.542
So normally if you had more than one of
these things and you very well should,

229
00:11:26.542 --> 00:11:29.424
then you just extract that
out into a bean, right?

230
00:11:29.424 --> 00:11:34.649
So httpservice proxy factory.

231
00:11:34.649 --> 00:11:35.560
Right, like that.

232
00:11:37.400 --> 00:11:38.960
So that would be pretty reasonable.

233
00:11:38.960 --> 00:11:43.565
You'd have a my HTTP service proxy factory
and then you could just reuse that.

234
00:11:43.565 --> 00:11:48.978
I would just inject this into this.

235
00:11:48.978 --> 00:11:55.670
Okay, and so now you can just say that or
just call it there.

236
00:11:55.670 --> 00:11:56.990
Okay, whatever.

237
00:11:56.990 --> 00:11:58.350
So now as I add more.

238
00:11:58.350 --> 00:12:03.734
So basically you do this ceremony once and
then as you want to add more declarative

239
00:12:03.734 --> 00:12:08.663
interface based clients to the system and
you can have multiple methods.

240
00:12:08.663 --> 00:12:12.579
I don't know if this one actually supports
an id for example, but let's see.

241
00:12:12.579 --> 00:12:15.677
Let me try, okay.

242
00:12:15.677 --> 00:12:17.070
Path variable.

243
00:12:17.070 --> 00:12:17.910
I don't know if that works.

244
00:12:17.910 --> 00:12:19.016
Let's try it.

245
00:12:19.016 --> 00:12:19.630
Does this work?

246
00:12:20.990 --> 00:12:21.825
Yes, it does.

247
00:12:21.825 --> 00:12:24.550
Okay, so
that's a free implementation there.

248
00:12:24.550 --> 00:12:26.701
So let's just try that out.

249
00:12:26.701 --> 00:12:29.294
Here we go.

250
00:12:29.294 --> 00:12:32.954
Okay, there's that and

251
00:12:32.954 --> 00:12:37.840
then users, client, dot user.

252
00:12:37.840 --> 00:12:39.891
What did I call it?

253
00:12:39.891 --> 00:12:40.830
User surely.

254
00:12:42.190 --> 00:12:43.030
That's the simple one.

255
00:12:43.030 --> 00:12:44.030
I want the declarative one.

256
00:12:46.480 --> 00:12:48.720
Okay.
User, client, user.

257
00:12:48.720 --> 00:12:50.560
And the ID is one.

258
00:12:50.560 --> 00:12:58.331
I'll print it out, okay.

259
00:12:59.585 --> 00:13:03.035
System out,

260
00:13:03.035 --> 00:13:08.685
take 512, okay.

261
00:13:08.685 --> 00:13:11.465
So you can see there's the single user and

262
00:13:11.465 --> 00:13:15.370
here's everything else right
from the endpoint, okay.

263
00:13:15.370 --> 00:13:20.610
So the burden, this is what you had
to write to get that client, right.

264
00:13:20.610 --> 00:13:24.930
But there is some machinery
that you had to do that's this.

265
00:13:27.010 --> 00:13:31.057
Okay, now for any new services, you
just define a new bean of this type and

266
00:13:31.057 --> 00:13:32.570
then create an interface.

267
00:13:32.570 --> 00:13:33.930
And it's pretty straightforward.

268
00:13:33.930 --> 00:13:35.730
You can move really quickly at this point.

269
00:13:35.730 --> 00:13:37.650
But you do need to have this.

270
00:13:37.650 --> 00:13:38.600
And why would you want to have this?

271
00:13:38.600 --> 00:13:41.200
Well, because you have a question
around your REST client.

272
00:13:41.200 --> 00:13:43.080
So behind the scenes
there's a REST client.

273
00:13:43.080 --> 00:13:45.092
Spring's providing this REST client.

274
00:13:45.092 --> 00:13:49.290
It in turn can adapt like four different
libraries that you can use for HTTP,

275
00:13:49.290 --> 00:13:51.600
actual low level HTTP libraries.

276
00:13:51.600 --> 00:13:55.005
And by default I'm not even sure
what it's using anymore, but

277
00:13:55.005 --> 00:13:56.880
it's probably using the JDK one.

278
00:13:56.880 --> 00:14:00.760
There's actually two different
JDK options now in Java.

279
00:14:00.760 --> 00:14:01.600
Like if you want to use.

280
00:14:01.600 --> 00:14:05.700
There's the old URL connection from
30 years ago that can work, but

281
00:14:05.700 --> 00:14:09.190
it doesn't support like options or
some things like that.

282
00:14:09.190 --> 00:14:09.950
It's not great.

283
00:14:09.950 --> 00:14:12.590
It works on older JVMs that
are like before Java 11.

284
00:14:12.590 --> 00:14:16.090
And then there's a simple JDK
client I think it's called.

285
00:14:16.090 --> 00:14:17.430
And that one's also probably being.

286
00:14:17.430 --> 00:14:18.710
It's probably what's being used here.

287
00:14:18.710 --> 00:14:23.562
But my point is the REST client will
dynamically adapt to whatever HTTP runtime

288
00:14:23.562 --> 00:14:27.630
it can find, not runtime library
it can find on the class path.

289
00:14:27.630 --> 00:14:31.809
And these REST clients, as you can see,
I've configured it with a base URL.

290
00:14:31.809 --> 00:14:34.208
So if you want to have like the full URL,
you don't.

291
00:14:34.208 --> 00:14:37.978
If you want to just reuse the same REST
client for all of your client use cases,

292
00:14:37.978 --> 00:14:39.030
then don't do that.

293
00:14:39.030 --> 00:14:43.508
Right, you can just put
the REST client URL here.

294
00:14:43.508 --> 00:14:44.730
Git mapping.

295
00:14:44.730 --> 00:14:47.160
Sorry, exchange mapping.

296
00:14:47.160 --> 00:14:51.736
Is it request mapping?

297
00:14:51.736 --> 00:14:57.495
I think it's this.

298
00:14:57.495 --> 00:15:01.405
So let's see if that works.

299
00:15:01.405 --> 00:15:02.970
So should still work.

300
00:15:06.970 --> 00:15:10.410
It does not URI with unidentified scheme.

301
00:15:13.770 --> 00:15:20.370
So maybe not.

302
00:15:20.370 --> 00:15:21.610
Maybe I have to do it here.

303
00:15:21.610 --> 00:15:22.490
Yeah, that's probably true.

304
00:15:22.490 --> 00:15:23.930
That's ugly.
I don't like that at all.

305
00:15:23.930 --> 00:15:33.155
So let's see.

306
00:15:33.155 --> 00:15:37.460
Yeah, okay, so that works,
but it's ugly, right?

307
00:15:37.460 --> 00:15:40.380
That's why I like to centralize it
instead of having to restipulate it.

308
00:15:40.380 --> 00:15:45.020
You could do static final string,

309
00:15:45.020 --> 00:15:49.987
base URL and then that'll work too.

310
00:15:49.987 --> 00:15:53.529
But makes me want to take a shower.

311
00:15:53.529 --> 00:15:55.452
So you've got your choices, okay.

312
00:15:55.452 --> 00:15:57.920
I would just put it in the REST client and
then make sure I have the right one.

313
00:15:57.920 --> 00:16:00.374
Okay, which brings us to a great point.

314
00:16:00.374 --> 00:16:04.975
If I have two REST clients that
spring this is the secured one or

315
00:16:04.975 --> 00:16:08.071
whatever, or this one has the base URL and

316
00:16:08.071 --> 00:16:13.939
spring has to answer the question of which
one to inject, which one to give me.

317
00:16:13.939 --> 00:16:16.433
If I define two beans of the same type,
well,

318
00:16:16.433 --> 00:16:18.544
we get into a question of qualifiers.

319
00:16:18.544 --> 00:16:21.310
So yeah, it gets very complicated,
doesn't it?

320
00:16:21.310 --> 00:16:22.430
So where's my use of it?

321
00:16:22.430 --> 00:16:23.030
It's up here.

322
00:16:23.030 --> 00:16:24.150
I'm injecting the REST client.

323
00:16:24.150 --> 00:16:27.073
You can see Intellij is saying,
hey, cannot auto wire.

324
00:16:27.073 --> 00:16:31.148
There's more than one bean of type
rest client in the context, okay?

325
00:16:31.148 --> 00:16:32.710
So you need to qualify.

326
00:16:32.710 --> 00:16:34.019
So a couple options here.

327
00:16:34.019 --> 00:16:40.990
You can do map of string, this and
basically in this case they're.

328
00:16:42.040 --> 00:16:45.759
I can get the bean by
the name one by the name.

329
00:16:45.759 --> 00:16:48.120
So the name is secured
rest client by default.

330
00:16:48.120 --> 00:16:53.736
That's this if I want
to avoid magic strings,

331
00:16:53.736 --> 00:16:59.497
right, I can say secured rest client,
right?

332
00:16:59.497 --> 00:17:02.840
And then over here I can say name is that.

333
00:17:02.840 --> 00:17:05.066
And then it doesn't matter what
you call this over here, right?

334
00:17:05.066 --> 00:17:09.370
It's completely relevant now and
over here I can use that constant.

335
00:17:11.530 --> 00:17:12.570
That works as well.

336
00:17:12.570 --> 00:17:13.450
That's one option.

337
00:17:13.450 --> 00:17:17.044
The other option, instead of injecting
all of them and then disambiguating,

338
00:17:17.044 --> 00:17:20.090
that way you can inject a single one and
use a qualifier.

339
00:17:20.090 --> 00:17:23.250
So like that and
then rest client and then that.

340
00:17:23.250 --> 00:17:27.210
Okay, there you go.

341
00:17:27.210 --> 00:17:32.730
So that qualifier is saying find the bean
that has this name, this match, okay?

342
00:17:32.730 --> 00:17:34.320
And this is very common for all of Spring.

343
00:17:34.320 --> 00:17:36.290
It has nothing to do
with Spring specifically,

344
00:17:36.290 --> 00:17:37.870
just rest programming for all.

345
00:17:37.870 --> 00:17:40.051
Any place where you have more
than one of type foo and

346
00:17:40.051 --> 00:17:43.310
you want to find just a particular one,
you can even go a step further.

347
00:17:43.310 --> 00:17:47.270
Remember, annotations in Spring
are composable, so you can compose them.

348
00:17:47.270 --> 00:17:50.350
You can actually create
a meta annotation like this.

349
00:17:50.350 --> 00:17:51.870
Copy and paste that.

350
00:17:51.870 --> 00:17:54.830
And I can say, let's say I have qualifier,

351
00:17:54.830 --> 00:17:58.670
I'm going to add this,
I'm going to call this secured.

352
00:18:00.110 --> 00:18:00.670
Whatever.

353
00:18:02.040 --> 00:18:08.520
Now I've got my own custom composable
qualifier, my custom secured annotation.

354
00:18:08.520 --> 00:18:13.000
Now at the call site secured.

355
00:18:16.759 --> 00:18:18.280
Put that in there.

356
00:18:18.280 --> 00:18:22.440
At the call site I'm going to use
secured on the REST client and

357
00:18:22.440 --> 00:18:27.880
at the definition I'll use ecured,
so I no longer need that anymore.

358
00:18:27.880 --> 00:18:31.483
Okay, so that should do as well.

359
00:18:32.765 --> 00:18:38.858
Did I use the REST plant

360
00:18:38.858 --> 00:18:44.368
somewhere else?

361
00:18:44.368 --> 00:18:47.960
I did in the first one.

362
00:18:47.960 --> 00:18:48.734
Yeah, here.

363
00:18:48.734 --> 00:18:51.240
Okay, well, clearly this one
shouldn't be involved anymore.

364
00:18:53.970 --> 00:18:55.086
There you go.
So you see,

365
00:18:55.086 --> 00:18:57.930
you can use qualifiers
to cleanly disambiguate.

366
00:18:57.930 --> 00:19:01.187
You can even make them type safe by
avoiding magic strings by creating your

367
00:19:01.187 --> 00:19:02.248
own meta annotations.

368
00:19:02.248 --> 00:19:04.563
Okay, that's just do that.

369
00:19:04.563 --> 00:19:07.424
So you can have like, maybe you have
one implementation that works with

370
00:19:07.424 --> 00:19:09.531
the iOS store and
another one that does a Play Store.

371
00:19:09.531 --> 00:19:12.250
And you need integrations in the back and
you want both available and

372
00:19:12.250 --> 00:19:14.770
you need different call sites
to have different call flows.

373
00:19:14.770 --> 00:19:17.012
Okay, so now I've got these
declarative interface clients.

374
00:19:17.012 --> 00:19:19.319
I've got a manual rest
client based client.

375
00:19:19.319 --> 00:19:20.370
Either way, I've got a client.

