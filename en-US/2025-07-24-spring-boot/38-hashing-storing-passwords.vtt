WEBVTT

1
00:00:00.080 --> 00:00:02.320
&gt;&gt; Josh Long: And the reason it won't let
me log in is because I got spring security

2
00:00:02.320 --> 00:00:02.960
in the class path.

3
00:00:02.960 --> 00:00:04.520
It's asking me for
a username and password.

4
00:00:04.520 --> 00:00:05.680
What username and password?

5
00:00:05.680 --> 00:00:10.320
Well, by default, unless you specify
something, you don't get one.

6
00:00:10.320 --> 00:00:11.200
Right?

7
00:00:11.200 --> 00:00:13.760
It used to be that you'd get like
a default username and password.

8
00:00:13.760 --> 00:00:14.640
I don't even get that.

9
00:00:14.640 --> 00:00:16.760
So the question is, what do I want to do?

10
00:00:16.760 --> 00:00:18.880
Well, I first have to answer
the question of authentication.

11
00:00:18.880 --> 00:00:20.400
Who is making this request.

12
00:00:20.400 --> 00:00:23.920
I can do an in memory user system, e.g.

13
00:00:23.920 --> 00:00:28.590
in memory user Details manager, return
new in memory using Details manager.

14
00:00:28.590 --> 00:00:31.310
And I'm going to do a terrible thing
that you should never ever do.

15
00:00:31.310 --> 00:00:36.390
I am going to create some memories, create
some users in memory whose passcodes.

16
00:00:36.390 --> 00:00:39.950
I'll just store it in plain text
here because I'm a terrible person.

17
00:00:39.950 --> 00:00:42.755
So user with J long hello,

18
00:00:42.755 --> 00:00:48.630
come back with j long roles
user password is password.

19
00:00:48.630 --> 00:00:50.270
Now where does that password come from?

20
00:00:50.270 --> 00:00:53.281
Well, I could just provide
a plain text password, but

21
00:00:53.281 --> 00:00:57.680
you want to encode those passwords,
they should never be stored in plain text.

22
00:00:57.680 --> 00:01:01.179
So what I'm going to do is I'm going to
use a hierarchy in spring security called

23
00:01:01.179 --> 00:01:03.240
the password encoder, right?

24
00:01:03.240 --> 00:01:08.198
And let me inject then that
password encoder pw and

25
00:01:08.198 --> 00:01:10.920
I'll say pw dot encode pw.

26
00:01:10.920 --> 00:01:12.577
That's the.
So the password,

27
00:01:12.577 --> 00:01:15.800
the raw encoded version
of the password is this.

28
00:01:15.800 --> 00:01:18.470
It's VAR PW1, right?

29
00:01:18.470 --> 00:01:19.990
Encoded PW.

30
00:01:21.430 --> 00:01:24.577
I've passed that into
the password here and

31
00:01:24.577 --> 00:01:27.990
I'm going to pass that
into the user's thing.

32
00:01:27.990 --> 00:01:29.110
Now this is in memory.

33
00:01:29.110 --> 00:01:32.550
Let's print out the encoded
version of the password.

34
00:01:32.550 --> 00:01:33.749
So here we go.

35
00:01:33.749 --> 00:01:34.710
Start that up again.

36
00:01:36.230 --> 00:01:36.750
There you go.

37
00:01:36.750 --> 00:01:37.910
Actually it came out.

38
00:01:37.910 --> 00:01:39.670
So look at what has just happened here.

39
00:01:40.950 --> 00:01:44.310
It gave me the encrypted encoded
version of the password.

40
00:01:44.310 --> 00:01:44.950
That's this bit.

41
00:01:45.970 --> 00:01:46.770
But what's this bit?

42
00:01:48.210 --> 00:01:49.130
That's the prefix.

43
00:01:49.130 --> 00:01:54.130
That prefix tells us what encoding
was used to encode that password.

44
00:01:54.130 --> 00:01:57.610
And the reason that we do this is because
we want to be able to support migration.

45
00:01:57.610 --> 00:02:01.169
Right now bcrypt is widely considered
to be the most secure encoding.

46
00:02:01.169 --> 00:02:02.770
So we use that by default.

47
00:02:02.770 --> 00:02:04.690
But what happens tomorrow?

48
00:02:04.690 --> 00:02:09.287
What if the much vaunted quantum security

49
00:02:09.287 --> 00:02:13.740
threat apocalypse arises tomorrow?

50
00:02:13.740 --> 00:02:16.540
Right?
What if they break bcrypt or something?

51
00:02:16.540 --> 00:02:19.980
Okay, so
now we need a post quantum encoder.

52
00:02:19.980 --> 00:02:21.820
So spring security deploys one of those.

53
00:02:21.820 --> 00:02:22.940
Okay, great.

54
00:02:22.940 --> 00:02:27.500
But what about the old passwords,
those old passwords?

55
00:02:27.500 --> 00:02:30.500
What if somebody tries to log in and
these are stored in the Database.

56
00:02:30.500 --> 00:02:32.620
You've got a database table full of users.

57
00:02:32.620 --> 00:02:36.790
Somebody tries to log in with
those old passwords, right?

58
00:02:36.790 --> 00:02:39.430
With the passwords that are stored
in the database using bcrypt.

59
00:02:39.430 --> 00:02:42.150
Spring security is going to go
to the database and say hey,

60
00:02:42.150 --> 00:02:45.260
it's going to go to this in memory
thing or to an actual database and

61
00:02:45.260 --> 00:02:48.390
say I've got an encoded version
of this password in the database.

62
00:02:48.390 --> 00:02:51.967
Never at rest, never stored in plain text,
but it's encoded and

63
00:02:51.967 --> 00:02:54.766
I'm going to encode
the current user's request,

64
00:02:54.766 --> 00:02:58.950
the current password that the challenge
that was presented to the service.

65
00:02:58.950 --> 00:03:00.870
I'm going to encode that on this request.

66
00:03:01.920 --> 00:03:04.560
I'm encoding it with
the post quantum encoder.

67
00:03:04.560 --> 00:03:06.880
But this old password is using Bcrypt.

68
00:03:06.880 --> 00:03:08.480
So they're not going to work, right?

69
00:03:08.480 --> 00:03:11.200
So what I have to do is I have to encode,
they're not going to match.

70
00:03:11.200 --> 00:03:12.320
That's how security works.

71
00:03:12.320 --> 00:03:15.120
I have an encoded
password in the database.

72
00:03:15.120 --> 00:03:16.920
I have a non encoded
password from the user.

73
00:03:16.920 --> 00:03:20.700
I encode that password from the user,
turn it into the same encoding as is in

74
00:03:20.700 --> 00:03:24.160
the database and
if they match then I allow access.

75
00:03:24.160 --> 00:03:25.640
I need to know what encoding was.

76
00:03:25.640 --> 00:03:29.410
So we prefixed the passwords we
with a string in this case bcrypt.

77
00:03:29.410 --> 00:03:30.090
Right?

78
00:03:30.090 --> 00:03:31.130
And the same is true for old.

79
00:03:31.130 --> 00:03:34.570
Like if you have old
sha256 first of all don't.

80
00:03:34.570 --> 00:03:37.065
But second of all, if you do,
we need to know that so

81
00:03:37.065 --> 00:03:39.130
we can use the old encoder to match that.

82
00:03:39.130 --> 00:03:42.730
Okay, so by default we encode passwords.

83
00:03:42.730 --> 00:03:45.010
That's what this password
encoder factory is doing.

84
00:03:45.010 --> 00:03:46.810
It's a delegating password encoder.

85
00:03:46.810 --> 00:03:47.906
If you look at this,

86
00:03:47.906 --> 00:03:51.530
it actually has a bunch of different
encoders that get put in a map.

87
00:03:51.530 --> 00:03:55.972
These are all the prefixes that that tell
us what the nature of the encoding is for

88
00:03:55.972 --> 00:03:57.470
each of the passwords.

89
00:03:57.470 --> 00:04:00.559
So if we see that you're trying to
authenticate using a password in

90
00:04:00.559 --> 00:04:01.773
a database using Scrypt,

91
00:04:01.773 --> 00:04:04.710
then we'll use the script encoder
to try and match it, right?

92
00:04:04.710 --> 00:04:06.350
To try and to validate it.

93
00:04:07.550 --> 00:04:09.230
Okay, so let's see if that works.

94
00:04:09.230 --> 00:04:12.510
We should be able to get to hello and
see the current authenticated user.

95
00:04:12.510 --> 00:04:14.350
Because we've only got the one user,
right?

96
00:04:14.350 --> 00:04:16.230
Let's actually create and the user.

97
00:04:16.230 --> 00:04:18.030
By the way, I'm doing it in memory.

98
00:04:18.030 --> 00:04:19.230
I've got one role.

99
00:04:20.940 --> 00:04:23.580
Okay, paste that in.

100
00:04:23.580 --> 00:04:24.220
Paste this.

101
00:04:24.220 --> 00:04:27.454
I'm going to add Spring
security lead Rob Winch,

102
00:04:27.454 --> 00:04:30.620
with whom I trust my life and
my data implicitly.

103
00:04:31.740 --> 00:04:37.260
Restart that okay, so
I'm going to go to localhost880.

104
00:04:37.260 --> 00:04:38.940
Hello again.

105
00:04:38.940 --> 00:04:42.460
Jlongpw and it says hello jlong.

106
00:04:43.660 --> 00:04:44.500
So clearly it's worked.

107
00:04:44.500 --> 00:04:45.100
I'm authenticated.

108
00:04:45.100 --> 00:04:46.590
I'm able to hit the endpoint.

109
00:04:46.590 --> 00:04:48.030
Fine.

110
00:04:48.030 --> 00:04:49.350
But like I said, that's in memory.

111
00:04:49.350 --> 00:04:52.390
It's not really what normally
people will do, right.

112
00:04:52.390 --> 00:04:54.590
They're going to store
stuff in a database.

113
00:04:54.590 --> 00:04:59.106
So let's switch this out and actually,
you know, to keep the example consistent,

114
00:04:59.106 --> 00:05:01.470
let's imagine that I had done Josh and
Rob.

115
00:05:01.470 --> 00:05:03.630
Okay, that's the old in memory 1.

116
00:05:03.630 --> 00:05:09.670
Let's switch to a database being
JDBC User Details Manager.

117
00:05:09.670 --> 00:05:14.000
Okay, I need a data source turn new jdbc.

118
00:05:14.000 --> 00:05:15.000
Voila.

119
00:05:15.000 --> 00:05:18.840
Okay, so that's going to expect
some schema to be in place.

120
00:05:18.840 --> 00:05:24.800
Now my question is, did I in my infinite
wisdom, did I put that in the front end?

121
00:05:24.800 --> 00:05:31.009
Masters git repository

122
00:05:31.009 --> 00:05:36.600
open security auth.

123
00:05:39.650 --> 00:05:40.290
Yes.

124
00:05:40.290 --> 00:05:44.290
Okay, I'm going to copy and paste that
schema here to my downloads directory.

125
00:05:47.170 --> 00:05:47.670
Open.

126
00:05:49.170 --> 00:05:54.210
Copy and
paste that source main resources paste.

127
00:05:54.210 --> 00:05:56.690
Okay, so let's look at that schema here.

128
00:05:58.930 --> 00:06:00.690
I've got some users.

129
00:06:00.690 --> 00:06:03.020
Josh, Rob, an accountant.

130
00:06:03.020 --> 00:06:04.420
I've got some roles I'm adding there.

131
00:06:04.420 --> 00:06:06.060
Role user.
Role user for Josh and Rob.

132
00:06:06.060 --> 00:06:10.620
And Rob, because he's the goat,
he also gets admin privileges.

133
00:06:10.620 --> 00:06:13.900
That is going to go into
a schema that I have here.

134
00:06:13.900 --> 00:06:16.879
Create table authorities,
create table users and

135
00:06:16.879 --> 00:06:19.660
add some foreign keys and
indexes and all that.

136
00:06:19.660 --> 00:06:22.780
This schema is in the Spring Security jar.

137
00:06:22.780 --> 00:06:25.929
There's a generic version that you can
find in the Spring Security jar itself or

138
00:06:25.929 --> 00:06:28.100
in the source code for
Spring Security, the project.

139
00:06:28.100 --> 00:06:30.780
It's on GitHub, but
I'm going to include this.

140
00:06:30.780 --> 00:06:32.060
This is in the git repository already.

141
00:06:32.060 --> 00:06:33.140
You can find the code there.

142
00:06:33.140 --> 00:06:34.380
And this is for postgres.

143
00:06:34.380 --> 00:06:35.780
I'm using postgres.

144
00:06:35.780 --> 00:06:38.929
I had to tweak it in some mysterious
ways that I don't remember, but

145
00:06:38.929 --> 00:06:40.100
this definitely works.

146
00:06:40.100 --> 00:06:40.820
So you can use this.

147
00:06:40.820 --> 00:06:43.740
Okay, so I'm going to.

148
00:06:43.740 --> 00:06:44.540
Everything else is the same.

149
00:06:44.540 --> 00:06:46.900
I'm just swapping out
the bean that I'm using.

150
00:06:46.900 --> 00:06:49.784
So instead of using in
memory User Details Manager,

151
00:06:49.784 --> 00:06:52.260
I'm using a JDBC User Details manager.

152
00:06:52.260 --> 00:06:53.380
So far so good.

153
00:06:53.380 --> 00:06:54.580
So we restart that.

154
00:06:56.806 --> 00:06:58.730
I have to tell it to load the schema,
don't I?

155
00:06:58.730 --> 00:06:59.530
I forgot to do that.

156
00:06:59.530 --> 00:07:00.770
So go over here.

157
00:07:00.770 --> 00:07:02.050
Sequel init always.

158
00:07:04.690 --> 00:07:07.930
Okay, same as always.

159
00:07:07.930 --> 00:07:09.650
Click on this little button.

160
00:07:09.650 --> 00:07:10.530
Click on that button.

161
00:07:10.530 --> 00:07:11.170
Click on Apply.

162
00:07:11.170 --> 00:07:11.792
Click on.
Ok.

163
00:07:11.792 --> 00:07:15.210
Click on this, click on that,
click on that, click on that.

164
00:07:15.210 --> 00:07:15.770
There we go.

165
00:07:15.770 --> 00:07:17.250
There's our users and our authorities.

166
00:07:17.250 --> 00:07:17.890
Okay.

167
00:07:17.890 --> 00:07:23.480
And you can see that these are using
the old password encoder SHA256.

168
00:07:23.480 --> 00:07:27.760
So I went out of my way to encode
some passwords in the wrong format.

169
00:07:27.760 --> 00:07:28.880
This is no longer secure.

170
00:07:28.880 --> 00:07:33.320
You know, this has been dead from
a security perspective for a decade.

171
00:07:33.320 --> 00:07:35.800
Do not use SHA256.

172
00:07:35.800 --> 00:07:38.040
So this is not secure.

173
00:07:38.040 --> 00:07:39.880
But I have passwords in the database.

174
00:07:39.880 --> 00:07:42.920
Well, of course, unless I get out a lot
of machines, I can't reverse these.

175
00:07:42.920 --> 00:07:43.760
It can be done.

176
00:07:43.760 --> 00:07:45.240
I just don't want to have to do that.

177
00:07:45.240 --> 00:07:47.240
So I want to migrate these passwords.

178
00:07:47.240 --> 00:07:48.980
Let's first make sure that I can log in.

179
00:07:48.980 --> 00:07:50.420
Okay, let's just do that.

180
00:07:50.420 --> 00:07:52.900
So Josh pw.

181
00:07:52.900 --> 00:07:53.860
Okay, great.

182
00:07:53.860 --> 00:07:57.780
Okay, let me go to a new
incognito window login.

183
00:07:57.780 --> 00:08:04.714
Rob pw wait.

184
00:08:04.714 --> 00:08:05.300
Sorry.

185
00:08:05.300 --> 00:08:06.660
Hello.

186
00:08:06.660 --> 00:08:08.180
There you go.

187
00:08:08.180 --> 00:08:12.900
Okay, so it's clearly, it's able to log me
in and out with that in memory JDBC thing.

188
00:08:12.900 --> 00:08:15.650
The problem is I've got
these old passwords.

189
00:08:15.650 --> 00:08:18.250
I do not want these old passwords
laying around in SHA 256.

190
00:08:18.250 --> 00:08:21.846
If this database, if somebody hacked
this database and this data went out,

191
00:08:21.846 --> 00:08:24.330
somebody could ultimately
reverse engineer that.

192
00:08:24.330 --> 00:08:25.650
It wouldn't take a lot of computing power.

193
00:08:27.170 --> 00:08:28.730
So we want to make sure
that never happens.

194
00:08:28.730 --> 00:08:33.890
So we want to migrate their passwords,
but obviously we can't easily migrate.

195
00:08:33.890 --> 00:08:34.930
It would take computing power.

196
00:08:34.930 --> 00:08:36.530
I don't want to do that.

197
00:08:36.530 --> 00:08:39.410
Especially with bcrypt,
I couldn't do that, not easily.

198
00:08:39.410 --> 00:08:43.610
So rather than me trying to brute force
my own users passwords, the most sensible

199
00:08:43.610 --> 00:08:47.934
thing is to as they log in once they've
presented a challenge, once they presented

200
00:08:47.934 --> 00:08:52.630
the credential to respond to the challenge
that we're forcing them to authenticate.

201
00:08:52.630 --> 00:08:57.299
Once they've done that,
when the value is in memory on login and

202
00:08:57.299 --> 00:09:03.006
we can see that, and once we've confirmed
that it authenticates correctly,

203
00:09:03.006 --> 00:09:04.995
migrate them seamlessly,

204
00:09:04.995 --> 00:09:10.360
you write out the value to the database
to update the value to be bcrypt.

205
00:09:10.360 --> 00:09:11.320
So let's do that.

206
00:09:11.320 --> 00:09:15.560
I'm going to change my
code here to use bcrypt.

207
00:09:17.480 --> 00:09:19.560
Where's my application here?

208
00:09:19.560 --> 00:09:21.560
Okay, go over here.

209
00:09:21.560 --> 00:09:23.999
Comment that out, go down there.

210
00:09:23.999 --> 00:09:30.760
I'm going to create a new bean
user details password service.

211
00:09:30.760 --> 00:09:31.560
Okay.

212
00:09:31.560 --> 00:09:37.410
And in order for this to work,
this seamless migration is not automatic.

213
00:09:37.410 --> 00:09:40.730
We want you to do it yourself because we
don't know if we might break anything.

214
00:09:40.730 --> 00:09:44.970
So here's this service gets
involved when you authenticate and

215
00:09:44.970 --> 00:09:47.490
you get a chance to, you get a Chance.

216
00:09:47.490 --> 00:09:51.745
Once their authentication is successful,
you get a pointer to the current user and

217
00:09:51.745 --> 00:09:54.905
to the new password,
the unencoded password that the user has

218
00:09:54.905 --> 00:09:57.490
entered that we know is
valid because it matched.

219
00:09:59.010 --> 00:10:03.922
So now your job is to, with
the injected JDBC User Details manager,

220
00:10:03.922 --> 00:10:07.090
create the new user with the new data.

221
00:10:07.090 --> 00:10:10.610
So user with user details.

222
00:10:10.610 --> 00:10:11.810
User.

223
00:10:11.810 --> 00:10:12.690
Right.

224
00:10:12.690 --> 00:10:13.730
Not user details.

225
00:10:13.730 --> 00:10:14.290
User.

226
00:10:14.290 --> 00:10:18.170
Okay with user details.

227
00:10:18.170 --> 00:10:20.330
What's wrong with that password?

228
00:10:20.330 --> 00:10:24.562
New password.build.

229
00:10:24.562 --> 00:10:25.090
it's this.

230
00:10:25.090 --> 00:10:26.540
Okay.

231
00:10:26.540 --> 00:10:28.140
Updated.

232
00:10:28.140 --> 00:10:28.700
Okay.

233
00:10:28.700 --> 00:10:31.980
So I've created, I've cloned everything
from the existing user details,

234
00:10:31.980 --> 00:10:35.020
except the only thing I've changed
is I've specified a new password.

235
00:10:35.020 --> 00:10:35.724
Yeah.
And

236
00:10:35.724 --> 00:10:39.020
that'll implicitly migrate
it to the new encoder.

237
00:10:39.020 --> 00:10:39.628
Right.
And

238
00:10:39.628 --> 00:10:42.139
the reason that that'll happen
is because I'm going to save it.

239
00:10:42.139 --> 00:10:47.100
So I use the user details manager and
I say update.

240
00:10:47.100 --> 00:10:47.900
User.

241
00:10:47.900 --> 00:10:49.260
Updated.

242
00:10:49.260 --> 00:10:51.020
Updated.

243
00:10:51.020 --> 00:10:52.630
Okay.

244
00:10:52.630 --> 00:10:54.790
And then I can return updated.

245
00:10:57.670 --> 00:10:58.270
Let's try that.

246
00:10:58.270 --> 00:10:59.670
Now I'm going to restart this code.

247
00:11:01.510 --> 00:11:06.550
So now I go to hello,
new incognito window.

248
00:11:06.550 --> 00:11:07.990
No Josh, no Rob.

249
00:11:07.990 --> 00:11:10.470
So let's make sure we're on
the same page here, though.

250
00:11:10.470 --> 00:11:12.830
Users still sha256.

251
00:11:12.830 --> 00:11:14.230
Right.

252
00:11:14.230 --> 00:11:18.880
PW and this one has been decrypted.

253
00:11:20.240 --> 00:11:21.920
It got migrated in place.

254
00:11:22.960 --> 00:11:24.000
Passwords are terrible.

255
00:11:24.000 --> 00:11:25.200
You should not use passwords.

256
00:11:25.200 --> 00:11:26.400
People forget to change them.

257
00:11:26.400 --> 00:11:27.400
They become archaic.

258
00:11:27.400 --> 00:11:29.120
They use the same one in multiple systems.

259
00:11:29.120 --> 00:11:30.914
Not everybody's going to
use a password manager, but

260
00:11:30.914 --> 00:11:32.480
if you're going to do passwords,
do it right.

261
00:11:32.480 --> 00:11:36.400
Make sure it's encoded, make sure you
have ways to seamlessly migrate forward.

262
00:11:36.400 --> 00:11:39.120
But they are terrible, really.

263
00:11:39.120 --> 00:11:42.480
The goal of a good security system
is to avoid passwords at all.

264
00:11:42.480 --> 00:11:43.440
They're not a good idea.

265
00:11:43.440 --> 00:11:46.897
And there's actually, you know, there's
actually government regulations around how

266
00:11:46.897 --> 00:11:50.000
people should manage password passwords,
the lifetime of passwords and so on.

267
00:11:50.000 --> 00:11:51.400
And this advice changes.

268
00:11:51.400 --> 00:11:54.951
Do you know that it's actually kind of
counter indicated, contraindicated that

269
00:11:54.951 --> 00:11:57.677
you should force users to migrate
their password every month or

270
00:11:57.677 --> 00:11:59.840
whatever to change their password.

271
00:11:59.840 --> 00:12:02.000
That practice of you need to change
your password every quarter.

272
00:12:02.000 --> 00:12:03.960
That's not actually good
security practice anymore.

273
00:12:03.960 --> 00:12:07.040
There are government standards
that talk about this stuff, Right.

274
00:12:07.040 --> 00:12:07.760
I didn't know that.

275
00:12:07.760 --> 00:12:08.640
I thought that was like.

276
00:12:08.640 --> 00:12:09.880
It still happens to me all the time.

277
00:12:09.880 --> 00:12:11.280
I'm forced to like migrate my passwords.

278
00:12:11.280 --> 00:12:12.960
In certain cases it's a bad idea.

279
00:12:12.960 --> 00:12:14.405
So I want to avoid passwords.

280
00:12:14.405 --> 00:12:15.520
But if you're going to do it,
do it like this.

281
00:12:15.520 --> 00:12:17.280
Okay?
Do it so that it's secure.

