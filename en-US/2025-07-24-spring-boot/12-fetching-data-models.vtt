WEBVTT

1
00:00:00.160 --> 00:00:01.760
&gt;&gt; Josh Long: Okay, so
I've got data in the database.

2
00:00:01.760 --> 00:00:03.720
Let's build some mapping to talk to it.

3
00:00:03.720 --> 00:00:04.800
I'm going to use.

4
00:00:04.800 --> 00:00:06.320
We're going to do this
the old fashioned way.

5
00:00:06.320 --> 00:00:12.917
First we'll say interface,
person, repository.

6
00:00:12.917 --> 00:00:15.360
We're just gonna create a repository
actually, an interface, okay?

7
00:00:15.360 --> 00:00:18.560
And we'll create an entity here.

8
00:00:18.560 --> 00:00:19.840
I'm using records.

9
00:00:19.840 --> 00:00:22.080
You've seen me use records a lot here.

10
00:00:22.080 --> 00:00:24.160
Person string.

11
00:00:24.160 --> 00:00:25.200
It'll be int id.

12
00:00:27.770 --> 00:00:28.810
Okay.

13
00:00:28.810 --> 00:00:30.890
Records are nice, but they're not.

14
00:00:30.890 --> 00:00:35.890
These are supported in every project
in Spring Data except for jpa.

15
00:00:35.890 --> 00:00:38.010
So Spring Data is an umbrella project.

16
00:00:38.010 --> 00:00:40.730
It is your one stop shop for
all things orm.

17
00:00:40.730 --> 00:00:42.506
If you want to persist
things to a database,

18
00:00:42.506 --> 00:00:45.690
no matter what the nature of the database,
there's a module here for you.

19
00:00:45.690 --> 00:00:49.450
So we have spring data, JDBC or JPA.

20
00:00:49.450 --> 00:00:52.730
Those both work with any SQL database,
right?

21
00:00:52.730 --> 00:00:56.490
You have spring data Neo4j for
a graph database, you have spring data.

22
00:00:56.490 --> 00:00:57.730
MongoDB for MongoDB.

23
00:00:57.730 --> 00:00:59.330
You have spring data Redis for Redis.

24
00:00:59.330 --> 00:00:59.890
You get the idea.

25
00:00:59.890 --> 00:01:01.770
There's dozens of different modules.

26
00:01:01.770 --> 00:01:04.889
Some of these modules are maintained
by the spring team proper or

27
00:01:04.889 --> 00:01:06.690
the spring team at other companies.

28
00:01:06.690 --> 00:01:10.330
Like for
example the Spring Cloud Spanner support.

29
00:01:10.330 --> 00:01:13.770
The Google Spanner on Google Cloud
is maintained by Google.

30
00:01:13.770 --> 00:01:16.650
The Couchbase support is
maintained by Couchbase, right?

31
00:01:16.650 --> 00:01:17.540
So we have.

32
00:01:17.540 --> 00:01:19.420
It doesn't matter which teams
you're talking about here.

33
00:01:19.420 --> 00:01:21.540
Cosmos DB is maintained by Microsoft.

34
00:01:21.540 --> 00:01:25.738
These are all spring data modules that
are maintained by different vendors, but

35
00:01:25.738 --> 00:01:27.700
they all work basically the same.

36
00:01:27.700 --> 00:01:31.290
And one of the things that's really nice
about these different spring data modules

37
00:01:31.290 --> 00:01:32.940
is that they provide a couple things.

38
00:01:32.940 --> 00:01:36.141
First, they provide this idea of
a template object which is a fluid,

39
00:01:36.141 --> 00:01:39.728
very convenient, one liner friendly style
way to interact with a lot of these

40
00:01:39.728 --> 00:01:41.540
different underlying data stores.

41
00:01:41.540 --> 00:01:46.625
They all provide spring idiomatic
declarative transaction demarcation so

42
00:01:46.625 --> 00:01:49.810
you can annotate a method
with transactional.

43
00:01:49.810 --> 00:01:52.479
And if the underlying data
source supports transactions and

44
00:01:52.479 --> 00:01:56.562
you've configured the transaction manager
accordingly, it'll automatically start and

45
00:01:56.562 --> 00:01:58.330
stop those transactions for you.

46
00:01:58.330 --> 00:02:01.530
And it provides this
concept of a repository.

47
00:02:01.530 --> 00:02:03.530
We're going to do a repository
the hard way here.

48
00:02:03.530 --> 00:02:06.490
This is a design pattern, but
we're going to do it the wrong way here.

49
00:02:06.490 --> 00:02:08.464
We're going to do it by hand.

50
00:02:08.464 --> 00:02:11.330
We're gonna say, find by id, int id.

51
00:02:12.370 --> 00:02:15.730
Okay, and now I'll say wrong way.

52
00:02:15.730 --> 00:02:21.250
Person repository implements
person repository.

53
00:02:21.250 --> 00:02:23.250
I'll implement that type.

54
00:02:23.250 --> 00:02:25.009
This is a new thing that added.

55
00:02:25.009 --> 00:02:26.730
Why do I want to make it abstract?

56
00:02:26.730 --> 00:02:29.890
This is who Needs that button.

57
00:02:29.890 --> 00:02:30.450
This is new.

58
00:02:30.450 --> 00:02:31.810
This didn't used to exist.

59
00:02:31.810 --> 00:02:36.880
My muscle memory is alt, enter, hit enter,
but now it's making it abstract.

60
00:02:36.880 --> 00:02:38.080
I want implement methods.

61
00:02:38.080 --> 00:02:39.040
That's all I want.

62
00:02:39.040 --> 00:02:40.360
It's the second one now on the list.

63
00:02:40.360 --> 00:02:42.480
I have to ping the people at Intellij.

64
00:02:42.480 --> 00:02:44.040
So, okay, I've got a repository.

65
00:02:44.040 --> 00:02:46.480
And remember we talked about
those marker annotations?

66
00:02:46.480 --> 00:02:49.120
These marker annotations
are stereotypical annotations.

67
00:02:49.120 --> 00:02:51.440
They are stereotypes in the UML sense.

68
00:02:51.440 --> 00:02:53.760
They identify the role of
the thing in the system.

69
00:02:53.760 --> 00:02:56.160
Okay, so repository.

70
00:02:56.160 --> 00:03:00.410
It has some runtime semantics, but
it's still just add component.

71
00:03:00.410 --> 00:03:01.610
It's a meta annotation.

72
00:03:01.610 --> 00:03:04.450
Anything that has at component
on it gets managed by spring.

73
00:03:04.450 --> 00:03:09.130
So this annotation in turn
is annotated with component.

74
00:03:09.130 --> 00:03:14.330
Okay, so repository,
functionally is just a component.

75
00:03:14.330 --> 00:03:15.821
It's just that it's cleaner and

76
00:03:15.821 --> 00:03:18.330
more understandable to
logically identify it as such.

77
00:03:18.330 --> 00:03:21.970
Okay, okay, so
now how do we implement that thing?

78
00:03:21.970 --> 00:03:24.810
Well, I'm going to use this
spring JDBC client, right?

79
00:03:24.810 --> 00:03:26.600
You saw me use this earlier.

80
00:03:26.600 --> 00:03:31.560
The JDBC client makes it trivial to talk
to an online SQL database in raw SQL.

81
00:03:31.560 --> 00:03:34.320
So I'll say this.db.

82
00:03:34.320 --> 00:03:39.440
sQL select all from person and then.

83
00:03:39.440 --> 00:03:40.840
And we wanna do by id, right?

84
00:03:40.840 --> 00:03:43.800
So where ID actually maybe
we want to do all of them.

85
00:03:43.800 --> 00:03:50.920
Let's just do all the customers,
all the people, person.

86
00:03:52.290 --> 00:03:58.450
Okay, find all, there we go, that's even
easier to kind of work through here.

87
00:03:58.450 --> 00:04:03.570
Okay, so we have the select all and
we're gonna create a row mapper.

88
00:04:03.570 --> 00:04:07.155
And the row mapper,
its job is to take a result set that comes

89
00:04:07.155 --> 00:04:10.610
back from the SQL database and
map it to the domain of our.

90
00:04:10.610 --> 00:04:11.650
Of our code here.

91
00:04:11.650 --> 00:04:12.450
Okay.

92
00:04:12.450 --> 00:04:13.890
List.

93
00:04:13.890 --> 00:04:15.970
Okay, and
then we want to do collection of.

94
00:04:18.139 --> 00:04:19.699
There you go.
So we've got the row mapper.

95
00:04:19.699 --> 00:04:22.459
And you know,
this can be a lambda, obviously.

96
00:04:24.539 --> 00:04:26.779
Get rid of that, get rid of this.

97
00:04:26.779 --> 00:04:30.139
And the contract is given the result set.

98
00:04:30.139 --> 00:04:31.019
Create the person.

99
00:04:31.019 --> 00:04:33.819
So person name int id.

100
00:04:33.819 --> 00:04:35.179
Pretty straightforward.

101
00:04:35.179 --> 00:04:43.910
And then why is this unhappy there?

102
00:04:43.910 --> 00:04:44.510
Same thing.

103
00:04:44.510 --> 00:04:49.350
Good, so we don't need the where id
since that's no longer domain, good.

104
00:04:50.550 --> 00:04:51.710
So now let's try this out.

105
00:04:51.710 --> 00:04:55.844
I want to just enumerate
all the people there.

106
00:04:55.844 --> 00:04:59.028
@Controller @responds body,
I don't have that.

107
00:04:59.028 --> 00:05:02.070
Let's do a spring bean that will get
run when the application starts up.

108
00:05:02.070 --> 00:05:06.230
I'll use the application runner here and
I'll inject the person repository.

109
00:05:09.440 --> 00:05:12.800
Okay, good.

110
00:05:12.800 --> 00:05:14.880
And then restart that.

111
00:05:14.880 --> 00:05:16.160
Restart that.

112
00:05:16.160 --> 00:05:18.800
Okay, so
you can see it found the one person.

113
00:05:18.800 --> 00:05:20.560
Okay, so it's obviously worked.

114
00:05:20.560 --> 00:05:22.280
It's a trivial example, but it does work.

115
00:05:22.280 --> 00:05:25.160
But even this trivial example
was just a lot of code.

116
00:05:25.160 --> 00:05:29.839
So spring data has this
declarative interface concept and

117
00:05:29.839 --> 00:05:36.870
it kind of reminds me of the best of
Active Directory in Ruby and Rails, right?

118
00:05:36.870 --> 00:05:39.030
It's imagine if that was done correctly.

119
00:05:39.030 --> 00:05:41.910
So you take that type, delete this code.

120
00:05:44.070 --> 00:05:45.750
Okay, there you go.

121
00:05:45.750 --> 00:05:48.310
So now I have a person repository.

122
00:05:48.310 --> 00:05:51.390
I'll delete that and
I can do two different ways.

123
00:05:51.390 --> 00:05:54.196
I can extend list of code repository for

124
00:05:54.196 --> 00:05:58.030
person whose primary key
is of type integer, right?

125
00:05:58.030 --> 00:05:59.190
That's the easiest.

126
00:05:59.190 --> 00:06:01.700
And in that case the code
doesn't change at all.

127
00:06:01.700 --> 00:06:04.140
Okay, there you go.

128
00:06:04.140 --> 00:06:05.380
So I got the same exact result.

129
00:06:06.500 --> 00:06:08.500
There's my id, there's my customer.

130
00:06:08.500 --> 00:06:12.260
But behind the scenes that method is
being inherited from this base class.

131
00:06:12.260 --> 00:06:15.380
There's methods here like find all,
saveall, etc.

132
00:06:15.380 --> 00:06:20.292
Crude repository in turn has other
methods like save, delete, find by id and

133
00:06:20.292 --> 00:06:25.380
it gives you an optional check and
see if something exists, do a count, etc.

134
00:06:25.380 --> 00:06:29.370
And spring data has these CRUD
repositories all throughout the code base.

135
00:06:29.370 --> 00:06:33.770
There's different CRUD repositories for
Redis, MongoDB, Neo4j, whatever.

136
00:06:33.770 --> 00:06:37.090
But obviously you don't want to
have the lowest common denominator.

137
00:06:37.090 --> 00:06:38.050
That seems like a waste, right?

138
00:06:38.050 --> 00:06:41.650
So there's other sub interfaces
that are more specific.

139
00:06:41.650 --> 00:06:44.210
In this case I'm using
a list of CRUD repository.

140
00:06:44.210 --> 00:06:45.575
If you're using Mongo,

141
00:06:45.575 --> 00:06:49.290
there might be a Mongo repository
that has extra features in there.

142
00:06:49.290 --> 00:06:53.100
And also you can create your own methods.

143
00:06:53.100 --> 00:06:57.039
So if I say collection person,
find by name and

144
00:06:57.039 --> 00:07:02.860
then let me just use that instead,
I'll say find by name is J long.

145
00:07:02.860 --> 00:07:05.900
Okay, so
now I'm asking it to find by name.

146
00:07:05.900 --> 00:07:08.779
And yeah,
it's giving me that one result back.

147
00:07:08.779 --> 00:07:10.780
Okay, so it's a declarative query.

148
00:07:10.780 --> 00:07:13.631
Obviously if I want to
exert even more control,

149
00:07:13.631 --> 00:07:17.780
I can say select all from person
where name equals name and whatever.

150
00:07:17.780 --> 00:07:18.500
And whatever and whatever.

151
00:07:18.500 --> 00:07:21.392
Maybe you could do some check to
check to see if they're the current

152
00:07:21.392 --> 00:07:24.918
authenticated user and they have access
to this data table or whatever, right?

153
00:07:24.918 --> 00:07:27.600
And you can also do spring
expression language queries.

154
00:07:27.600 --> 00:07:31.608
You can put in templated values from
the current environment, for example,

155
00:07:31.608 --> 00:07:34.080
the security context and so on.

156
00:07:34.080 --> 00:07:37.688
So let's try this one out.

157
00:07:37.688 --> 00:07:42.560
Suctol from person where
p.name equals this, okay?

158
00:07:46.400 --> 00:07:51.060
And of course, it's gonna return the right
one, right, because, of course, it would.

159
00:07:51.060 --> 00:07:52.133
So I can have as much or

160
00:07:52.133 --> 00:07:55.377
as little control as I need to to
work with my back end data store.

161
00:07:55.377 --> 00:07:59.641
Spring data, I'm using JDBC,
which is very, very expressive.

162
00:07:59.641 --> 00:08:02.098
But we also support custom
where it's appropriate.

163
00:08:02.098 --> 00:08:05.893
So, for example, if you're using
MongoDB or PostGIS and Postgres,

164
00:08:05.893 --> 00:08:08.820
they both support geospatial primitives,
right?

165
00:08:08.820 --> 00:08:10.980
So there's actually a point concept.

166
00:08:10.980 --> 00:08:17.313
So you could say find by name and location
string name and then you put in a point.

167
00:08:17.313 --> 00:08:19.950
Org springframeworkdata GL point, right?

168
00:08:19.950 --> 00:08:24.120
And it'll create a query that looks at
that correct type in the underlying

169
00:08:24.120 --> 00:08:25.070
backing thing.

