WEBVTT

1
00:00:00.640 --> 00:00:01.661
&gt;&gt; Josh Long: So
I'm going to close this out.

2
00:00:01.661 --> 00:00:05.920
This is all modulith is how you build
modular systems in a single jvm.

3
00:00:05.920 --> 00:00:10.715
Obviously, even with that, even this
monolithic example, I still had easy

4
00:00:10.715 --> 00:00:15.240
interop with external modules right
through the externalized module.

5
00:00:15.240 --> 00:00:19.403
And I talked to a database and
there's other moving parts, but sometimes,

6
00:00:19.403 --> 00:00:24.160
sometimes, sometimes, sometimes you've
got to build a distributed system.

7
00:00:24.160 --> 00:00:26.080
There's more than one
service in your system.

8
00:00:26.080 --> 00:00:27.960
Just do you have more than
one service in your system?

9
00:00:29.400 --> 00:00:33.873
I mean, I was kind of being facetious,
but yeah, of course you do.

10
00:00:33.873 --> 00:00:36.872
Even if you're not intentionally
building a microservice system today,

11
00:00:36.872 --> 00:00:39.213
there's a lot of moving parts
in most people's systems.

12
00:00:39.213 --> 00:00:42.573
And there are things that sort of
naturally fall out of that arrangement

13
00:00:42.573 --> 00:00:44.200
that you need to care for, right.

14
00:00:44.200 --> 00:00:48.662
Things that are just a natural part of
the complexity of building these kinds of

15
00:00:48.662 --> 00:00:49.280
systems.

16
00:00:49.280 --> 00:00:52.472
And so
we have a project called Spring Cloud.

17
00:00:52.472 --> 00:00:56.239
Spring Cloud is a set of extensions for
building distributed systems and

18
00:00:56.239 --> 00:00:59.110
microservices layered on
top of Spring Boot, okay.

19
00:00:59.110 --> 00:01:02.111
And there's several different things
that you can use there to make your life

20
00:01:02.111 --> 00:01:02.950
a little bit easier.

21
00:01:02.950 --> 00:01:06.470
So I'm going to talk to you about
just a few of them right here.

22
00:01:06.470 --> 00:01:08.470
Okay, so let's go back here.

23
00:01:08.470 --> 00:01:09.613
Start Spring IO.

24
00:01:09.613 --> 00:01:10.978
What we're going to do is I want to do.

25
00:01:10.978 --> 00:01:15.185
I need to set up some moving parts,
some infrastructure, olkay.

26
00:01:15.185 --> 00:01:16.378
First things first.

27
00:01:16.378 --> 00:01:17.837
If I have more than one service,

28
00:01:17.837 --> 00:01:20.900
I'm going to want to have a single
place to get my configuration.

29
00:01:20.900 --> 00:01:22.900
When I say configuration,
I mean keys and values.

30
00:01:22.900 --> 00:01:26.580
You've seen me talk about environment
variables or property files, whatever.

31
00:01:26.580 --> 00:01:30.243
But I also mentioned in passing
things like HashiCorp Vault or

32
00:01:30.243 --> 00:01:32.220
the Spring Cloud Config Server.

33
00:01:32.220 --> 00:01:34.019
I love the Spring Cloud Config server.

34
00:01:34.019 --> 00:01:34.979
So let's create one of these.

35
00:01:34.979 --> 00:01:43.630
Okay, Config Server Web Enter Open uio.

36
00:01:43.630 --> 00:01:44.517
Here we go.

37
00:01:44.517 --> 00:01:49.306
So now what this is going to do is it's
going to give me a API that will babysit

38
00:01:49.306 --> 00:01:52.958
or mediate access to a directory
full of configuration or

39
00:01:52.958 --> 00:01:56.550
a hosted sort of repository
of configuration, right.

40
00:01:56.550 --> 00:01:59.070
As long as it's git,
I'm using a git repository.

41
00:01:59.070 --> 00:02:06.470
And this will run in Port 8888, which is,
you know, bad luck in the Far East.

42
00:02:06.470 --> 00:02:07.190
Sorry about that.

43
00:02:07.190 --> 00:02:08.910
And it's just the default port.

44
00:02:08.910 --> 00:02:12.811
So okay, the last thing you need to
do is to say, enable Config Server.

45
00:02:12.811 --> 00:02:17.740
So Enable Config Server,
point to a directory full of config.

46
00:02:17.740 --> 00:02:21.902
That directory exists on my desktop Here,

47
00:02:21.902 --> 00:02:25.841
it's a directory full of config files.

48
00:02:25.841 --> 00:02:27.100
You can see it's got to get.

49
00:02:28.540 --> 00:02:29.620
The code is public.

50
00:02:29.620 --> 00:02:32.159
Please feel free to take it.

51
00:02:32.159 --> 00:02:35.020
All right, so GitHub.

52
00:02:35.020 --> 00:02:36.480
Sorry, did I start this?

53
00:02:36.480 --> 00:02:38.264
I didn't start this.

54
00:02:38.264 --> 00:02:43.643
So now we're going to localhost 8888 and
I'm going to go for

55
00:02:43.643 --> 00:02:48.929
the configuration for
the Auth server in the default profile.

56
00:02:48.929 --> 00:02:54.760
Okay, so you can see it says Auth and
then we have this concept of a profile.

57
00:02:54.760 --> 00:02:58.713
A profile in Spring is a label that you
can attach to objects to determine whether

58
00:02:58.713 --> 00:02:59.960
they're loaded or not.

59
00:02:59.960 --> 00:03:04.390
For now, actually, for most of what you
do, just stick with the default profile.

60
00:03:04.390 --> 00:03:07.950
You don't need to worry about it much,
but it can be useful in some rare cases.

61
00:03:07.950 --> 00:03:11.497
So the Auth is the name of the service and
then the default profile.

62
00:03:11.497 --> 00:03:16.442
When I ask for the Auth configuration,
what I get is two property sources

63
00:03:16.442 --> 00:03:21.390
that contains the details of whatever's
in application properties and

64
00:03:21.390 --> 00:03:23.270
whatever's in Auth YAML.

65
00:03:24.950 --> 00:03:28.501
Now I'm going to set up another
service which is going to consume this

66
00:03:28.501 --> 00:03:29.430
configuration.

67
00:03:30.460 --> 00:03:33.861
It's going to identify itself as Auth,
for example, and say, hey,

68
00:03:33.861 --> 00:03:35.023
I need configuration.

69
00:03:35.023 --> 00:03:36.448
For me, I'm called Auth.

70
00:03:36.448 --> 00:03:38.228
What is my configuration?

71
00:03:38.228 --> 00:03:40.207
Well, since this lives
in the config server,

72
00:03:40.207 --> 00:03:42.940
I can change the configuration
without having to change the.

73
00:03:42.940 --> 00:03:44.300
I don't have to redeploy the service.

74
00:03:46.860 --> 00:03:47.540
So let's try that.

75
00:03:47.540 --> 00:03:48.620
Let's create a simple service here.

76
00:03:48.620 --> 00:03:54.700
Start Spring IO and I'll call this service
again because I'm great with names.

77
00:03:54.700 --> 00:03:57.639
I'll use the config client,
I'm going to use the web support,

78
00:03:57.639 --> 00:03:59.960
I'm going to use
the discovery client support.

79
00:03:59.960 --> 00:04:00.600
So I've got that.

80
00:04:00.600 --> 00:04:02.400
I'll go ahead and
leave the discovery client in there.

81
00:04:02.400 --> 00:04:07.421
I'll use the web, I'll use the config
client, open that up just like before.

82
00:04:07.421 --> 00:04:11.487
In order to do service registration and
discovery, I need a service registry,

83
00:04:11.487 --> 00:04:13.381
something like Hashicorp Console.

84
00:04:13.381 --> 00:04:16.557
Something like Zookeeper Apache,
Zookeeper,

85
00:04:16.557 --> 00:04:19.120
something like Netflix Eureka, etc.

86
00:04:19.120 --> 00:04:23.830
So Netflix Eureka is, by the way, a lot of
these patterns came from Netflix, right?

87
00:04:23.830 --> 00:04:27.988
This is a project that was originally
built on the integrations that we built on

88
00:04:27.988 --> 00:04:31.270
top of Netflix, and
this project came out in 2015.

89
00:04:31.270 --> 00:04:36.230
Netflix, remember, they have famously
deployed on AWS their entire time, right?

90
00:04:36.230 --> 00:04:38.195
It's always been aws, but

91
00:04:38.195 --> 00:04:44.550
there are things you need to do to tame
the cloud environment on aws, right?

92
00:04:44.550 --> 00:04:45.190
Even today.

93
00:04:45.190 --> 00:04:49.158
So they built a lot of infrastructure to
sort of make that more approachable to

94
00:04:49.158 --> 00:04:50.939
Russell, that complexity down.

95
00:04:50.939 --> 00:04:53.941
And we they open source a lot of it.

96
00:04:53.941 --> 00:04:56.190
We then packaged it up as
Spring Cloud components.

97
00:04:56.190 --> 00:04:58.639
These components are reusable,
they're open source, but

98
00:04:58.639 --> 00:05:01.904
they also inspired abstractions because
there are several other players in a lot

99
00:05:01.904 --> 00:05:03.070
of these different spaces.

100
00:05:03.070 --> 00:05:05.521
So I'm going to use Eureka,
which is from Netflix.

101
00:05:05.521 --> 00:05:06.963
It's a service registry.

102
00:05:06.963 --> 00:05:12.910
So I'm going to go back here, start
Spring IO, I'm going to build a Eureka.

103
00:05:12.910 --> 00:05:16.570
I'll use the Eureka service registry.

104
00:05:16.570 --> 00:05:20.170
I'll use the web support,
I'll use the config client.

105
00:05:21.850 --> 00:05:22.770
Okay, here we go.

106
00:05:22.770 --> 00:05:25.530
Enter UAO Eureka.

107
00:05:28.330 --> 00:05:31.290
Okay, so now application properties.

108
00:05:31.290 --> 00:05:33.050
Well, first of all,
you go to the Eureka Java code.

109
00:05:33.050 --> 00:05:36.010
You say, enable Eureka server.

110
00:05:37.370 --> 00:05:38.970
I guess I don't need to Eureka.

111
00:05:40.090 --> 00:05:41.290
Did I add the wrong one?

112
00:05:47.744 --> 00:05:48.260
Wrong one.

113
00:05:49.380 --> 00:05:53.860
I want the Eureka server.

114
00:05:55.060 --> 00:05:57.673
Copy and paste.

115
00:05:57.673 --> 00:05:58.660
Okay, Command shift.

116
00:05:58.660 --> 00:06:04.300
I reload, go back to my Java code.

117
00:06:04.300 --> 00:06:06.340
Enable Eureka server.

118
00:06:06.340 --> 00:06:07.860
Okay, that's the hard part.

119
00:06:09.230 --> 00:06:10.543
Well, maybe this is also difficult.

120
00:06:10.543 --> 00:06:15.950
So I'll do port 8761 and
I'll tell it not to register with itself.

121
00:06:17.150 --> 00:06:19.710
Register with Eureka, false.

122
00:06:19.710 --> 00:06:21.030
Now I'm going to start up this code.

123
00:06:21.030 --> 00:06:22.039
I did a lot of code there.

124
00:06:22.039 --> 00:06:24.459
I don't like doing that much code for
no reason, but I did.

125
00:06:24.459 --> 00:06:27.852
I've also told it to get its
config from the config server.

126
00:06:27.852 --> 00:06:31.870
So now this is the first thing that
will act as a config client actually.

127
00:06:31.870 --> 00:06:35.780
So I'm not sure if I put
this in the config server.

128
00:06:35.780 --> 00:06:37.460
So I'm going to go ahead and create a new.

129
00:06:37.460 --> 00:06:39.140
This is a service called Eureka.

130
00:06:39.140 --> 00:06:43.364
I'm going to create a new config
file in my directory full of

131
00:06:43.364 --> 00:06:46.980
configuration called Eureka Properties.

132
00:06:46.980 --> 00:06:50.980
Okay, so paste that in.

133
00:06:50.980 --> 00:06:56.652
Git Add Eureka git,

134
00:06:56.652 --> 00:07:01.657
commit Eureka git

135
00:07:01.657 --> 00:07:05.666
push, okay.

136
00:07:05.666 --> 00:07:07.390
Okay, authorize, good.

137
00:07:07.390 --> 00:07:11.491
All right, so
now I've got a Eureka instance.

138
00:07:11.491 --> 00:07:12.430
So let's restart it.

139
00:07:14.590 --> 00:07:15.430
It's going to start up.

140
00:07:15.430 --> 00:07:18.261
It's going to draw the configuration
from that property file by default.

141
00:07:18.261 --> 00:07:20.799
That means it's going to run in Port 8761.

142
00:07:20.799 --> 00:07:23.169
There's Eureka.

143
00:07:23.169 --> 00:07:27.310
This is a full blown service registry
that I just with that one annotation.

144
00:07:28.700 --> 00:07:32.079
So this is Spring boot standing up a web
service that actually does service

145
00:07:32.079 --> 00:07:33.340
registration discovery.

146
00:07:33.340 --> 00:07:36.884
Remember I drew the configuration,
there's no config here, right.

147
00:07:36.884 --> 00:07:39.414
All I did was I said, hey, microservice,

148
00:07:39.414 --> 00:07:44.057
draw your configuration from the config
server running on the default host and

149
00:07:44.057 --> 00:07:48.440
port the way you would specify that is
by overriding this part right here.

150
00:07:48.440 --> 00:07:50.860
If you don't specify it,
it goes to localhost8888.

151
00:07:50.860 --> 00:07:53.020
That config server is over here.

152
00:07:55.030 --> 00:08:00.522
I can go back to Eureka and there's the
config files called Eureka Properties and

153
00:08:00.522 --> 00:08:02.870
Application Properties.

154
00:08:02.870 --> 00:08:06.470
So whatever the name of the microservice,
the name is Eureka.

155
00:08:06.470 --> 00:08:08.358
It'll look for Eureka in there and

156
00:08:08.358 --> 00:08:13.110
it'll return the property file called
Eureka Properties or Eureka YAML.

157
00:08:13.110 --> 00:08:15.654
All microservices,
no matter what they're called,

158
00:08:15.654 --> 00:08:18.310
will see whatever is in
Application Properties.

159
00:08:18.310 --> 00:08:20.450
Only the microservice called Eureka will.

160
00:08:20.450 --> 00:08:22.770
We'll see what's in Eureka Properties.

161
00:08:22.770 --> 00:08:23.650
So far, so good.

162
00:08:23.650 --> 00:08:26.394
So this is a composite, and
if you have the duplicate key,

163
00:08:26.394 --> 00:08:30.034
if you have server port equals foo and
it's server port equals bar over here,

164
00:08:30.034 --> 00:08:33.330
then the more specific file
overrides the least specific one.

165
00:08:33.330 --> 00:08:36.069
Okay, so
I've got a Eureka service registry, and

166
00:08:36.069 --> 00:08:40.161
that service registry is in turn drawing
its config from the config server.

167
00:08:40.161 --> 00:08:44.258
Now I want to create a microservice
that talks to both the config server and

168
00:08:44.258 --> 00:08:47.572
the Eureka service registry
to advertise if its location.

169
00:08:47.572 --> 00:08:51.175
A service registry is a great way to
advertise what services are available.

170
00:08:51.175 --> 00:08:53.275
Remember, DNS is not your friend.

171
00:08:53.275 --> 00:08:54.788
It's always DNS, right.

172
00:08:54.788 --> 00:08:56.989
DNS is flaky.

173
00:08:56.989 --> 00:09:00.573
It encourages caching, which is great for
the overall large web, but

174
00:09:00.573 --> 00:09:04.403
it's really bad for dynamic turbulent
volatile microservice systems and

175
00:09:04.403 --> 00:09:07.660
cloud native systems,
where things come and go all the time.

176
00:09:07.660 --> 00:09:08.816
So you don't want DNS.

177
00:09:08.816 --> 00:09:09.988
DNS is the enemy, right.

178
00:09:09.988 --> 00:09:11.180
Use a service registry.

179
00:09:12.310 --> 00:09:14.990
So I've got this.

180
00:09:14.990 --> 00:09:16.550
Where's my.
I've got the config server.

181
00:09:16.550 --> 00:09:17.910
I've got my service.

182
00:09:17.910 --> 00:09:21.830
Well, this is going to draw its
configuration from the config server.

183
00:09:21.830 --> 00:09:22.347
Same thing.

184
00:09:22.347 --> 00:09:23.317
I just put that in there.

185
00:09:23.317 --> 00:09:26.990
Okay, and I don't even know what's
in the config server for service.

186
00:09:26.990 --> 00:09:28.230
Let's go find out.

187
00:09:28.230 --> 00:09:32.029
Okay, you can see if it's modulus,
I'm ready to go, if I've GraphQL,

188
00:09:32.029 --> 00:09:33.270
I'm ready to go, etc.

189
00:09:33.270 --> 00:09:34.390
So pretty good.

190
00:09:34.390 --> 00:09:35.350
Pretty standard stuff.

191
00:09:35.350 --> 00:09:36.390
Nothing special though.

192
00:09:36.390 --> 00:09:37.149
Is there any.

193
00:09:37.149 --> 00:09:38.500
No prescription on the port?

194
00:09:38.500 --> 00:09:39.540
Nope.
Okay, good.

195
00:09:39.540 --> 00:09:41.940
So this is a service in the service.

196
00:09:41.940 --> 00:09:45.940
I'm going to inject the current port.

197
00:09:45.940 --> 00:09:47.700
I'm going to get the current port.

198
00:09:47.700 --> 00:09:51.840
So I'll say void on startup and
I'm going to listen for

199
00:09:51.840 --> 00:09:55.083
the web server initialized event, okay.

200
00:09:55.083 --> 00:09:55.820
Why am I going to do that?

201
00:09:55.820 --> 00:10:01.329
Because I want to get the current port and
stash it so that I have a value.

202
00:10:01.329 --> 00:10:06.659
So event get web server, get port.

203
00:10:06.659 --> 00:10:08.770
I'll say this port set.

204
00:10:08.770 --> 00:10:10.766
Is that okay?

205
00:10:10.766 --> 00:10:15.250
And I shall create a rest
controller at response body.

206
00:10:15.250 --> 00:10:18.646
And I'll go over here,
I'll say get mapping.

207
00:10:18.646 --> 00:10:20.232
Hello, whatever, right.

208
00:10:20.232 --> 00:10:22.937
Map string, string.

209
00:10:22.937 --> 00:10:27.188
Hello.

210
00:10:27.188 --> 00:10:35.500
Hello, okay.

211
00:10:35.500 --> 00:10:41.094
Okay, hello

212
00:10:41.094 --> 00:10:46.183
from port.

213
00:10:46.183 --> 00:10:47.139
There you go, okay.

214
00:10:47.139 --> 00:10:48.860
Pretty straightforward.

215
00:10:48.860 --> 00:10:49.740
Put that in there.

216
00:10:49.740 --> 00:10:51.420
So now let's start this service up.

217
00:10:51.420 --> 00:10:53.100
I want this to run on a random port.

218
00:10:53.100 --> 00:10:55.740
So I'm going to modify
the config file here, right?

219
00:10:55.740 --> 00:10:57.530
I'll just say start on a random port.

220
00:10:57.530 --> 00:11:00.233
Server port equals zero means
start on a random port.

221
00:11:00.233 --> 00:11:02.170
Yeah, it just picks any
port that's not used.

222
00:11:03.850 --> 00:11:05.010
So I'm going to start this up.

223
00:11:05.010 --> 00:11:06.730
Remember its name is service.

224
00:11:06.730 --> 00:11:08.981
So if I go now to service registry,

225
00:11:08.981 --> 00:11:13.808
my Eureka instance over here,
there's an instance of service, right?

226
00:11:13.808 --> 00:11:16.570
And here's the host and
port, the domain, et cetera.

227
00:11:17.690 --> 00:11:18.371
Not bad.

228
00:11:18.371 --> 00:11:21.770
The problem with this,
like let's say stop it, okay?

229
00:11:22.820 --> 00:11:26.580
Now the service is down, eventually it'll
disappear, but it's down, it's flagging.

230
00:11:26.580 --> 00:11:28.660
We can't establish
a heartbeat with it anymore.

231
00:11:28.660 --> 00:11:33.059
The problem with this is that Eureka
doesn't distinguish between multiple nodes

232
00:11:33.059 --> 00:11:34.469
on the same host and port.

233
00:11:34.469 --> 00:11:37.059
Sorry, the same host,
you need to distinguish by port.

234
00:11:37.059 --> 00:11:39.744
So what I would do is I'll say Eureka id.

235
00:11:39.744 --> 00:11:41.620
Instance ID is equal to.

236
00:11:43.300 --> 00:11:48.571
I'll use UUID and
then spring application name.

237
00:11:48.571 --> 00:11:54.181
Okay, that'll give this instance a random
name or somewhat randomized name, right?

238
00:11:54.181 --> 00:11:58.002
So now if I refresh,
you can see it says random-service.

239
00:11:58.002 --> 00:12:00.382
Okay, so now if I run the program again,

240
00:12:00.382 --> 00:12:03.402
I'm going to run the same
service multiple times.

241
00:12:03.402 --> 00:12:07.670
So I'll say you have to tell
Intellij to run multiples, right?

242
00:12:07.670 --> 00:12:08.550
It doesn't do it by default.

243
00:12:08.550 --> 00:12:11.470
So where is that config thing?

244
00:12:19.480 --> 00:12:23.640
Allow multiple instances apply.

245
00:12:23.640 --> 00:12:27.720
So now I start this again there I got two
instead of rewriting the existing one.

246
00:12:27.720 --> 00:12:29.400
So now I go back over here.

247
00:12:29.400 --> 00:12:33.537
Now there's two instances of
the service in the service registry.

248
00:12:33.537 --> 00:12:40.499
So now if I go to one of these host and
ports, that's the actuator input.

249
00:12:40.499 --> 00:12:43.521
By the way, if you have the actuator,
it'll check that and

250
00:12:43.521 --> 00:12:45.040
surface information there.

251
00:12:45.040 --> 00:12:48.610
So it's saying one instance
was Living on Port 49918.

252
00:12:48.610 --> 00:12:54.290
So if I go there, I can get, hello,
I've got the service registry.

253
00:12:54.290 --> 00:12:57.330
You can programmatically interact
with that service registry.

254
00:12:57.330 --> 00:12:59.751
You can ask IT questions,
We can do things for

255
00:12:59.751 --> 00:13:01.930
you with that service registry as well.

256
00:13:01.930 --> 00:13:05.454
For example, if I want to make
a REST request from a client,

257
00:13:05.454 --> 00:13:08.530
I can do client side load balancing.

258
00:13:08.530 --> 00:13:11.984
Before I make the REST call, the client
will look at the service registry and say,

259
00:13:11.984 --> 00:13:14.210
which service instance is available?

260
00:13:14.210 --> 00:13:15.010
I'll take that one.

261
00:13:15.010 --> 00:13:16.650
Please send the request that way.

262
00:13:16.650 --> 00:13:19.192
And you can do round robin,
you can do sticky sessions,

263
00:13:19.192 --> 00:13:22.610
you can do all sorts of different
kinds of load balancing in the client.

264
00:13:22.610 --> 00:13:27.090
This means that, remember, there's no
such thing as one true load balancing.

265
00:13:27.090 --> 00:13:30.196
Just because one service is using load
balancing that's round robin doesn't mean

266
00:13:30.196 --> 00:13:31.610
that's good for everybody else.

267
00:13:31.610 --> 00:13:35.498
And this is the problem with having
centralized gateways that do that kind

268
00:13:35.498 --> 00:13:36.068
of stuff.

269
00:13:36.068 --> 00:13:37.450
It's not one size fits all.

