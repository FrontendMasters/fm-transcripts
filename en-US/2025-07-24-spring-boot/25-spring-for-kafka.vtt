WEBVTT

1
00:00:00.160 --> 00:00:04.695
&gt;&gt; Josh Long: Spring has a couple of
a few different layers of support.

2
00:00:04.695 --> 00:00:08.385
When you talk about
messaging technologies,

3
00:00:08.385 --> 00:00:13.880
at the lowest level you'll have a X,,
spring 4x project, right?

4
00:00:13.880 --> 00:00:18.760
Usually so for example,
Spring for Apache Kafka, right?

5
00:00:18.760 --> 00:00:21.987
You have to do that or
you have spring for spring AMQP,

6
00:00:21.987 --> 00:00:26.007
which is the project that supports
the open source AMQP protocol,

7
00:00:26.007 --> 00:00:29.482
of which RabbitMQ is by far
the largest implementation.

8
00:00:29.482 --> 00:00:33.059
Fun fact, RabbitMQ,
the open source technology,

9
00:00:33.059 --> 00:00:37.629
is a project shepherded by the same
team that does spring, right?

10
00:00:37.629 --> 00:00:40.572
Well, we're two different
teams technically now, but

11
00:00:40.572 --> 00:00:44.618
we're all under the same happy family and
it was because of Spring that they got

12
00:00:44.618 --> 00:00:47.210
acquired into the same
company as spring exists.

13
00:00:47.210 --> 00:00:48.286
So RabbitMQ is.

14
00:00:48.286 --> 00:00:53.327
I love that technology, but I won't be
talking about it here because again,

15
00:00:53.327 --> 00:00:57.608
Kafka's I think the new thing and
then Spring for Apache Pulsar.

16
00:00:57.608 --> 00:00:59.537
So notice that we didn't
have to say spring for

17
00:00:59.537 --> 00:01:01.969
RabbitMQ because we're talking
about the spec, right?

18
00:01:01.969 --> 00:01:05.527
As opposed to spring for RabbitMQ.

19
00:01:05.527 --> 00:01:07.670
It's an open source protocol.

20
00:01:07.670 --> 00:01:09.590
Okay, so
these are some projects you can use.

21
00:01:09.590 --> 00:01:11.350
These are low level and
I'm gonna start with that.

22
00:01:11.350 --> 00:01:14.027
I think that's the easiest way
to get purchased in the wide and

23
00:01:14.027 --> 00:01:15.670
wonderful world of messaging.

24
00:01:15.670 --> 00:01:18.916
So let's just build a simple
example to do this.

25
00:01:18.916 --> 00:01:23.200
You'll need a Docker image or
something to spin up Kafka.

26
00:01:23.200 --> 00:01:25.279
Fun fact, there's actually a Docker image.

27
00:01:25.279 --> 00:01:27.671
This one, I would take a photo of this.

28
00:01:27.671 --> 00:01:29.577
You don't need to do this right now,
but just take a photo of this.

29
00:01:29.577 --> 00:01:31.864
This is the Docker image for

30
00:01:31.864 --> 00:01:37.240
Kafka that has been compiled as
a graalvm native image, right?

31
00:01:37.240 --> 00:01:41.000
So remember we've been talking about
Graalvm Kafka, the Kafka team itself.

32
00:01:41.000 --> 00:01:42.890
Remember, Kafka is written in the jvm.

33
00:01:42.890 --> 00:01:45.770
It's a Scala code base,
but that's a JVM language.

34
00:01:45.770 --> 00:01:49.357
They compiled the whole thing
into a graalvm native image and

35
00:01:49.357 --> 00:01:51.404
they put that into a Docker image.

36
00:01:51.404 --> 00:01:54.652
So now you can start one of
the most venerable, tried and

37
00:01:54.652 --> 00:01:58.400
true messaging brokers in like
sub second,, response times.

38
00:01:58.400 --> 00:01:59.850
Okay, so I'm going to do this now.

39
00:01:59.850 --> 00:02:00.890
Let's see what it looks like.

40
00:02:00.890 --> 00:02:02.970
Docker compose up.

41
00:02:02.970 --> 00:02:03.852
Well, no, not minus D.

42
00:02:03.852 --> 00:02:05.370
I'm just going to do Docker compose up.

43
00:02:05.370 --> 00:02:06.570
Ready, steady, go.

44
00:02:06.570 --> 00:02:07.770
Whoops, what did I do?

45
00:02:07.770 --> 00:02:08.741
So do we have compose?

46
00:02:08.741 --> 00:02:09.458
Yeah, we don't.

47
00:02:09.458 --> 00:02:14.639
So I'm going to Move Kafka YAML

48
00:02:14.639 --> 00:02:20.218
to compose YAML make dear Kafka,

49
00:02:20.218 --> 00:02:25.401
Move everything that's Kafka

50
00:02:25.401 --> 00:02:31.978
into the folder called Kafka and okay,

51
00:02:31.978 --> 00:02:37.572
cd Kafka and Docker compose up.

52
00:02:37.572 --> 00:02:38.217
That was slow.

53
00:02:38.217 --> 00:02:38.950
What happened there?

54
00:02:40.310 --> 00:02:41.830
I have to pull it, I guess.

55
00:02:41.830 --> 00:02:44.230
Ready, steady, go.

56
00:02:44.230 --> 00:02:45.036
That's the broker.

57
00:02:45.036 --> 00:02:49.973
The entire thing is now up and
running and ready to handle traffic.

58
00:02:49.973 --> 00:02:51.934
So that part was easy.

59
00:02:51.934 --> 00:02:54.177
We got Kafka going.

60
00:02:54.177 --> 00:02:57.110
I want to build a very simple
application that talks to this thing.

61
00:02:57.110 --> 00:03:00.731
So we're going to go back to
the lab again, start Spring IO,

62
00:03:00.731 --> 00:03:04.290
I'm going to call this Kafka,
even though it's not okay.

63
00:03:04.290 --> 00:03:07.606
And we're gonna bring in the Spring for
Apache Kafka support, right?

64
00:03:07.606 --> 00:03:10.514
So add that.

65
00:03:10.514 --> 00:03:13.650
Add the Graalvm native image support,
if you like, add in.

66
00:03:13.650 --> 00:03:14.937
Do we care about a web server?

67
00:03:14.937 --> 00:03:15.694
Nah, it's fine.

68
00:03:15.694 --> 00:03:17.178
Just hit Enter.

69
00:03:17.178 --> 00:03:21.120
Okay, open this up.

70
00:03:21.120 --> 00:03:21.649
Where is that?

71
00:03:21.649 --> 00:03:23.161
That's all this other stuff from before.

72
00:03:23.161 --> 00:03:23.770
Delete that.

73
00:03:23.770 --> 00:03:24.850
Goodbye.

74
00:03:24.850 --> 00:03:25.570
Here we go.

75
00:03:27.500 --> 00:03:28.540
And we're not going to do too much here.

76
00:03:28.540 --> 00:03:30.260
I'm just going to demonstrate
how to send and receive.

77
00:03:30.260 --> 00:03:34.388
This is all you really need to know for
most use cases and from the balance of

78
00:03:34.388 --> 00:03:38.620
stuff you can figure out in the
documentation, in the details and so on.

79
00:03:38.620 --> 00:03:40.885
So the code is actually
fairly straightforward here.

80
00:03:40.885 --> 00:03:42.950
The code is actually the easiest part, so

81
00:03:42.950 --> 00:03:46.436
let's get that out of the way now
a little bit of sweet before the sour.

82
00:03:46.436 --> 00:03:51.425
Then we need configuration, and
the configuration is tedious.

83
00:03:51.425 --> 00:03:54.220
So how are we going to send a message?

84
00:03:54.220 --> 00:03:56.168
Let's just create a spring
bean that will start up.

85
00:03:56.168 --> 00:04:00.725
When the application starts up, it'll be
invoked and so we'll call this sender,

86
00:04:00.725 --> 00:04:03.340
and we're going to use
the old Kafka template.

87
00:04:03.340 --> 00:04:05.289
So you're going to see this
idiom a lot in Spring.

88
00:04:05.289 --> 00:04:07.801
You'll see different template objects, or

89
00:04:07.801 --> 00:04:12.567
sometimes increasingly today you'll see
clients like the JDBC client, whatever.

90
00:04:12.567 --> 00:04:14.218
But I'm going to send a.

91
00:04:14.218 --> 00:04:17.220
I'm going to inject a Kafka
template that has the key, right?

92
00:04:17.220 --> 00:04:20.660
This is the key that Kafka uses and
then the type of payload.

93
00:04:20.660 --> 00:04:22.041
And what kind of payload
am I going to send?

94
00:04:22.041 --> 00:04:27.415
I'll just send a dog adoption request,
for example.

95
00:04:27.415 --> 00:04:32.610
Okay, so int, dog ID string,
dog name, okay?

96
00:04:32.610 --> 00:04:36.469
And we'll put that here and
so when the application runs,

97
00:04:36.469 --> 00:04:41.589
it's going to run this program, it's
going to inject the Kafka template and

98
00:04:41.589 --> 00:04:45.010
I shall use it to send
a message to a topic, okay?

99
00:04:45.010 --> 00:04:47.650
And the topic is dog adoption request.

100
00:04:47.650 --> 00:04:52.308
Sure,, to make that cleaner, since
we're going to do both the producer and

101
00:04:52.308 --> 00:04:54.602
the consumer in the same JVM program,

102
00:04:54.602 --> 00:04:59.207
I'll just extract that out into a constant
and refer to that constant here.

103
00:04:59.207 --> 00:05:01.300
Okay, so
that's going to publish a message.

104
00:05:01.300 --> 00:05:03.020
Now how do I consume that message?

105
00:05:03.020 --> 00:05:04.980
Imagine I have a different jvm.

106
00:05:04.980 --> 00:05:07.340
You've already seen this
event listener annotation.

107
00:05:07.340 --> 00:05:10.182
Well, we're doing event
listener lets you listen for

108
00:05:10.182 --> 00:05:12.358
spring published events in the same jvm.

109
00:05:12.358 --> 00:05:15.876
If you want to listen for Kafka events,
use Kafka listener, right.

110
00:05:15.876 --> 00:05:18.391
So listen for Kafka,
that dog adoption event, and

111
00:05:18.391 --> 00:05:20.037
you have to specify a few things.

112
00:05:20.037 --> 00:05:23.350
First of all, what's the destination,
what's the topic,

113
00:05:23.350 --> 00:05:26.310
what's the address that
you're going to listen to?

114
00:05:26.310 --> 00:05:28.107
And then what is your group id?

115
00:05:28.107 --> 00:05:32.223
So for a group ID in Kafka is
an exclusive consumer group.

116
00:05:32.223 --> 00:05:37.443
So basically messages that are in
the if you say you're part of a group,

117
00:05:37.443 --> 00:05:44.090
then you won't get messages duplicated
to you across different partitions.

118
00:05:44.090 --> 00:05:46.003
So I'll call this,
what do I want to call this?

119
00:05:46.003 --> 00:05:48.212
I call this my group.

120
00:05:48.212 --> 00:05:49.761
Who cares?
It's arbitrary as long as you're

121
00:05:49.761 --> 00:05:50.458
consistent, right.

122
00:05:50.458 --> 00:05:51.530
And now we've got the message.

123
00:05:51.530 --> 00:05:55.210
So system out, got request, whatever.

124
00:05:55.210 --> 00:05:58.650
Okay, let's configure this now.

125
00:05:58.650 --> 00:06:01.290
And the configuration is a little
annoying because you have to seal.

126
00:06:01.290 --> 00:06:05.869
Remember, Kafka, like RabbitMQ,
is sort of client agnostic.

127
00:06:05.869 --> 00:06:09.250
It doesn't require you to,
it doesn't require Java or whatever.

128
00:06:09.250 --> 00:06:10.490
It can be used from any language.

129
00:06:10.490 --> 00:06:13.210
This is, by the way,
in stark contrast to something called jms.

130
00:06:13.210 --> 00:06:15.380
Java Messaging Service.

131
00:06:15.380 --> 00:06:18.420
If you ever encounter this,
run the other way, right?

132
00:06:18.420 --> 00:06:20.220
Just turn right back around,
go somewhere else.

133
00:06:20.220 --> 00:06:21.140
It's not for you.

134
00:06:21.140 --> 00:06:26.376
JMS is a very, very misguided
standard from the Oracle Java

135
00:06:26.376 --> 00:06:32.780
community process people from 20
years ago, 25 years ago, right.

136
00:06:32.780 --> 00:06:36.340
And it's meant to be
an abstraction around messaging.

137
00:06:36.340 --> 00:06:40.180
And the core abstraction
has this concept of a.

138
00:06:41.760 --> 00:06:46.719
You have topics and or queues.

139
00:06:46.719 --> 00:06:50.880
You have a producer and a consumer
that can send to a topic in a queue.

140
00:06:50.880 --> 00:06:51.960
Well, a couple things.

141
00:06:51.960 --> 00:06:55.536
First, it was just a set
of Java interfaces.

142
00:06:55.536 --> 00:06:57.881
There's no protocol implied.

143
00:06:57.881 --> 00:07:02.528
So if you are on one microservice and
you're the consumer of the message and

144
00:07:02.528 --> 00:07:07.324
I'm in the other microservice and
the central JMS broker that we're using,

145
00:07:07.324 --> 00:07:10.311
whatever it is,
has upgraded the technology.

146
00:07:10.311 --> 00:07:11.951
They can actually break
their own wire protocol.

147
00:07:11.951 --> 00:07:16.638
Requiring both producer and consumer
to upgrade their client jars, right?

148
00:07:16.638 --> 00:07:17.797
There's no protection against that.

149
00:07:17.797 --> 00:07:21.717
The whole point of messaging is to
decouple systems from each other so

150
00:07:21.717 --> 00:07:25.650
if you have to have so called flag
day upgrades to upgrade the client.

151
00:07:25.650 --> 00:07:28.758
And the server at the same time otherwise
they won't be able to speak to each other

152
00:07:28.758 --> 00:07:30.550
that breaks the whole point.

153
00:07:30.550 --> 00:07:33.413
It's completely anathema to
the idea of enterprise integration

154
00:07:33.413 --> 00:07:34.510
as a means of messaging.

155
00:07:34.510 --> 00:07:35.916
So JMS not great right?

156
00:07:35.916 --> 00:07:39.248
The other thing that wasn't great
about this is that the producer and

157
00:07:39.248 --> 00:07:42.596
the consumer share the same address,
they share the same location.

158
00:07:42.596 --> 00:07:44.552
They have to talk to the same topic or

159
00:07:44.552 --> 00:07:48.678
queue in the broker which means that if
I want to do some routing in between.

160
00:07:48.678 --> 00:07:52.500
If I decide tomorrow that I want to
introduce some intermediary steps between

161
00:07:52.500 --> 00:07:56.400
producer and consumer I can't do that
without rewriting the consumer right?

162
00:07:57.440 --> 00:08:00.838
So protocols like RabbitMQ and
now Kafka have support for

163
00:08:00.838 --> 00:08:05.170
sort of transparently slotting in
these extra opportunities, right?

164
00:08:05.170 --> 00:08:06.810
These extra waypoints.

