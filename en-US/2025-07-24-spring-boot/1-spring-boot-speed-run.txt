[00:00:00]
>> Josh Long: So what is it? What does it look like when it's done? Well, I don't know if I can do it well, but let's just take a look at it. We're going to build something very, very quickly here. We're going to go to my second favorite place on the Internet.

[00:00:09]
This is Start Spring IO. This is where I'm going to begin all my little Spring Boot projects. Today you have some choices you need to make when you build your first application. What build tool do you want to use? Look, this thing has memory, right? So Start Spring IO, it keeps a cookie.

[00:00:23]
So if I go here, refresh and it says Kotlin again, even though I chose Maven before, now I refresh, it says Maven. Get it? Yeah, okay, good. So that's convenient. I'll be choosing Maven for you. The default will probably be Gradle and Groovy, right? If you want Maven, just check that old box there.

[00:00:39]
What language do you like to use? I'm going to use Java, just because for the moment it is the most widely used language on the jvm. How many of you are using Java? Kotlin. Okay, well, Kotlin is very, very popular in the Java community. I think an owing into in part to the prevalence of its use in Android and of course the full throated support for it by spring in the spring ecosystem back in 2016 and onward.

[00:01:04]
So Kotlin's a very good choice. Groovy, a nice language as well. Very, very well supported as well. So that's that. What version of Spring Boot are we going to use? Well, of course, the latest and greatest 3.4.4. And then what questions do we want to ask? What do we want to name this service?

[00:01:17]
Well, I'm going to call this service Service because I'm amazing with names. Amazing with names. I get that from my dad. My dad was amazing with names. When we had a small. When I was a boy, we had a small white dog and my father named him White Dog.

[00:01:29]
Again, amazing with names. Okay, now we have a choice also down here of what version of Java do you want to use? Friends, I would be doing you a disservice if I recommended anything but the latest and greatest GA version, which to wit, is Java 24. So we're going to use Java 24.

[00:01:48]
If you wanted to do it wrong, you could use one of these other ones. Right, but that would be. There's a lot of reasons why you should be using Java 24, about which we'll speak in due course. But just keep in mind Java 24 is a great version.

[00:01:58]
So anyway, we have this new project and we're going to add some dependencies. We're just going to build something very quickly. This is not really an introduction to any of these technologies per se, just a demonstration of what is possible if you're sort of inspired enough. So I'm going to use the Spring Boot DevTools to do fast reloads.

[00:02:13]
I'll bring in Spring's Web support to support building a Web server. I'm gonna bring in the Spring Boot Actuator to support observability. I'm gonna bring in Spring Data JDBC to bring in an ORM. I'm gonna bring in Postgres, the driver, the client to talk to the Postgres database that will be stood up for me by Docker Compose, which I'll also bring in.

[00:02:28]
And I'm also gonna bring in GraalVM's Native Image support technology, and I think that'll do. So let's go ahead and hit Generate. I'm going to open this up in my IDE now, friends, I have this. Unzip and open uao. This is a Java and what I mean by that is I'm using this Java program, right?

[00:02:47]
It's a void main var find the file, detect the presence of a file that is a build file, right? And if it's there, I shell out and I run idea space buildFile. It's written in Java and I'm not even running the class file. Notice this is just a source code file.

[00:03:03]
You can run this on the JVM just by saying java --enable-preview --source 24 and then pointing to the source code file. So it's a script written in Java. Notice that there's no class. There's no class main whatever around the void main method. And there's no public static either.

[00:03:17]
So it's very, very convenient. So that's an alias in my shell. All it's doing is running unzip, seeding into the directory and then running idea space pom xml, okay? So you can do the same at home or you could use that same source code or whatever. So uao, there we go.

[00:03:33]
And we're not going to spend too long here. I've got a brand new project that was created for me that gave me a Docker Compose file, right? You can see that right here. I'm going to manually connect to this. I'm gonna add the port so it's exposed, it's for Postgres, obviously.

[00:03:46]
I'm going to disable the spring boot support for Docker Compose. We'll get into this stuff a little bit later, but don't need it just now. I'm going to go ahead and run the Docker image. So Docker compose up- D, okay? That should. Wow, pulling, okay. And we're going to build a simple application that talks to that database to store data of type customer.

[00:04:06]
So let's talk about the code here first. The code is the hardest part, right. We want to get that done as quickly as possible. So we'll create a domain called customer int ID string name and there's this customer integer. And then this would be called customer repository, okay.

[00:04:28]
So there's that. That's my whole ORM domain model. And I want a simple HTTP endpoint. Yeah, so I'll say bean router function, server response, okay. Server response HT. Whatever my routes, right. Return route. Okay, .build. Get customers. And we're going to return a handler server response, okay. Body passing in the results from the orm.

[00:04:59]
So we'll say customer repository repository. Injecting that there for reference, find all, okay. So that's the core code. Remove this. Get rid of the static import. Fantastic. Get rid of the unused variable. Good. And we want to say, okay, let's get rid of that dot body. Put that in there.

[00:05:27]
And then we don't need this. Okay, that looks like it should work. So that's my basic code. But we need a domain obviously we need something in the database. So let's actually initialize some schema here. So I'll create a little file here called schema SQL create table if not exists customer Idaho serial primary key name text not null.

[00:05:50]
And I'll create some sample data as well. So I'll say data SQL insert into customer name values. My name is Josh. Let's go around the room and get some other names here. What's your name, friend? If you want.
>> Tom: Tom.
>> Josh Long: Tom, okay. You can give me fake names, by the way.

[00:06:08]
There's no requirement here.
>> Ben: Ben.
>> Josh Long: Ben, nice to meet you all by the way. Tom and Ben. Just go for a few of them. Here we go.
>> Luke: Luke.
>> Josh Long: Hi, Luke.
>> Sam: Sam.
>> Josh Long: Okay, people in the room. Okay, so that's some sample data. I'm going to drop the table if it exists before I recreate it, because it's going to get.

[00:06:26]
We'll restart all the time. So if table exists customer. And then we're going to tell spring boot to connect to that data source. So spring data Source data source URL JDBC, PostgreSQL, Localhost, MyDatabase. Yeah, and then we'll say username, my user and then password. And again we specified this in the docker compose file.

[00:06:52]
You can see it says database Secret, MyUser, etc. So secret. Don't tell anybody. That's our little secret. I'm going to tell spring boot also to initialize the database with the schema files that we've put there. And I think that's it. Let's go ahead and spin that up and see what we get.

[00:07:05]
So we'll go over to the browser localhost 8080 customers and there's our HTTP endpoint with some customer data. Fine, okay. Now of course I've got the application up and running over here and I've got dev tools working in the background. So let's just create a simple hello world.

[00:07:21]
I suppose I should have done that first, right? So I can go over here, I'll add hello world, map of message. Hello world. Go over here and I go to hello and there's that endpoint. The codes in the repo, it's called intro. It's the first folder called there and I've got a readme in the base of the repository called readme and you can see that.

[00:07:44]
But I wanted to do just let me just spin through this here quickly and so you can kind of see what we're going for and then we'll slowly unwind it. Okay, so okay, so we've got the application, we're able to move quickly. I'm able to add HTTP endpoints here.

[00:07:56]
I think it's now time to by the way, also observability. Right, we've got to actuator. You've got these endpoints that show you the health status of the application. This kind of stuff. You can easily imagine deploying this to a production environment and it would play well with your load balancers and the like.

[00:08:10]
But now I want to actually make this a production worthy application by default. In spring boot, if you compile a spring boot application, you say maven clean package and then compile and run that, okay. CD target. By default you get a jar, right? This is a jar right here and you can run the jar.

[00:08:28]
Let me stop the running process here. Stop that. You can run the jar over here by saying Java minus jar service jar. The problem with that is that this requires you to have a JRE on your host. You need to have the Java runtime installed for this to work.

[00:08:45]
So what we'll talk about today, a lot is graalvm. So here's what that's going to look like. I'm going to compile this into a native image. We're going to compile this. This will take, I don't know, 30 seconds. Did I not choose Graal? What did I do? D, there we go.

[00:09:02]
It's going to turn it into a graalvm native image. This is a JVM that we're having on our local machine. And we're going to talk about how to get your machine set up accordingly in just a bit here. But basically, when I install GraalVM for Java 24, and this will take a little while to compile, this takes a fair bit longer than any JRE compilation.

[00:09:20]
Okay, like it could be 10, 20, 30 seconds, I don't know, something like that, maybe as much as a minute. But the benefit of this is that it's not going to require a Java runtime. It's going to have everything it needs to run and execute efficiently on an operating system.

[00:09:37]
So target. Here we go. DU HS service. There you go, 90 megs. That includes the JRE, that includes your binary, the web server, the ORM data access technology, the postgres client, etc. And there's the program up and running. So that's been a speedrun. We've gone from zero to hero in no time at all.

[00:09:55]
I don't know how long that took, but a matter of minutes. And that includes a walking tour of everything as we went along. We didn't really get into the dips, but now you kind of understand what we're looking for, right? My goal is to get us to the point where by the end of this, you're all able to do that as well.

