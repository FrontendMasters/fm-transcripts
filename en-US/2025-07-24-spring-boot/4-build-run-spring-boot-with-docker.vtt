WEBVTT

1
00:00:00.240 --> 00:00:03.744
&gt;&gt; Josh Long: We have a sample application
that we built in the intro and

2
00:00:03.744 --> 00:00:07.324
that sample application,
I showed you both how to run it.

3
00:00:07.324 --> 00:00:08.903
I ran it from within the IDE.

4
00:00:08.903 --> 00:00:12.880
I right clicked on it and
I chose debug or run or whatever.

5
00:00:12.880 --> 00:00:14.400
And that'll run in your local IDE.

6
00:00:14.400 --> 00:00:16.493
I've got the port being blocked.

7
00:00:16.493 --> 00:00:18.599
Let me shut down that.

8
00:00:18.599 --> 00:00:21.521
Where is actually that
port over here surely.

9
00:00:21.521 --> 00:00:25.158
Yeah, so
I can run in the IDE like that, right?

10
00:00:25.158 --> 00:00:29.553
And make sure that when you're running it,
make sure you have the green spring leaf,

11
00:00:29.553 --> 00:00:30.990
not the regular Java one.

12
00:00:30.990 --> 00:00:33.110
This is just a regular Java process.

13
00:00:33.110 --> 00:00:34.590
IntelliJ has some badging.

14
00:00:34.590 --> 00:00:35.830
It's like a facet or whatever.

15
00:00:35.830 --> 00:00:38.399
It'll detect that you're
using a spring app and

16
00:00:38.399 --> 00:00:41.629
it'll run things a little
bit more quickly that way.

17
00:00:41.629 --> 00:00:43.116
Okay, so that's on the IDE.

18
00:00:43.116 --> 00:00:47.676
But if I just want to
test on the command line,

19
00:00:47.676 --> 00:00:53.916
if want to like know for
sure it's working, go to your code and

20
00:00:53.916 --> 00:00:59.319
CD service and
I'm going to do maven spring boot run.

21
00:00:59.319 --> 00:01:00.530
Let me stop this over here.

22
00:01:01.970 --> 00:01:06.567
And then that'll run it on the JRE on
your local machine, as you'd expect.

23
00:01:06.567 --> 00:01:12.930
Now that's on the jre,
I've got this JVM application.

24
00:01:12.930 --> 00:01:14.250
It's on the JRE like I said.

25
00:01:14.250 --> 00:01:17.899
And I showed you this,
the self contained jar.

26
00:01:17.899 --> 00:01:19.530
But that still requires a jvm, right?

27
00:01:19.530 --> 00:01:23.330
So DU minus HS service blah jar.

28
00:01:23.330 --> 00:01:26.252
This is not what you would normally
get if you compiled the jar.

29
00:01:26.252 --> 00:01:30.410
Because we only wrote like
10 lines of code, right?

30
00:01:30.410 --> 00:01:31.296
It's whatever.

31
00:01:31.296 --> 00:01:35.879
The source code that we contributed to
the project was not even a kilobyte,

32
00:01:35.879 --> 00:01:36.691
basically.

33
00:01:36.691 --> 00:01:38.570
And yet this jar is 27 megs.

34
00:01:38.570 --> 00:01:42.466
And that's because it contains everything
you need to run the program, except for

35
00:01:42.466 --> 00:01:44.130
the JRE itself.

36
00:01:44.130 --> 00:01:45.762
Then I turned it into a native image and

37
00:01:45.762 --> 00:01:48.318
then it contained everything
it needed to run the program.

38
00:01:48.318 --> 00:01:49.870
Including the jre, right?

39
00:01:49.870 --> 00:01:51.812
Including the runtime
in that native binary.

40
00:01:51.812 --> 00:01:55.871
And that native binary was a full 75,
no, 90 megs.

41
00:01:55.871 --> 00:01:59.120
So yeah, quite a bit bigger, right?

42
00:01:59.120 --> 00:02:02.159
63 megs bigger than without.

43
00:02:02.159 --> 00:02:07.116
So that 63 megs will be the JRE that
gets packaged in the native binary.

44
00:02:07.116 --> 00:02:08.930
That native binary is macOS specific.

45
00:02:08.930 --> 00:02:11.805
It does not run,
it's not write once run anywhere.

46
00:02:11.805 --> 00:02:16.035
It only works on Mac and when you compile
it on Windows you get service exe and

47
00:02:16.035 --> 00:02:16.786
guess what?

48
00:02:16.786 --> 00:02:18.006
It'll only run on Windows.

49
00:02:18.006 --> 00:02:20.567
When you compile it on Linux, guess what?

50
00:02:20.567 --> 00:02:22.526
It'll run on Linux.

51
00:02:22.526 --> 00:02:26.618
One of the things that's really nice
about that is that you can also build

52
00:02:26.618 --> 00:02:28.642
a Docker image out of this project.

53
00:02:28.642 --> 00:02:37.000
So Maven Spring Boot build image.

54
00:02:38.680 --> 00:02:40.186
So I'm going to run that and

55
00:02:40.186 --> 00:02:43.538
then let it do its thing in
the background behind the scenes.

56
00:02:43.538 --> 00:02:45.102
That's going to use buildpacks and

57
00:02:45.102 --> 00:02:47.458
buildpacks will actually
dockerize my image for me.

58
00:02:54.464 --> 00:02:55.250
Buildpacks are.

59
00:02:55.250 --> 00:02:55.761
There you go.

60
00:02:55.761 --> 00:03:01.290
Buildpacks are a technology that was
originally created by the folks at Heroku.

61
00:03:01.290 --> 00:03:02.108
Have you heard of Heroku?

62
00:03:02.108 --> 00:03:03.730
It's a platform as a service.

63
00:03:03.730 --> 00:03:07.123
They created it back in 2008.

64
00:03:07.123 --> 00:03:12.702
They made originally they were a platform
specifically for Ruby on Rails apps and

65
00:03:12.702 --> 00:03:18.132
eventually they migrated towards sort
of cross language polyglot runtimes.

66
00:03:18.132 --> 00:03:21.807
And to support that they needed a little
bit of indirection between the bit that

67
00:03:21.807 --> 00:03:24.380
actually runs the program and
the bit that you upload.

68
00:03:24.380 --> 00:03:29.300
So when you upload something to Heroku,
how do they then know to run it?

69
00:03:29.300 --> 00:03:30.860
Well, they need to standardize.

70
00:03:30.860 --> 00:03:34.013
They need to have a set of
standardized scripts that know how

71
00:03:34.013 --> 00:03:36.550
to run a given source code repository,
right?

72
00:03:36.550 --> 00:03:40.780
So if it's a Java workload versus a Ruby
on Rails workload versus a Python workload

73
00:03:40.780 --> 00:03:45.230
versus a PHP versus whatever, they need to
have a standardized set of hooks to call.

74
00:03:45.230 --> 00:03:48.969
So they created this buildpack concept.

75
00:03:48.969 --> 00:03:52.190
I work at Broadcom, we have
a distribution called Cloud Foundry.

76
00:03:52.190 --> 00:03:53.950
Cloud Foundry is.

77
00:03:53.950 --> 00:03:57.188
We have a product called Tanzu Application
service based on something called

78
00:03:57.188 --> 00:03:57.893
Cloud Foundry.

79
00:03:57.893 --> 00:04:01.380
Cloud Foundry is an open source
platform platform as a service,

80
00:04:01.380 --> 00:04:03.976
very much in the style and
the spirit of Heroku.

81
00:04:03.976 --> 00:04:08.447
And because that was a good idea,
these buildpacks are such a good idea,

82
00:04:08.447 --> 00:04:12.360
we pulled these things in,
we pulled in buildpacks as well.

83
00:04:12.360 --> 00:04:16.680
And so buildpacks are actually something
that we both separately innovated on.

84
00:04:16.680 --> 00:04:21.520
And then eventually for version 3.0 of
the technology, we worked together.

85
00:04:21.520 --> 00:04:23.966
So we actually released
version three of BuildPacks.

86
00:04:23.966 --> 00:04:26.892
And you can actually find
information about BuildPacks here.

87
00:04:26.892 --> 00:04:30.608
BuildPacks IO, Cloud Native BuildPacks.

88
00:04:30.608 --> 00:04:34.878
And these are basically
container first recipes for

89
00:04:34.878 --> 00:04:39.730
turning an arbitrary workload,
be it a Java application or

90
00:04:39.730 --> 00:04:43.428
Python or NET or COBOL or
Next JS or whatever.

91
00:04:43.428 --> 00:04:47.792
And turning it into a container
that you can then run.

92
00:04:47.792 --> 00:04:49.080
If you're using that, you can use it.

93
00:04:49.080 --> 00:04:51.160
There's a pack CLI that you can use.

94
00:04:51.160 --> 00:04:52.238
But I just did this.

95
00:04:52.238 --> 00:04:55.046
I used the spring boot plugin,

96
00:04:55.046 --> 00:05:00.242
spring boot build image and
I got this Docker image here.

97
00:05:00.242 --> 00:05:05.200
So I can do Docker run and
there's the application.

98
00:05:06.560 --> 00:05:08.758
So I've already Got the port.

99
00:05:08.758 --> 00:05:12.607
I don't have the right.

100
00:05:12.607 --> 00:05:16.576
It's not going to connect to postgres
because it's inside of local host in

101
00:05:16.576 --> 00:05:19.548
my Docker image is not the same
as my Mac OS Hosting port.

102
00:05:19.548 --> 00:05:24.758
So minus e spring data source

103
00:05:24.758 --> 00:05:31.276
URL equals jdbc PostgreSQL local.

104
00:05:31.276 --> 00:05:32.086
Sorry, it's what is it?

105
00:05:32.086 --> 00:05:39.303
A host.docker.Internet my database,

106
00:05:39.303 --> 00:05:45.080
I think, 8080: 8080.

107
00:05:46.670 --> 00:05:47.550
Is that the right port?

108
00:05:48.750 --> 00:05:49.350
Looks like it.

109
00:05:49.350 --> 00:05:52.070
Okay, so
now if I go to localhost customers.

110
00:05:52.070 --> 00:05:53.790
Yeah, there you go.

111
00:05:53.790 --> 00:05:58.190
So I ran this Docker image, this Docker
image I generated from buildpacks.

112
00:05:58.190 --> 00:05:58.910
Did you all see that?

113
00:06:01.709 --> 00:06:03.350
I used spring boot build image.

114
00:06:03.350 --> 00:06:06.187
It built a Docker image for
me out of my application.

115
00:06:06.187 --> 00:06:10.350
I then ran it on my local machine and I
had to override the environment variable,

116
00:06:10.350 --> 00:06:12.520
the property spring data source URL.

117
00:06:12.520 --> 00:06:17.245
I overrode it by pointing it to
host.docker.Internet which is the host of

118
00:06:17.245 --> 00:06:20.470
my Mac relative to the container
running on my Mac,

119
00:06:20.470 --> 00:06:24.360
which is running inside
of a virtual machine.

120
00:06:24.360 --> 00:06:26.520
Okay, so that should be very easy.

121
00:06:26.520 --> 00:06:30.520
Getting a dockerized image out of your
source code should not be a thing.

122
00:06:30.520 --> 00:06:31.800
This should not be a problem.

123
00:06:31.800 --> 00:06:36.458
If you spend more than one second trying
to make that work, you spend too long.

124
00:06:36.458 --> 00:06:40.843
It's built in your production
worthy out of the box, so

125
00:06:40.843 --> 00:06:43.280
you can focus on other things.

126
00:06:43.280 --> 00:06:44.860
You can also build a native image.

127
00:06:44.860 --> 00:06:46.940
So I go over here, let's see.

128
00:06:46.940 --> 00:06:48.220
Do that again.

129
00:06:48.220 --> 00:06:53.370
Remember, I built a native image on
the local Mac, but if you want this Docker

130
00:06:53.370 --> 00:06:58.700
image to have that native image,
then you have to enable this so P native.

131
00:06:58.700 --> 00:07:00.540
And that will take a fair bit longer.

132
00:07:00.540 --> 00:07:05.473
But what that's going to do is it's
going to compile in my Docker image.

133
00:07:05.473 --> 00:07:09.953
It's going to compile the native image and
then package that native Linux binary in

134
00:07:09.953 --> 00:07:12.833
the Docker image,
even though I'm running on a Mac.

135
00:07:12.833 --> 00:07:17.322
So it's going to do the compilation in
the Docker virtual machine on Linux.

136
00:07:17.322 --> 00:07:19.972
So then the resulting binary
will be Linux as well.

137
00:07:19.972 --> 00:07:24.595
So now I'll have something I can
deploy to any container registry, and

138
00:07:24.595 --> 00:07:26.916
it'll run anywhere that Linux is.

139
00:07:26.916 --> 00:07:27.590
It will work.

140
00:07:27.590 --> 00:07:28.790
So this will take a fair bit longer.

141
00:07:28.790 --> 00:07:31.688
Remember that native
image compilation takes

142
00:07:31.688 --> 00:07:34.220
a lot longer than just regular JVM runs.

143
00:07:36.220 --> 00:07:38.980
Okay, so
that Docker image is built, right?

144
00:07:38.980 --> 00:07:41.821
That took a minute, a whole minute to
build a Docker image that has native

145
00:07:41.821 --> 00:07:43.180
code inside of it though, right?

146
00:07:43.180 --> 00:07:50.316
So if I run this Docker run that starts
up Same issue as before, though.

147
00:07:50.316 --> 00:07:52.588
So here we go.

148
00:07:52.588 --> 00:07:54.968
That starts up in 75 milliseconds.

149
00:07:54.968 --> 00:07:57.460
So keep in mind what just happened.

150
00:07:57.460 --> 00:08:05.016
I built a native image inside of
a Docker image, ran it on my Mac.

151
00:08:05.016 --> 00:08:09.648
Remember, behind the scenes, Docker is
using virtualization to simulate Linux and

152
00:08:09.648 --> 00:08:12.600
then inside Linux, I did the compilation.

153
00:08:12.600 --> 00:08:16.336
And then I'm inside that Linux emulation,
I'm running Java,

154
00:08:16.336 --> 00:08:18.440
I'm running the native binary.

155
00:08:18.440 --> 00:08:23.099
The native binary inside of Linux on
my Mac start up in 75 milliseconds,

156
00:08:23.099 --> 00:08:27.330
whereas the native binary on my
Mac directly started up in point.

157
00:08:27.330 --> 00:08:29.010
What was it, 9 or something like that?

158
00:08:29.010 --> 00:08:30.050
0.8.

159
00:08:30.050 --> 00:08:31.114
It's actually faster.

160
00:08:31.114 --> 00:08:32.390
The Linux compilation.

161
00:08:32.390 --> 00:08:35.250
The native image compilation you get
on Linux is actually amazingly fast.

162
00:08:35.250 --> 00:08:39.011
It's much faster than the native
one on Mac OS for me at least.

163
00:08:39.011 --> 00:08:43.568
So you might be surprised to actually
have better performance on Linux,

164
00:08:43.568 --> 00:08:48.812
even though you've presumably got a much
better laptop than you do in production.

165
00:08:48.812 --> 00:08:53.401
Your machine's low, your machine for
your desktop is better.

166
00:08:53.401 --> 00:08:56.320
Okay, so that's how to get.

167
00:08:56.320 --> 00:08:57.977
That's how to get.

168
00:08:57.977 --> 00:09:02.718
I want you to know, graalvm, Docker,
these two things, they are your tools for

169
00:09:02.718 --> 00:09:05.952
building and
producing images that go to production.

170
00:09:05.952 --> 00:09:11.409
When I say Docker, one of the things that
people always ask about is, how do I build

171
00:09:11.409 --> 00:09:16.888
applications and support that git clone
run life if I need a postgres or whatever?

172
00:09:16.888 --> 00:09:20.586
Well, you saw me do it earlier,
you saw me go to start Spring IO and

173
00:09:20.586 --> 00:09:22.760
I can choose Docker Compose support.

174
00:09:23.880 --> 00:09:28.093
There's another thing I can choose,
which is test containers support.

175
00:09:28.093 --> 00:09:30.314
So I'm going to add postgres here again.

176
00:09:30.314 --> 00:09:33.480
So this is, I'm going to close
the old example down here.

177
00:09:33.480 --> 00:09:35.040
This is not running anymore.

178
00:09:35.040 --> 00:09:40.033
Closing that and we're going to hit

179
00:09:40.033 --> 00:09:44.690
Enter CD Downloads UAO demo.

180
00:09:44.690 --> 00:09:49.357
Okay, so you can see what has happened
is that the Spring initializer

181
00:09:49.357 --> 00:09:54.106
generated this Docker compose file for
postgres and it'll do that for

182
00:09:54.106 --> 00:09:57.904
a lot of things if you do MySQL
let's see if it does that.

183
00:09:57.904 --> 00:09:59.248
If I go, by the way,

184
00:09:59.248 --> 00:10:03.810
control space on Start Spring IO lets you
explore the files that will get generated.

185
00:10:05.090 --> 00:10:05.731
So there you go.

186
00:10:05.731 --> 00:10:08.370
You can see, actually there's Postgres and
MySQL at the top.

187
00:10:08.370 --> 00:10:10.971
What about Neo4j?

188
00:10:10.971 --> 00:10:14.076
Or what about MongoDB?

189
00:10:14.076 --> 00:10:18.151
If I go over here, there's MongoDB,
Atlas, the Vector Store,

190
00:10:18.151 --> 00:10:21.500
there's MySQL there's Neo4j,
what about Redis?

191
00:10:23.820 --> 00:10:26.900
Go over here again and there's Redis.

192
00:10:26.900 --> 00:10:29.232
So you can see it's pretty
helpful if you really want to.

193
00:10:29.232 --> 00:10:32.460
If you like Cert Spring, that is not just
a great way to build a new Spring project.

194
00:10:32.460 --> 00:10:35.017
It can be a really great way
to get some test images for

195
00:10:35.017 --> 00:10:38.405
all these different data stores you
might want to use up and running.

196
00:10:38.405 --> 00:10:39.854
So I went to Start Spring IO.

197
00:10:39.854 --> 00:10:41.050
I had chose control space.

198
00:10:42.650 --> 00:10:46.570
I can explore, compose YAML,
I can copy and paste that.

199
00:10:46.570 --> 00:10:50.626
I'm adding infrastructure to my build and
it's automatically giving me these Docker

200
00:10:50.626 --> 00:10:53.050
containers that I can run
to start up a test local.

201
00:10:53.050 --> 00:10:56.490
MongoDB, MySQL, Neo4j,
Postgres, Redis, etc.

202
00:10:58.090 --> 00:11:01.770
I did that over here in my brand
new project Start Spring IO.

203
00:11:01.770 --> 00:11:05.530
And when I did that,
it added some dependencies to the build.

204
00:11:05.530 --> 00:11:07.539
Docker Compose, right?

205
00:11:07.539 --> 00:11:10.090
It also added test containers.

206
00:11:10.090 --> 00:11:13.803
So these two things are very important
when we start the Spring boot application.

207
00:11:13.803 --> 00:11:17.331
When I start the Spring boot application
with the Docker Compose support,

208
00:11:17.331 --> 00:11:19.179
remember in this Docker compose file,

209
00:11:19.179 --> 00:11:21.936
I have not exposed,
I have not exported the port, right.

210
00:11:21.936 --> 00:11:23.210
The port is just local.

211
00:11:23.210 --> 00:11:25.370
But I've got a Docker image here for
postgres.

212
00:11:25.370 --> 00:11:27.266
Okay, so let's go back to this.

213
00:11:27.266 --> 00:11:32.604
I'll say Docker PS minus a Docker RM F and

214
00:11:32.604 --> 00:11:36.064
then take that Docker ps.

215
00:11:36.064 --> 00:11:38.042
There's no Docker images running here.

216
00:11:38.042 --> 00:11:39.845
So now I'm going to run
this application and

217
00:11:39.845 --> 00:11:42.097
remember how quickly these
things start up normally.

218
00:11:42.097 --> 00:11:46.494
But I've left this
Docker Compose support here.

219
00:11:46.494 --> 00:11:47.810
Docker Compose.

220
00:11:47.810 --> 00:11:48.870
Okay, that's there.

221
00:11:48.870 --> 00:11:50.249
Let's run this application.

222
00:11:50.249 --> 00:11:55.014
No changes to the code whatsoever.

223
00:11:55.014 --> 00:11:59.676
You can see it took forever to start up
because it actually started up the Docker

224
00:11:59.676 --> 00:12:00.460
file for me.

225
00:12:02.380 --> 00:12:05.016
But the result is that that
took almost twice as long,

226
00:12:05.016 --> 00:12:08.140
four times as long as it would
normally to start it up.

227
00:12:08.140 --> 00:12:12.648
This is quite convenient because
now during my development time,

228
00:12:12.648 --> 00:12:17.407
if I go over here, Docker ps,
you can see I've got Postgres running.

229
00:12:17.407 --> 00:12:19.261
My applications are already
connected to it.

