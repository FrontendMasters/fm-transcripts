WEBVTT

1
00:00:00.150 --> 00:00:04.843
&gt;&gt; Maximiliano Firtman: So,
the final section, it's just some ideas,

2
00:00:04.843 --> 00:00:09.421
some other patterns that
I wanna just throw here

3
00:00:09.421 --> 00:00:15.080
that cannot be categorized
on the previous one.

4
00:00:15.080 --> 00:00:18.577
First, when we are talking about
design patterns for web apps,

5
00:00:18.577 --> 00:00:22.009
there are a lot of classic patterns
that probably you know, but

6
00:00:22.009 --> 00:00:25.370
you didn't recognize
initially as design patterns.

7
00:00:25.370 --> 00:00:27.250
For example, progressive web apps.

8
00:00:28.400 --> 00:00:32.870
Progressive web app creation or design or
development is actually a design pattern.

9
00:00:32.870 --> 00:00:37.336
We don't have an API with
the name progressive web app,

10
00:00:37.336 --> 00:00:40.781
it's not really a type of HTML.

11
00:00:40.781 --> 00:00:43.531
So what it is, it's just a design pattern.

12
00:00:44.931 --> 00:00:49.204
It's more an architectural design pattern,
but it's a design pattern when you wanna

13
00:00:49.204 --> 00:00:52.551
create installable offline capable
apps using web technologies.

14
00:00:53.911 --> 00:00:58.531
Responsive web design is
another design pattern.

15
00:00:58.531 --> 00:01:03.832
When you use those terms, and
you realize there is no API behind that.

16
00:01:03.832 --> 00:01:07.238
Yeah, responsibly using media queries,
yeah, it's using, but

17
00:01:07.238 --> 00:01:10.382
that using is part of the solution
of the design pattern.

18
00:01:10.382 --> 00:01:14.605
There was a problem, this design
pattern is offering you a solution.

19
00:01:14.605 --> 00:01:17.382
Then these are design patterns,

20
00:01:17.382 --> 00:01:23.107
mobile first is another classic
design pattern for web apps.

21
00:01:23.107 --> 00:01:28.766
The idea was, when you start a new
project, start thinking about the mobile

22
00:01:28.766 --> 00:01:34.607
device first, and then you move it
into the desktop offline first.

23
00:01:34.607 --> 00:01:37.737
Just think your app for offline usage.

24
00:01:37.737 --> 00:01:40.276
So think that the user will
never have connection.

25
00:01:40.276 --> 00:01:42.861
Of course, at least you will need
connection once to actually get

26
00:01:42.861 --> 00:01:43.976
your app once.

27
00:01:43.976 --> 00:01:52.046
But try to think about your app as if
we'll never get connection in the future.

28
00:01:52.046 --> 00:01:57.419
Okay, so well in the progressive web app,
course, of course, another

29
00:01:57.419 --> 00:02:03.426
link to another course, we cover some of
those design patterns in more details.

30
00:02:05.636 --> 00:02:10.676
Progressive enhancement is another design
pattern that we have already used here.

31
00:02:10.676 --> 00:02:13.966
In fact, the P in PWAs is coming
from progressive enhancement.

32
00:02:15.066 --> 00:02:18.006
Not every platform supports all
the APIs that we want to use.

33
00:02:19.488 --> 00:02:24.115
So instead of just using it or giving
the user an error message, I'm sorry,

34
00:02:24.115 --> 00:02:27.668
you cannot use my app,
your browser is not compatible.

35
00:02:27.668 --> 00:02:31.148
That was in the 90s,
we were saying this, a message.

36
00:02:31.148 --> 00:02:34.828
Now you need Netscape to access my
website if not, it's not gonna work.

37
00:02:34.828 --> 00:02:39.750
Instead of that, the solution is
start by offering A web solution

38
00:02:39.750 --> 00:02:43.699
that works everywhere that
you can run even on IE4.

39
00:02:44.829 --> 00:02:49.229
And then maybe not IE4, but IE12 maybe.

40
00:02:49.229 --> 00:02:52.999
And then you add layers on top.

41
00:02:52.999 --> 00:02:58.629
It's like if view transitions API is
available, okay, we use view transitions.

42
00:02:58.629 --> 00:03:01.064
If web Bluetooth is available,
we use web Bluetooth.

43
00:03:01.064 --> 00:03:06.164
But you don't give them an error
message if the API is not there.

44
00:03:06.164 --> 00:03:09.094
Yeah, that ability might not be there,
but that's all.

45
00:03:10.294 --> 00:03:15.263
Use cases, access hardware and platform
APIs offline support because maybe

46
00:03:15.263 --> 00:03:20.014
you don't have service worker support,
accessibility as well, okay?

47
00:03:22.204 --> 00:03:27.756
I think I have two or
three more quick design patterns

48
00:03:27.756 --> 00:03:33.384
to show you in case you
wanna get deeper later.

49
00:03:33.384 --> 00:03:35.944
HTML streaming, this sounds interesting.

50
00:03:36.994 --> 00:03:42.035
So on large pages the browser doesn't
render or even parse the page until all

51
00:03:42.035 --> 00:03:47.103
the response was sent and downloaded,
which leads to a performance issue.

52
00:03:47.103 --> 00:03:51.468
And by the way,
performance is a large, huge topic.

53
00:03:51.468 --> 00:03:54.310
There are a couple of workshops at
Frontend Masters just to talk about

54
00:03:54.310 --> 00:03:55.094
performance, and

55
00:03:55.094 --> 00:03:58.093
there are a lot of design patterns
also that are targeting performance.

56
00:03:59.333 --> 00:04:03.071
So, In this case, there is a new
API known as the Stream API.

57
00:04:04.121 --> 00:04:08.539
So you can use the Streams API
with Service Workers, and

58
00:04:08.539 --> 00:04:11.871
you will be rendering HTML in chunks.

59
00:04:11.871 --> 00:04:17.331
So you will be receiving
chunks of bytes with the HTML.

60
00:04:17.331 --> 00:04:22.229
So the server will actually send you
partial HTML responses over the same

61
00:04:22.229 --> 00:04:23.520
HTTP connection.

62
00:04:24.550 --> 00:04:28.830
Using service workers on the Streams API,
you will receive them and

63
00:04:28.830 --> 00:04:32.808
you will pass them to the browser,
to the main window context so

64
00:04:32.808 --> 00:04:35.160
it can start rendering part by part.

65
00:04:37.050 --> 00:04:38.290
Okay, make sense?

66
00:04:38.290 --> 00:04:44.133
Use case is to improve performance on
the initial page load, that's the idea.

67
00:04:44.133 --> 00:04:48.823
Also, you can render the data
above the fold initially.

68
00:04:48.823 --> 00:04:50.423
Do you know what above the fold means?

69
00:04:52.043 --> 00:04:53.543
Have you heard about that?

70
00:04:53.543 --> 00:04:57.453
Well, I can do this,
so this is a newspaper.

71
00:04:57.453 --> 00:05:00.707
So think about newspaper,
all classic printed newspaper,

72
00:05:00.707 --> 00:05:05.325
well that newspapers were actually
really large so they were folded.

73
00:05:05.325 --> 00:05:09.507
So, of course, if you pay for
an ad it's more

74
00:05:09.507 --> 00:05:14.845
expensive if it's above
the fold not below the fold.

75
00:05:14.845 --> 00:05:19.684
And we are actually using the same terms
from above the fold and below the fold on

76
00:05:19.684 --> 00:05:24.615
the web that has to do that,
it's actually about the first scroll.

77
00:05:24.615 --> 00:05:28.848
We don't have fold levels, but
we are not talking about fold

78
00:05:28.848 --> 00:05:33.805
level devices like a Galaxy Fold,
it's just that for performance.

79
00:05:33.805 --> 00:05:37.311
The idea is that let's download the HTML
first for the above default for

80
00:05:37.311 --> 00:05:40.699
what you actually are seeing
without scrolling.

81
00:05:40.699 --> 00:05:45.775
And after that, we render the rest
using just one HTTP request,

82
00:05:45.775 --> 00:05:49.509
but using Streams, that's the idea.

83
00:05:49.509 --> 00:05:52.619
Okay this is how it looks like.

84
00:05:52.619 --> 00:05:55.499
Without streaming, it has to wait for

85
00:05:55.499 --> 00:05:59.879
the full response before
actually parsing that.

86
00:05:59.879 --> 00:06:05.797
But now the one from the bottom,
as soon as some markup arrives in chunks,

87
00:06:05.797 --> 00:06:10.403
you will start parsing and
rendering the chunk, okay?

88
00:06:10.403 --> 00:06:14.643
It's just that, so then you can
render content on the screen faster.

89
00:06:14.643 --> 00:06:16.793
&gt;&gt; Speaker 2: So
it's like infinite scrolling.

90
00:06:16.793 --> 00:06:20.229
&gt;&gt; Maximiliano Firtman: For infinite
scrolling, you can use that pattern.

91
00:06:20.229 --> 00:06:24.522
The problem with infinite scrolling
is that it's infinite and

92
00:06:24.522 --> 00:06:26.070
you cannot for that.

93
00:06:26.070 --> 00:06:30.144
It's probably better to use web sockets or
other technique,

94
00:06:30.144 --> 00:06:34.999
because in this case, we're still
we're still using HTTP response, so

95
00:06:34.999 --> 00:06:38.230
it's a server sending a response chunks.

96
00:06:38.230 --> 00:06:40.383
The problem with infinite scrolling is
that you need to wait for the user to.

97
00:06:40.383 --> 00:06:45.780
Scroll, and you don't want to keep
the HTTP connection open waiting for

98
00:06:45.780 --> 00:06:48.293
users the users to scroll.

99
00:06:48.293 --> 00:06:53.281
So maybe WebSocket is a better
implementation for that problem.

100
00:06:53.281 --> 00:06:56.787
Virtual DOM,
if you have ever played with React,

101
00:06:56.787 --> 00:07:01.473
you probably have heard about
the Virtual DOM, what's the idea?

102
00:07:01.473 --> 00:07:04.587
Working with the DOM directly
is expensive, for example,

103
00:07:04.587 --> 00:07:06.752
on an infinite scroll.

104
00:07:06.752 --> 00:07:13.662
That's one of the most used examples
of why you need this design pattern.

105
00:07:13.662 --> 00:07:18.962
So working with the DOM is expensive
from a rendering point of view.

106
00:07:18.962 --> 00:07:21.449
So the solution is to create
a Virtual DOM in memory.

107
00:07:21.449 --> 00:07:26.929
So you add elements or remove elements
in memory, not in the real DOM.

108
00:07:26.929 --> 00:07:30.929
And every once in a while,
when you when it's a good time for it.

109
00:07:30.929 --> 00:07:35.809
And there are different techniques to
actually decide when it's a good time.

110
00:07:35.809 --> 00:07:40.251
You go and synchronize your virtual
DOM with the real DOM, but you touch.

111
00:07:40.251 --> 00:07:45.963
To the real DOM once, not a lot of times,
that's kind of the idea.

112
00:07:45.963 --> 00:07:50.262
This is for complex user
interfaces with lot of elements or

113
00:07:50.262 --> 00:07:56.683
large list with re-order and operations
that you create, you add, you move, okay?

114
00:07:56.683 --> 00:07:59.663
You can use the idea of a virtual DOM.

