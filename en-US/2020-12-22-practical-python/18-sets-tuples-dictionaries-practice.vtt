WEBVTT

1
00:00:00.060 --> 00:00:04.946
We went through the practice for
sets, tuples, and

2
00:00:04.946 --> 00:00:11.064
dictionaries, as well as the practice for
logic and functions.

3
00:00:11.064 --> 00:00:16.210
After lunch, we're going to review
loops and the exercises for loops.

4
00:00:16.210 --> 00:00:21.045
I feel like I am doing a pretty good job
today cuz I think everybody is back, so

5
00:00:21.045 --> 00:00:26.505
you're learning and you're sticking,
you're sticking around for the long haul.

6
00:00:26.505 --> 00:00:29.861
So super thrilled about that.

7
00:00:29.861 --> 00:00:35.002
Now, before I kick things off, does anyone
have any quick questions that are not

8
00:00:35.002 --> 00:00:39.926
related to the exercises because I'm
gonna be going through those with you.

9
00:00:43.827 --> 00:00:46.195
Now, all right, you're all Python experts.

10
00:00:46.195 --> 00:00:49.191
Awesome, do my job.

11
00:00:49.191 --> 00:00:54.856
Let's talk about sets,
tuples and dictionaries.

12
00:00:54.856 --> 00:00:57.364
This is the practice that you
should have gone through.

13
00:00:57.364 --> 00:00:59.175
So let's take a walk.

14
00:01:04.353 --> 00:01:06.164
Starting the python ripple.

15
00:01:06.164 --> 00:01:12.161
We remember that in order
to create an empty set.

16
00:01:12.161 --> 00:01:16.939
If we check for the type of my set,
it's going to be a dictionary.

17
00:01:16.939 --> 00:01:22.992
So we create an empty set by
calling the set constructor.

18
00:01:22.992 --> 00:01:27.703
Empty list is just two brackets,

19
00:01:27.703 --> 00:01:33.264
empty dictionary is two curly braces.

20
00:01:33.264 --> 00:01:37.503
In empty tuple is
parentheses with a sorry,

21
00:01:37.503 --> 00:01:44.735
empty tuple is one set a parenthesis
with one item in it has a comma.

22
00:01:44.735 --> 00:01:48.794
And an empty set is created

23
00:01:48.794 --> 00:01:53.782
by using this set constructor.

24
00:01:53.782 --> 00:01:59.803
Remember that lists, sets,
and dictionaries are mutable.

25
00:01:59.803 --> 00:02:01.753
Tuples are immutable.

26
00:02:01.753 --> 00:02:06.287
If you need a shortcut to figure
out if an item is mutable or

27
00:02:06.287 --> 00:02:09.880
not, you can pass it
into the hash function.

28
00:02:09.880 --> 00:02:14.940
So a hash of an empty tuple has a value

29
00:02:14.940 --> 00:02:19.168
hash of an empty dictionary.

30
00:02:19.168 --> 00:02:27.414
Sorry, an empty,
set Does not have a value.

31
00:02:27.414 --> 00:02:31.660
A hash of an empty dictionary
does not have a value and

32
00:02:31.660 --> 00:02:35.670
a hash of an empty list
does not have a value.

33
00:02:35.670 --> 00:02:39.223
Those are all unhashable types
because they are mutable and

34
00:02:39.223 --> 00:02:40.723
they can't be changed.

35
00:02:40.723 --> 00:02:45.904
While if we check the hash for
an integer or the hash for

36
00:02:45.904 --> 00:02:51.792
a string, those do have values
because they are immutable.

37
00:02:51.792 --> 00:02:55.409
Now, remember that for a set,

38
00:02:55.409 --> 00:03:00.291
every item in that set needs to be unique.

39
00:03:00.291 --> 00:03:04.845
So if I have a list of names that has

40
00:03:04.845 --> 00:03:09.402
some duplicates in it, [SOUND] and

41
00:03:09.402 --> 00:03:15.284
I pass these into the constructor per set.

42
00:03:15.284 --> 00:03:20.701
To make them into a set, that set is
only going to have two values in it.

43
00:03:20.701 --> 00:03:23.557
Sets don't have order.

44
00:03:23.557 --> 00:03:26.599
So this order is not guaranteed.

45
00:03:26.599 --> 00:03:31.833
That also means that I cannot ask for

46
00:03:31.833 --> 00:03:36.893
the zero item sorry, I need to make

47
00:03:36.893 --> 00:03:43.012
a variable here, call this my names set.

48
00:03:43.012 --> 00:03:47.442
I cannot ask for
the zero if items in a set.

49
00:03:47.442 --> 00:03:51.550
I'll get an error that says the set
object is not sub scriptable.

50
00:03:51.550 --> 00:03:54.582
That means that it does
not have an order to it.

51
00:03:54.582 --> 00:03:59.376
That also means that I cannot
change values in my set at,

52
00:03:59.376 --> 00:04:02.034
for example, the zero index.

53
00:04:02.034 --> 00:04:09.621
The set object does not
support item assignment.

54
00:04:09.621 --> 00:04:13.023
We talked a little bit about tuples,

55
00:04:13.023 --> 00:04:18.420
tuples need to have that comma
if they only have one value.

56
00:04:32.067 --> 00:04:35.214
You need to type that correctly.

57
00:04:35.214 --> 00:04:40.062
Something else that you might
see that is valid Python syntax.

58
00:04:40.062 --> 00:04:45.793
But I recommend against
using it is you can actually

59
00:04:45.793 --> 00:04:52.466
create these tuples without
the parentheses around them.

60
00:04:52.466 --> 00:04:58.781
So I can say,
my tuple is equal to 1 and a comma.

61
00:04:58.781 --> 00:05:02.524
This is valid syntax in Python.

62
00:05:02.524 --> 00:05:07.072
If I check the type of
my tuple it's a tuple.

63
00:05:07.072 --> 00:05:09.204
I can take a look at it.

64
00:05:09.204 --> 00:05:13.036
I very much recommend that
you do not do this and

65
00:05:13.036 --> 00:05:16.092
that you be as explicit as possible.

66
00:05:16.092 --> 00:05:21.457
That's because this can be the source
of a lot of really weird errors.

67
00:05:21.457 --> 00:05:25.914
When you have a function,
you're passing an arguments to it,

68
00:05:25.914 --> 00:05:30.132
each argument is on its own line
with that trail link comma.

69
00:05:30.132 --> 00:05:34.321
Let's say you're doing a little
bit of refactoring and

70
00:05:34.321 --> 00:05:39.931
you pull out one of those arguments onto
its own line to make it a variable and

71
00:05:39.931 --> 00:05:44.673
you forget to remove this trail
link comma, now it's a tuple.

72
00:05:44.673 --> 00:05:47.882
You aren't expecting a tuple but
you got a tuple.

73
00:05:47.882 --> 00:05:52.792
And even recently, this is the kind
of bug that has just bitten me for

74
00:05:52.792 --> 00:05:55.880
hours because I'm looking at it.

75
00:05:55.880 --> 00:05:59.891
And this commas just
invisible in my brain.

76
00:05:59.891 --> 00:06:05.022
And I'm not understanding why I'm
getting this error about tuples

77
00:06:05.022 --> 00:06:10.334
when I'm not seeing the tuple so
I recommend always being explicit and

78
00:06:10.334 --> 00:06:13.953
adding those parentheses
around your tuples.

79
00:06:13.953 --> 00:06:17.010
Now, we talked about how
you can unpack tuples.

80
00:06:17.010 --> 00:06:24.004
So if you have a student and
the student has a name and

81
00:06:24.004 --> 00:06:29.386
an age and a favorite subject and a GPA.

82
00:06:29.386 --> 00:06:31.553
Let's say John is about student.

83
00:06:31.553 --> 00:06:36.250
We can use tuple unpacking to grab
multiple values out of this tuple all

84
00:06:36.250 --> 00:06:36.893
at once.

85
00:06:36.893 --> 00:06:40.067
So we can say name, age, subject.

86
00:06:40.067 --> 00:06:43.082
GPA is equal to student.

87
00:06:43.082 --> 00:06:47.842
And now I will have all of
those variables defined.

88
00:06:47.842 --> 00:06:52.594
If I do not have a match between
the number of variables on the left

89
00:06:52.594 --> 00:06:56.202
hand side with the number
of values in the tuple,

90
00:06:56.202 --> 00:07:01.402
this is gonna blow up with an error
that says too many values to unpack.

91
00:07:01.402 --> 00:07:08.582
Remember when you are doing any sort of
unpacking like this remember this error,

92
00:07:08.582 --> 00:07:14.917
you'll probably be seeing a quite a bit
as you go through python code and

93
00:07:14.917 --> 00:07:19.471
now you can just zero in
to exactly what that means.

94
00:07:19.471 --> 00:07:24.503
If there is a variable that we don't
care about saving to use later,

95
00:07:24.503 --> 00:07:29.977
can use this anonymous underscore to say,
hey, here's a placeholder so

96
00:07:29.977 --> 00:07:35.627
that I have the right amount of variables
on the left side of the expression,

97
00:07:35.627 --> 00:07:39.270
I don't care about saving it though.

98
00:07:39.270 --> 00:07:42.134
And now I don't have that value error.

99
00:07:44.802 --> 00:07:47.103
We talked about dictionaries, and

100
00:07:47.103 --> 00:07:52.350
how dictionaries are defined with
the curly braces, and the colons.

101
00:07:52.350 --> 00:08:00.992
So, I can say that my dictionary has a key
separated by a colon, and then the value.

102
00:08:04.870 --> 00:08:09.412
And I can not access items
in a dictionary by position,

103
00:08:09.412 --> 00:08:14.860
because dictionaries do not have an order,
they only have keys.

104
00:08:14.860 --> 00:08:18.884
So if I tried to ask my dictionary for
something at position zero,

105
00:08:18.884 --> 00:08:20.652
doesn't know what that is.

106
00:08:20.652 --> 00:08:22.326
I'm just going to get a key error.

107
00:08:25.043 --> 00:08:28.701
If we wanted to add new
items to our dictionary,

108
00:08:28.701 --> 00:08:32.272
we can do that with
a square bracket notation.

109
00:08:32.272 --> 00:08:35.492
So if I wanted to get
back the value at key,

110
00:08:35.492 --> 00:08:38.713
I would use the square bracket notation.

111
00:08:38.713 --> 00:08:41.640
But unlike a list where I
was passing in a position,

112
00:08:41.640 --> 00:08:44.712
instead I will pass in a key
that is in the dictionary.

113
00:08:44.712 --> 00:08:48.522
And I will get back that value for
the key.

114
00:08:48.522 --> 00:08:53.438
If I wanted to update that value in place,

115
00:08:53.438 --> 00:08:59.341
I could just use the equals
to assign a value to it.

116
00:08:59.341 --> 00:09:02.443
And now if I looked in my dictionary,

117
00:09:02.443 --> 00:09:06.553
I would see that the value
has been overwritten.

118
00:09:06.553 --> 00:09:10.556
If I wanted to check to see if
a key was in my dictionary,

119
00:09:10.556 --> 00:09:12.652
I would use the end keyword.

120
00:09:12.652 --> 00:09:17.272
So I can say key in my dict.

121
00:09:17.272 --> 00:09:24.304
And that will return true or not a key
in my dict and that will return false.

122
00:09:24.304 --> 00:09:28.823
Remember that lists are mutable,
you can change them.

123
00:09:28.823 --> 00:09:34.007
So if I had a list here, I can say that my

124
00:09:34.007 --> 00:09:40.660
list at zero is not now
going to be negative 99.

125
00:09:40.660 --> 00:09:43.260
And that will go ahead and change it.

126
00:09:43.260 --> 00:09:47.602
Dictionaries are also mutable so

127
00:09:47.602 --> 00:09:54.741
I can say my dictionary at
key equals some other value.

128
00:09:54.741 --> 00:09:58.041
And that works just fine.

129
00:09:58.041 --> 00:10:00.542
Sets are also mutable.

130
00:10:00.542 --> 00:10:06.636
So if I had a set here I
can use the .add operator

131
00:10:06.636 --> 00:10:12.741
to add a new item to
the set tuples not mutable.

132
00:10:12.741 --> 00:10:18.045
So if I have my student,
I can get the value at position zero,

133
00:10:18.045 --> 00:10:20.959
because tuples do have an order.

134
00:10:20.959 --> 00:10:25.580
In fact, that order is very,
very important, but they are not mutable.

135
00:10:25.580 --> 00:10:30.350
So if I try to change the name here,
I'm going to get an error because

136
00:10:30.350 --> 00:10:34.049
the tuple object does not
support item assignment.

137
00:10:36.168 --> 00:10:41.145
So all of these have different purposes,
they all have different pluses,

138
00:10:41.145 --> 00:10:43.912
minuses, advantages, and scenarios.

139
00:10:43.912 --> 00:10:47.330
I recommend that you spend some
time reading Python code, and

140
00:10:47.330 --> 00:10:51.683
that will give you a better understanding
of which data type is best used when.

141
00:10:51.683 --> 00:10:56.087
And also, while you're learning,
referring back to the cheat sheets,

142
00:10:56.087 --> 00:11:00.845
because those are going to give you hints
about mutability, about how to access

143
00:11:00.845 --> 00:11:05.840
objects about order and about what methods
you can use on these different objects.

