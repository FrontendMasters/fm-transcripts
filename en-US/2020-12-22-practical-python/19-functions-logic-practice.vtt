WEBVTT

1
00:00:00.340 --> 00:00:05.080
We can create functions
with the def keyword.

2
00:00:05.080 --> 00:00:09.220
So we had a function called add numbers.

3
00:00:09.220 --> 00:00:11.949
We can give our function
optional arguments

4
00:00:17.289 --> 00:00:24.158
And, we want to, when we wanna call
the function, we use the function name,

5
00:00:24.158 --> 00:00:30.180
and then we pass in the correct
number of required arguments.

6
00:00:30.180 --> 00:00:35.240
If we pass in too many, or
too few, you will see that this

7
00:00:35.240 --> 00:00:41.064
argument takes two positional
arguments but three were given.

8
00:00:41.064 --> 00:00:45.084
Or this function is missing one
required positional argument and

9
00:00:45.084 --> 00:00:47.560
it'll tell you which one.

10
00:00:47.560 --> 00:00:52.030
So in this case,
the number of arguments matters.

11
00:00:52.030 --> 00:00:57.670
Remember that functions in
Python don't have curly braces.

12
00:00:57.670 --> 00:01:01.150
So indentation is very important.

13
00:01:01.150 --> 00:01:07.197
If I tried to define a function here and
I did not indent.

14
00:01:10.777 --> 00:01:13.900
This is a an indentation error.

15
00:01:13.900 --> 00:01:17.889
Python is telling me I expected
an indented block to signify the start

16
00:01:17.889 --> 00:01:18.930
of the function.

17
00:01:18.930 --> 00:01:20.560
You did not give me one.

18
00:01:21.890 --> 00:01:24.401
So if you see an indentation error,

19
00:01:24.401 --> 00:01:29.500
it's likely that you're Indentation
is not at the correct level.

20
00:01:29.500 --> 00:01:31.850
We talked about function scope.

21
00:01:31.850 --> 00:01:38.550
So if you have variables that
are defined outside of your function.

22
00:01:38.550 --> 00:01:39.672
If you try to change them.

23
00:01:48.118 --> 00:01:52.560
If I check the value of x, it's two.

24
00:01:52.560 --> 00:01:57.597
If I call my function, it's three inside
of the function, but that value of

25
00:01:57.597 --> 00:02:02.730
x that was defined outside of the function
was not changed by this statement.

26
00:02:04.480 --> 00:02:08.680
Remember that we have positional
arguments and keyword arguments.

27
00:02:08.680 --> 00:02:15.655
So if I have my add function here

28
00:02:19.450 --> 00:02:24.820
I can have an optional
argument about what to do.

29
00:02:24.820 --> 00:02:26.175
Let's call this one operation.

30
00:02:30.421 --> 00:02:37.041
And There

31
00:02:37.041 --> 00:02:41.460
are two here,
I need to get these names not values.

32
00:02:41.460 --> 00:02:46.527
All right, so I've defined my
add_numbers function and I can

33
00:02:46.527 --> 00:02:53.430
say that if the operation is equal to
the word add, we're going to return x + y.

34
00:02:53.430 --> 00:02:59.457
Otherwise, we're going to subtract and
return x- y.

35
00:02:59.457 --> 00:03:02.762
So by default add_numbers will add.

36
00:03:08.522 --> 00:03:14.244
But if I pass in an operation
that's something else,

37
00:03:14.244 --> 00:03:17.177
it will instead subtract.

38
00:03:17.177 --> 00:03:21.160
This keyword argument is optional.

39
00:03:21.160 --> 00:03:24.440
If I don't pass one in
the default will be used.

40
00:03:24.440 --> 00:03:27.680
We talked a little bit
about boolean logic.

41
00:03:27.680 --> 00:03:33.066
So comparisons in Python less than,
less than equals, greater than,

42
00:03:33.066 --> 00:03:37.759
greater than equals, and
then double equals and not equals.

43
00:03:39.760 --> 00:03:44.250
And a reminder that these
operators test the objects value.

44
00:03:44.250 --> 00:03:51.290
You want to use is, and is not, in order
to test if two objects are the same thing.

45
00:03:51.290 --> 00:03:56.210
And this is useful for those
singletons that are defined in Python,

46
00:03:56.210 --> 00:03:58.860
like none and true and false.

47
00:03:58.860 --> 00:04:03.867
So, none, true and false are when
you want to use the is keyword

48
00:04:03.867 --> 00:04:08.610
because you're not comparing
two different values.

49
00:04:08.610 --> 00:04:14.076
You want to make sure that, the singleton

50
00:04:14.076 --> 00:04:19.860
is what with that
variable is pointing out.

51
00:04:21.750 --> 00:04:24.980
We talked a little bit about truthiness.

52
00:04:24.980 --> 00:04:29.985
So instead of saying 3, or

53
00:04:29.985 --> 00:04:35.870
5 less than 3 is equal to true.

54
00:04:37.190 --> 00:04:42.186
And seeing some weird unexpected behavior,
because remember

55
00:04:42.186 --> 00:04:47.580
in Python under the hood,
true is actually the number one.

56
00:04:47.580 --> 00:04:52.680
We want to just use five less than three,

57
00:04:52.680 --> 00:04:57.940
and that will give us the correct result.

58
00:04:59.400 --> 00:05:05.150
So here we had three less than
five is equal to true as false,

59
00:05:05.150 --> 00:05:09.430
even though it should be true, right.

60
00:05:09.430 --> 00:05:12.394
So use this and not that.

61
00:05:15.475 --> 00:05:17.910
We talked about boolean operators.

62
00:05:17.910 --> 00:05:22.230
So x or y, x and y and not x.

63
00:05:22.230 --> 00:05:26.620
These work as expected,
the same way that they do in other

64
00:05:26.620 --> 00:05:31.384
languages except in Python,
we use the keywords or and a not.

65
00:05:31.384 --> 00:05:36.372
And that makes our statements read
a little bit more like actual sentences

66
00:05:36.372 --> 00:05:40.160
in English, and
makes Python code easy to understand.

67
00:05:42.150 --> 00:05:47.190
We talked about control statements,
like if and else.

68
00:05:47.190 --> 00:05:51.695
So, typing if a true
expression in this case,

69
00:05:51.695 --> 00:05:56.201
let's see, true, print(hi) otherwise,

70
00:05:56.201 --> 00:06:01.484
print Bye, this will print hi and not bye,

71
00:06:01.484 --> 00:06:06.395
if this was false we
would instead skip all of

72
00:06:06.395 --> 00:06:10.643
the code inside of the if statement and

73
00:06:10.643 --> 00:06:16.110
jump straight to the code
in the else statement.

74
00:06:17.320 --> 00:06:23.800
If we were to, we don't define
any logic in the else statement.

75
00:06:23.800 --> 00:06:30.100
If we needed to define extra conditional
statements, we would use the else if.

76
00:06:31.920 --> 00:06:38.337
So I could say if false print 1,

77
00:06:38.337 --> 00:06:45.468
elif true print 2 else, print 3,

78
00:06:45.468 --> 00:06:50.810
this condition is false.

79
00:06:50.810 --> 00:06:54.270
It's going to evaluate this one next,
which is true.

80
00:06:54.270 --> 00:06:56.027
So it will go ahead and print 2.

81
00:06:57.694 --> 00:07:06.510
We can use these in complex ways
by adding statements together.

82
00:07:06.510 --> 00:07:11.134
So, if we wanted to define fizzbuzz,
for example

83
00:07:15.244 --> 00:07:19.458
For a number, we can say that if

84
00:07:19.458 --> 00:07:24.160
the number is divisible by three,

85
00:07:24.160 --> 00:07:29.205
and the number is divisible by five.

86
00:07:29.205 --> 00:07:35.235
Then print fizzbuzz.

87
00:07:37.953 --> 00:07:45.650
So fizzbuzz of three, I think I
missed my let me double check this.

88
00:07:48.080 --> 00:07:50.460
I think I should have had
parentheses around this.

89
00:07:50.460 --> 00:07:56.057
Let me know if any of you ran into
the same issue in this exercise

90
00:08:05.565 --> 00:08:07.400
No, had it right the first time.

91
00:08:07.400 --> 00:08:09.060
Forgot what fizzbuzz did.

92
00:08:09.060 --> 00:08:14.370
So this only checks if it's divisible
by both three and five, which 15 is.

93
00:08:14.370 --> 00:08:15.660
But three and five are not.

94
00:08:16.730 --> 00:08:18.730
So no parenthesis necessary.

