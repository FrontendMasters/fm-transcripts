WEBVTT

1
00:00:00.378 --> 00:00:06.916
So, numbers in Python,
these are all integers.

2
00:00:12.852 --> 00:00:15.201
And we can always verify
that by calling type.

3
00:00:15.201 --> 00:00:19.307
There are also floats in Python so

4
00:00:19.307 --> 00:00:23.421
numbers that have decimal points

5
00:00:31.285 --> 00:00:32.792
Something that's a little
tricky that might bite you.

6
00:00:32.792 --> 00:00:36.020
This is a valid float.

7
00:00:37.520 --> 00:00:40.350
You don't need to have
a decimal point after.

8
00:00:40.350 --> 00:00:43.720
You shouldn't really define
your floats like this.

9
00:00:43.720 --> 00:00:44.900
It's kind of confusing.

10
00:00:44.900 --> 00:00:48.680
But if you see this in Python code,
just know that's not a syntax error.

11
00:00:48.680 --> 00:00:53.340
And then there are also complex numbers.

12
00:00:53.340 --> 00:00:58.320
And these end with the character
j I'm not a math person.

13
00:00:58.320 --> 00:01:02.464
I don't think I've ever used complex
numbers in my Python code, but

14
00:01:02.464 --> 00:01:04.470
they're there if you need them.

15
00:01:05.550 --> 00:01:10.200
Because like you saw earlier, these
types are just objects under the hood.

16
00:01:10.200 --> 00:01:15.740
You can also declare them by calling
the constructor for that built in type.

17
00:01:15.740 --> 00:01:24.400
So I can say, into five I can
also pass in a string in here.

18
00:01:26.420 --> 00:01:28.478
Same thing for float if I pass in,

19
00:01:28.478 --> 00:01:33.120
let's say an integer into the float
constructor will return a float back.

20
00:01:34.180 --> 00:01:38.644
Generally you never want to do this in
your code unless you are converting

21
00:01:38.644 --> 00:01:39.679
between types.

22
00:01:40.850 --> 00:01:43.330
But this is something that you might see.

23
00:01:43.330 --> 00:01:47.184
One example of converting
between types as if you're using

24
00:01:47.184 --> 00:01:49.750
an old style string formatting.

25
00:01:49.750 --> 00:01:52.252
If you try to, for example,

26
00:01:52.252 --> 00:01:57.897
concatenate when we'll talk about
strings a little bit later.

27
00:01:57.897 --> 00:02:01.767
A string with a number you're going to
get a type error that says you can only

28
00:02:01.767 --> 00:02:03.740
concatenate strings and not stings.

29
00:02:03.740 --> 00:02:08.981
So in this case, you can pass in
the number five to the stir method.

30
00:02:08.981 --> 00:02:13.246
Again, with modern Python
string formatting,

31
00:02:13.246 --> 00:02:18.350
you won't really ever need to do this,
but could happen.

32
00:02:18.350 --> 00:02:23.263
You can do all the standard
mathematical operations that

33
00:02:23.263 --> 00:02:26.650
you might expect with Python numbers.

34
00:02:26.650 --> 00:02:33.060
You can add them up, and
you can multiply them.

35
00:02:33.060 --> 00:02:35.140
You can divide them.

36
00:02:35.140 --> 00:02:36.988
Note that if you divide two integers,

37
00:02:36.988 --> 00:02:39.930
the type that you get back
is going to be a float.

38
00:02:39.930 --> 00:02:44.451
If you want to do integer division,
you need to use 2 slashes and

39
00:02:44.451 --> 00:02:46.895
that will get you an integer back.

40
00:02:46.895 --> 00:02:51.054
You can also raise to the power.

41
00:02:51.054 --> 00:02:54.563
So let's say we have x equals 4 and

42
00:02:54.563 --> 00:03:00.620
y equals 3 we can say x to the power
of 3 or x to the power of y.

43
00:03:01.750 --> 00:03:06.105
So everything that you might expect,
and then you can also use

44
00:03:06.105 --> 00:03:11.155
parentheses to make sure that things
happen in the order that you want.

45
00:03:16.206 --> 00:03:18.490
And that is all valid Python code.

46
00:03:18.490 --> 00:03:24.840
Python has a few more built in
methods that are useful for numbers.

47
00:03:24.840 --> 00:03:28.101
And you might hear me say built
in methods, what does that mean?

48
00:03:28.101 --> 00:03:32.352
You saw earlier in our tour of
a Python program that I had to import

49
00:03:32.352 --> 00:03:34.210
the request module.

50
00:03:34.210 --> 00:03:38.410
Later on, we'll see how to import
modules from the standard library.

51
00:03:38.410 --> 00:03:40.174
When I'm using these built ins,

52
00:03:40.174 --> 00:03:43.840
I don't need to import anything
they're just available in Python.

53
00:03:45.380 --> 00:03:51.790
And the three helpful methods for
math are a min and max or round.

54
00:03:51.790 --> 00:03:56.030
So for
min you could pass in some values, And

55
00:03:56.030 --> 00:04:00.900
it will always return
the smallest of them.

56
00:04:00.900 --> 00:04:03.850
The same is true for
Mac's except the opposite.

57
00:04:06.010 --> 00:04:11.030
This will return 10 thousand because
it is the largest number in that list.

58
00:04:11.030 --> 00:04:15.204
You can also use round
to round down decimals.

59
00:04:17.456 --> 00:04:18.307
Or round them up.

60
00:04:20.155 --> 00:04:26.360
There are built in Boolean types in Python
just like we saw that none is a keyword.

61
00:04:26.360 --> 00:04:32.059
In Python the Boolean types are defined
with uppercase true and lowercase false.

62
00:04:33.550 --> 00:04:35.780
These are keywords.

63
00:04:35.780 --> 00:04:40.690
Something of note in Python
that I've seen trip people up.

64
00:04:40.690 --> 00:04:43.360
Again in Python, everything is an object.

65
00:04:43.360 --> 00:04:47.507
These Boolean are objects and in fact,

66
00:04:47.507 --> 00:04:52.669
under the hood they
are subclasses of integers.

67
00:04:54.060 --> 00:04:57.931
And that means that under the hood
true has a value of one and

68
00:04:57.931 --> 00:05:00.480
false has a value of zero.

69
00:05:00.480 --> 00:05:06.400
Don't do this Please, but because of that,

70
00:05:06.400 --> 00:05:10.962
you can actually add these together or
do anything, but

71
00:05:10.962 --> 00:05:15.927
you could do to numbers,
don't do this but Python fun fact.

