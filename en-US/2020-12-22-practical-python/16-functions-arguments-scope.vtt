WEBVTT

1
00:00:00.100 --> 00:00:05.991
Functions in Python are defined with
that def keyword that we saw earlier,

2
00:00:05.991 --> 00:00:12.266
followed by a function name which is
lower case, separated with underscores.

3
00:00:12.266 --> 00:00:19.767
And then parenthesis that contain zero or
more arguments, and a colon.

4
00:00:19.767 --> 00:00:26.650
Everything that is indented after
the function belongs to that function.

5
00:00:26.650 --> 00:00:32.881
So early on in the class, if you remember
we tried to from future import braces, and

6
00:00:32.881 --> 00:00:38.328
we got a no way error, never gonna happen,
that was a little Easter egg.

7
00:00:38.328 --> 00:00:42.786
Other programming languages
like JavaScript use curly

8
00:00:42.786 --> 00:00:47.633
braces to delineate where is the start and
end of a function.

9
00:00:47.633 --> 00:00:52.058
Python does not have that,
instead it relies on whitespace.

10
00:00:52.058 --> 00:00:56.681
And so going forward as we start
talking about functions, classes,

11
00:00:56.681 --> 00:01:02.279
if statements, you're going to have to be
very mindful of how you use whitespace.

12
00:01:02.279 --> 00:01:05.572
Because if things are not
indented at the correct level,

13
00:01:05.572 --> 00:01:07.707
you're going to get syntax errors.

14
00:01:09.979 --> 00:01:14.929
If we try to create functions
that are missing some of

15
00:01:14.929 --> 00:01:20.337
those core components, so
if I try to create a function.

16
00:01:22.308 --> 00:01:28.169
That does not have that colon,
I'm going to get an invalid syntax.

17
00:01:28.169 --> 00:01:32.704
So def, the name of the function,
parentheses, colon, and

18
00:01:32.704 --> 00:01:35.942
we'll see the repo shows
us a helpful hint.

19
00:01:35.942 --> 00:01:40.057
Once we have that colon,
it's going to turn into dot,

20
00:01:40.057 --> 00:01:44.451
dot prompt to say, hey,
I'm expecting more input here.

21
00:01:44.451 --> 00:01:47.336
In the repo, you can just hit Tab.

22
00:01:51.616 --> 00:01:56.241
When I hit Enter again, the repo is
gonna say, hey, I'm still waiting for

23
00:01:56.241 --> 00:01:57.056
more input.

24
00:01:57.056 --> 00:02:03.308
If you're done defining your function
at this point, you can just hit Enter

25
00:02:03.308 --> 00:02:08.595
again to get back to that three
arrow prompt that we saw earlier.

26
00:02:08.595 --> 00:02:12.604
And that means that the function
has now been defined,

27
00:02:12.604 --> 00:02:14.878
and it means that I can call it.

28
00:02:14.878 --> 00:02:20.927
When we are writing Python files,
this extra new line after the function,

29
00:02:20.927 --> 00:02:24.876
if you don't have it,
it's not a syntax error.

30
00:02:24.876 --> 00:02:29.331
But prep it, it does state that you
should have a new line after your

31
00:02:29.331 --> 00:02:32.765
function definitions just for
readability sake.

32
00:02:32.765 --> 00:02:39.118
You can save the output of calling
a function into a variable,

33
00:02:39.118 --> 00:02:44.018
I would have to change my
function a little bit.

34
00:02:44.018 --> 00:02:49.588
So I would have to change my function
to actually return something.

35
00:02:49.588 --> 00:02:55.351
Because if I see what isn't greeting right
now, it's actually gonna be a no value.

36
00:02:55.351 --> 00:02:58.935
The function only printed something,
it does not return any values.

37
00:03:02.313 --> 00:03:05.927
So, I can redefine my function,

38
00:03:10.326 --> 00:03:15.833
And have it return a value
instead of printing it.

39
00:03:15.833 --> 00:03:19.847
Now when I call my function,
it should return the string Hi,

40
00:03:19.847 --> 00:03:22.298
and now I can save that to a variable.

41
00:03:26.818 --> 00:03:30.855
So return statements allow you
to do stuff in the function and

42
00:03:30.855 --> 00:03:33.639
then pass those values back to the color.

43
00:03:33.639 --> 00:03:36.514
You can return whatever you like.

44
00:03:36.514 --> 00:03:40.832
If you're going to be returning more
than one value, you can use a tubule.

45
00:03:44.355 --> 00:03:49.241
Now, pretty straightforward calling
functions with no arguments,

46
00:03:49.241 --> 00:03:53.392
how do we start making functions
that do accept arguments?

47
00:04:00.294 --> 00:04:05.608
We define what arguments we want
to accept by separating the names

48
00:04:05.608 --> 00:04:10.258
that we expect them to be with
commas in the parentheses.

49
00:04:13.677 --> 00:04:16.319
And then we can use them in our function.

50
00:04:27.517 --> 00:04:34.397
If we wanted to store the value of this,
that would be pretty straightforward.

51
00:04:38.296 --> 00:04:42.494
Now result is an integer with 30.

52
00:04:42.494 --> 00:04:49.607
We can also have optional arguments and
provide a default value for them.

53
00:05:00.778 --> 00:05:03.948
Invalid syntax, I forgot to say def.

54
00:05:07.573 --> 00:05:10.466
You would not want to write
a function like this in production,

55
00:05:10.466 --> 00:05:12.116
your coworkers would be mad at you.

56
00:05:12.116 --> 00:05:16.473
It is a mystery function that
does some weird stuff, but

57
00:05:16.473 --> 00:05:18.798
just for the sake of example.

58
00:05:18.798 --> 00:05:23.147
Now I can still add my numbers,
let's say 3 and 5.

59
00:05:23.147 --> 00:05:29.277
I'm actually gonna get 9,
because there's this default value

60
00:05:29.277 --> 00:05:34.525
in z that is 1, but
I can also pass in my own value for it.

61
00:05:38.306 --> 00:05:43.874
These arguments must be provided because
they don't have defaults providing

62
00:05:43.874 --> 00:05:49.121
these arguments is optional, and
they need to be in this specific order.

63
00:05:49.121 --> 00:05:52.245
Required arguments need
to be defined first,

64
00:05:52.245 --> 00:05:55.297
optional arguments need
to be defined last.

65
00:05:55.297 --> 00:05:58.797
If you mix up the order of these,
you're going to get errors.

66
00:06:07.503 --> 00:06:10.935
And it's pretty helpful error,
it says syntax error,

67
00:06:10.935 --> 00:06:14.086
non default argument
follows default arguments.

68
00:06:19.842 --> 00:06:24.957
One more thing about functions
is that here we define

69
00:06:24.957 --> 00:06:29.964
them exactly as they were
defined in the function.

70
00:06:29.964 --> 00:06:35.013
If you provided labels for
these when you call the function,

71
00:06:35.013 --> 00:06:38.875
you can pass those in any
order you would like.

72
00:06:38.875 --> 00:06:46.238
So looking at the add
numbers function here,

73
00:06:46.238 --> 00:06:52.438
I could call add_numbers(1, 2,

74
00:06:52.438 --> 00:06:57.472
3) or I could say that y = 1,

75
00:06:57.472 --> 00:07:00.783
z = 2, and x = 3.

76
00:07:00.783 --> 00:07:04.484
And because I've helped Python out and
told it, hey,

77
00:07:04.484 --> 00:07:08.828
I'm not calling these an order,
but I am giving you the labels,

78
00:07:08.828 --> 00:07:11.985
it's able to figure out
what your intent was.

79
00:07:13.913 --> 00:07:16.906
Does that make sense?

80
00:07:16.906 --> 00:07:20.642
Okay, cool.

81
00:07:20.642 --> 00:07:21.586
Now.

82
00:07:25.198 --> 00:07:31.651
We talked about default argument,
we talked about order.

83
00:07:31.651 --> 00:07:37.740
If we try to call a function without
all of its default arguments,

84
00:07:37.740 --> 00:07:40.964
we're going to get an exception.

85
00:07:40.964 --> 00:07:48.359
So for add numbers, I have two arguments
that need to have values x and y.

86
00:07:48.359 --> 00:07:51.583
If I tried to call this
function with only one value,

87
00:07:51.583 --> 00:07:55.411
I'm going to get a pretty helpful error,
it's a type error.

88
00:07:55.411 --> 00:08:01.818
It says add numbers is missing,
one required positional argument of y.

89
00:08:01.818 --> 00:08:06.050
Right, because I passed in a value for
this, but not for this, and

90
00:08:06.050 --> 00:08:10.596
Python doesn't have a default value for
it, it doesn't know what to do

91
00:08:15.085 --> 00:08:19.880
If you have arguments that
have default values for

92
00:08:19.880 --> 00:08:24.674
everything, you can then
pass in none of them, or

93
00:08:24.674 --> 00:08:29.711
some of them, or all of them,
you can mix and match.

94
00:08:29.711 --> 00:08:34.478
So we thought we had
a create query method, and

95
00:08:34.478 --> 00:08:40.103
I can say that the language
is JavaScript by default and

96
00:08:40.103 --> 00:08:44.503
the number of stars is 10 by default, and

97
00:08:44.503 --> 00:08:48.804
the sort order is descending by default.

98
00:08:52.066 --> 00:08:59.086
And this is just gonna return an F string

99
00:08:59.086 --> 00:09:05.255
that says language is language and

100
00:09:05.255 --> 00:09:10.361
num_stars is non_stars,

101
00:09:10.361 --> 00:09:13.563
and sort is sort.

102
00:09:13.563 --> 00:09:17.102
Now when I call this with no arguments,

103
00:09:17.102 --> 00:09:21.836
I get JavaScript or
I can just provide the language.

104
00:09:25.077 --> 00:09:29.529
Or I can just provide the number of

105
00:09:29.529 --> 00:09:34.629
stars, Or any mix of them.

106
00:09:34.629 --> 00:09:37.546
So these default arguments are very,
very helpful.

107
00:09:39.767 --> 00:09:45.536
One thing I want to cover before
we move on from arguments

108
00:09:45.536 --> 00:09:51.688
is something that trips up
beginners in Python quite a bit.

109
00:09:51.688 --> 00:09:55.892
Don't use mutable types
as default arguments,

110
00:09:55.892 --> 00:09:59.692
they don't behave the way that you expect.

111
00:10:06.574 --> 00:10:11.624
So if I have a function, And

112
00:10:11.624 --> 00:10:15.176
I wanna have a default
argument with a list.

113
00:10:17.682 --> 00:10:19.076
And say,

114
00:10:24.842 --> 00:10:30.342
Append this string to
my list when I call it.

115
00:10:30.342 --> 00:10:33.626
When I call this function the first time.

116
00:10:33.626 --> 00:10:39.977
Oops, Sorry, I want to go ahead and
return that.

117
00:10:43.512 --> 00:10:46.344
So that we can actually see what happens.

118
00:10:46.344 --> 00:10:52.215
When I call it for the first time,
It does the right thing.

119
00:10:52.215 --> 00:10:56.844
When I call it the second time,
there is now two instances of

120
00:10:56.844 --> 00:11:00.930
stuff in this list, and
then three, and then four.

121
00:11:00.930 --> 00:11:05.060
Do not use mutable arguments for defaults,

122
00:11:05.060 --> 00:11:12.210
because the way that Python works under
the hood is these get declared once.

123
00:11:12.210 --> 00:11:17.066
So when you do this,
you are going to continue using that very

124
00:11:17.066 --> 00:11:21.827
same instance of my list every
time you call that function,

125
00:11:21.827 --> 00:11:25.655
even though that is not
what you intended to do.

126
00:11:25.655 --> 00:11:29.968
So, this is the source of a lot
of subtle bugs for beginners.

127
00:11:29.968 --> 00:11:35.031
So remember, no mutable default arguments.

128
00:11:35.031 --> 00:11:40.470
The way that you would want to
do this instead is to have a,

129
00:11:45.120 --> 00:11:51.380
Have a placeholder here where you're
using a nun value as a placeholder.

130
00:11:53.396 --> 00:11:58.841
And I'm gonna introduce some concepts
we haven't talked about yet,

131
00:11:58.841 --> 00:12:03.743
but then you can just say If I've
passed in a list, then use it.

132
00:12:03.743 --> 00:12:10.612
Otherwise, you can say, if not my list,
which means if it's sorry,

133
00:12:10.612 --> 00:12:14.812
you wanna say,
if my list is equal to none,

134
00:12:16.290 --> 00:12:23.718
Then making new list here,
and then append to it.

135
00:12:31.418 --> 00:12:36.711
Now, when I call do_stuff(),
it's going to do the right thing

136
00:12:36.711 --> 00:12:42.097
each time because I took care of
creating the list in this function,

137
00:12:42.097 --> 00:12:46.272
I did not pass in an empty
list as a keyword argument.

138
00:12:46.272 --> 00:12:52.420
&gt;&gt; It only appends stuff in the case
where my list isn't defined.

139
00:12:52.420 --> 00:12:55.431
&gt;&gt; Yeah, just a silly little example.

140
00:12:58.187 --> 00:13:05.105
So right, I would want to move
this over one to the left so

141
00:13:05.105 --> 00:13:12.921
that this example worked when I
did pass in a list to start with.

142
00:13:12.921 --> 00:13:16.308
Good catch, thank you.

143
00:13:16.308 --> 00:13:21.847
Cool, so these are arguments.

144
00:13:21.847 --> 00:13:26.159
And I wanna talk about scope a little bit.

145
00:13:26.159 --> 00:13:30.090
There is scope inside of a function.

146
00:13:30.090 --> 00:13:35.159
So I'm going to exit my repo and
start it from scratch

147
00:13:35.159 --> 00:13:40.932
to clear out everything that
I might have defined already.

148
00:13:40.932 --> 00:13:48.224
If I have a function that takes a name and
prints it.

149
00:13:55.956 --> 00:14:00.887
I cannot access this name
variable outside of the function,

150
00:14:00.887 --> 00:14:03.498
outside of this indented zone,

151
00:14:03.498 --> 00:14:08.149
because the name is only
defined inside of the function.

152
00:14:08.149 --> 00:14:13.467
Once the function exits,
that variable doesn't exist.

153
00:14:13.467 --> 00:14:18.202
So, Python scope works pretty similar
to scope and other languages.

154
00:14:18.202 --> 00:14:20.639
This is something you
want to be mindful of.

155
00:14:22.818 --> 00:14:28.668
You want to be very careful
when you're using variables

156
00:14:28.668 --> 00:14:34.153
inside of a function that
are defined outside of it.

157
00:14:34.153 --> 00:14:40.967
Because if you try to change the value
of that variable inside of the function,

158
00:14:40.967 --> 00:14:45.109
the value is only going to apply for
that scope.

159
00:14:45.109 --> 00:14:50.054
When your function exits,
you're not actually going to be able to

160
00:14:50.054 --> 00:14:55.018
modify the value of the variable
defined outside of the function.

161
00:14:55.018 --> 00:14:57.479
This can result in some weird subtle bugs.

162
00:14:57.479 --> 00:14:58.810
So here's an example.

163
00:15:01.522 --> 00:15:08.608
And I can say print,
Out the name outside of the function.

164
00:15:13.126 --> 00:15:17.685
And then I'm gonna make a method
that says try to change the name

165
00:15:20.162 --> 00:15:23.003
And I'm gonna say that name
in the function is Max.

166
00:15:24.975 --> 00:15:26.509
And print out.

167
00:15:32.145 --> 00:15:36.252
Name inside of the function.

168
00:15:47.182 --> 00:15:52.187
Now if I call this method try change name,

169
00:15:52.187 --> 00:15:57.335
the name inside of the function is Max,
but

170
00:15:57.335 --> 00:16:03.062
the name outside of
the function is still Nina.

171
00:16:03.062 --> 00:16:10.215
So don't try to change variables in a
function that were declared outside of it.

172
00:16:10.215 --> 00:16:12.496
You will have access to them,

173
00:16:12.496 --> 00:16:17.427
which can be helpful if you have
like a global variable defined,

174
00:16:17.427 --> 00:16:23.382
that is like a URL or something that's
static, that's not going to change.

175
00:16:23.382 --> 00:16:27.618
But don't try to update it, you're gonna
end up with some weird scoping issues.

176
00:16:32.999 --> 00:16:38.564
And so a use case for using a variable
in a function that's defined

177
00:16:38.564 --> 00:16:44.445
outside of it is a constant, and
to delineate that it's a constant.

178
00:16:44.445 --> 00:16:49.878
In that case, you can name it
with all uppercase characters,

179
00:16:49.878 --> 00:16:52.185
split with a underscore.

180
00:16:52.185 --> 00:16:54.350
And that's just convention,

181
00:16:54.350 --> 00:16:59.520
it doesn't mean that there's anything
different about that variable.

182
00:16:59.520 --> 00:17:02.148
It's just named a little
bit differently in

183
00:17:02.148 --> 00:17:05.640
order to signify something to
the readers of the program.

