WEBVTT

1
00:00:00.000 --> 00:00:03.962
[MUSIC]

2
00:00:03.962 --> 00:00:06.710
&gt;&gt; Bianca Gandolfo: So the first one
that I wanna talk about is each.

3
00:00:06.710 --> 00:00:15.120
This is one of the most common
underscore methods that is used.

4
00:00:15.120 --> 00:00:18.500
And it's not only used in
functional programming.

5
00:00:18.500 --> 00:00:20.740
In fact, a lot of people use this.

6
00:00:20.740 --> 00:00:25.060
I wanna argue that most people use each,
either in underscores each,

7
00:00:25.060 --> 00:00:29.150
jQuery has its own version of each, and
then there's a native for each, as well,

8
00:00:29.150 --> 00:00:31.660
that comes with JavaScript.

9
00:00:31.660 --> 00:00:36.990
So what each does, is that it takes
a list, it could be an object,

10
00:00:36.990 --> 00:00:40.310
or an array, and for every element.

11
00:00:40.310 --> 00:00:44.000
In that array it calls
the callback function here.

12
00:00:44.000 --> 00:00:47.680
So now you guys can see what I
was talking about with the value,

13
00:00:47.680 --> 00:00:51.230
the index, and
the list from the exercises.

14
00:00:51.230 --> 00:00:53.120
It's because that's how each works.

15
00:00:53.120 --> 00:01:00.070
So in this example, this function,
here it's going to be called three times.

16
00:01:00.070 --> 00:01:03.740
The first time it's going to be
called with one as the value,

17
00:01:03.740 --> 00:01:06.430
and then zero, and the whole array.

18
00:01:07.470 --> 00:01:10.160
The second time,
the val is going to be two.

19
00:01:11.850 --> 00:01:13.590
And the index is going to be what.

20
00:01:13.590 --> 00:01:14.450
What's the index going to be?

21
00:01:14.450 --> 00:01:16.460
&gt;&gt; Speaker 2: One.
&gt;&gt; Bianca Gandolfo: One.

22
00:01:16.460 --> 00:01:18.240
And then the whole list, right?

23
00:01:18.240 --> 00:01:18.789
That array.

24
00:01:20.230 --> 00:01:22.680
And then the last time,
the val is going to be three,

25
00:01:22.680 --> 00:01:28.880
i is going to be two, and then again,
list is going to be the whole list.

26
00:01:28.880 --> 00:01:31.370
And we know from our

27
00:01:31.370 --> 00:01:35.590
prior discussions that we don't have
to work with all the parameters, right?

28
00:01:35.590 --> 00:01:39.360
So in this signature here,
this function signature.

29
00:01:39.360 --> 00:01:40.900
Those are just parameter names.

30
00:01:40.900 --> 00:01:42.240
We don't have to reference all of those.

31
00:01:42.240 --> 00:01:45.110
So if we just wanted to console
that log to val, that's fine.

32
00:01:45.110 --> 00:01:47.970
But if we wanna do all of them,
we could also do that too.

33
00:01:47.970 --> 00:01:52.400
And we also know that we could
call this whatever we want.

34
00:01:52.400 --> 00:01:53.560
Sometimes it's called element.

35
00:01:53.560 --> 00:01:55.190
You can like spell it all out index.

36
00:01:57.450 --> 00:01:58.440
I don't know.

37
00:01:58.440 --> 00:02:00.620
You can call whatever you want.

38
00:02:00.620 --> 00:02:05.680
And so, as long as they match in the
function body, that's what's important.

39
00:02:09.140 --> 00:02:13.630
So, in,
as far as the order of element index in

40
00:02:13.630 --> 00:02:17.110
the whole list that order doesn't change.

41
00:02:17.110 --> 00:02:21.550
So it's always gonna be the value,
it's always gonna be the index, and

42
00:02:21.550 --> 00:02:24.130
then it's always gonna be the list,
in that order.

43
00:02:24.130 --> 00:02:26.540
That's the order of the parameters.

44
00:02:26.540 --> 00:02:28.100
So whatever you call it,

45
00:02:28.100 --> 00:02:31.940
call those parameters,
it's still gonna be passed in that order.

46
00:02:31.940 --> 00:02:35.320
So for example,
let me just go back the way.

47
00:02:35.320 --> 00:02:35.820
It won't let me.

48
00:02:37.580 --> 00:02:44.950
We had it like this before val,
i, and list, right.

49
00:02:44.950 --> 00:02:51.353
If we swapped val and i like that,

50
00:02:51.353 --> 00:02:55.250
i would then be val.

51
00:02:55.250 --> 00:02:57.230
You can't mix these up.

52
00:02:58.460 --> 00:02:59.940
Or you can name them whatever you want,
but

53
00:02:59.940 --> 00:03:01.770
it's not gonna affect
the value that it holds.

54
00:03:01.770 --> 00:03:05.240
So this first one is always gonna
be the value, and the second one is

55
00:03:05.240 --> 00:03:10.230
always gonna be the index, cool?
&gt;&gt; Speaker 3: And just to quickly kinda,

56
00:03:10.230 --> 00:03:12.448
instead of having a function
that loops through a collection.

57
00:03:12.448 --> 00:03:15.740
&gt;&gt; Bianca Gandolfo: Mm-hm, mm-hm, yeah.

58
00:03:15.740 --> 00:03:21.560
And so, this is awesome because you don't
have to write out the loop the whole time.

59
00:03:21.560 --> 00:03:25.620
It's more obvious what it's
doing where your attention and

60
00:03:25.620 --> 00:03:29.400
loop syntax is drawn to
the mechanics of the loop.

61
00:03:29.400 --> 00:03:31.940
Where does it start, up until when etc.

62
00:03:31.940 --> 00:03:36.520
And then also each will work with both
arrays and objects so you don't have to

63
00:03:36.520 --> 00:03:41.350
worry about the for end loop versus the
for loop with the semicolons and then or

64
00:03:41.350 --> 00:03:46.150
the length, or
like having to do high zone property.

65
00:03:46.150 --> 00:03:48.450
And those kind of things, you don't
have to worry about that with each.

66
00:03:48.450 --> 00:03:51.500
And it kinda just takes care of it for
you, which is great.

67
00:03:51.500 --> 00:03:56.840
However the native for each,
in JavaScript is only for arrays.

68
00:03:56.840 --> 00:03:58.400
So keep that in mind.

69
00:03:58.400 --> 00:04:02.950
But each in underscore can do both.

70
00:04:04.220 --> 00:04:10.900
Oops, my email's open.
&gt;&gt; Bianca Gandolfo: Yeah, so awesome.

71
00:04:10.900 --> 00:04:12.400
So let's look at a little more.

72
00:04:13.550 --> 00:04:18.420
So we're gonna use each with
this array say my pocketmon

73
00:04:18.420 --> 00:04:22.360
array with the Charisaur,
Bulbazard and Twomew.

74
00:04:23.830 --> 00:04:25.850
And we have this function logger.

75
00:04:25.850 --> 00:04:32.017
All logger does is it takes a value and
it console.logs that value.

76
00:04:32.017 --> 00:04:38.834
So, how are we going to use each?
&gt;&gt; Bianca Gandolfo: To log all the values

77
00:04:38.834 --> 00:04:47.591
of our pocketmon.
&gt;&gt; Bianca Gandolfo: So

78
00:04:47.591 --> 00:04:49.730
we start with each like this.

79
00:04:51.160 --> 00:04:55.362
Let's see, William?

80
00:04:55.362 --> 00:05:02.983
Do you know?
&gt;&gt; William: Pocketmon.

81
00:05:02.983 --> 00:05:04.458
&gt;&gt; Bianca Gandolfo: Mm-hm.

82
00:05:04.458 --> 00:05:07.408
Pocketmon, yep.

83
00:05:07.408 --> 00:05:16.098
And then the second one?
&gt;&gt; Bianca Gandolfo: Do you know Grace?

84
00:05:16.098 --> 00:05:18.574
&gt;&gt; Grace: Logger.

85
00:05:18.574 --> 00:05:19.480
&gt;&gt; Bianca Gandolfo: Logger, yeah.

86
00:05:19.480 --> 00:05:23.060
Yeah, so iterator is just a fancy word for

87
00:05:23.060 --> 00:05:26.310
the function that's gonna be
called every time in the loop.

88
00:05:27.780 --> 00:05:33.510
So yeah, and that's basically how
you use each as we pass it array and

89
00:05:33.510 --> 00:05:38.000
then each time the loop is called.

90
00:05:38.000 --> 00:05:43.460
It's going to call this logger function
with first it's going to say Charisaur,

91
00:05:43.460 --> 00:05:47.770
then it's gonna be Bulbazard,
and then it's gonna be Twomew.

92
00:05:47.770 --> 00:05:52.150
So that's the order.
&gt;&gt; Bianca Gandolfo: Cool.

93
00:05:53.650 --> 00:05:56.550
I wanted to introduce,
remember AnimalMaker from yesterday?

94
00:05:56.550 --> 00:06:02.620
We have this AnimalMaker constructor
function that creates are animals.

95
00:06:05.510 --> 00:06:06.588
We had some animal names,

96
00:06:06.588 --> 00:06:08.213
can someone give me some animal names?

97
00:06:10.712 --> 00:06:11.249
&gt;&gt; Speaker 6: Smokey.

98
00:06:11.249 --> 00:06:12.546
&gt;&gt; Bianca Gandolfo: Smokey.

99
00:06:14.629 --> 00:06:15.379
&gt;&gt; Speaker 7: Fluffy.

100
00:06:15.379 --> 00:06:19.060
&gt;&gt; Bianca Gandolfo: Fluffy.

101
00:06:19.060 --> 00:06:20.330
&gt;&gt; Speaker 7: Trigger.
&gt;&gt; Bianca Gandolfo: Trigger, okay.

102
00:06:23.950 --> 00:06:27.520
So what we want to do here is,
the same as yesterday,

103
00:06:27.520 --> 00:06:31.060
is we want to loop through
all the animal names.

104
00:06:31.060 --> 00:06:34.940
Create an animal object that
has the speak method on it and

105
00:06:34.940 --> 00:06:36.360
then add them to our farm.

106
00:06:38.670 --> 00:06:41.310
And so this is how we did it
with just a regular loop.

107
00:06:41.310 --> 00:06:44.690
We did a foreloop, we started at zero,

108
00:06:44.690 --> 00:06:49.520
we looped while i is less
than m on Names.length.

109
00:06:49.520 --> 00:06:51.430
And then we set i++.

110
00:06:51.430 --> 00:06:57.670
Right, we incremented i each time by one,
and then we are running each animal name,

111
00:06:57.670 --> 00:07:02.430
so Smokey, Fluffy, Trigger, one at a time,
into our AnimalMaker function.

112
00:07:02.430 --> 00:07:06.350
So we see here that we're calling
a function the animalName at i.

113
00:07:07.360 --> 00:07:10.925
And then we're pushing that
whole thing Into our farm.

114
00:07:17.088 --> 00:07:17.945
&gt;&gt; Bianca Gandolfo: And so,

115
00:07:17.945 --> 00:07:22.967
my challenge to you is to
take a couple minutes and

116
00:07:22.967 --> 00:07:30.224
rewrite this using each.
&gt;&gt; Bianca Gandolfo: Anyone

117
00:07:30.224 --> 00:07:35.004
know what the first argument we
should pass to each should be?

118
00:07:35.004 --> 00:07:37.905
&gt;&gt; Speaker 7: Animal names?

119
00:07:37.905 --> 00:07:39.224
&gt;&gt; Bianca Gandolfo: Mm-hm.

120
00:07:39.224 --> 00:07:43.409
[LAUGH] And
the second one's gonna be a function,

121
00:07:43.409 --> 00:07:51.111
right?
&gt;&gt; Bianca Gandolfo: Lets move this up,

122
00:07:51.111 --> 00:07:52.430
so we have more space.

123
00:07:58.080 --> 00:07:59.340
So, what are we going to put inside

124
00:07:59.340 --> 00:08:04.660
the function?
&gt;&gt; Speaker 8: Push.

125
00:08:06.620 --> 00:08:07.800
&gt;&gt; Bianca Gandolfo: So farm dot push?

126
00:08:10.990 --> 00:08:11.920
What are we gonna push?

127
00:08:13.540 --> 00:08:22.690
Andy do you know we're gonna push?
&gt;&gt; Andy: I think we're gonna push name.

128
00:08:24.910 --> 00:08:26.400
&gt;&gt; Bianca Gandolfo: Close.

129
00:08:26.400 --> 00:08:27.410
We do need to use the name.

130
00:08:28.560 --> 00:08:31.530
We need to make sure that we
don't forget to pass it through

131
00:08:31.530 --> 00:08:33.250
our constructor function, AnimalMaker.

132
00:08:33.250 --> 00:08:38.480
What about Kim,

133
00:08:38.480 --> 00:08:41.438
do you have an idea of what
we should add to this line?

134
00:08:41.438 --> 00:08:46.148
&gt;&gt; Kim: [INAUDIBLE]

135
00:08:46.148 --> 00:08:49.058
&gt;&gt; Bianca Gandolfo: Like that?

136
00:08:49.058 --> 00:08:52.189
Yeah.

137
00:08:52.189 --> 00:08:55.320
Cool.

138
00:08:55.320 --> 00:08:57.460
And so now we can just delete this.

139
00:08:57.460 --> 00:09:02.060
Well, actually lets take a moment and
sort of compare how these look.

140
00:09:02.060 --> 00:09:03.110
Right?

141
00:09:03.110 --> 00:09:07.920
You remember how I was saying that for our
for loop the attention is drawn more to

142
00:09:07.920 --> 00:09:11.920
the mechanics of the loop,
rather than what it's actually doing.

143
00:09:11.920 --> 00:09:14.120
You can see this pretty clearly here.

144
00:09:14.120 --> 00:09:17.590
The mechanics of the loop
actually takes a lot of typing.

145
00:09:17.590 --> 00:09:18.810
And that's not the important part.

146
00:09:18.810 --> 00:09:24.050
And there's also leaves a lot of room for
human error like off by one or

147
00:09:24.050 --> 00:09:28.500
you put a comma, instead of
semicolon where you're suppose to.

148
00:09:28.500 --> 00:09:32.470
So with each, it really simplifies
that where you only have to

149
00:09:32.470 --> 00:09:36.350
pay attention to the data, and then
the function in which you want to run,

150
00:09:36.350 --> 00:09:39.520
and the functionality.
&gt;&gt; Speaker 11: So that, can we

151
00:09:40.730 --> 00:09:46.450
underscore each part,
where it says function parenthesis name?

152
00:09:46.450 --> 00:09:47.750
That's referring to each of

153
00:09:47.750 --> 00:09:50.770
the objects in the animal names, or?

154
00:09:50.770 --> 00:09:53.570
&gt;&gt; Bianca Gandolfo: Here?
&gt;&gt; Speaker 11: Just

155
00:09:53.570 --> 00:09:55.650
the placeholder.
&gt;&gt; Bianca Gandolfo: Here?

156
00:09:55.650 --> 00:09:56.240
&gt;&gt; Speaker 11: Yeah, so that name.

157
00:09:56.240 --> 00:09:57.050
&gt;&gt; Bianca Gandolfo: That's a placeholder.

158
00:09:57.050 --> 00:09:58.380
&gt;&gt; Speaker 11: This is a placeholder

159
00:09:58.380 --> 00:10:01.820
that represents each of the iterations.
&gt;&gt; Bianca Gandolfo: Yeah.

160
00:10:01.820 --> 00:10:02.900
&gt;&gt; Speaker 11: Of animal names.

161
00:10:02.900 --> 00:10:03.610
&gt;&gt; Bianca Gandolfo: Exactly, so

162
00:10:03.610 --> 00:10:04.410
it's val.
&gt;&gt; Speaker 11: And

163
00:10:04.410 --> 00:10:07.330
then you have to put val down there.
&gt;&gt; Bianca Gandolfo: Right exactly.

164
00:10:07.330 --> 00:10:08.500
&gt;&gt; Speaker 11: It's got to be the same.

165
00:10:08.500 --> 00:10:09.270
&gt;&gt; Bianca Gandolfo: Yeah, and

166
00:10:09.270 --> 00:10:12.120
the cool thing about this is
that we can say name, right?

167
00:10:12.120 --> 00:10:12.710
It's just more

168
00:10:12.710 --> 00:10:14.910
clear versus animalNames[i].
&gt;&gt; Speaker 11: Yeah.

169
00:10:16.030 --> 00:10:16.830
&gt;&gt; Bianca Gandolfo: It's less clear what

170
00:10:16.830 --> 00:10:17.370
that means.

171
00:10:17.370 --> 00:10:21.260
If we just say we call this name,
then it's clear to me so

172
00:10:21.260 --> 00:10:27.060
we're making an animal, we're passing in
an and then we're adding it to the farm.

173
00:10:27.060 --> 00:10:28.620
So it's just more clear
in what you're doing, and

174
00:10:28.620 --> 00:10:33.660
you're able to do that naming here
versus when we have a regular loop where

175
00:10:33.660 --> 00:10:37.870
we have to do all this bracket i stuff.
&gt;&gt; Speaker 11: So

176
00:10:37.870 --> 00:10:46.080
the argument in the callback function
refers to the index in the Do you list?

177
00:10:47.130 --> 00:10:49.890
List?
&gt;&gt; Bianca Gandolfo: Yeah, so,

178
00:10:49.890 --> 00:10:54.240
the parameter is gonna be,
the first one's gonna be Smokey.

179
00:10:55.420 --> 00:10:56.930
And you can also put the index here.

180
00:10:58.570 --> 00:11:00.510
Then you can also put the whole list, but

181
00:11:00.510 --> 00:11:03.210
since we're not really using it,
we don't need to do that.

182
00:11:03.210 --> 00:11:05.490
But you could.
&gt;&gt; Speaker 11: So every time it loops,

183
00:11:05.490 --> 00:11:08.824
that name will go Smokey, Fluffy, Trigger?
&gt;&gt; Bianca Gandolfo: Yes.

184
00:11:08.824 --> 00:11:13.710
Yep.
&gt;&gt; Speaker 12: What if animal names,

185
00:11:13.710 --> 00:11:19.100
that array, instead of just having
a string n each area or each spot,

186
00:11:19.100 --> 00:11:23.790
what if it was an object with,
you know what I'm saying?

187
00:11:23.790 --> 00:11:28.490
What if it was a more complex object, how
would each know what to pick out of there.

188
00:11:30.320 --> 00:11:31.430
&gt;&gt; Bianca Gandolfo: Yeah, so,

189
00:11:31.430 --> 00:11:33.130
there's a few ways you can deal with that.

190
00:11:33.130 --> 00:11:36.040
You can call this,
then this would be animal.

191
00:11:36.040 --> 00:11:40.460
You can call it animalObj,
in case you forget that it's an object.

192
00:11:40.460 --> 00:11:42.790
And then you can actually just nest.

193
00:11:42.790 --> 00:11:44.460
Nest your each like this.

194
00:11:47.350 --> 00:11:49.450
And this would loop through
your animal object.

195
00:11:52.700 --> 00:11:58.150
And then, in this function,
you can do whatever you wanted

196
00:11:58.150 --> 00:12:05.462
to do with it.
&gt;&gt; Bianca Gandolfo: So this would be like.

197
00:12:17.962 --> 00:12:19.394
&gt;&gt; Bianca Gandolfo: So then you could nest

198
00:12:19.394 --> 00:12:25.816
your each statement like that.
&gt;&gt; Speaker 11: So in that case,

199
00:12:25.816 --> 00:12:30.040
when you pass in an object, first argument
is gonna be the property name and

200
00:12:30.040 --> 00:12:34.300
the second argument is gonna be the value?
&gt;&gt; Bianca Gandolfo: No,

201
00:12:34.300 --> 00:12:39.699
it's gonna be the value and then property
name and then the animal object.

202
00:12:41.360 --> 00:12:45.570
So where, for an array would be the index,
for an object,

203
00:12:45.570 --> 00:12:47.550
it would just be the property name itself.

204
00:12:50.030 --> 00:12:54.550
And again, if you were nesting
regular regular four loops,

205
00:12:54.550 --> 00:12:58.990
then you would start to have things like,
you'd probably have a j in there, and

206
00:12:58.990 --> 00:13:00.880
it gets really complicated here.

207
00:13:00.880 --> 00:13:07.260
If, for example, this is like, I can't
even think about what it could be like.

208
00:13:10.120 --> 00:13:15.780
Yeah, you can call it characteristics.

209
00:13:17.270 --> 00:13:21.220
Or we'll just call it char for short.

210
00:13:21.220 --> 00:13:26.108
And then you would just,
it's easy to see, that we're gonna like,

211
00:13:26.108 --> 00:13:31.505
now we are console logging all of
the characteristics of our animal object,

212
00:13:31.505 --> 00:13:41.254
versus something at i j.
&gt;&gt; Bianca Gandolfo: Cool.

213
00:13:41.254 --> 00:13:46.637
Awesome, so we're pushing our
animal now what if we wanted

214
00:13:46.637 --> 00:13:52.448
to then,
&gt;&gt; Bianca Gandolfo: Actually

215
00:13:52.448 --> 00:13:55.086
do I have that one?

216
00:13:55.086 --> 00:13:56.060
Okay.

217
00:13:56.060 --> 00:13:57.708
Cool, so any questions about this?

218
00:13:57.708 --> 00:14:03.870
Pretty straightforward, awesome.

