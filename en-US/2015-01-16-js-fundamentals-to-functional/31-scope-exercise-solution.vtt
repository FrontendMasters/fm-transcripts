WEBVTT

1
00:00:00.000 --> 00:00:04.046
[MUSIC]

2
00:00:04.046 --> 00:00:07.230
&gt;&gt; Bianca Gandolfo: So I'm just gonna
quickly go through the answers for this.

3
00:00:08.430 --> 00:00:11.979
So it starts off with 11 failures and
1 passing.

4
00:00:11.979 --> 00:00:15.337
And let's see.

5
00:00:19.714 --> 00:00:22.836
&gt;&gt; Bianca Gandolfo: So
I'm gonna walk through it with you, so

6
00:00:22.836 --> 00:00:24.830
here's one assertion.

7
00:00:24.830 --> 00:00:29.500
It says a function's local scope
variables are not available

8
00:00:29.500 --> 00:00:31.390
anywhere outside of that function.

9
00:00:32.520 --> 00:00:35.650
So here we have this function
called first function.

10
00:00:36.800 --> 00:00:39.370
And we call first function here.

11
00:00:40.450 --> 00:00:42.620
So then we enter into that function body.

12
00:00:42.620 --> 00:00:50.150
We set localToFirstFn to the string
inner and then we exit the function.

13
00:00:50.150 --> 00:00:53.960
All this is doing here is it's stopping it
from, whenever you have an error it will

14
00:00:53.960 --> 00:00:56.900
stop running your code,
it will just break everything.

15
00:00:56.900 --> 00:01:01.279
This will stop that from happening so
it will run the subsequent lines of code.

16
00:01:02.930 --> 00:01:08.087
And this one says expect
actual to equal what?

17
00:01:15.462 --> 00:01:17.462
&gt;&gt; Bianca Gandolfo: So
we're setting actual here.

18
00:01:22.629 --> 00:01:23.251
&gt;&gt; Speaker 2: What was the first function?

19
00:01:27.337 --> 00:01:29.680
&gt;&gt; Bianca Gandolfo: Which string?

20
00:01:29.680 --> 00:01:30.980
&gt;&gt; Speaker 2: The one that-.

21
00:01:30.980 --> 00:01:31.860
&gt;&gt; Speaker 3: Inner.

22
00:01:31.860 --> 00:01:33.130
&gt;&gt; Bianca Gandolfo: To inner.
&gt;&gt; Speaker 2: Right there.

23
00:01:33.130 --> 00:01:33.630
&gt;&gt; Bianca Gandolfo: Like this?

24
00:01:34.650 --> 00:01:35.170
&gt;&gt; Speaker 2: Which string.

25
00:01:36.470 --> 00:01:37.390
&gt;&gt; Bianca Gandolfo: So we can check it.

26
00:01:37.390 --> 00:01:39.840
So I just saved, so I just saved that.

27
00:01:39.840 --> 00:01:43.650
And we can check it by coming into
our spec runner and refreshing it.

28
00:01:43.650 --> 00:01:44.890
And we see that that didn't pass.

29
00:01:44.890 --> 00:01:49.483
So there's some assumptions here that we-
&gt;&gt; Speaker 3: Why did you

30
00:01:49.483 --> 00:01:51.870
skip the test above?

31
00:01:51.870 --> 00:01:54.210
&gt;&gt; Bianca Gandolfo: Did I skip the,
whoops, sorry.

32
00:01:54.210 --> 00:01:56.756
I'm in the middle of the screen.

33
00:01:56.756 --> 00:02:02.520
So sorry,
let me start from the second one.

34
00:02:03.740 --> 00:02:06.220
So this one's the first one,
here's the second one.

35
00:02:06.220 --> 00:02:11.370
So the first one is input to a function
are treated as local scope variables.

36
00:02:11.370 --> 00:02:13.480
&gt;&gt; Speaker 2: Is that a true statement?

37
00:02:13.480 --> 00:02:16.260
&gt;&gt; Bianca Gandolfo: Yeah, so
you want to, it's a true statement and

38
00:02:16.260 --> 00:02:19.480
then the code,
you're trying to prove it right.

39
00:02:19.480 --> 00:02:23.080
So it's testing for this rule.

40
00:02:24.470 --> 00:02:31.069
So we have this function and
it takes a parameter called name and

41
00:02:31.069 --> 00:02:37.047
then here we're calling function
to equal with inner and

42
00:02:37.047 --> 00:02:42.171
so the parameter is now
holding the value inner.

43
00:02:42.171 --> 00:02:44.379
And so ACTUAL equals inner.

44
00:02:46.171 --> 00:02:49.210
&gt;&gt; Bianca Gandolfo: So
we type in inner and then we save it.

45
00:02:49.210 --> 00:02:51.510
The saving part's really important.

46
00:02:51.510 --> 00:02:55.813
And then we go to our test and
we're gonna refresh this page, and

47
00:02:55.813 --> 00:02:57.336
we see that it passed.

48
00:03:00.255 --> 00:03:01.795
&gt;&gt; Bianca Gandolfo: Cool?

49
00:03:07.421 --> 00:03:11.056
&gt;&gt; Bianca Gandolfo: And so the point here
is that parameters to a function, or

50
00:03:11.056 --> 00:03:16.380
I'm sorry, arguments, whatever your input
is, is gonna be local to that scope.

51
00:03:19.270 --> 00:03:23.830
So a function has access to the variables
contained within the same scope

52
00:03:23.830 --> 00:03:25.140
that the function was created in.

53
00:03:26.620 --> 00:03:31.960
So here we created this variable outer,

54
00:03:31.960 --> 00:03:36.810
we have this function here that we call,
and we say actual equals name.

55
00:03:38.070 --> 00:03:39.290
What do we expect that to equal?

56
00:03:40.360 --> 00:03:41.620
&gt;&gt; Speaker 4: Outer.

57
00:03:41.620 --> 00:03:42.120
&gt;&gt; Bianca Gandolfo: Outer.

58
00:03:43.880 --> 00:03:45.340
&gt;&gt; Speaker 4: The kid can
reach into the parent,

59
00:03:45.340 --> 00:03:47.330
but the parent can't go into the blender.

60
00:03:47.330 --> 00:03:50.590
&gt;&gt; Bianca Gandolfo: Yeah, exactly,
no parents in the blenders.

61
00:03:50.590 --> 00:03:51.320
I don't want that.

62
00:03:51.320 --> 00:03:56.400
[LAUGH] And
then we can refresh it, awesome.

63
00:03:56.400 --> 00:04:00.588
So that passed test as well,
that test passed as well.

64
00:04:03.500 --> 00:04:08.430
&gt;&gt; Bianca Gandolfo: All right, so
now we're back to the other one.

65
00:04:08.430 --> 00:04:12.830
A function's local scope variables are not
available anywhere outside that function.

66
00:04:16.340 --> 00:04:18.710
So here's a function, first function.

67
00:04:18.710 --> 00:04:23.050
We set that variable,
that local variable to inner.

68
00:04:23.050 --> 00:04:28.630
We call it and then here we are.

69
00:04:28.630 --> 00:04:32.986
So this is kind of a hint that
it's expecting it to throw

70
00:04:32.986 --> 00:04:35.959
an error when we call this function.

71
00:04:35.959 --> 00:04:37.340
What is this gonna be?

72
00:04:39.810 --> 00:04:40.840
&gt;&gt; Speaker 3: Null.

73
00:04:40.840 --> 00:04:42.465
&gt;&gt; Bianca Gandolfo: Why is it null and
not undefined?

74
00:04:42.465 --> 00:04:47.415
&gt;&gt; Speaker 5: Cuz it's not declared
anywhere in the global scope or

75
00:04:47.415 --> 00:04:51.270
in the scope outside of the first method?

76
00:04:51.270 --> 00:04:53.410
&gt;&gt; Bianca Gandolfo: That's a good guess.

77
00:04:53.410 --> 00:04:58.540
&gt;&gt; Speaker 4: Is it because of the expect
thing, so that the code doesn't break?

78
00:04:58.540 --> 00:05:01.880
&gt;&gt; Bianca Gandolfo: Well, actually it has
something to do with this beforeEach.

79
00:05:01.880 --> 00:05:07.380
So beforeEach of these eight functions
it's gonna set ACTUAL to null.

80
00:05:07.380 --> 00:05:11.107
&gt;&gt; Speaker 4: Right, but because that
expect doesn't actually run the code

81
00:05:11.107 --> 00:05:14.500
to set it to undefined,
it just keeps it at null?

82
00:05:14.500 --> 00:05:16.630
&gt;&gt; Bianca Gandolfo: So yeah,
every time, it will set it null.

83
00:05:16.630 --> 00:05:18.170
It will reset it to
null every single time.

84
00:05:19.630 --> 00:05:24.688
So if we didn't have that function there,
ACTUAL wouldn't keep holding

85
00:05:24.688 --> 00:05:30.087
the previous value of ACTUAL from
the other exercises if you're not careful.

86
00:05:30.087 --> 00:05:34.222
&gt;&gt; Speaker 4: No, I understand that,
but to make this exercise correct,

87
00:05:34.222 --> 00:05:38.550
the one we're on now,
the ACTUAL is expected to be null.

88
00:05:38.550 --> 00:05:41.720
But the only reason is that
ACTUAL really hasn't changed,

89
00:05:41.720 --> 00:05:44.080
because the before function
changed it to null.

90
00:05:44.080 --> 00:05:44.580
&gt;&gt; Bianca Gandolfo: Yeah, exactly.

91
00:05:44.580 --> 00:05:46.540
&gt;&gt; Speaker 4: We started as null,
nothing's changed it.

92
00:05:46.540 --> 00:05:47.250
&gt;&gt; Bianca Gandolfo: Totally.

93
00:05:47.250 --> 00:05:49.568
&gt;&gt; Speaker 4: And the reason nothing's
changed it, I think, I mean,

94
00:05:49.568 --> 00:05:52.336
I guess my question is,
is because you have that expect statement.

95
00:05:52.336 --> 00:05:55.726
That's kind of like,
if it's gonna be undefined or

96
00:05:55.726 --> 00:05:59.050
an error then just leave
everything the way it was.

97
00:05:59.050 --> 00:06:01.060
&gt;&gt; Bianca Gandolfo: Right,
it's because, yeah, exactly.

98
00:06:01.060 --> 00:06:02.740
Because this localToFirstFn,

99
00:06:02.740 --> 00:06:05.520
since it doesn't exist in
the scope it will throw an error.

100
00:06:05.520 --> 00:06:06.600
&gt;&gt; Speaker 4: Right.
&gt;&gt; Bianca Gandolfo: And it would

101
00:06:06.600 --> 00:06:07.548
stop running the code.

102
00:06:07.548 --> 00:06:14.962
So this ACTUAL doesn't have
access to this variable.

103
00:06:14.962 --> 00:06:15.500
&gt;&gt; Speaker 4: Right.

104
00:06:15.500 --> 00:06:18.925
&gt;&gt; Speaker 5: She didn't have that before,
what was it called,

105
00:06:18.925 --> 00:06:22.959
before each test at the top it would be.

106
00:06:22.959 --> 00:06:27.330
Because was the result of
the previous test piece.

107
00:06:27.330 --> 00:06:28.048
&gt;&gt; Speaker 4: Okay.

108
00:06:28.048 --> 00:06:28.760
&gt;&gt; Bianca Gandolfo: Yeah.

109
00:06:30.960 --> 00:06:34.660
So the next one is, if function's local
scope variables are not available

110
00:06:34.660 --> 00:06:38.480
anywhere outside that function regardless
of the context, it's called in.

111
00:06:41.110 --> 00:06:48.770
So we have our first function here,
and we have this variable first.

112
00:06:48.770 --> 00:06:50.080
And there's a little hint here.

113
00:06:50.080 --> 00:06:54.769
It says, although false, it might seem
reasonable to think that the secondFn

114
00:06:54.769 --> 00:07:00.102
mentions the local second function, should
have access to the localToFirstFn variable

115
00:07:00.102 --> 00:07:05.171
since it's being called here from within
the scope that the variable is declaring.

116
00:07:08.379 --> 00:07:09.350
&gt;&gt; Bianca Gandolfo: This is a tricky one.

117
00:07:11.570 --> 00:07:13.940
So we have our second function here.

118
00:07:13.940 --> 00:07:15.700
Sorry, we call secondFn here.

119
00:07:17.280 --> 00:07:20.421
But since this hasn't run yet,
we actually even haven't gotten there.

120
00:07:20.421 --> 00:07:26.838
So we declared secondFn,
ACTUAL = localToFirstFn.

121
00:07:26.838 --> 00:07:31.710
And then we expect this to throw,
so this is where we're thrown,

122
00:07:31.710 --> 00:07:35.500
calling our secondFn in here, I'm sorry.

123
00:07:37.710 --> 00:07:44.142
I actually think it's gonna call
firstFn first here and where that goes,

124
00:07:44.142 --> 00:07:49.754
it goes into this inner block,
declares this localToFirstFn.

125
00:07:49.754 --> 00:07:52.154
Then it calls second function and

126
00:07:52.154 --> 00:07:56.878
then second function is setting
ACTUAL to local first function.

127
00:07:56.878 --> 00:08:02.147
And this is tricky because this is
something called lexicoscope, if

128
00:08:02.147 --> 00:08:08.160
you wanna read into it later, is that this
doesn't have access to the localToFirstFn.

129
00:08:09.240 --> 00:08:10.460
So what do we expect this to be?

130
00:08:13.297 --> 00:08:14.171
&gt;&gt; Speaker 3: Null.

131
00:08:16.962 --> 00:08:18.780
&gt;&gt; Bianca Gandolfo: Let's double check it.

132
00:08:18.780 --> 00:08:24.230
&gt;&gt; Speaker 4: So
blenders can't access sibling blenders.

133
00:08:25.300 --> 00:08:29.440
I mean, our function one, second from
first, like siblings if you will.

134
00:08:29.440 --> 00:08:33.430
&gt;&gt; Bianca Gandolfo: Yeah, you can call it
siblings I guess, but the point here is

135
00:08:33.430 --> 00:08:40.390
that, yeah, so, yes, siblings can't
access inside other functions either.

136
00:08:40.390 --> 00:08:41.680
Yeah.

137
00:08:41.680 --> 00:08:44.368
Even though it may seem like you could
because you're calling it from within

138
00:08:44.368 --> 00:08:44.962
that function.

139
00:08:48.462 --> 00:08:49.064
&gt;&gt; Bianca Gandolfo: Cool.

140
00:08:49.064 --> 00:08:51.660
&gt;&gt; [INAUDIBLE].

141
00:08:51.660 --> 00:08:54.657
&gt;&gt; Bianca Gandolfo: So if an inner and
outer variable share the same name, and

142
00:08:54.657 --> 00:08:58.216
the name is referenced in the inner scope,
the inner scope variable

143
00:08:58.216 --> 00:09:01.350
masks the variable from the outer
scope with the same name.

144
00:09:01.350 --> 00:09:04.360
This is from the slide
where I called precedence.

145
00:09:04.360 --> 00:09:07.420
This renders the outer scope
variables inaccessible from

146
00:09:07.420 --> 00:09:09.690
anywhere within the inner function block.

147
00:09:11.680 --> 00:09:13.130
So what's this one?

148
00:09:13.130 --> 00:09:14.890
So we have a function, or sorry,

149
00:09:14.890 --> 00:09:20.460
we have this variable outer and then we
have this function that has the same name.

150
00:09:20.460 --> 00:09:21.230
Reset to inner.

151
00:09:21.230 --> 00:09:23.560
We set ACTUAL to sameName.

152
00:09:23.560 --> 00:09:25.712
What are we gonna expect ACTUAL to be?

153
00:09:33.796 --> 00:09:35.738
&gt;&gt; Bianca Gandolfo: Anyone?

154
00:09:35.738 --> 00:09:37.790
I hear whispers, but
I can't understand them.

155
00:09:39.210 --> 00:09:41.710
What about Kim, did you get this far?

156
00:09:41.710 --> 00:09:43.310
&gt;&gt; Kim: No,
because I didn't know what rule meant.

157
00:09:44.460 --> 00:09:47.540
I don't do unit testing, so
I don't know any of that stuff.

158
00:09:47.540 --> 00:09:48.910
&gt;&gt; Bianca Gandolfo: No worries.

159
00:09:48.910 --> 00:09:50.630
Anyone else get this far?

160
00:09:50.630 --> 00:09:51.150
&gt;&gt; Speaker 3: I'd say outer.
&gt;&gt; Bianca Gandolfo: Outer?

161
00:09:51.150 --> 00:09:52.750
What do you think?

162
00:09:52.750 --> 00:09:53.980
&gt;&gt; Speaker 7: Inner.
&gt;&gt; Bianca Gandolfo: You think it's

163
00:09:53.980 --> 00:09:54.480
gonna be inner?

164
00:09:55.520 --> 00:09:56.620
You're right.
It's gonna be inner.

165
00:09:58.780 --> 00:10:00.399
Why is it gonna be inner and not outer?

166
00:10:02.090 --> 00:10:05.430
&gt;&gt; Speaker 7: Because it
only gets as far as the.

167
00:10:08.140 --> 00:10:11.370
&gt;&gt; Bianca Gandolfo: Because if we
think about the way it's called, so

168
00:10:11.370 --> 00:10:15.820
we call this function, so
first we set outer up here and

169
00:10:15.820 --> 00:10:21.170
then we say awesome, there's this FN
function, we skip it, we call it,

170
00:10:21.170 --> 00:10:27.160
and then at this point,
we enter into this, to the function body.

171
00:10:27.160 --> 00:10:30.470
Now we set sameName to inner,
and at that point,

172
00:10:30.470 --> 00:10:35.200
we're setting ACTUAL to sameName,
and at that point, it's inner and

173
00:10:35.200 --> 00:10:38.700
that's why, when it's evaluated down here,
it's inner.

174
00:10:38.700 --> 00:10:40.403
&gt;&gt; Speaker 2: I was looking at the bottom,
the next exercise.

175
00:10:40.403 --> 00:10:41.053
&gt;&gt; Bianca Gandolfo: Okay.

176
00:10:41.053 --> 00:10:43.001
Looking ahead.

177
00:10:43.001 --> 00:10:48.046
[LAUGH]
&gt;&gt; Bianca Gandolfo: Awesome.

178
00:10:50.712 --> 00:10:53.176
&gt;&gt; Bianca Gandolfo: So,
the next one is if an inner and

179
00:10:53.176 --> 00:10:59.162
outer variable share the same name and
the name is referenced in the outer scope,

180
00:10:59.162 --> 00:11:02.000
the outer value binding will be used.

181
00:11:05.640 --> 00:11:09.450
So, here we're declaring sameName.

182
00:11:09.450 --> 00:11:11.360
Great function, we skip over it.

183
00:11:11.360 --> 00:11:16.040
We call the function,
we enter into the function body,

184
00:11:16.040 --> 00:11:21.890
we assign sameName to inner,
we exit here on line 85 and

185
00:11:21.890 --> 00:11:28.370
then we set ACTUAL to sameName and
since ACTUAL is in a scope that is outside

186
00:11:28.370 --> 00:11:32.930
of this function,
it only has access to the sameName

187
00:11:32.930 --> 00:11:37.410
within the same scope and so
that means that actual is going to be?

188
00:11:40.195 --> 00:11:41.302
Hm?

189
00:11:41.302 --> 00:11:44.060
&gt;&gt; Speaker 2: Outer.

190
00:11:44.060 --> 00:11:45.050
&gt;&gt; Bianca Gandolfo: Outer, yes.

191
00:11:45.050 --> 00:11:51.620
Then we save it and then we can
check it and make sure we're right.

192
00:11:51.620 --> 00:11:53.671
Awesome, starting to get more greens.

193
00:11:59.212 --> 00:12:01.516
&gt;&gt; Bianca Gandolfo: So
a new variable scope is created for

194
00:12:01.516 --> 00:12:05.020
every call to a function as
exemplified with a counter.

195
00:12:07.810 --> 00:12:15.300
So we have our FN function,
we say cool restore it, we skip it, and

196
00:12:15.300 --> 00:12:21.590
then we call it and then we have,
we call it, we enter into the body.

197
00:12:23.190 --> 00:12:28.150
We say var innerCounter
equals innerCounter or ten

198
00:12:29.790 --> 00:12:34.770
and so if innerCounter,
so if this is undefined,

199
00:12:35.940 --> 00:12:41.110
it will be false and it will skip to
the right side and it will be ten.

200
00:12:41.110 --> 00:12:47.182
Otherwise, inner counter will
be inner counter plus one,

201
00:12:47.182 --> 00:12:49.860
do we have inner counter?

202
00:12:54.410 --> 00:12:55.040
Okay.

203
00:12:55.040 --> 00:12:55.970
I see.

204
00:12:55.970 --> 00:12:59.960
So if there's no inner counter already,
then it's gonna be ten and

205
00:12:59.960 --> 00:13:04.290
at this point it's gonna be 11, and
then we set ACTUAL to innerCounter.

206
00:13:04.290 --> 00:13:07.950
So we call it once and
what is this gonna be?

207
00:13:07.950 --> 00:13:08.700
&gt;&gt; Speaker 3: 11?

208
00:13:08.700 --> 00:13:09.460
&gt;&gt; Speaker 2: 11.

209
00:13:09.460 --> 00:13:10.210
&gt;&gt; Bianca Gandolfo: 11.

210
00:13:10.210 --> 00:13:13.878
And then we call it again.

211
00:13:16.421 --> 00:13:17.342
&gt;&gt; Speaker 2: Call.

212
00:13:17.342 --> 00:13:18.014
&gt;&gt; Speaker 3: 11?

213
00:13:18.014 --> 00:13:19.250
&gt;&gt; Bianca Gandolfo: 11.

214
00:13:19.250 --> 00:13:23.347
So it's gonna be 11 because
every time we call the function,

215
00:13:23.347 --> 00:13:27.600
it creates a new scope and so
innerCounter is never gonna change,

216
00:13:27.600 --> 00:13:30.712
cuz it's always gonna
start off as undefined.

217
00:13:40.462 --> 00:13:41.338
&gt;&gt; Bianca Gandolfo: Great.

218
00:13:45.172 --> 00:13:47.987
&gt;&gt; Bianca Gandolfo: So,
a new variable scope is created for

219
00:13:47.987 --> 00:13:53.630
each call to a function as exemplified
with uninitialized string variables.

220
00:13:56.260 --> 00:14:00.710
So here, we have our function again.

221
00:14:00.710 --> 00:14:06.090
We skip it, right, to the end,
we call it, we go inside,

222
00:14:06.090 --> 00:14:11.400
and we say we initialize a local
variable at undefined and

223
00:14:11.400 --> 00:14:19.930
it says if localVariable is undefined,
enter into this block.

224
00:14:19.930 --> 00:14:25.130
So ACTUAL is now alpha and
then we're gonna skip the else and

225
00:14:25.130 --> 00:14:30.337
then we're gonna set this
localVariable to initialized.

226
00:14:33.461 --> 00:14:35.690
&gt;&gt; Bianca Gandolfo: And
now we're gonna call the function.

227
00:14:35.690 --> 00:14:39.966
The first time you call it,
&gt;&gt; Bianca Gandolfo: What is it going to

228
00:14:39.966 --> 00:14:40.762
print out?

229
00:14:40.762 --> 00:14:49.600
&gt;&gt; [INAUDIBLE]
&gt;&gt; Speaker 4: Alpha.

230
00:14:49.600 --> 00:14:50.690
&gt;&gt; Bianca Gandolfo: Alpha, exactly.

231
00:14:51.770 --> 00:14:54.720
And then if we call it again?

232
00:14:56.080 --> 00:14:57.238
So, we call it again.

233
00:14:57.238 --> 00:14:59.789
&gt;&gt; Speaker 3: That's initialized.

234
00:14:59.789 --> 00:15:02.180
&gt;&gt; Bianca Gandolfo: Well,
let's think about how it runs.

235
00:15:02.180 --> 00:15:05.090
So we call the function,
we go back up here.

236
00:15:06.710 --> 00:15:08.420
It's initialized again as undefined.

237
00:15:09.670 --> 00:15:12.529
It says if local variable is undefined,
enter in this block.

238
00:15:13.990 --> 00:15:18.590
And it says ACTUAL alpha, it skips it and
then it says local variables initialized.

239
00:15:19.680 --> 00:15:21.050
So, mm-hm?

240
00:15:21.050 --> 00:15:22.750
&gt;&gt; Speaker 5: Sorry,
I got tripped up on this one.

241
00:15:22.750 --> 00:15:25.870
I thought local variable is
null instead of undefined.

242
00:15:26.940 --> 00:15:30.070
Could you maybe touch
on why it's not null?

243
00:15:30.070 --> 00:15:34.370
&gt;&gt; Bianca Gandolfo: Sure, sure, so the
reason that local variable is undefined is

244
00:15:34.370 --> 00:15:39.670
because whenever you don't explicitly
define a variable, it's undefined.

245
00:15:39.670 --> 00:15:41.480
You have to actually
set something to null.

246
00:15:43.630 --> 00:15:47.338
So, JavaScript will make
it undefined automatically.

247
00:15:47.338 --> 00:15:51.626
But, so in general, if you want to set
something to empty, it's best practice to

248
00:15:51.626 --> 00:15:55.854
set it to null and not undefined so that
you can kind of differentiate between that

249
00:15:55.854 --> 00:15:59.180
and you'll notice that we Set
actual to null before each time.

250
00:15:59.180 --> 00:16:01.570
That's us manually setting it.

251
00:16:01.570 --> 00:16:03.950
But here,
we're just initializing a variable and

252
00:16:03.950 --> 00:16:05.110
it's just going to be undefined.

253
00:16:05.110 --> 00:16:09.130
The same way if you have parameters
that don't have an argument pass and

254
00:16:09.130 --> 00:16:12.950
you reference those parameters,
they're going to be undefined.

255
00:16:17.190 --> 00:16:18.827
So what did we decide this one was?

256
00:16:22.119 --> 00:16:23.453
&gt;&gt; Speaker 5: Alpha.
&gt;&gt; Bianca Gandolfo: Alpha.

257
00:16:30.744 --> 00:16:31.911
&gt;&gt; Bianca Gandolfo: Cool.

258
00:16:31.911 --> 00:16:34.120
So, let's check it.

259
00:16:37.369 --> 00:16:38.120
&gt;&gt; Bianca Gandolfo: Awesome.

260
00:16:44.830 --> 00:16:48.950
So an inner function can act both as
local scope variables and variables

261
00:16:48.950 --> 00:16:52.770
in its containing scope, provided
the variables have different names.

262
00:16:55.340 --> 00:16:59.710
So here we have our outer name,
then we have FN again,

263
00:16:59.710 --> 00:17:03.720
we skip it, we call FN,
we enter into that body.

264
00:17:03.720 --> 00:17:10.330
We set innerName to inner and
then ACTUAL is innerName + outerName.

265
00:17:13.690 --> 00:17:14.390
So, what is ACTUAL?

266
00:17:17.580 --> 00:17:18.198
&gt;&gt; Speaker 5: innerouter?

267
00:17:18.198 --> 00:17:20.038
&gt;&gt; Bianca Gandolfo: Mm-hm.

268
00:17:20.038 --> 00:17:23.720
Is innerouter.

269
00:17:23.720 --> 00:17:29.010
And the reason that ACTUAL can be set like
this is because it's a global variable.

270
00:17:29.010 --> 00:17:32.310
And we see that has no var, so that's
something important to note as well.

271
00:17:35.700 --> 00:17:36.340
So we check it.

272
00:17:37.620 --> 00:17:38.619
Great, only two more.

273
00:17:41.786 --> 00:17:43.453
&gt;&gt; Bianca Gandolfo: Let's see.

274
00:17:46.100 --> 00:17:48.966
&gt;&gt; Bianca Gandolfo: Between
calls to an inner function,

275
00:17:48.966 --> 00:17:54.340
that inner function retains access
to a variable in outer scope.

276
00:17:54.340 --> 00:17:57.732
Modifying those variables has
a lasting effect between calls to

277
00:17:57.732 --> 00:17:58.869
the inner function.

278
00:18:02.036 --> 00:18:03.770
&gt;&gt; Bianca Gandolfo: So
here is our outerCounter.

279
00:18:03.770 --> 00:18:07.030
And we have a function.

280
00:18:09.360 --> 00:18:11.390
We skip it, we call it.

281
00:18:12.450 --> 00:18:15.860
We enter into the body
an outerCounter = outerCounter + 1.

282
00:18:15.860 --> 00:18:18.690
So outerCounter is 10.

283
00:18:18.690 --> 00:18:20.360
So that means outerCounter is now 11.

284
00:18:20.360 --> 00:18:24.100
And we're setting ACTUAL to outerCounter.

285
00:18:25.390 --> 00:18:26.180
So what is ACTUAL?

286
00:18:26.180 --> 00:18:27.560
&gt;&gt; Speaker 2: 11?

287
00:18:27.560 --> 00:18:28.911
&gt;&gt; Bianca Gandolfo: Yeah.

288
00:18:32.240 --> 00:18:36.520
&gt;&gt; Bianca Gandolfo: And
then we call it again, call function.

289
00:18:36.520 --> 00:18:39.400
We go inside the function body,
outerCounter.

290
00:18:39.400 --> 00:18:42.320
What's outerCounter again?

291
00:18:42.320 --> 00:18:44.018
&gt;&gt; Group: 11.
&gt;&gt; Bianca Gandolfo: 11 plus 1, is 12.

292
00:18:44.018 --> 00:18:48.750
So now outerCounter, I'm sorry,

293
00:18:48.750 --> 00:18:51.690
now ACTUAL is set to outerCounter,
which is 12.

294
00:18:51.690 --> 00:18:57.010
So what should we expect ACTUAL
to be at the second call?

295
00:18:57.010 --> 00:18:58.160
12.

296
00:18:58.160 --> 00:19:01.800
The difference here is that our
counter is outside of our function.

297
00:19:03.770 --> 00:19:07.500
And since our child function here, our
nested function, has access to that outer

298
00:19:07.500 --> 00:19:13.720
counter, it's still, it can change it,
but it still has reference to the value.

299
00:19:15.290 --> 00:19:16.244
Cool, let's save it.

300
00:19:20.077 --> 00:19:21.744
&gt;&gt; Bianca Gandolfo: Great.

301
00:19:25.452 --> 00:19:26.970
&gt;&gt; Bianca Gandolfo: And then our last one.

302
00:19:28.170 --> 00:19:31.990
The rule about retaining access to
variables from the outer scope still

303
00:19:31.990 --> 00:19:37.402
applies even after the outer function call
that created the outer scope has returned.

304
00:19:37.402 --> 00:19:40.360
&gt;&gt; [INAUDIBLE]
&gt;&gt; Bianca Gandolfo: So

305
00:19:40.360 --> 00:19:41.760
we have our outer function.

306
00:19:44.090 --> 00:19:45.396
And remember we skip over it?

307
00:19:45.396 --> 00:19:53.340
We call, where does this end?

308
00:19:53.340 --> 00:19:54.160
I see.

309
00:19:54.160 --> 00:19:55.786
So we skip over it down here.

310
00:19:58.670 --> 00:20:00.161
&gt;&gt; Bianca Gandolfo: And
then we run the outer function,

311
00:20:02.911 --> 00:20:03.740
&gt;&gt; Bianca Gandolfo: And call it.

312
00:20:03.740 --> 00:20:08.250
And we go inside of the function body,
we set counterInOuterScope to 10.

313
00:20:08.250 --> 00:20:15.980
And then we have our incrementing
function, which we skip.

314
00:20:15.980 --> 00:20:19.678
We call the incrementing function
&gt;&gt; Bianca Gandolfo: And

315
00:20:19.678 --> 00:20:24.622
we say counter in outer scope plus one,
when we set that,

316
00:20:24.622 --> 00:20:29.170
and then we return here
to our expect statement.

317
00:20:29.170 --> 00:20:30.610
We expect actual to equal what?

318
00:20:30.610 --> 00:20:31.150
&gt;&gt; Speaker 5: 11.

319
00:20:31.150 --> 00:20:31.700
&gt;&gt; Bianca Gandolfo: 11.

320
00:20:31.700 --> 00:20:36.379
And then we call our inner incrementing

321
00:20:36.379 --> 00:20:41.810
function again
&gt;&gt; Bianca Gandolfo: And then what happens?

322
00:20:41.810 --> 00:20:42.360
&gt;&gt; Speaker 4: 12.

323
00:20:42.360 --> 00:20:42.920
&gt;&gt; Bianca Gandolfo: 12.

324
00:20:42.920 --> 00:20:47.088
&gt;&gt; Speaker 4: So up to now,
it's like the previous exercise.

325
00:20:47.088 --> 00:20:47.784
&gt;&gt; Bianca Gandolfo: Mm hm.

326
00:20:52.560 --> 00:20:53.705
&gt;&gt; Bianca Gandolfo: It's similar, but

327
00:20:53.705 --> 00:20:57.620
the difference here is that we're
explicitly inside of a function.

328
00:21:06.869 --> 00:21:10.400
&gt;&gt; Bianca Gandolfo: And
now what is, what is this one?

329
00:21:10.400 --> 00:21:13.300
I would, to be a function.

330
00:21:16.280 --> 00:21:17.563
Let's see.

331
00:21:17.563 --> 00:21:19.940
Here we go, so I skipped this line.

332
00:21:19.940 --> 00:21:24.396
So then we have window.retainedInnerFn
= innerIncrementingFn.

333
00:21:24.396 --> 00:21:27.495
So remember we put things on
the window object, it makes it global?

334
00:21:32.369 --> 00:21:35.610
&gt;&gt; Bianca Gandolfo: And then we call
it here again, retainedInnerFn().

335
00:21:35.610 --> 00:21:39.093
And so once we call it,
we go back in here.

336
00:21:39.093 --> 00:21:45.430
And then we do + 1 again.

337
00:21:45.430 --> 00:21:48.371
And since we still retain
value in the parent scope.

338
00:21:53.243 --> 00:21:56.452
&gt;&gt; Bianca Gandolfo: What are the, it's 13.

339
00:22:03.327 --> 00:22:08.010
&gt;&gt; Bianca Gandolfo: Cool, so
any questions about that exercise?

340
00:22:08.010 --> 00:22:09.827
It's pretty in-depth.

341
00:22:11.980 --> 00:22:15.704
&gt;&gt; Bianca Gandolfo: If you read
through all these rules in here,

342
00:22:15.704 --> 00:22:19.980
these are basically all the rules for
a scope.

343
00:22:19.980 --> 00:22:24.470
So if you go through those a few
times you will have been mastered

344
00:22:24.470 --> 00:22:26.308
all of the different scenarios for scope.

345
00:22:26.308 --> 00:22:30.457
Any questions?

346
00:22:30.457 --> 00:22:33.030
I'd like just one question, so.

347
00:22:34.110 --> 00:22:35.900
Someone gives me one question
that would be great.

348
00:22:35.900 --> 00:22:37.450
&gt;&gt; Speaker 4: So if you click on them,
you get the actual.

349
00:22:38.815 --> 00:22:43.993
&gt;&gt; Bianca Gandolfo: Yeah, if you click
on them, you can see the exercise.

350
00:22:48.577 --> 00:22:49.803
&gt;&gt; Speaker 9: I have a question.

351
00:22:49.803 --> 00:22:50.912
&gt;&gt; Bianca Gandolfo: Mm-hm.

352
00:22:50.912 --> 00:22:56.760
&gt;&gt; Speaker 9: I have one error remaining,
I don't know which one it is.

353
00:22:56.760 --> 00:22:59.420
How do we find which one it is?

354
00:22:59.420 --> 00:23:00.070
&gt;&gt; Speaker 4: The red X.

355
00:23:02.440 --> 00:23:06.380
&gt;&gt; Bianca Gandolfo: Yeah I can
look at yours if you want.

356
00:23:06.380 --> 00:23:07.970
Yeah. Great.
&gt;&gt; Group: The red X [CROSSTALK]

357
00:23:07.970 --> 00:23:10.190
&gt;&gt; Bianca Gandolfo: Yeah the style sheet,

358
00:23:10.190 --> 00:23:12.980
there was an error with the style sheet.

