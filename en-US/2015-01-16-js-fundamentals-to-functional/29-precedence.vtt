WEBVTT

1
00:00:00.000 --> 00:00:03.797
[MUSIC]

2
00:00:03.797 --> 00:00:07.938
&gt;&gt; Bianca Gandolfo: And so, this is also
how we create privacy, private variables,

3
00:00:07.938 --> 00:00:10.060
is by storing them in a function.

4
00:00:10.060 --> 00:00:14.970
There's no other way in JavaScript, we
don't have block scope like Ruby does, for

5
00:00:14.970 --> 00:00:15.540
example.

6
00:00:15.540 --> 00:00:18.600
We have a lot of people who take this
class who come from a Ruby background, and

7
00:00:18.600 --> 00:00:23.910
that's a little bit confusing at first,
but there's only, at least at this

8
00:00:23.910 --> 00:00:29.290
point in time, there is in future
generations of JavaScript, there's going

9
00:00:29.290 --> 00:00:34.960
to be a keyword that will allow you to
have block scope, but for now, we don't.

10
00:00:36.490 --> 00:00:37.310
Cool.

11
00:00:37.310 --> 00:00:41.710
And so, I spoke a little bit
about creating scopes, about how

12
00:00:41.710 --> 00:00:46.740
the variable scope is not created
until we invoke the function.

13
00:00:49.940 --> 00:00:51.040
Cool.

14
00:00:51.040 --> 00:00:54.880
And then, so we have these nested scopes.

15
00:00:54.880 --> 00:00:57.070
How do we know which one wins?

16
00:00:57.070 --> 00:01:00.260
When we have two variables
with the same name.

17
00:01:00.260 --> 00:01:01.590
This is called precedence.

18
00:01:05.460 --> 00:01:09.980
I like to play this game where we go
around the room and we pretend that we're

19
00:01:09.980 --> 00:01:14.100
the JavaScript interpreter, and
we say what line we start in.

20
00:01:15.920 --> 00:01:21.210
So, for example, what I would say,
if I was gonna do this previous example,

21
00:01:21.210 --> 00:01:25.760
I would be like, okay, so I'm a JavaScript
interpreter, I just created a variable g,

22
00:01:25.760 --> 00:01:30.760
I stored the stream global, then I would
see the blender, I would skip over

23
00:01:30.760 --> 00:01:35.950
the blender, I would store this in memory,
skip over the blender,

24
00:01:35.950 --> 00:01:41.380
then I would go down to this invocation
where I would call it with blueberry.

25
00:01:41.380 --> 00:01:44.910
That's when I come into
the function body and

26
00:01:44.910 --> 00:01:48.240
the function body fruit is now blueberry.

27
00:01:48.240 --> 00:01:50.710
So, B is blueberry.

28
00:01:50.710 --> 00:01:54.220
Then, we're saving Y as yogurt string.

29
00:01:54.220 --> 00:01:57.770
Then, we see this function,
we skip over the function body

30
00:01:57.770 --> 00:02:01.660
until we get to this last line here,
in which we call the function,

31
00:02:01.660 --> 00:02:06.800
now at that point is when we go
into the function body and we alert

32
00:02:08.970 --> 00:02:13.920
blueberries and
yogurt make a blueberry swirl.

33
00:02:13.920 --> 00:02:17.640
And then, at that point,
this function is out and

34
00:02:17.640 --> 00:02:21.476
then it comes out here.
&gt;&gt; Bianca Gandolfo: And

35
00:02:21.476 --> 00:02:24.920
it goes into the next line,
if there was a next line underneath.

36
00:02:24.920 --> 00:02:29.780
So, that's kinda how just sort of like
going through how the code would run and

37
00:02:29.780 --> 00:02:33.550
like a very crude understanding
of like how it's run.

38
00:02:35.650 --> 00:02:38.659
So, who wants to go first, and
then we'll just go down in

39
00:02:38.659 --> 00:02:43.752
line?
&gt;&gt; Bianca Gandolfo: The first

40
00:02:43.752 --> 00:02:45.194
line is the easiest one, so

41
00:02:45.194 --> 00:02:46.774
it's better if you go first.

42
00:02:46.774 --> 00:02:47.450
&gt;&gt; Grace: Thank you

43
00:02:47.450 --> 00:02:47.955
&gt;&gt; Bianca Gandolfo: Okay

44
00:02:47.955 --> 00:02:49.197
&gt;&gt; Grace: [LAUGH]
&gt;&gt; Bianca Gandolfo: All right,

45
00:02:49.197 --> 00:02:50.210
Grace.
&gt;&gt; Speaker 3: Go, Grace.

46
00:02:50.210 --> 00:02:51.180
&gt;&gt; Grace: G is global,

47
00:02:51.180 --> 00:02:53.510
I don't know what else to say about it.
&gt;&gt; Bianca Gandolfo: Yeah, so

48
00:02:53.510 --> 00:02:56.278
you're just storing a string global in g,
yep.

49
00:02:56.278 --> 00:02:59.167
And then, Jill
&gt;&gt; Joe: Bar one was

50
00:02:59.167 --> 00:03:02.490
local?
&gt;&gt; Bianca Gandolfo: So,

51
00:03:02.490 --> 00:03:05.090
the next line that runs is
gonna be this line, right?

52
00:03:07.160 --> 00:03:10.470
Just how it would run,
how the code is actually gonna be run.

53
00:03:10.470 --> 00:03:16.002
So, you could just say,
you can just say that there's a function,

54
00:03:16.002 --> 00:03:20.020
a function called go.
&gt;&gt; Joe: So, you store that in memory and

55
00:03:20.020 --> 00:03:23.760
then you invoke
&gt;&gt; Bianca Gandolfo: So,

56
00:03:23.760 --> 00:03:27.040
we skip the function body, right?
&gt;&gt; Joe: Yep.

57
00:03:27.040 --> 00:03:27.620
&gt;&gt; Bianca Gandolfo: Skip the entire,

58
00:03:27.620 --> 00:03:29.400
so this part we skip.

59
00:03:29.400 --> 00:03:30.370
That's really, really important.

60
00:03:30.370 --> 00:03:31.620
I'm gonna say like eight times.

61
00:03:31.620 --> 00:03:32.490
But that's super important.

62
00:03:33.860 --> 00:03:35.260
And then, we
&gt;&gt; Joe: And then,

63
00:03:35.260 --> 00:03:37.690
you call go.
&gt;&gt; Bianca Gandolfo: Call go, and then,

64
00:03:37.690 --> 00:03:39.575
Kim, what happens next?
&gt;&gt; Kim: l =

65
00:03:39.575 --> 00:03:41.400
local
&gt;&gt; Bianca Gandolfo: And

66
00:03:41.400 --> 00:03:46.370
we're going to the function body,
l equals local and

67
00:03:46.370 --> 00:03:49.730
then William, Jimmy William.
&gt;&gt; Speaker 6: Yeah.

68
00:03:49.730 --> 00:03:50.305
&gt;&gt; Bianca Gandolfo: Okay.

69
00:03:50.305 --> 00:03:51.440
&gt;&gt; Speaker 6: [COUGH] Then,

70
00:03:51.440 --> 00:03:56.395
it will be on the next slide for
the g variable which set that.

71
00:03:56.395 --> 00:03:57.190
&gt;&gt; Bianca Gandolfo: Mm-hm, in here?

72
00:03:57.190 --> 00:04:01.340
And then, Andy.
&gt;&gt; Andy: And

73
00:04:01.340 --> 00:04:04.270
you're gonna alert g plus inside go.
&gt;&gt; Bianca Gandolfo: Mm-hm.

74
00:04:04.270 --> 00:04:08.850
And what's g?
&gt;&gt; Andy: G will be the local variable

75
00:04:08.850 --> 00:04:10.700
in the go function.
&gt;&gt; Bianca Gandolfo: Mm-hm.

76
00:04:10.700 --> 00:04:12.020
So, it would be in here, right?

77
00:04:12.020 --> 00:04:13.790
&gt;&gt; Andy: Yeah.
&gt;&gt; Bianca Gandolfo: Great.

78
00:04:15.050 --> 00:04:18.320
And then, Kevin?
&gt;&gt; Kevin: You're gonna alert g outside of

79
00:04:19.590 --> 00:04:20.780
go?
&gt;&gt; Bianca Gandolfo: Yep, and then we'll,

80
00:04:20.780 --> 00:04:22.940
so once this function's done running.

81
00:04:22.940 --> 00:04:25.580
It's going to return back to here.

82
00:04:25.580 --> 00:04:26.960
It's going to exit here and

83
00:04:26.960 --> 00:04:30.390
run the next line, which is going
to alert, what is it going to say?

84
00:04:30.390 --> 00:04:36.510
What is it going to say?
&gt;&gt; Kevin: Outside go.

85
00:04:36.510 --> 00:04:37.847
&gt;&gt; Bianca Gandolfo: With the G part.

86
00:04:37.847 --> 00:04:41.754
&gt;&gt; Kevin: In here.

87
00:04:41.754 --> 00:04:43.630
Or global
&gt;&gt; Bianca Gandolfo: Yeah.

88
00:04:44.730 --> 00:04:47.100
So, this is just an example of

89
00:04:48.620 --> 00:04:52.690
how the code is running to help
you understand that whatever,

90
00:04:52.690 --> 00:04:58.640
whatever variable in the most
local scope wins precedence.

91
00:04:58.640 --> 00:05:03.400
And that's the variable, that's the value
that's going to be printed out.

92
00:05:03.400 --> 00:05:10.920
So, since G here is the most local to that
scope G is going to overwrite any memory

93
00:05:12.090 --> 00:05:17.890
of any other variables if there
was any and it would alert here.

94
00:05:20.410 --> 00:05:23.935
And then, the most local to
this global right is gonna be

95
00:05:23.935 --> 00:05:27.939
the global G.
&gt;&gt; Bianca Gandolfo: Any questions

96
00:05:27.939 --> 00:05:28.530
about that?

97
00:05:30.600 --> 00:05:32.120
Joe?
&gt;&gt; Joe: Is that whole,

98
00:05:33.660 --> 00:05:35.810
does go come off the stack then,

99
00:05:35.810 --> 00:05:37.295
after the execution is done?

100
00:05:37.295 --> 00:05:45.694
&gt;&gt; Bianca Gandolfo: Yes.
&gt;&gt; Bianca Gandolfo: Cool.

101
00:05:45.694 --> 00:05:50.630
And so, back to block scope.

102
00:05:53.020 --> 00:05:54.010
Let's play the game again.

103
00:05:54.010 --> 00:05:55.770
Where did we leave off?

104
00:05:55.770 --> 00:05:58.340
We left off at Ben.

105
00:05:58.340 --> 00:05:59.500
What's the first line?

106
00:05:59.500 --> 00:06:02.820
What happens the first line?
&gt;&gt; Ben: Create the variable in block and

107
00:06:02.820 --> 00:06:05.890
set it to false.
&gt;&gt; Bianca Gandolfo: Mm-hm.

108
00:06:05.890 --> 00:06:11.300
And then, Jake
&gt;&gt; Jake: I'm sorry.

109
00:06:11.300 --> 00:06:12.530
He said which one?

110
00:06:12.530 --> 00:06:13.200
The top.
&gt;&gt; Bianca Gandolfo: Yeah.

111
00:06:13.200 --> 00:06:15.953
He said the top one.
&gt;&gt; Jake: Okay.

112
00:06:15.953 --> 00:06:22.289
We skip that and we go to the bottom,

113
00:06:22.289 --> 00:06:26.010
correct in black.
&gt;&gt; Bianca Gandolfo: We have

114
00:06:26.010 --> 00:06:26.710
this one still.

115
00:06:28.170 --> 00:06:30.190
So, this is a for loop,
this isn't a function.

116
00:06:32.540 --> 00:06:36.430
So, it's a little bit misleading
because it does have a block.

117
00:06:36.430 --> 00:06:41.690
So, a block is defined as any

118
00:06:41.690 --> 00:06:47.000
area surrounded by two parentheses,
I'm sorry, two curly brackets.

119
00:06:47.000 --> 00:06:48.370
That's not an object.

120
00:06:49.550 --> 00:06:53.740
So, whenever you see in JavaScript the
syntax where you have two curly brackets

121
00:06:53.740 --> 00:06:55.760
and it's not an object,
that's considered a block.

122
00:06:55.760 --> 00:07:01.010
In a lot of languages,
a block would define a scope, but

123
00:07:01.010 --> 00:07:06.969
in JavaScript only a function block
defines the area of private scope.

124
00:07:11.940 --> 00:07:18.543
So, this is the line here.
&gt;&gt; Bianca Gandolfo: Do

125
00:07:18.543 --> 00:07:25.129
you know what this line does?
&gt;&gt; Bianca Gandolfo: No?

126
00:07:25.129 --> 00:07:28.420
No worries, so it's going to loop, right?

127
00:07:28.420 --> 00:07:33.160
It's a for loop, and what this for
loop has says start at 0,

128
00:07:33.160 --> 00:07:37.890
keep adding 1 to i

129
00:07:39.450 --> 00:07:41.970
while i is less than 5.

130
00:07:41.970 --> 00:07:46.380
So, it's gonna run whenever it's
in this body that many times.

131
00:07:46.380 --> 00:07:49.930
So, it's going to set inBlock to true.

132
00:07:49.930 --> 00:07:50.760
Five times.

133
00:07:51.930 --> 00:07:56.820
Just to make sure that's true.

134
00:07:56.820 --> 00:08:00.020
And then, what's the next thing that run,
I'm sorry, Tanner's next.

135
00:08:01.070 --> 00:08:02.170
Okay.
&gt;&gt; Speaker 11: Next,

136
00:08:02.170 --> 00:08:07.130
we found if inblock and
the console log which it's going to

137
00:08:07.130 --> 00:08:11.160
pull up the false Even though, we said it
five times true because it's at a scope.

138
00:08:11.160 --> 00:08:12.000
&gt;&gt; Bianca Gandolfo: So, what is if and

139
00:08:12.000 --> 00:08:13.000
block going to do?

140
00:08:13.000 --> 00:08:17.623
Sorry, I skipped over that pretty quick.
&gt;&gt; Speaker 11: That's going to invoke

141
00:08:17.623 --> 00:08:23.411
the council.log and
it'll ask you their block scope,

142
00:08:23.411 --> 00:08:27.844
and then it'll add false because the other

143
00:08:27.844 --> 00:08:31.990
variable in block [INAUDIBLE]
&gt;&gt; Bianca Gandolfo: Absolutely, so

144
00:08:31.990 --> 00:08:36.820
this if is going to evaluate
whether end block is true or false.

145
00:08:36.820 --> 00:08:40.430
And if it's true, it's going to
enter into the if block here.

146
00:08:40.430 --> 00:08:43.880
And it's going to counsel that log,
is there block scope?

147
00:08:43.880 --> 00:08:47.270
And this is not, so
this is gonna return the opposite,

148
00:08:47.270 --> 00:08:52.490
since inBlock is true and this is not,
this is gonna evaluate to false.

149
00:08:52.490 --> 00:08:55.454
So, the question is, is there block scope,

150
00:08:55.454 --> 00:09:00.483
in JavaScript?
&gt;&gt; Bianca Gandolfo: Well, I don't know,

151
00:09:00.483 --> 00:09:06.349
let's ask, false.
&gt;&gt; Speaker 12: Would it ever get

152
00:09:06.349 --> 00:09:11.380
into that block though, since it's false?
&gt;&gt; Bianca Gandolfo: It's true though.

153
00:09:11.380 --> 00:09:13.160
We said it's true here.
&gt;&gt; Speaker 12: Really?

154
00:09:13.160 --> 00:09:13.920
&gt;&gt; Bianca Gandolfo: And since, we don't

155
00:09:13.920 --> 00:09:16.670
have any, so that's all the global scope,

156
00:09:16.670 --> 00:09:21.260
so it's all inBlock is
just going to be true.

157
00:09:22.790 --> 00:09:23.790
So, it's not private.

158
00:09:23.790 --> 00:09:26.270
So, if this was a function,
if this for loop was a function,

159
00:09:27.800 --> 00:09:32.930
then when we change inBlock to
true it wouldn't affect this

160
00:09:34.890 --> 00:09:38.260
inBlock up here but
since we don't have block scope and

161
00:09:38.260 --> 00:09:42.920
this is all operating on
the global scope that's

162
00:09:42.920 --> 00:09:47.870
why we can that's why this is true here.
&gt;&gt; Speaker 12: So, var inBlock = false,

163
00:09:47.870 --> 00:09:51.600
that's a global variable.
&gt;&gt; Bianca Gandolfo: Yep, they're all,

164
00:09:51.600 --> 00:09:54.510
everything on this-
&gt;&gt; Speaker 12: Because there's no child,

165
00:09:54.510 --> 00:09:55.960
there's no-
&gt;&gt; Bianca Gandolfo: There's no function.

166
00:09:55.960 --> 00:10:00.879
So, everything on this page is global.
&gt;&gt; Speaker 12: It's global, got it.

167
00:10:00.879 --> 00:10:02.274
&gt;&gt; Bianca Gandolfo: Mm-hm.

