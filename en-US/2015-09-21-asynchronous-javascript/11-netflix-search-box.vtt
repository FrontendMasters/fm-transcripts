WEBVTT

1
00:00:00.000 --> 00:00:04.103
[MUSIC]

2
00:00:04.103 --> 00:00:05.970
&gt;&gt; Jafar Husain: So
we already covered this point.

3
00:00:05.970 --> 00:00:10.610
switchLatest and takeUntil are why I
don't unsubscribe from Events ever.

4
00:00:10.610 --> 00:00:13.450
I never call or removeEventListener and
I haven't in five years.

5
00:00:13.450 --> 00:00:18.150
My code isn't littered with memory leaks
because I do takeUntil and switchLatest.

6
00:00:18.150 --> 00:00:19.889
It turns out,
that's pretty much all you need.

7
00:00:21.750 --> 00:00:23.970
So let's take a look at another example.

8
00:00:23.970 --> 00:00:25.490
This is where things
get particularly sexy.

9
00:00:25.490 --> 00:00:28.160
If we look at the Mouse Drags example,

10
00:00:28.160 --> 00:00:30.060
we're just composing together events,
right?

11
00:00:30.060 --> 00:00:34.275
But I already told you, UIs are made up
of usually three asynchronous actions.

12
00:00:34.275 --> 00:00:37.705
Events followed by an asynchronous
request, to a network for example,

13
00:00:37.705 --> 00:00:39.955
and then finally ending with an animation.

14
00:00:39.955 --> 00:00:41.745
So let's do something just
a little more interesting.

15
00:00:41.745 --> 00:00:45.765
And let's use Observable to combine
together events and asynchronous requests.

16
00:00:45.765 --> 00:00:47.591
So who's built an autocomplete box,

17
00:00:47.591 --> 00:00:50.925
sorry I've got a question back there.
&gt;&gt; Speaker 2: Can you filter ahead of time

18
00:00:50.925 --> 00:00:56.060
and ignore the empty observable?
&gt;&gt; Jafar Husain: Well, ahead of time

19
00:00:56.060 --> 00:01:01.820
implies that there is some sort of,
that you can look ahead.

20
00:01:01.820 --> 00:01:02.730
You can't.

21
00:01:02.730 --> 00:01:06.280
With an observable,
you can only get data when it arrives.

22
00:01:06.280 --> 00:01:08.910
You have no notion of what's
coming down the pipe.

23
00:01:08.910 --> 00:01:11.710
Much as when you subscribe
to a mouse move.

24
00:01:11.710 --> 00:01:13.570
You don't know when the next
mouse's gonna arrive,

25
00:01:13.570 --> 00:01:15.950
there is no look ahead with an observable.

26
00:01:15.950 --> 00:01:17.650
There's only the right now, right?

27
00:01:17.650 --> 00:01:19.340
I just threw a piece of cake at her.

28
00:01:19.340 --> 00:01:21.730
She can't look ahead and
see that I have no more cake left over or

29
00:01:21.730 --> 00:01:23.260
I have 15 more slices.

30
00:01:23.260 --> 00:01:24.850
There's no way of knowing that.

31
00:01:24.850 --> 00:01:25.800
So there is no look ahead.

32
00:01:25.800 --> 00:01:29.451
So basically, the switchLatest operator
has to get an observable, and then because

33
00:01:29.451 --> 00:01:32.898
it doesn't know that it's empty, and
it won't know at all until it for eaches,

34
00:01:32.898 --> 00:01:35.100
it doesn't try and
figure out that it was empty.

35
00:01:35.100 --> 00:01:39.773
What it does is, as soon as it gets a new
inner observable, it stopped listening to

36
00:01:39.773 --> 00:01:43.718
the current inner observable by
calling subscription.dispose.

37
00:01:43.718 --> 00:01:46.170
So you can't look ahead with
an observable, there's no foresight.

38
00:01:46.170 --> 00:01:49.210
Can't see into the future, right,
cuz it's a collection over time.

39
00:01:49.210 --> 00:01:50.930
Much the same way you
can't see in the future,

40
00:01:50.930 --> 00:01:52.780
you do not know what
an observable will give you.

41
00:01:55.150 --> 00:01:56.697
So who's written an autocomplete box

42
00:01:56.697 --> 00:02:01.168
before?
&gt;&gt; Jafar Husain: Anybody

43
00:02:01.168 --> 00:02:02.755
find it really easy?

44
00:02:02.755 --> 00:02:05.167
Was it hard?

45
00:02:05.167 --> 00:02:07.020
I mean write it from scratch,
not just use a component.

46
00:02:07.020 --> 00:02:07.824
&gt;&gt; [INAUDIBLE]

47
00:02:07.824 --> 00:02:08.912
&gt;&gt; Jafar Husain: [LAUGH] Somebody used

48
00:02:08.912 --> 00:02:11.490
a component, that's great.

49
00:02:11.490 --> 00:02:15.420
If you write it from scratch, it's one of
those problems that seems like it's gonna

50
00:02:15.420 --> 00:02:19.040
be really easy, and you're gonna go
home at 5 o'clock, and you don't.

51
00:02:19.040 --> 00:02:20.484
It's surprisingly hard.

52
00:02:20.484 --> 00:02:22.095
And it's everywhere on the web.

53
00:02:22.095 --> 00:02:24.123
Why would it be so
hard to write an autocomplete box,

54
00:02:24.123 --> 00:02:28.557
does anybody got an idea?
&gt;&gt; Jafar Husain: There's a reason why

55
00:02:28.557 --> 00:02:29.426
people make components so

56
00:02:29.426 --> 00:02:31.209
they don't have to keep solving this.
&gt;&gt; Speaker 3: Race,

57
00:02:31.209 --> 00:02:35.283
there's a race between the inputs.
&gt;&gt; Jafar Husain: There's a race condition.

58
00:02:35.283 --> 00:02:38.855
The race condition is, I type A,
I'm in a Netflix search and I type A and

59
00:02:38.855 --> 00:02:42.625
then we go off and we send a network
request for all the search results for A.

60
00:02:42.625 --> 00:02:45.571
And then I type B, and
then we send a network request for

61
00:02:45.571 --> 00:02:47.245
all the search results for AB.

62
00:02:47.245 --> 00:02:50.051
Is there any guarantee at all
that the request I sent for

63
00:02:50.051 --> 00:02:52.560
A will come back before
the request I sent for AB?

64
00:02:54.330 --> 00:02:57.840
No, networks, shit happens, right?

65
00:02:57.840 --> 00:03:00.220
So it can come back in
any particular order.

66
00:03:00.220 --> 00:03:05.034
So I might end up getting the request for
AB back before the request for

67
00:03:05.034 --> 00:03:08.700
A and then showing the old
data on top of the new data.

68
00:03:08.700 --> 00:03:10.550
Does that make sense?

69
00:03:10.550 --> 00:03:13.710
So how do we prevent that from happening?
&gt;&gt; Speaker 4: switchLatest.

70
00:03:13.710 --> 00:03:14.497
&gt;&gt; Jafar Husain: switchLatest,

71
00:03:14.497 --> 00:03:15.679
this guy's on the ball.

72
00:03:15.679 --> 00:03:17.717
Absolutely, right?

73
00:03:17.717 --> 00:03:21.108
We're gonna start to see that some
common UI patterns just fits into one

74
00:03:21.108 --> 00:03:22.870
of those three strategies, right?

75
00:03:23.920 --> 00:03:24.710
So how do we prevent it?

76
00:03:24.710 --> 00:03:29.008
What's another problem that we might run
into with a autocomplete box that we can

77
00:03:29.008 --> 00:03:33.582
only solve with a little asynchrony?
&gt;&gt; Jafar Husain: What

78
00:03:33.582 --> 00:03:36.406
happens if I type ABCDEFG?

79
00:03:36.406 --> 00:03:37.834
How many network requests do I wanna send

80
00:03:37.834 --> 00:03:43.223
off?
&gt;&gt; Jafar Husain: ABCDEFG.

81
00:03:43.223 --> 00:03:44.277
&gt;&gt; Speaker 5: If you Google,

82
00:03:44.277 --> 00:03:44.928
six.
&gt;&gt; Jafar Husain: [LAUGH]

83
00:03:44.928 --> 00:03:46.757
&gt;&gt; Speaker 5: I mean, Google Instant, or

84
00:03:46.757 --> 00:03:51.345
whatever, you get the updated
autocomplete coming for every letter.

85
00:03:51.345 --> 00:03:52.055
&gt;&gt; Jafar Husain: I think they probably

86
00:03:52.055 --> 00:03:53.600
have at least some debounce in there,
right?

87
00:03:53.600 --> 00:03:54.817
&gt;&gt; Speaker 5: There's some probably.

88
00:03:54.817 --> 00:03:55.378
&gt;&gt; Jafar Husain: They will have

89
00:03:55.378 --> 00:03:56.060
some debounce.

90
00:03:56.060 --> 00:03:59.620
But the point here is that you probably
don't, cuz most of us aren't Google,

91
00:03:59.620 --> 00:04:01.395
you probably don't want to
send off a network request for

92
00:04:01.395 --> 00:04:02.885
every single key somebody types.

93
00:04:02.885 --> 00:04:06.003
You wanna chill, right,
just like wait a little second,

94
00:04:06.003 --> 00:04:08.559
a few milliseconds after
somebody types a key.

95
00:04:08.559 --> 00:04:09.893
And then if they type no other key,

96
00:04:09.893 --> 00:04:13.083
then you wanna take whatever's in the text
box and send it off as a search request.

97
00:04:13.083 --> 00:04:14.147
Does that make sense?

98
00:04:14.147 --> 00:04:18.287
So this is sometimes called debouncing.

99
00:04:18.287 --> 00:04:20.985
Here is what an autocomplete
box looks like at Netflix.

100
00:04:22.510 --> 00:04:25.460
So as we begin solving these problems,

101
00:04:25.460 --> 00:04:29.250
we are gonna start describing
them in four steps.

102
00:04:30.630 --> 00:04:32.010
What collections do I have?

103
00:04:33.340 --> 00:04:35.678
What collection do I want?

104
00:04:35.678 --> 00:04:39.200
How do I get from the collections I
have to the collection that I want?

105
00:04:39.200 --> 00:04:41.630
And then,
once I've got the collection that I want,

106
00:04:41.630 --> 00:04:45.030
what am I gonna do with
the data that comes out of it?

107
00:04:45.030 --> 00:04:47.449
So what collections do we have when
we're building an autocomplete box?

108
00:04:47.449 --> 00:04:50.665
What are the input, when I say
collections I mean observables, right.

109
00:04:50.665 --> 00:04:51.925
Observables are collections.

110
00:04:51.925 --> 00:04:55.915
What are the collections of events that we
have that are interesting to help us build

111
00:04:55.915 --> 00:04:57.898
an autocomplete box?
&gt;&gt; Speaker 6: Key press?

112
00:04:57.898 --> 00:04:58.600
&gt;&gt; Jafar Husain: Key presses, right?

113
00:04:58.600 --> 00:05:00.249
That's one interesting collection.

114
00:05:00.249 --> 00:05:03.860
Another one is the one created
when we make a network request.

115
00:05:03.860 --> 00:05:06.350
When we call this getJSON
function that you see up here,

116
00:05:06.350 --> 00:05:09.010
what we're really doing is
we're creating an observable

117
00:05:09.010 --> 00:05:13.860
that will eventually onNext us the one
value of the result from the server.

118
00:05:13.860 --> 00:05:16.020
And so, if you were to visualize
what that observable looked like,

119
00:05:16.020 --> 00:05:18.664
it would look like .......results.

120
00:05:18.664 --> 00:05:20.670
In this case,
it happens to be inside of an array.

121
00:05:20.670 --> 00:05:23.830
Don't get confused the fact that an
observable happens to give you an array.

122
00:05:23.830 --> 00:05:25.620
It's no different than it gives you one or
two or three.

123
00:05:25.620 --> 00:05:27.990
Don't get confused about the fact
that we're handing off an array and

124
00:05:27.990 --> 00:05:29.680
that happens to be a collection.

125
00:05:29.680 --> 00:05:32.433
It's an observable of a value, and
that value happens to be an array.

126
00:05:32.433 --> 00:05:35.970
So the way this works is,
well, actually technically,

127
00:05:35.970 --> 00:05:39.653
getJSON will return you a string I think,
and well, yeah,

128
00:05:39.653 --> 00:05:44.538
a string in this particular case or a JSON
object whatever that JSON object is.

129
00:05:44.538 --> 00:05:47.111
All right, so
getJSON returns an observable and

130
00:05:47.111 --> 00:05:50.888
it's the result of whatever we get
back from the server parsed as JSON.

131
00:05:50.888 --> 00:05:53.155
Does that make sense?

132
00:05:53.155 --> 00:05:55.288
At that URL.

133
00:05:55.288 --> 00:05:58.652
So it's an observable
with one value in it.

134
00:05:58.652 --> 00:05:59.867
Does that seem weird to anybody?

135
00:05:59.867 --> 00:06:01.985
That I create an observable
with just one value in it?

136
00:06:05.177 --> 00:06:07.229
&gt;&gt; Jafar Husain: Nobody?

137
00:06:07.229 --> 00:06:08.785
Collections have one value, right?

138
00:06:08.785 --> 00:06:11.328
You can create an array with one value,
nothing weird about that.

139
00:06:11.328 --> 00:06:12.893
You can have an observable with one value.

140
00:06:12.893 --> 00:06:16.133
And so, again, if you were to use,
visualizing that syntax we made up for

141
00:06:16.133 --> 00:06:19.612
what that getJSON observable, just
the getJSON observable would look like.

142
00:06:19.612 --> 00:06:23.940
It would look like ......JSON object and
then onComplete it.

143
00:06:23.940 --> 00:06:27.620
So it'll onNext you and
then immediately onComplete.

144
00:06:27.620 --> 00:06:29.270
Cuz it's only got the one value.

145
00:06:29.270 --> 00:06:30.620
So, what are we doing here?

146
00:06:30.620 --> 00:06:33.770
We're taking the key presses and then
we're using this handy throttle method.

147
00:06:33.770 --> 00:06:35.230
And the throttle method is very simple.

148
00:06:35.230 --> 00:06:39.807
It takes an observable that looks

149
00:06:39.807 --> 00:06:44.387
like ABC DEF and turns it into CF.

150
00:06:44.387 --> 00:06:49.249
It takes any items that come very, very
close together and it just drops them and

151
00:06:49.249 --> 00:06:50.710
gets the last one.

152
00:06:50.710 --> 00:06:53.540
So the idea here is,
if you get an item in the observable,

153
00:06:53.540 --> 00:06:56.800
right, instead of immediately returning
that observable, the throttle

154
00:06:56.800 --> 00:07:00.340
operator will wait a couple milliseconds
and see if another item arrives.

155
00:07:00.340 --> 00:07:03.188
And if another item arrives,
it just drops the other item.

156
00:07:03.188 --> 00:07:06.000
And then it takes the new item,
waits a couple of milliseconds.

157
00:07:06.000 --> 00:07:09.470
And if a couple of milliseconds go by,
in this case 250 of them, and

158
00:07:09.470 --> 00:07:12.300
no other items have arrived,
then only then does it take that and

159
00:07:12.300 --> 00:07:14.880
forward it along to whoever's listening.

160
00:07:14.880 --> 00:07:20.870
So that's why it turns ABC DEF into CF.

161
00:07:20.870 --> 00:07:21.737
Does that make sense?

162
00:07:21.737 --> 00:07:26.517
So now we've solved the problem of issuing
seven network requests when somebody

163
00:07:26.517 --> 00:07:28.910
types ABCDEF, right?

164
00:07:28.910 --> 00:07:30.230
So that's how we solve that problem.

165
00:07:30.230 --> 00:07:32.750
Now we just have a less chatty stream.

166
00:07:32.750 --> 00:07:35.360
So we're gonna take each
one of those key objects,

167
00:07:35.360 --> 00:07:36.770
we don't care about those key events.

168
00:07:36.770 --> 00:07:39.260
We're just gonna map and
map is all about substitution.

169
00:07:39.260 --> 00:07:42.220
It's all about replacing something
in the stream with something else.

170
00:07:42.220 --> 00:07:47.530
And we are gonna map it and return the
observable we get from calling getJSON.

171
00:07:47.530 --> 00:07:50.118
So we're gonna take this flat
stream of key presses and

172
00:07:50.118 --> 00:07:52.319
turn it into a two-dimensional observable.

173
00:07:52.319 --> 00:07:56.199
Because each one of those key events is
gonna get replaced with an observable that

174
00:07:56.199 --> 00:07:58.496
represents the network
request to the server.

175
00:07:58.496 --> 00:08:01.297
Now remember, it's an observable
of one but it's still observable.

176
00:08:01.297 --> 00:08:04.085
So now we have an observable
of observables.

177
00:08:04.085 --> 00:08:07.109
Because for every key press,
we're creating an observable and

178
00:08:07.109 --> 00:08:10.040
substituting it in that
represents the network request.

179
00:08:10.040 --> 00:08:10.865
For every key press,

180
00:08:10.865 --> 00:08:14.470
we're substituting in an observable
that represents the network request.

181
00:08:14.470 --> 00:08:18.845
So now that we've got a two-dimensional
observable, we've gotta flatten it.

182
00:08:18.845 --> 00:08:22.540
And we've gotta flatten it so that we
solve the race condition problem, right?

183
00:08:22.540 --> 00:08:24.033
So here's how we can do that.

184
00:08:24.033 --> 00:08:26.862
I'm gonna talk about the retry
operator in just a moment,

185
00:08:26.862 --> 00:08:29.380
but notice what we're
doing here with takeUntil.

186
00:08:29.380 --> 00:08:32.175
I've got a network request and
it's out for A, right?

187
00:08:32.175 --> 00:08:33.932
I've created my network request for A.

188
00:08:33.932 --> 00:08:37.730
And then I create B, and I create another
network request and it's going out for AB.

189
00:08:37.730 --> 00:08:38.624
Does that make sense?
I type B,

190
00:08:38.624 --> 00:08:40.712
now I've got a network
request going out for AB.

191
00:08:40.712 --> 00:08:45.877
Notice that because I apply takeUntil with
(keyPresses) to each network request,

192
00:08:45.877 --> 00:08:50.140
as soon as I type B, that outgoing
network request for A completes.

193
00:08:50.140 --> 00:08:56.620
It fires on completed and
it just stops and it becomes empty, right?

194
00:08:56.620 --> 00:09:00.368
So I've triggered a network request for
A and then I click B and that network

195
00:09:00.368 --> 00:09:04.750
request for A is immediately gonna
complete because now I've pressed a key.

196
00:09:04.750 --> 00:09:08.569
So it's gonna look like ...., and
in just a few more milliseconds

197
00:09:08.569 --> 00:09:12.858
it would've actually gotten us a result,
but instead, [SOUND] it completes.

198
00:09:12.858 --> 00:09:16.508
And then,
we apply concatAll to the stream.

199
00:09:16.508 --> 00:09:19.813
And what happens to that
observable that we completed,

200
00:09:19.813 --> 00:09:24.514
with nothing inside of it?
&gt;&gt; Speaker 7: It's gone.

201
00:09:24.514 --> 00:09:27.198
&gt;&gt; Jafar Husain: [SOUND] Right?

202
00:09:27.198 --> 00:09:28.980
We didn't cancel the network request.

203
00:09:28.980 --> 00:09:32.624
I didn't write abort or
removeEventListener or any of that stuff.

204
00:09:32.624 --> 00:09:35.130
I declaratively described the conditions

205
00:09:35.130 --> 00:09:38.330
under which that network
request was to end.

206
00:09:38.330 --> 00:09:40.941
And it was to end, regardless of
whether we got the data or not,

207
00:09:40.941 --> 00:09:45.929
as soon as the next key press happened.
&gt;&gt; Jafar Husain: Very different

208
00:09:45.929 --> 00:09:49.840
way of thinking about asynchronous
programming, all right?

209
00:09:49.840 --> 00:09:54.090
I'm not canceling things, I'm not changing
things, I'm describing declaratively

210
00:09:54.090 --> 00:09:57.110
the conditions under which
I want streams to end.

211
00:09:57.110 --> 00:10:00.311
And so that network request return for
A has now completed.

212
00:10:00.311 --> 00:10:02.577
And now we've got an open
network request for AB.

213
00:10:02.577 --> 00:10:05.201
And eventually when that finishes, right,

214
00:10:05.201 --> 00:10:08.550
concatAll is going to return
the network request for AB.

215
00:10:08.550 --> 00:10:10.440
Because the previous
observable is completed so

216
00:10:10.440 --> 00:10:12.350
it's now on to the second observable.

217
00:10:12.350 --> 00:10:15.395
And we get out the search results for AB.

218
00:10:15.395 --> 00:10:17.349
And that outer observable,
is it ever gonna complete?

219
00:10:17.349 --> 00:10:20.890
Is the searchResultSets observable that
we've created ever gonna complete?

220
00:10:22.600 --> 00:10:23.340
Anybody tell me.

221
00:10:23.340 --> 00:10:23.850
Is it gonna end?

222
00:10:25.950 --> 00:10:28.000
Well, first of all what
is searchResultSets?

223
00:10:28.000 --> 00:10:31.330
It's the stream of all of
the search results for

224
00:10:31.330 --> 00:10:33.460
every search that you
enter into the text box.

225
00:10:34.460 --> 00:10:35.620
That's really what we've done.

226
00:10:35.620 --> 00:10:39.440
We've taken the streams that we had,
which is key presses,

227
00:10:39.440 --> 00:10:43.280
and a function which creates more streams
which is the network request, and

228
00:10:43.280 --> 00:10:46.330
we've combined them together into
one stream, the stream that we want.

229
00:10:46.330 --> 00:10:49.540
Which is the stream of all of the search
results that arrive from the server.

230
00:10:50.690 --> 00:10:53.420
And then at the very bottom,
we for eached over them and

231
00:10:53.420 --> 00:10:56.170
for every search result set that
we get back, which is basically,

232
00:10:56.170 --> 00:10:59.970
it could be an array of search results,
we're just gonna put it on screen.

233
00:10:59.970 --> 00:11:01.950
That's what we're going to do with it.

234
00:11:01.950 --> 00:11:03.520
So let's go over the four steps.

235
00:11:03.520 --> 00:11:04.900
Yeah, question?
&gt;&gt; Speaker 2: Question was,

236
00:11:04.900 --> 00:11:10.020
would we ever want to concatenate
the throttled presses together to pass to

237
00:11:10.020 --> 00:11:15.110
getJSON instead of looking at input.value?
&gt;&gt; Jafar Husain: Yes, we could.

238
00:11:15.110 --> 00:11:17.970
So I'm making stuff easy on myself here.

239
00:11:17.970 --> 00:11:21.580
Now, because at any point I can just
look up the value property of the text

240
00:11:21.580 --> 00:11:23.510
box, that's easy.

241
00:11:23.510 --> 00:11:26.440
But imagine you didn't have access
to the value of the text box.

242
00:11:26.440 --> 00:11:29.071
Imagine all you got was key press signals.

243
00:11:29.071 --> 00:11:32.115
Well, then you'd have to figure out some
way of concatenating them together and

244
00:11:32.115 --> 00:11:33.921
basically doing the job
that the text box does.

245
00:11:33.921 --> 00:11:38.415
Which is like I'm gonna aggregate up what
the current string is in that text box.

246
00:11:38.415 --> 00:11:41.080
And when I get a back press key,
I'm gonna have to remove one.

247
00:11:41.080 --> 00:11:43.122
There is actually a way of doing that.

248
00:11:43.122 --> 00:11:45.670
It's called a scan operator,
which allows you to do exactly that.

249
00:11:45.670 --> 00:11:50.260
To take an observable that's infinite and
aggregate up values over time and

250
00:11:50.260 --> 00:11:51.330
then change them.

251
00:11:51.330 --> 00:11:52.520
We'll get to that later on.

252
00:11:53.550 --> 00:11:55.920
But I mean,
you can get the value of a text box.

253
00:11:55.920 --> 00:11:57.660
So let's not bother,
that's much more complicated.

254
00:11:57.660 --> 00:11:58.534
So let's just do it this way.

255
00:11:58.534 --> 00:11:59.754
But that's a totally valid question.

256
00:11:59.754 --> 00:12:02.150
Yes.
&gt;&gt; Speaker 8: What does retry(3) mean?

257
00:12:02.150 --> 00:12:03.140
&gt;&gt; Jafar Husain: Can I come back to that?

258
00:12:03.140 --> 00:12:06.050
I wanna get the overall structure
first before we come back that.

259
00:12:06.050 --> 00:12:07.890
That is important, but
I wanna come back to it.

260
00:12:07.890 --> 00:12:10.560
I really wanna make sure we go through,
think about things in these four stages

261
00:12:10.560 --> 00:12:13.320
cuz it's gonna be really important for
you when you do your exercises.

262
00:12:13.320 --> 00:12:15.860
What are the streams that I have or
functions that give me streams?

263
00:12:15.860 --> 00:12:17.210
What do I have?

264
00:12:17.210 --> 00:12:18.144
What do I wanna create?

265
00:12:18.144 --> 00:12:19.450
Well, I wanna take the key presses and

266
00:12:19.450 --> 00:12:22.660
I wanna take my ability to issue network
requests and get them as observables.

267
00:12:22.660 --> 00:12:25.213
And I wanna create just a stream of
all the search results that come back

268
00:12:25.213 --> 00:12:25.868
from the server.

269
00:12:25.868 --> 00:12:28.460
Cuz all I'm gonna do with this is I'm
just gonna display them on screen.

270
00:12:28.460 --> 00:12:31.590
I just wish that, think about
this as a process of inspiration.

271
00:12:31.590 --> 00:12:34.970
Wouldn't it be great if I had an event
that just fired every single time

272
00:12:34.970 --> 00:12:36.430
I had search results from the server?

273
00:12:36.430 --> 00:12:37.790
That would be super convenient, right?

274
00:12:37.790 --> 00:12:39.060
Then I could just subscribe to that,

275
00:12:39.060 --> 00:12:41.300
and whenever one came out
I could slap it on screen.

276
00:12:42.350 --> 00:12:44.390
Well, we don't have that but
we can create it.

277
00:12:44.390 --> 00:12:46.510
So first,
it's almost like starting backwards.

278
00:12:46.510 --> 00:12:50.047
Imagine what event you want and
then take a look at the events you have.

279
00:12:50.047 --> 00:12:52.905
And then the hard part is figuring out
how to take the events you have and

280
00:12:52.905 --> 00:12:55.865
combine them together using these
functions, map, reduce, filter,

281
00:12:55.865 --> 00:12:59.580
merge, zip, that I'm gonna be teaching
you, into the event that you want.

282
00:12:59.580 --> 00:13:01.020
And then once you've got
the event that you want,

283
00:13:01.020 --> 00:13:02.640
the stream of data that you want,

284
00:13:02.640 --> 00:13:06.410
all that's left to do is to forEach
over it and do something with the data.

285
00:13:06.410 --> 00:13:09.160
So we're seeing all three stages here
in the sense that we've got keyPresses,

286
00:13:09.160 --> 00:13:11.680
we've got getJSON,
those are the streams and

287
00:13:11.680 --> 00:13:15.220
functions that will give us streams that
we have, that are very easy, we have them.

288
00:13:15.220 --> 00:13:19.485
Then we're using all of the map and
retry and concatAll functions and

289
00:13:19.485 --> 00:13:23.320
takeUntil to combine all the these streams
together into the stream that we want.

290
00:13:23.320 --> 00:13:25.630
Which is the stream of searchResultSets.

291
00:13:25.630 --> 00:13:29.110
And then at the end we're using forEach to
consume the data and put it on the screen.

292
00:13:30.540 --> 00:13:31.110
Does that make sense?

