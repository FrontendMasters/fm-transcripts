WEBVTT

1
00:00:00.180 --> 00:00:04.314
Let's say I wanna have branching
logic inside of my program here.

2
00:00:04.314 --> 00:00:06.823
So I have this Boolean, skyIsBlue, which,

3
00:00:06.823 --> 00:00:11.058
depending on the day in Seattle is not
always true, it's frequently gray.

4
00:00:11.058 --> 00:00:15.957
Sometimes, there was one time it was red,
when there was forest fires in California,

5
00:00:15.957 --> 00:00:17.982
so that would have made this false.

6
00:00:17.982 --> 00:00:19.857
Anyway, so I can ask an if statement.

7
00:00:19.857 --> 00:00:23.493
An if statement just is saying,
if this is true,

8
00:00:23.493 --> 00:00:27.412
do a thing, if this is false,
do a different thing.

9
00:00:27.412 --> 00:00:32.636
So I'm asking, inside of the parentheses
here, is this true or false?

10
00:00:32.636 --> 00:00:39.384
Obviously I set this to be true up here,
so this is always gonna evaluate as true.

11
00:00:39.384 --> 00:00:43.142
But you can also give it an else statement
to say, else the sky is not blue.

12
00:00:43.142 --> 00:00:49.632
So for example, if it was gray in
Seattle today I could say false here,

13
00:00:49.632 --> 00:00:56.494
and then it would say the sky is not blue,
or true, the sky is blue.

14
00:00:56.494 --> 00:00:57.896
And that is how you do if statements.

15
00:00:57.896 --> 00:01:02.810
Everything between these curly
braces here, Will be evaluated, so

16
00:01:02.810 --> 00:01:04.978
I could also have another
console.log here.

17
00:01:09.430 --> 00:01:15.992
Right, and it's gonna evaluate everything
here and nothing in here, which is great.

18
00:01:15.992 --> 00:01:20.045
This allows me to set good branching
logic of doing something one time and

19
00:01:20.045 --> 00:01:21.714
not doing it different time.

20
00:01:21.714 --> 00:01:25.502
And I can also have anything here,
I can have 2 + 2 === 4, right?

21
00:01:27.996 --> 00:01:31.404
So anything that can be
evaluated to true or

22
00:01:31.404 --> 00:01:34.914
false can be evaluated here between these.

23
00:01:34.914 --> 00:01:38.735
And then this is an arbitrary long block.

24
00:01:38.735 --> 00:01:46.596
Something between these curly braces would
be called a block, it's a block of code.

25
00:01:46.596 --> 00:01:50.964
So the first block would be evaluated,
the second one would not.

26
00:01:50.964 --> 00:01:52.408
Okay, questions about that?

27
00:01:58.303 --> 00:02:03.320
It's nice cuz it kind of reads like
you would expect it to, right?

28
00:02:03.320 --> 00:02:08.417
If this is true,
then do this, else, do this.

29
00:02:15.183 --> 00:02:18.085
So I actually do the exact
same thing down here,

30
00:02:18.085 --> 00:02:21.508
you can see I'm very creative
with my thought process.

31
00:02:21.508 --> 00:02:26.067
So some of you might be looking at that
triple equals and being, what is that?

32
00:02:26.067 --> 00:02:29.149
It's actually just my font
shoving them together.

33
00:02:29.149 --> 00:02:35.011
It's actually three equal signs put
together, but my font puts them together.

34
00:02:35.011 --> 00:02:42.560
So that's a double equal right there,
and that's a triple equals there.

35
00:02:42.560 --> 00:02:45.933
So you might ask me, Brian,
why are you using three equal signs?

36
00:02:45.933 --> 00:02:50.362
Why can't I just do that,
right, one equal signs?

37
00:02:50.362 --> 00:02:53.877
Well, if you remember, up here,

38
00:02:53.877 --> 00:02:58.587
what is one equal sign do in JavaScript?

39
00:02:58.587 --> 00:03:02.437
I want you to replace one equal sign
in your brain with is assigned, right?

40
00:03:02.437 --> 00:03:04.318
So skyIsBlue is assigned true.

41
00:03:04.318 --> 00:03:07.517
So if I'm doing this, 2 + 2 is assigned 4,

42
00:03:07.517 --> 00:03:11.958
that doesn't make any sense,
I have to ask a question, right?

43
00:03:11.958 --> 00:03:16.578
I have to say is this true or
false, because this if statement,

44
00:03:16.578 --> 00:03:21.738
this block here, it has to end up
somehow being true or false, right?

45
00:03:21.738 --> 00:03:25.253
So I can either put double equals,
which technically would work here.

46
00:03:25.253 --> 00:03:29.173
But I'm gonna say just go ahead and
do a triple equals, and

47
00:03:29.173 --> 00:03:33.108
there's no such thing as a four equals,
so that's fine.

48
00:03:33.108 --> 00:03:37.887
I'll explain to you why that's important
just momentarily, just bear with me for

49
00:03:37.887 --> 00:03:38.509
a second.

50
00:03:38.509 --> 00:03:41.979
So 2 + 2 === 4,
this is asking the question,

51
00:03:41.979 --> 00:03:45.146
is this side of this equal
to this side of this?

52
00:03:48.488 --> 00:03:53.769
So up here I could ask,
is skyIsBlue === true?

53
00:03:53.769 --> 00:03:54.780
It is.

54
00:03:58.470 --> 00:04:01.531
Right, or is it equal to false?

55
00:04:01.531 --> 00:04:05.388
It's not equal to false, so
this can be a little confusing, but

56
00:04:05.388 --> 00:04:07.899
skyIsBlue is not equal to false, right?

57
00:04:07.899 --> 00:04:10.351
So therefore, it's going to do this.

58
00:04:14.185 --> 00:04:17.056
So that triple equals sign
just asked the question,

59
00:04:17.056 --> 00:04:20.590
is the left side of this and
the right side of this the same thing?

60
00:04:25.995 --> 00:04:29.879
Now, let's talk just a moment about
double equals versus triple equals,

61
00:04:29.879 --> 00:04:30.815
do I have it done?

62
00:04:30.815 --> 00:04:31.315
I do.

63
00:04:34.148 --> 00:04:38.641
So single equals is assigned, And

64
00:04:38.641 --> 00:04:43.209
this triple equals asks the thing,

65
00:04:43.209 --> 00:04:49.765
is this both the same thing
as well as the same type?

66
00:04:49.765 --> 00:04:53.013
So let's make this a string.

67
00:04:53.013 --> 00:04:56.970
So by putting the quotes around this,
I've now made this a string, right?

68
00:04:56.970 --> 00:05:00.458
Just like this could be any
arbitrary amount of things, but

69
00:05:00.458 --> 00:05:03.055
let's make it an actual
just a string of 4.

70
00:05:03.055 --> 00:05:06.175
If this is double equals,
it's gonna be true,

71
00:05:06.175 --> 00:05:10.466
because it's the same thing even
though it's not the same type.

72
00:05:10.466 --> 00:05:16.097
So this ends up being 4,
this is a string 4, right?

73
00:05:16.097 --> 00:05:20.211
So those end up being true, and
double equals will say, hey,

74
00:05:20.211 --> 00:05:23.139
as long as these end up
being the same thing,

75
00:05:23.139 --> 00:05:27.755
even if they're different data types,
by all means, return true.

76
00:05:27.755 --> 00:05:33.556
By putting triple equals here, That it's
gonna say, this is not the same data type,

77
00:05:33.556 --> 00:05:38.091
these are not both numbers, therefore,
I'm not going to accept this.

78
00:05:38.091 --> 00:05:41.606
I'm gonna say, always use triple equals,

79
00:05:41.606 --> 00:05:45.603
unless you really intend
on using double equals.

80
00:05:45.603 --> 00:05:51.449
You'll fall into some weird traps by using
double equals, it's called type coercion.

81
00:05:51.449 --> 00:05:53.484
You'd never have to care about
that term that I just said,

82
00:05:53.484 --> 00:05:55.243
you can just literally
throw it out of your brain.

83
00:05:55.243 --> 00:05:59.401
And I don't really wanna get too
much into it because it's weird,

84
00:05:59.401 --> 00:06:04.318
there's a lot of things that you wouldn't
expect to work the way that it does.

85
00:06:07.788 --> 00:06:11.745
I'll just give you an example here,
is false == 0?

86
00:06:11.745 --> 00:06:16.296
Yes, would you expect that?

87
00:06:16.296 --> 00:06:18.170
Maybe, is false === 0?

88
00:06:18.170 --> 00:06:21.654
No, that's my point, there's weird things.

89
00:06:21.654 --> 00:06:28.003
By putting triple equals here,
you're making things very explicit, right?

90
00:06:28.003 --> 00:06:30.663
This is what I'm telling that you're
writing code for your future self here.

91
00:06:30.663 --> 00:06:35.792
You're being very explicit that I expect
this to be false, or expect this to be 0.

92
00:06:35.792 --> 00:06:38.660
Okay, I think that's enough on that.

93
00:06:38.660 --> 00:06:43.931
There's a bunch of JavaScript
kind of fundamental courses from

94
00:06:43.931 --> 00:06:50.386
Kyle Simpson on Frontend Masters, and
he really digs into this kind of stuff.

95
00:06:50.386 --> 00:06:53.549
So definitely check that
out if you're interested.

96
00:06:53.549 --> 00:06:55.679
Let's talk about else ifs.

97
00:06:55.679 --> 00:07:00.188
So you have friends at your party,
and let's say ten friends show up, and

98
00:07:00.188 --> 00:07:04.715
then we can do branching logic on what
to do with how many friends you have.

99
00:07:04.715 --> 00:07:09.695
So if you have 0 friends at your party,
then you get a lot of nachos to yourself.

100
00:07:09.695 --> 00:07:15.895
It's definitely not a bad thing, I could
definitely go for some nachos right now.

101
00:07:15.895 --> 00:07:18.438
If friends is less than or equal to 4,

102
00:07:18.438 --> 00:07:21.783
it's the perfect amount
to play some Mario Kart.

103
00:07:21.783 --> 00:07:23.889
And if you have more than that,

104
00:07:23.889 --> 00:07:27.945
then you probably should turn
on some dance music, right?

105
00:07:31.587 --> 00:07:35.277
So let's talk about this glyph for
a second,

106
00:07:35.277 --> 00:07:39.462
this is an angle bracket,
so this is the less than.

107
00:07:39.462 --> 00:07:44.570
Yeah, I always gotta think
of how you verbalize these.

108
00:07:44.570 --> 00:07:47.510
Again, my font, if you put a less than and

109
00:07:47.510 --> 00:07:52.653
then another equal sign next to it,
it puts that into one glyph, right?

110
00:07:52.653 --> 00:07:54.971
So if less than or
equal to 4, then play this.

111
00:07:54.971 --> 00:07:58.970
But what I'm trying to demonstrate to
you here is you can have multiple sets

112
00:07:58.970 --> 00:08:00.569
of branching logic, right?

113
00:08:00.569 --> 00:08:04.921
You can have, if it's 0,
do this, if it's less than or

114
00:08:04.921 --> 00:08:08.746
equal to 4, then do this,
otherwise, do this.

115
00:08:10.114 --> 00:08:14.214
So it's gonna ask multiple questions
before you end up wherever you are.

116
00:08:14.214 --> 00:08:17.052
You also don't even have to
have this else here, right?

117
00:08:17.052 --> 00:08:21.111
So if I just delete that,
what's it gonna do?

118
00:08:24.261 --> 00:08:25.448
Nothing, right?

119
00:08:25.448 --> 00:08:29.853
10 is not equal to 0, and
it's not less than or

120
00:08:29.853 --> 00:08:34.911
equal to 4, so
it just skips everything here, right?

121
00:08:34.911 --> 00:08:39.309
There's no else block,
the else block just basically says,

122
00:08:39.309 --> 00:08:42.196
if nothing else is true, then run this.

123
00:08:45.531 --> 00:08:48.522
And you can mess around this, like if I
put 3 here, what do I expect to happen?

124
00:08:52.412 --> 00:08:56.149
All right, if I put 0 here,
what do I expect to happen?

125
00:08:58.718 --> 00:09:02.363
If I put -1, what do I expect to happen?

126
00:09:05.578 --> 00:09:08.448
Is that what you expected to happen?

127
00:09:08.448 --> 00:09:09.843
Is -1 less than or equal to 4?

128
00:09:13.000 --> 00:09:15.586
It is, so if you have -1
person attend your party, so

129
00:09:15.586 --> 00:09:19.383
I guess if you leave your party, that's
the perfect amount to play Mario Kart.

130
00:09:19.383 --> 00:09:23.253
I'm doing this just to show you how
bugs creep up in your code, right?

131
00:09:23.253 --> 00:09:25.546
What happens if you get unexpected input?

132
00:09:25.546 --> 00:09:28.810
Weird things start happening, and
that's how you get bugs in your code.

133
00:09:28.810 --> 00:09:32.998
That's why that joke to me is always so
funny, like it's a QA person walks into

134
00:09:32.998 --> 00:09:37.514
a bar, orders a beer, orders ten beers,
orders green beer, orders a cat, right?

135
00:09:37.514 --> 00:09:39.582
And they just start trying
to do everything to try and

136
00:09:39.582 --> 00:09:42.877
cause bugs in your code, that's exactly
demonstrating what's happening here.

