WEBVTT

1
00:00:00.189 --> 00:00:03.774
Let's talk about builtins.

2
00:00:03.774 --> 00:00:07.682
Builtins are just functions that
someone's already made for you.

3
00:00:07.682 --> 00:00:10.649
They're built into the browser,
that's why they're called builtins.

4
00:00:12.191 --> 00:00:15.298
So a really good example of that,
we have this sentence,

5
00:00:15.298 --> 00:00:18.949
which has the infamous SpongeBob casing,
which I did not invent.

6
00:00:18.949 --> 00:00:23.000
This is actually called SpongeBob casing,

7
00:00:23.000 --> 00:00:26.725
where it's alternating caps, right?

8
00:00:26.725 --> 00:00:32.700
There's a function built into strings,
right, that says, called toLowerCase.

9
00:00:32.700 --> 00:00:40.093
It'll take this SpongeBob casing and
it will make it have lowercase, right?

10
00:00:40.093 --> 00:00:47.168
You probably expect that there's also one
called toUpperCase, also works as well.

11
00:00:47.168 --> 00:00:49.784
This function is built into all strings.

12
00:00:52.230 --> 00:00:58.716
To the point, we can actually just
move this directly onto this.

13
00:00:58.716 --> 00:01:01.390
I know this looks a little weird,
but this does work, right?

14
00:01:09.593 --> 00:01:11.339
But that's what this period means,

15
00:01:11.339 --> 00:01:14.392
is it means you're calling
a function onto something, right?

16
00:01:18.378 --> 00:01:22.794
So I have sentence, and I know sentence
has a function built into it that I can

17
00:01:22.794 --> 00:01:26.037
call called toLowerCase,
that's what the dot means.

18
00:01:26.037 --> 00:01:29.165
It's like I'm reaching into
the sentence to call this function.

19
00:01:32.894 --> 00:01:38.117
You'll frequently hear this
referred to as a method.

20
00:01:38.117 --> 00:01:41.517
For all intensive purposes,
you can kind of just make function and

21
00:01:41.517 --> 00:01:43.284
method the same word in your head.

22
00:01:43.284 --> 00:01:44.573
There's a difference there.

23
00:01:44.573 --> 00:01:47.096
A method is built into something,

24
00:01:47.096 --> 00:01:50.927
a function is any function
that you can run, right?

25
00:01:50.927 --> 00:01:54.675
I just say that because I use
both terms very frequently and

26
00:01:54.675 --> 00:01:56.521
I don't wanna confuse you.

27
00:01:56.521 --> 00:01:59.429
If I say method, I just mean
a function that's built onto something.

28
00:02:03.492 --> 00:02:10.786
Okay, so Brian, how do I know what
functions are built into things, right?

29
00:02:10.786 --> 00:02:12.717
What other methods are on strings?

30
00:02:12.717 --> 00:02:16.477
Well, one, VS Code is actually
very helpful with this.

31
00:02:20.077 --> 00:02:25.422
So if I make a string here, right, and
I say string., VS Code is smart enough

32
00:02:25.422 --> 00:02:30.306
to say, I know this is a string,
cuz I saw you declare it, right?

33
00:02:30.306 --> 00:02:33.938
Here's everything that I
know about strings, and so

34
00:02:33.938 --> 00:02:37.178
these are all functions
you can use on strings.

35
00:02:37.178 --> 00:02:39.051
So what's a good one?

36
00:02:39.051 --> 00:02:41.784
Well, I showed you padStart
not too long ago, right?

37
00:02:41.784 --> 00:02:44.220
That was one of them.

38
00:02:45.598 --> 00:02:48.850
How about, what's a good one?

39
00:02:48.850 --> 00:02:52.998
Split, split.

40
00:03:00.707 --> 00:03:06.172
Let's not do split, let's do substring.

41
00:03:08.931 --> 00:03:11.524
And again, it gives you lots of
helpful things like, all right,

42
00:03:11.524 --> 00:03:12.762
I'm expecting a number here.

43
00:03:12.762 --> 00:03:15.020
So where do you want to start?

44
00:03:15.020 --> 00:03:18.455
So let's make this a bit longer,
say, hi, my name is Brian.

45
00:03:25.764 --> 00:03:29.652
And this is a string that says,
hi, my name is Brian, and

46
00:03:29.652 --> 00:03:32.164
I wanted to just say my name is Brian.

47
00:03:32.164 --> 00:03:36.970
So I wanna cut off the first three
letters, right, the h, i, and

48
00:03:36.970 --> 00:03:38.644
then the space there.

49
00:03:38.644 --> 00:03:41.746
So you're gonna start at 0.

50
00:03:41.746 --> 00:03:46.031
So 0 would be the very first letter,
then 1, then 2.

51
00:03:49.464 --> 00:03:56.150
And I think I wanna start at 3,
and that have to start here.

52
00:03:56.150 --> 00:03:59.139
And then I don't need the end character.

53
00:03:59.139 --> 00:04:02.862
If I wanted it to end first, right,
so I could say, my name is, and

54
00:04:02.862 --> 00:04:06.336
cut off Brian as well, but
let's just leave that off for now.

55
00:04:07.648 --> 00:04:09.755
And get rid of this as well.

56
00:04:12.769 --> 00:04:21.123
Console.log(string).

57
00:04:23.665 --> 00:04:25.867
Yeah, and you have to store it as well.

58
00:04:25.867 --> 00:04:28.870
So let's just say,
let string and string =,

59
00:04:28.870 --> 00:04:33.726
right, cuz it was returning something and
I was ignoring it, basically.

60
00:04:33.726 --> 00:04:36.571
It doesn't modify the string itself,
it gives you a new string back.

61
00:04:39.091 --> 00:04:42.189
So there, now we have, my name is Brian.

62
00:04:42.189 --> 00:04:44.995
That's another built in
functionality to strings, so

63
00:04:44.995 --> 00:04:46.915
you can take some strings out of them.

64
00:04:46.915 --> 00:04:54.167
If I wanted to, Get it to here,

65
00:04:54.167 --> 00:04:59.132
where Brian is, I have to take, Let's see.

66
00:05:06.048 --> 00:05:09.359
We can kinda just guess and check here.

67
00:05:09.359 --> 00:05:14.506
Yeah, so this just has my,
right, because I went

68
00:05:14.506 --> 00:05:19.791
from 3 to 5, and
the fifth index here is this one.

69
00:05:19.791 --> 00:05:24.583
So if I wanted to get all the way
to my name is, I'd have to go 1, 2,

70
00:05:24.583 --> 00:05:29.063
3, 4, 5, 6, 7, 8, 9, so
I think this would be 14.

71
00:05:31.403 --> 00:05:32.618
And there you go.

72
00:05:32.618 --> 00:05:36.931
One too many, it'd have to be to 13,
cuz I got the extra space in there.

73
00:05:36.931 --> 00:05:39.193
There we go.

74
00:05:39.193 --> 00:05:43.823
So that's taking the string and
then it's returning to me

75
00:05:43.823 --> 00:05:49.020
starting from character number
3 all the way to character 13,

76
00:05:49.020 --> 00:05:52.244
which gives me back this middle string.

77
00:05:55.541 --> 00:05:59.116
So all this to say is, this is all stuff
I can't remember off the top of my head.

78
00:05:59.116 --> 00:06:00.738
I don't remember how these functions work,
right?

79
00:06:00.738 --> 00:06:03.116
There's so
many functions built into JavaScript.

80
00:06:03.116 --> 00:06:05.509
VS Code can be my little helper,

81
00:06:05.509 --> 00:06:11.115
cuz it has all these documented
things directly in here, right?

82
00:06:11.115 --> 00:06:13.132
Which I think is pretty cool.

83
00:06:13.132 --> 00:06:18.855
Now, a perhaps more better way of
looking at it is you can go to the MDN,

84
00:06:18.855 --> 00:06:21.959
which is Mozilla Developer Network,

85
00:06:21.959 --> 00:06:26.713
which is a documentation here,
and I can look for string.

86
00:06:26.713 --> 00:06:31.776
And here, I can see all of the various
different functions built into string,

87
00:06:31.776 --> 00:06:33.553
and there is a lot, right?

88
00:06:39.988 --> 00:06:43.439
But I mean, frequently,
I won't even do that.

89
00:06:43.439 --> 00:06:48.464
I'll just Google javaScript extract

90
00:06:48.464 --> 00:06:52.709
string, something like that.

91
00:06:52.709 --> 00:06:56.229
And you can see here, there's five
different ways that it'll tell me how to

92
00:06:56.229 --> 00:07:01.299
extract strings out of it,
Using substring.

93
00:07:04.568 --> 00:07:11.524
Okay, A lot of it just comes from getting

94
00:07:11.524 --> 00:07:15.882
more familiar with what JavaScript can do,
and you'll just get used to it over time.

95
00:07:18.860 --> 00:07:21.699
Yeah, I just wanna emphasize again,

96
00:07:21.699 --> 00:07:26.058
Googling things is not cheating,
it's part of your job.

97
00:07:26.058 --> 00:07:30.999
Being a really good developer is just
being really good at Google, for

98
00:07:30.999 --> 00:07:32.094
the most part.

99
00:07:32.094 --> 00:07:36.430
It's talent, it's literally
something that's required for

100
00:07:36.430 --> 00:07:38.043
you to do your job well.

101
00:07:42.796 --> 00:07:44.319
I like to emphasize that,

102
00:07:44.319 --> 00:07:48.690
because there's this group of
overachieving students from high school.

103
00:07:48.690 --> 00:07:53.461
They're like, I'm not gonna look at it in
the book, I have to remember it, cuz my

104
00:07:53.461 --> 00:07:58.464
chemistry teacher made me memorize how to
do redox equations or something like that.

105
00:07:58.464 --> 00:08:01.061
Not that, throw that attitude away.

106
00:08:01.061 --> 00:08:04.405
Just live your life in Google,
it's totally fine.

107
00:08:04.405 --> 00:08:08.932
Copy things from Stack Overflow, break
things, that's what you're supposed to do.

108
00:08:08.932 --> 00:08:10.741
So how about if you wanna round a number?

109
00:08:10.741 --> 00:08:14.346
Let's say I have a number and
I want it to be rounded up or down.

110
00:08:14.346 --> 00:08:19.128
You can use Math, which is a kind of
universally available object that

111
00:08:19.128 --> 00:08:21.895
has a bunch of useful math methods on it.

112
00:08:21.895 --> 00:08:24.401
Round is one of them, right?

113
00:08:24.401 --> 00:08:28.093
So, You have rounded number here.

114
00:08:28.093 --> 00:08:32.722
So number is 5.3, but
if I put rounded number here,

115
00:08:32.722 --> 00:08:36.583
you get 5, Which is cool, right?

116
00:08:36.583 --> 00:08:41.585
If you need to round something, it'll
round it to the nearest whole integer.

117
00:08:41.585 --> 00:08:44.566
You can also do floor,
which will always round down.

118
00:08:44.566 --> 00:08:47.982
So even if this is 5.999999,

119
00:08:47.982 --> 00:08:52.693
it'll still round down,
that's what floor does.

120
00:08:52.693 --> 00:08:58.774
And you can do ceiling,
right, always rounds up.

121
00:08:58.774 --> 00:09:00.871
5.1, still rounds up.

122
00:09:03.206 --> 00:09:11.302
So there is,
let's do this instead, number.

123
00:09:12.748 --> 00:09:16.107
There's also Math.random,
if you need a random number,

124
00:09:16.107 --> 00:09:19.142
which will give you a random
number between 0 and 1.

125
00:09:19.142 --> 00:09:21.497
So it's gonna be some long decimal.

126
00:09:21.497 --> 00:09:25.503
But notice if I keep changing this, I get
a different number every single time.

127
00:09:28.196 --> 00:09:29.323
Kind of fun, right?

128
00:09:32.194 --> 00:09:36.288
And I'm just deleting that semicolon,
inserting, because every time I delete

129
00:09:36.288 --> 00:09:40.393
that, it rebrands my code automatically,
that's why that keeps evaluating.

130
00:09:40.393 --> 00:09:44.942
Keep in mind, this is still pseudo-random,
it's not true random.

131
00:09:44.942 --> 00:09:47.458
That's a big thing in the computing
world of what's random and

132
00:09:47.458 --> 00:09:48.939
what's actually pseudo-random.

133
00:09:48.939 --> 00:09:51.042
Technically, if you know
enough about my computer,

134
00:09:51.042 --> 00:09:52.968
you could guess what
the next number is gonna be.

135
00:09:52.968 --> 00:09:56.342
So therefore, it is pseudo-random,
it's not truly random.

136
00:09:56.342 --> 00:09:58.690
It'd be hard to figure it out,
but it's possible.

137
00:09:58.690 --> 00:10:02.428
But for example, if you're, I don't know,
mining Bitcoin or something where money's

138
00:10:02.428 --> 00:10:05.887
on the line here, someone actually might
be incentivized to try and figure it out.

139
00:10:05.887 --> 00:10:08.845
And the fact that it's
possible means someone could.

140
00:10:08.845 --> 00:10:12.975
Whereas if you're taking atmospheric
interference and things like that,

141
00:10:12.975 --> 00:10:16.854
things that really you can't predict,
that's a true random number.

142
00:10:16.854 --> 00:10:17.958
This is not true random.

143
00:10:22.345 --> 00:10:24.615
That's kind of fun, right?

144
00:10:25.678 --> 00:10:32.415
Okay, So

145
00:10:32.415 --> 00:10:36.378
we wanna see if one string
contains another string.

146
00:10:36.378 --> 00:10:41.485
So let's say I have a word here
that I'm looking for called cute.

147
00:10:41.485 --> 00:10:45.409
And the first one I look at is, The quick
brown fox jumps over the lazy dog.

148
00:10:45.409 --> 00:10:49.513
Does cute exist in that string?

149
00:10:49.513 --> 00:10:50.724
No.

150
00:10:50.724 --> 00:10:53.578
Or how about this?

151
00:10:53.578 --> 00:10:57.513
I think this is a Lizzo lyric,
I think I chose it cuz I'm in Minnesota,

152
00:10:57.513 --> 00:10:59.068
Lizzo's from Minnesota.

153
00:10:59.068 --> 00:11:00.960
Mirror, mirror on the wall,
don't say it cuz I know I'm cute.

154
00:11:00.960 --> 00:11:04.136
Is cute in that sentence?

155
00:11:04.136 --> 00:11:05.189
It is.

156
00:11:05.189 --> 00:11:07.938
So as you'd expect,
the first one, testStringOne,

157
00:11:07.938 --> 00:11:11.067
this returns false, right,
because cute is not in that one.

158
00:11:13.932 --> 00:11:16.004
And that's what includes does,

159
00:11:16.004 --> 00:11:19.931
it's basically to see if one
string is contained in the other.

160
00:11:19.931 --> 00:11:24.729
But this other one here, Does.

161
00:11:24.729 --> 00:11:27.008
But you could also get kind
of wonky results here, right?

162
00:11:27.008 --> 00:11:31.664
So let's say I had testStringThree,

163
00:11:31.664 --> 00:11:35.891
and this string could be execute.

164
00:11:41.069 --> 00:11:42.533
What am I gonna get if I put three here?

165
00:11:45.587 --> 00:11:46.715
True, right?

166
00:11:46.715 --> 00:11:50.368
Cute is right there.

167
00:11:50.368 --> 00:11:51.932
So that's gonna be true.

168
00:11:51.932 --> 00:11:53.758
So that's gonna be if it's
anywhere in the string.

169
00:11:55.391 --> 00:11:59.418
Or if later I come back and say the lazy
cute dog, then all of them are true.

170
00:12:03.695 --> 00:12:06.593
So includes is a nice one,
that's a relatively new one as well,

171
00:12:06.593 --> 00:12:09.564
makes it easy to see if something
is contained in something else.

172
00:12:12.553 --> 00:12:15.841
Another useful one is figuring
out what the time is.

173
00:12:15.841 --> 00:12:20.877
So if you say Date.now,
this function will give you back how

174
00:12:20.877 --> 00:12:27.250
many milliseconds have elapsed
since January 1st, 1970.

175
00:12:27.250 --> 00:12:32.435
[LAUGH] People are probably
wondering right now,

176
00:12:32.435 --> 00:12:35.478
why January 1, 1970?

177
00:12:35.478 --> 00:12:40.675
So this is called the Linux epoch,
E-P-O-C-H.

178
00:12:40.675 --> 00:12:44.285
I don't actually really remember
why they started measuring it, but

179
00:12:44.285 --> 00:12:47.284
at some point,
they just started measuring dates in terms

180
00:12:47.284 --> 00:12:50.668
of how many seconds have elapsed
since January 1st, 1970.

181
00:12:50.668 --> 00:12:53.341
It's probably a Linux thing or a Unix.

182
00:12:53.341 --> 00:12:57.306
I'm gonna guess it's actually a Unix
thing, which Linux is based on top of,

183
00:12:57.306 --> 00:12:59.023
cuz it's called the Unix epoch.

184
00:12:59.023 --> 00:13:04.535
But I mean, it's really easy to
turn this number into a real date.

185
00:13:06.598 --> 00:13:12.659
So yeah, there's a bunch of
functions that will tell you,

186
00:13:12.659 --> 00:13:17.643
you can translate that
time into an actual date.

187
00:13:17.643 --> 00:13:20.933
Yeah, most computer things
are measured in this.

188
00:13:20.933 --> 00:13:25.058
For whatever reason,
it's the unit of choice of measurement.

189
00:13:25.058 --> 00:13:27.321
Normally, it's actually seconds,
not milliseconds, but

190
00:13:27.321 --> 00:13:29.507
JavaScript will actually give
you back the milliseconds.

191
00:13:29.507 --> 00:13:32.232
So if you want,
you just divide by 1,000 and

192
00:13:32.232 --> 00:13:35.964
you'll end up with how many
seconds have elapsed since 1970.

193
00:13:38.118 --> 00:13:41.890
And what's fun is, again,
if I just keep doing this,

194
00:13:41.890 --> 00:13:44.681
you can see time is marching on, right?

195
00:13:47.191 --> 00:13:51.634
That's your life just wasting away
watching Brian hit things on a keyboard.

196
00:13:53.932 --> 00:13:56.605
Just going, one step closer to death.

197
00:13:56.605 --> 00:14:02.602
Anyway, [LAUGH] you won't have any
questions, it's dark in the afternoon.

198
00:14:02.602 --> 00:14:08.366
[LAUGH]
&gt;&gt; I looked at that,

199
00:14:08.366 --> 00:14:10.934
but it's actually just arbitrary.

200
00:14:10.934 --> 00:14:12.479
&gt;&gt; I assumed it was.

201
00:14:12.479 --> 00:14:17.248
They just had to measure time in
some universally compatible way.

202
00:14:17.248 --> 00:14:20.912
And so now, everything does, all your
servers, I guarantee your iPhone is

203
00:14:20.912 --> 00:14:24.020
measured that way,
everything is measured in the Linux epoch.

