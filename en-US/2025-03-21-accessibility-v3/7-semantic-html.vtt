WEBVTT

1
00:00:00.160 --> 00:00:04.920
So we'll move on to the next subsection of
Screen Readers, which is semantic HTML.

2
00:00:04.920 --> 00:00:06.640
How many people have
heard this term before?

3
00:00:06.640 --> 00:00:09.128
I feel like it gets thrown around quite
a bit, but it's a little bit fuzzy.

4
00:00:09.128 --> 00:00:11.358
So we're gonna try to
kind of describe it and

5
00:00:11.358 --> 00:00:14.672
explain specifically why it's
important and what it means.

6
00:00:14.672 --> 00:00:19.208
Because I don't have strong feelings about
using all the great new HTML5 elements,

7
00:00:19.208 --> 00:00:22.792
I have strong feelings about
providing really good experiences.

8
00:00:22.792 --> 00:00:26.237
And so we're gonna kind of focus on what
actually is going to be really helpful

9
00:00:26.237 --> 00:00:26.820
for people.

10
00:00:27.850 --> 00:00:31.308
So some elements that we have in
HTML have semantic meaning but

11
00:00:31.308 --> 00:00:33.434
no special functionality, right?

12
00:00:33.434 --> 00:00:36.610
So they don't do anything different,
but they do have semantic meaning.

13
00:00:36.610 --> 00:00:39.394
And examples here are like header,
footer and aside.

14
00:00:39.394 --> 00:00:43.585
If you have div's or if you have these,
they don't do anything differently, but

15
00:00:43.585 --> 00:00:45.234
they present differently.

16
00:00:45.234 --> 00:00:48.751
And so these are important not because
of some kind of interaction, but

17
00:00:48.751 --> 00:00:51.890
because of using assistive
technology like screen readers.

18
00:00:51.890 --> 00:00:55.684
They provide this really nice content
that the screen reader can help with,

19
00:00:55.684 --> 00:00:59.417
where it can say, hey, there's a new
section here that's got this in it,

20
00:00:59.417 --> 00:01:01.516
as opposed to just reading div after div.

21
00:01:01.516 --> 00:01:05.207
So these are not only nice because they
have meaning for other developers,

22
00:01:05.207 --> 00:01:08.490
but they're nice for screen readers
because the screen reader can

23
00:01:08.490 --> 00:01:12.651
help the user understand that they're in
the header, that they're in the footer,

24
00:01:12.651 --> 00:01:14.740
that they're in a section.

25
00:01:14.740 --> 00:01:18.172
Other elements provide a ton
of built in functionality.

26
00:01:18.172 --> 00:01:22.394
So this was something that kind of blew
my mind when I started working with

27
00:01:22.394 --> 00:01:27.100
accessibility is I always thought about
HTML and then I thought about HTML in this

28
00:01:27.100 --> 00:01:31.758
abstract concept of spans are inline and
div's are block or things like this.

29
00:01:31.758 --> 00:01:33.744
I know they render a little
bit differently, but

30
00:01:33.744 --> 00:01:35.430
ultimately they're just these tags.

31
00:01:35.430 --> 00:01:37.062
But then when you think about it,

32
00:01:37.062 --> 00:01:40.782
there's some HTML elements that provide
a ton of functionality to them.

33
00:01:40.782 --> 00:01:45.776
We have all these new input type, email
and it controls what keyboard comes up and

34
00:01:45.776 --> 00:01:49.743
it does validation and it does,
when you really think about it,

35
00:01:49.743 --> 00:01:54.001
if you were at a job and that job had
tied you to some super old browser,

36
00:01:54.001 --> 00:01:57.470
like some 12 year old browser or
something like that.

37
00:01:57.470 --> 00:02:02.247
And then your task was to implement a
dropdown button or something like that, or

38
00:02:02.247 --> 00:02:06.174
an email validated input select,
there's a lot of work there.

39
00:02:06.174 --> 00:02:10.421
You'd have to write a substantial amount
of JavaScript and there's keyboard

40
00:02:10.421 --> 00:02:14.796
shortcuts and the way it behaves with the
escape button and is it tabable and where

41
00:02:14.796 --> 00:02:19.064
does it come in in the tab order and turn
on a screen reader and how does it read?

42
00:02:19.064 --> 00:02:21.287
How do you tell the user
that there's a list here and

43
00:02:21.287 --> 00:02:22.680
how many items are in the list.

44
00:02:22.680 --> 00:02:25.752
And you can start thinking about the
amount of JavaScript you would write for

45
00:02:25.752 --> 00:02:29.112
this, let alone a date picker or a color
picker, which could get just enormous, so

46
00:02:29.112 --> 00:02:29.704
it's a lot.

47
00:02:29.704 --> 00:02:34.333
So we've got these set of semantic
elements which help the screen reader but

48
00:02:34.333 --> 00:02:36.160
don't add functionality.

49
00:02:36.160 --> 00:02:40.498
And then we've got these highly
functional elements here and, and one

50
00:02:40.498 --> 00:02:45.409
of the big traps that people fall into is,
and I imagine a lot of us have seen this,

51
00:02:45.409 --> 00:02:50.266
is that UI or design will want, will not
like the look of one of these elements.

52
00:02:50.266 --> 00:02:54.517
And so they will task us as developers
with building our own checkbox or

53
00:02:54.517 --> 00:02:59.186
our own button or something like that
that looks the way that we want it to.

54
00:02:59.186 --> 00:03:03.556
And it can be very easy to forget all
the important stuff that kind of gets us

55
00:03:03.556 --> 00:03:04.114
there.

56
00:03:04.114 --> 00:03:08.876
For semantic markup to be Level A
compliant, we need to use semantic markup,

57
00:03:08.876 --> 00:03:14.128
like lists, to designate things, H1s,
to designate our headers, our regions.

58
00:03:14.128 --> 00:03:17.742
This is stuff that we often know
intuitively as developers who do a lot of

59
00:03:17.742 --> 00:03:20.424
HTML, but
it's kind of cool to see written down.

60
00:03:20.424 --> 00:03:23.000
Tables should only be used for
tabular data.

61
00:03:23.000 --> 00:03:25.559
Text labels should
accompany form elements,

62
00:03:25.559 --> 00:03:28.680
basically using the tools
available to you.

63
00:03:28.680 --> 00:03:32.344
And we'll get into it with a screen
reader exercise that if you label your

64
00:03:32.344 --> 00:03:36.220
form elements, it can be very
difficult to fill out a form.

65
00:03:36.220 --> 00:03:39.537
And then another thing is this reading and
navigation order must be logical and

66
00:03:39.537 --> 00:03:40.180
intuitive.

67
00:03:40.180 --> 00:03:44.290
So again, I think things that a lot of us
do as engineers, starting with an H1 and

68
00:03:44.290 --> 00:03:46.940
then the subsections are H2s,
things like that.

69
00:03:46.940 --> 00:03:50.830
But really understanding the importance of
doing it for accessibility because when

70
00:03:50.830 --> 00:03:54.113
you have the screen reader on and
you say read me all the top level items,

71
00:03:54.113 --> 00:03:57.508
it's really only going to read the things
that are in those header tags.

72
00:03:57.508 --> 00:04:01.291
It's not going to read something that
you've used CSS to make large and bold,

73
00:04:01.291 --> 00:04:03.484
but doesn't have an appropriate tag to it.

74
00:04:03.484 --> 00:04:06.203
Form labels in general
can be really confusing,

75
00:04:06.203 --> 00:04:10.460
forms in general can be very confusing for
screen reader users.

76
00:04:10.460 --> 00:04:13.711
There's lots of different ways which
we'll get into to label forms and

77
00:04:13.711 --> 00:04:16.212
choosing whichever one you
want is completely fine.

78
00:04:16.212 --> 00:04:19.588
But the thing that is very bad is if
you don't have any type of label,

79
00:04:19.588 --> 00:04:23.322
then you will literally just be giving
screen reader users this input blank

80
00:04:23.322 --> 00:04:26.756
as they're supposed to fill out
their first name, their last name,

81
00:04:26.756 --> 00:04:29.444
their credit card information,
things like that.

82
00:04:29.444 --> 00:04:33.660
So it can be really almost impossible
to use without some kind of labeling.

83
00:04:33.660 --> 00:04:39.218
An anti pattern, and I see this quite
often is using visual labels so

84
00:04:39.218 --> 00:04:42.268
a sighted user can see the context.

85
00:04:42.268 --> 00:04:46.511
We all do this at the very minimum that
will put some kind of visual label,

86
00:04:46.511 --> 00:04:48.620
first name text, last name text.

87
00:04:48.620 --> 00:04:49.692
Because if we didn't have that,

88
00:04:49.692 --> 00:04:51.916
then sighted users wouldn't be
able to fill out the form either.

89
00:04:51.916 --> 00:04:56.100
But these aren't the correct tags,
this isn't semantic HTML.

90
00:04:56.100 --> 00:05:00.621
And it is really important for screen
reader users because as we visually can

91
00:05:00.621 --> 00:05:03.388
see, these are associated with each other.

92
00:05:03.388 --> 00:05:07.215
A screen reader user will hit tab and
they'll go directly to the input box,

93
00:05:07.215 --> 00:05:09.140
skipping over that paragraph tag.

94
00:05:09.140 --> 00:05:13.350
And all their experience will be is
input text blank, input text blank,

95
00:05:13.350 --> 00:05:14.820
input password blank.

96
00:05:14.820 --> 00:05:18.058
That's all they'll get, so they'll have
no idea that they want first name,

97
00:05:18.058 --> 00:05:19.404
last name or first name email.

98
00:05:19.404 --> 00:05:21.140
They'll have no concept there.

99
00:05:21.140 --> 00:05:23.158
And so this is all that they'll see.

100
00:05:23.158 --> 00:05:26.942
So one way that we can do this
better is we can use HTML labels.

101
00:05:26.942 --> 00:05:30.726
So this is the kind of oldest way
that we've had to label these things.

102
00:05:30.726 --> 00:05:35.262
You can have your inputs with an ID and
then your labels with a for attribute.

103
00:05:35.262 --> 00:05:37.270
And that will tie those things together,
right?

104
00:05:37.270 --> 00:05:42.310
And so they will have first name text
blank as opposed to input text blank.

105
00:05:42.310 --> 00:05:45.596
This can provide some issues because
now maybe you don't like the way that

106
00:05:45.596 --> 00:05:48.710
the label looks or maybe you already
have some design stuff going on.

107
00:05:48.710 --> 00:05:50.976
So you've got great ways to
deal with that as well, but

108
00:05:50.976 --> 00:05:53.510
I wanted to talk about a few
other ways to label these things.

109
00:05:55.170 --> 00:05:58.807
So yeah, now it'll read first name edit
text blank as opposed to before it

110
00:05:58.807 --> 00:06:00.346
was reading edittext blank.

111
00:06:00.346 --> 00:06:01.802
So much, much better, all right, cool.

112
00:06:01.802 --> 00:06:03.366
So that's HTML labels, and

113
00:06:03.366 --> 00:06:07.514
then we have another option that we
can use which is implicit HTML labels.

114
00:06:07.514 --> 00:06:12.079
So instead of using this label for
and the ID concept, we can kind of do

115
00:06:12.079 --> 00:06:17.178
the same thing by wrapping the input
with or without an ID inside label tags.

116
00:06:17.178 --> 00:06:19.991
So you can use a self closing
label tag like this, or

117
00:06:19.991 --> 00:06:24.242
you can use a closed label tag like this
and match their IDs with their fours.

118
00:06:24.242 --> 00:06:28.349
Or you can use a label tag like this and
just put the ID or

119
00:06:28.349 --> 00:06:30.490
the input inside of them.

120
00:06:30.490 --> 00:06:32.990
So those will both kind of
accomplish the same thing here.

121
00:06:34.090 --> 00:06:36.098
So limitations with the label tag.

122
00:06:36.098 --> 00:06:40.866
So the label tag only works with what the
HTML spec defines as labelable elements.

123
00:06:40.866 --> 00:06:45.668
So that's like button, input, keygen,
meter output, progress, select, text area.

124
00:06:45.668 --> 00:06:49.267
So if you're building a more robust
application that doesn't use one of these

125
00:06:49.267 --> 00:06:52.788
labelable elements, you can kind of
get yourself into some trouble here.

126
00:06:52.788 --> 00:06:56.436
And again, this is where things
like the ARIA spec come into play.

127
00:06:56.436 --> 00:06:59.465
So the ARIA spec gives you
this ARIA label property and

128
00:06:59.465 --> 00:07:02.020
you can apply that to
any element you want.

129
00:07:02.020 --> 00:07:06.003
So it's kind of an either or choice that
you have, you could just use ARIA labels,

130
00:07:06.003 --> 00:07:08.487
they'll work the same way
with screen readers, or

131
00:07:08.487 --> 00:07:11.020
you can use the label element for
HTML labelable.

132
00:07:11.020 --> 00:07:15.440
And if you're ever working on something
like, I don't know, like a video game or

133
00:07:15.440 --> 00:07:19.989
a really robust screen, and you just need
to label something that is not labelable,

134
00:07:19.989 --> 00:07:23.490
you can do that simply with
the ARIA label property.

135
00:07:23.490 --> 00:07:26.810
&gt;&gt; Speaker 1: Yeah, talking about
the ARIA label and the label itself,

136
00:07:26.810 --> 00:07:28.474
which one has precedence?

137
00:07:28.474 --> 00:07:29.730
&gt;&gt; Speaker 1: Yeah,
that's a great question.

138
00:07:29.730 --> 00:07:33.770
So if you were to have an element
like this, this label 4, and

139
00:07:33.770 --> 00:07:38.591
then on the input you were to put the ARIA
labeled by the ARIA specification

140
00:07:38.591 --> 00:07:42.872
bit will take precedent over
the HTML specific specification.

141
00:07:42.872 --> 00:07:45.720
So if you had label for
first and this said first name,

142
00:07:45.720 --> 00:07:49.454
and then you had input ARIA labeled
by my first name or your first name,

143
00:07:49.454 --> 00:07:53.656
it would just read the your first name and
it wouldn't read the label itself.

144
00:07:53.656 --> 00:07:54.725
These ARIA label elements, and

145
00:07:54.725 --> 00:07:57.337
they work the same way, you just pass in
a string and then the screen reader will

146
00:07:57.337 --> 00:07:59.371
read that before it reads
the actual content of the element.

