WEBVTT

1
00:00:00.000 --> 00:00:02.953
But if we get into an infinite
scrolling situation,

2
00:00:02.953 --> 00:00:07.650
then this is not going to be ideal because
we don't want to be rendering hundreds and

3
00:00:07.650 --> 00:00:09.346
hundreds of these elements.

4
00:00:09.346 --> 00:00:11.536
Instead, we want to render
just a few at a time.

5
00:00:11.536 --> 00:00:15.105
So we need to use a technique
called windowing, and

6
00:00:15.105 --> 00:00:19.842
only render the elements that
are actually relevant at the moment.

7
00:00:19.842 --> 00:00:21.053
And in order to do this,

8
00:00:21.053 --> 00:00:25.307
we first need to wrap this entire thing in
an element that I'm gonna call viewport.

9
00:00:25.307 --> 00:00:28.003
div class=viewport,

10
00:00:32.222 --> 00:00:37.058
And that's gonna have, for
now just so that we can see it,

11
00:00:37.058 --> 00:00:41.923
we'll give it a maximum height of,
say, 500 pixels.

12
00:00:47.352 --> 00:00:51.681
And we'll make that, Overflow.

13
00:00:54.687 --> 00:00:56.650
Y of auto.

14
00:00:59.808 --> 00:01:02.479
And right now, of course,
we're still rendering everything.

15
00:01:02.479 --> 00:01:08.341
But now that we have some scroll
behavior on that viewport, we can start

16
00:01:08.341 --> 00:01:14.998
to do some calculations about which of
these elements should actually be shown.

17
00:01:14.998 --> 00:01:19.472
And before we do that,
let's add the next page link for

18
00:01:19.472 --> 00:01:22.694
the users who don't have JavaScript.

19
00:01:22.694 --> 00:01:26.043
So if next is specified,

20
00:01:26.043 --> 00:01:30.827
then we'll add &lt;a href=next with

21
00:01:30.827 --> 00:01:35.617
some text that just says next page.

22
00:01:35.617 --> 00:01:39.487
So for our windowing we're gonna
need to add a scroll handler and

23
00:01:39.487 --> 00:01:43.141
on every scroll event we're
gonna need to recalculate which

24
00:01:43.141 --> 00:01:45.738
elements should currently be in the view.

25
00:01:45.738 --> 00:01:49.162
So I'm gonna create a function
called handlescroll.

26
00:01:53.967 --> 00:01:58.369
And I'm gonna create some variables that
are bound to the elements that we're

27
00:01:58.369 --> 00:01:59.510
dealing with here.

28
00:01:59.510 --> 00:02:05.380
We're gonna have one for the viewport,
it's gonna be an HTML div element,

29
00:02:05.380 --> 00:02:09.966
and we're gonna have one for
the results block as well, and

30
00:02:09.966 --> 00:02:13.928
I'm gonna use bind this to
get references to them.

31
00:02:18.076 --> 00:02:19.752
If you put on the outer div.

32
00:02:24.613 --> 00:02:27.568
And results on the inner div there.

33
00:02:34.026 --> 00:02:37.288
And we're gonna add the scroll
listener to the viewport itself.

34
00:02:37.288 --> 00:02:42.027
It's gonna move this style declaration
into the CSS, so that is out of the way,

35
00:02:42.027 --> 00:02:43.392
it's already there.

36
00:02:43.392 --> 00:02:50.599
OnScroll, we'll pass in that
handle scroll function.

37
00:02:50.599 --> 00:02:56.143
Just to verify that it's working,
we'll log out the word

38
00:02:56.143 --> 00:03:01.132
scrolling, open our dev tools,
go to the console.

39
00:03:04.225 --> 00:03:07.855
Right, when we scroll,
we get the event handler has been called.

40
00:03:18.751 --> 00:03:22.573
And this handle scroll function
is going to have two jobs,

41
00:03:22.573 --> 00:03:27.097
firstly is gonna determine which
elements are currently in view, so

42
00:03:27.097 --> 00:03:29.910
that we can get rid of
the ones that are not.

43
00:03:29.910 --> 00:03:34.384
But secondly,
it's also gonna tell the parent component,

44
00:03:34.384 --> 00:03:36.409
how close we are to the end.

45
00:03:36.409 --> 00:03:40.346
If we're getting to the bottom of
the display elements, then if this is

46
00:03:40.346 --> 00:03:44.822
an infinite scroll component, then we
gonna need to go and fetch some more data.

47
00:03:44.822 --> 00:03:47.740
And so for that to work,
we gonna need to emit an event.

48
00:03:47.740 --> 00:03:50.144
But we not gonna worry
about that just now, for

49
00:03:50.144 --> 00:03:53.298
right now we're just gonna deal
with the windowing aspect.

50
00:03:59.472 --> 00:04:05.028
So to track which elements
are supposed to be in view,

51
00:04:05.028 --> 00:04:08.245
we're gonna create a value a.

52
00:04:08.245 --> 00:04:13.281
This is gonna be the first visible
element and b is the last,

53
00:04:13.281 --> 00:04:17.123
or the first invisible
element I should say.

54
00:04:19.003 --> 00:04:24.392
And we can initialize these to 0 and

55
00:04:24.392 --> 00:04:27.270
movies.length.

56
00:04:35.219 --> 00:04:38.089
So by default,
everything is gonna get rendered.

57
00:04:38.089 --> 00:04:43.267
Movie.slice a, b is gonna ensure
that only the movies that we're

58
00:04:43.267 --> 00:04:48.883
currently concerned with
are being rendered And

59
00:04:48.883 --> 00:04:52.803
inside handles scroll,
we need to update those values.

60
00:04:52.803 --> 00:04:54.894
But if we're gonna be taking
things out of the DOM,

61
00:04:54.894 --> 00:04:57.232
then everything else is gonna
jump up to fill that space.

62
00:04:57.232 --> 00:05:01.209
So we're also gonna need to add some
padding on this element to compensate for

63
00:05:01.209 --> 00:05:03.177
the elements that have been removed.

64
00:05:03.177 --> 00:05:08.716
So we're gonna add some
padding_top = 0 and

65
00:05:08.716 --> 00:05:12.415
padding bottom = 0, right?

66
00:05:12.415 --> 00:05:15.547
So if we take out
the first row of elements,

67
00:05:15.547 --> 00:05:20.854
then we'll add some padding on
the results div that will make everything

68
00:05:20.854 --> 00:05:25.819
else get pushed down as though that
row of elements was still there.

69
00:05:25.819 --> 00:05:27.734
In order to do any of this,

70
00:05:27.734 --> 00:05:31.750
we need to know what size
the elements in this grid are.

71
00:05:31.750 --> 00:05:35.370
So we need to start adding some values for
those as well.

72
00:05:35.370 --> 00:05:40.695
We'll have one for item width,
which is gonna be a number,

73
00:05:40.695 --> 00:05:44.847
one for item height,
also gonna be a number and

74
00:05:44.847 --> 00:05:48.699
we'll have one for the number of columns.

75
00:05:48.699 --> 00:05:52.918
And right now that's
hard coded in our CSS,

76
00:05:52.918 --> 00:05:58.291
down here is 4, so
I'm just gonna do that here as well.

77
00:05:58.291 --> 00:06:02.887
Later, we can make this responsive because
on mobile, we're gonna have like two

78
00:06:02.887 --> 00:06:06.634
columns, and then on a much bigger screen,
we're gonna have 6.

79
00:06:06.634 --> 00:06:11.538
It'd be nice for that to be dynamic,
but for now, we'll just do hard coding.

80
00:06:15.295 --> 00:06:17.356
In order to get these values,

81
00:06:17.356 --> 00:06:22.481
we're gonna need to do some measurements
every time the page is resized.

82
00:06:22.481 --> 00:06:26.965
So we're gonna add a resize function
as well as a scroll function.

83
00:06:26.965 --> 00:06:30.879
Function handle_resize and in here,

84
00:06:30.879 --> 00:06:36.698
we're gonna get those item width and
item height values.

85
00:06:41.779 --> 00:06:45.998
And so that we can call that function
every time the window gets resized,

86
00:06:45.998 --> 00:06:47.944
we'll add a spelt colon window.

87
00:06:47.944 --> 00:06:52.639
On resize=handle_resize but
we also wanna call

88
00:06:52.639 --> 00:06:57.568
this function when
the component is first mounted.

89
00:06:57.568 --> 00:07:05.010
So we're gonna add an on mount, I'm just
gonna immediately call handle_resize.

90
00:07:07.444 --> 00:07:12.098
And of course, after we've taken
the measurements that we're about to take,

91
00:07:12.098 --> 00:07:15.439
we're gonna wanna update the a and
b and padding values.

92
00:07:15.439 --> 00:07:20.476
So at the bottom of our handle_resize
function, we're gonna call handle_scroll.

93
00:07:27.307 --> 00:07:30.864
So the first thing we're gonna
do inside handle resize is,

94
00:07:30.864 --> 00:07:33.210
grab a reference to the first element,

95
00:07:33.210 --> 00:07:37.704
because we know that all of these poster
images have the same aspect ratio.

96
00:07:37.704 --> 00:07:42.111
And because this is a regular grid, we
can use that as a proxy for all of them.

97
00:07:42.111 --> 00:07:46.783
So the first element is gonna tell us

98
00:07:46.783 --> 00:07:51.922
what the width of every single item is,

99
00:07:51.922 --> 00:07:57.080
const first=results.firstchild.

100
00:07:57.080 --> 00:08:03.528
And you'll recall that results is
bound to this div class=results.

101
00:08:03.528 --> 00:08:07.012
So it's gonna give us the first anchor,
element.

102
00:08:09.236 --> 00:08:13.384
And the item width is just gonna be

103
00:08:13.384 --> 00:08:18.570
the offset width of element item height,

104
00:08:18.570 --> 00:08:23.907
itemheight=first.offsetheight, and

105
00:08:23.907 --> 00:08:30.427
num_columns again,
we're gonna keep that as 4,

106
00:08:30.427 --> 00:08:35.153
for now So

107
00:08:35.153 --> 00:08:40.144
it's giving us some red squigglies
here because we can't guarantee or

108
00:08:40.144 --> 00:08:45.481
TypeScript at least can't guarantee
that results has any children at all.

109
00:08:45.481 --> 00:08:50.080
So we need to tell it that no,
we do definitely have a child here,

110
00:08:50.080 --> 00:08:51.713
an exclamation mark.

111
00:08:51.713 --> 00:08:56.273
But that is actually a good point,
we might not have any elements at all

112
00:08:56.273 --> 00:09:01.161
in which case we probably don't want
to to render this results page at all.

113
00:09:01.161 --> 00:09:05.696
So later we'll make sure that we only
render the results page component when we

114
00:09:05.696 --> 00:09:07.218
do in fact have some movies

115
00:09:13.428 --> 00:09:18.371
It's complaining that this first element
might not be the sort of thing that has

116
00:09:18.371 --> 00:09:20.673
an offset width or an offset height.

117
00:09:20.673 --> 00:09:23.199
So we need to give TypeScript
some more information.

118
00:09:23.199 --> 00:09:27.039
Do as HTML_anchor element
because that's what it is and

119
00:09:27.039 --> 00:09:30.565
now you can see those red
squigglers have gone away.

120
00:09:33.350 --> 00:09:37.991
Now that we've got the width and
the height, we can start doing some

121
00:09:37.991 --> 00:09:43.305
calculations inside our handle scroll
function and get rid of that logging.

122
00:09:43.305 --> 00:09:46.791
And we're gonna set the value of a,
it's gonna be.

123
00:09:48.212 --> 00:09:54.004
Math.floor of the viewport,
scrolltop divided by

124
00:09:54.004 --> 00:09:59.531
the item height,
which is the height of each row,

125
00:09:59.531 --> 00:10:03.755
multiplied by the number of columns.

126
00:10:17.295 --> 00:10:20.232
And then the final value, the b value,

127
00:10:20.232 --> 00:10:24.072
which is the first element that is not yet
visible.

128
00:10:24.072 --> 00:10:29.110
We can calculate that with math.ceil,

129
00:10:29.110 --> 00:10:34.147
math.ceiling of scroll top, plus, so

130
00:10:34.147 --> 00:10:40.533
if you put .scrolltop+viewport
client height.

131
00:10:45.227 --> 00:10:51.449
Divided by item height and
then multiplied by the number of columns.

132
00:10:54.644 --> 00:10:58.676
Right, so if we just get get
rid of this for a minute, so

133
00:10:58.676 --> 00:11:00.793
that we can visualize this.

134
00:11:00.793 --> 00:11:06.001
We're gonna add some
debugging information,

135
00:11:06.001 --> 00:11:09.254
showing items a to b, and it,

136
00:11:09.254 --> 00:11:14.853
it's doing some funky
floating point stuff here,

137
00:11:14.853 --> 00:11:20.206
because I got my parenthesis
in the wrong place.

138
00:11:20.206 --> 00:11:21.595
So let's just fix that real quick.

139
00:11:33.584 --> 00:11:36.370
You can see that it's currently
showing items 0 to 20.

140
00:11:36.370 --> 00:11:41.944
And that makes sense because we can
see 4 by 5 is showing all 20 elements.

141
00:11:41.944 --> 00:11:45.707
If we made this window smaller.

142
00:11:49.975 --> 00:11:58.270
Then I would hope that it was,
It was gonna change that but

143
00:11:58.270 --> 00:12:04.429
it has not changed that, let me just
take a quick look and figure out why

144
00:12:08.538 --> 00:12:13.719
I think it might be because
the viewport is too large.

145
00:12:18.865 --> 00:12:21.678
Okay, if you constrain the viewport so

146
00:12:21.678 --> 00:12:26.793
that we only get a smaller window,
then we can see now as we are scrolling

147
00:12:26.793 --> 00:12:31.841
it's figuring out correctly which
elements are currently visible.

148
00:12:35.421 --> 00:12:39.961
So now we just need to add the padding and
then we can actually get rid of

149
00:12:39.961 --> 00:12:44.055
the elements that are not
currently in the visible viewport.

150
00:12:44.055 --> 00:12:45.691
Padding_top.

151
00:12:46.745 --> 00:12:54.286
Is gonna be Math.floor of a divided
by the number of columns,

152
00:12:54.286 --> 00:12:58.500
multiplied by the item_height.

153
00:12:58.500 --> 00:13:04.890
And padding_bottom is gonna be math.floor,

154
00:13:04.890 --> 00:13:10.959
we get the length of
the entire array minus b,

155
00:13:10.959 --> 00:13:16.227
so that gives us all of the xs at the end,

156
00:13:16.227 --> 00:13:24.875
divided by the number of columns
multiplied by the item height.

157
00:13:24.875 --> 00:13:27.998
Okay so
now if we put that slice back in there so

158
00:13:27.998 --> 00:13:31.628
that we only render the elements
that we care about.

159
00:13:31.628 --> 00:13:33.966
And then on the results div,

160
00:13:33.966 --> 00:13:38.649
we'll add some inline styles
which apply that padding.

161
00:13:41.563 --> 00:13:44.945
Style:padding-top=.

162
00:13:44.945 --> 00:13:51.499
Padding_top px and
we'll duplicate that for the bottom.

163
00:13:59.471 --> 00:14:04.935
And now you can't tell by looking at it,
but hopefully if we look inside the DOM.

164
00:14:04.935 --> 00:14:12.047
We'll see that the fourth item there
is actually the first item in the DOM.

165
00:14:12.047 --> 00:14:16.135
We haven't got the first four
elements of the array in the DOM, but

166
00:14:16.135 --> 00:14:19.495
as far as the user is concerned,
everything is there.

167
00:14:19.495 --> 00:14:23.850
So this is the basis of
a windowing mechanism.

168
00:14:23.850 --> 00:14:27.189
You'll recall that our results
page component has two jobs.

169
00:14:27.189 --> 00:14:31.198
One is the windowing, but the other is
that it needs to tell its parent when

170
00:14:31.198 --> 00:14:35.094
the user has scrolled far enough,
that it needs to load some more data.

171
00:14:35.094 --> 00:14:38.310
So this component needs to
become an event dispatcher.

172
00:14:38.310 --> 00:14:40.495
So we're gonna create a dispatch function.

173
00:14:44.168 --> 00:14:48.041
By importing createEventDispatcher
from Svelte and coding it.

174
00:14:48.041 --> 00:14:52.782
And then inside our scroll handler,
we're gonna determine whether or

175
00:14:52.782 --> 00:14:57.127
not we are close enough to the end
that it's time to tell the parent

176
00:14:57.127 --> 00:14:59.433
component to load some more data.

177
00:15:02.064 --> 00:15:06.654
So the value that we care about is

178
00:15:06.654 --> 00:15:11.244
the remaining scroll room, and

179
00:15:11.244 --> 00:15:16.344
we can calculate that by doing const

180
00:15:16.344 --> 00:15:22.295
remaining = viewport.scrollHeight-

181
00:15:22.295 --> 00:15:29.954
viewport.scrollTop+viewport.clientHeight.

182
00:15:29.954 --> 00:15:35.137
And if we log that out as we're scrolling,

183
00:15:44.540 --> 00:15:49.244
You can see that number gets lower
the closer that we get to the end,

184
00:15:49.244 --> 00:15:53.865
until eventually, when we get
to the bottom, that number is 0.

185
00:15:53.865 --> 00:15:56.788
And just as a crude heuristic,

186
00:15:56.788 --> 00:16:01.848
we'll say that if that
value drops below say 400,

187
00:16:01.848 --> 00:16:09.732
then we'll broadcast an event that tells
the parent we need to load some more data.

188
00:16:11.753 --> 00:16:15.064
I don't know what to call this event,
naming stuff is hard.

189
00:16:15.064 --> 00:16:21.839
I'm just gonna call it,
end, like that, that'll do.

190
00:16:28.428 --> 00:16:33.308
And now in the page that
is using this component,

191
00:16:33.308 --> 00:16:36.411
we can add an on:end handler.

192
00:16:43.213 --> 00:16:44.506
And we can load some more data.

193
00:16:44.506 --> 00:16:51.001
We'll just verify that that's working.

194
00:16:51.001 --> 00:16:55.507
If we scroll down far enough then it
starts logging that we need to load some

195
00:16:55.507 --> 00:16:56.239
more data.

