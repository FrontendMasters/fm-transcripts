WEBVTT

1
00:00:00.174 --> 00:00:02.109
Now if we go back to the homepage,

2
00:00:02.109 --> 00:00:05.442
we'll see that we've created a problem for
ourselves.

3
00:00:05.442 --> 00:00:09.973
We've got that footer at the bottom of the
screen because we added some CSS that's

4
00:00:09.973 --> 00:00:14.322
controlling the height of the main element
that contains all of this content.

5
00:00:14.322 --> 00:00:18.841
And we can no longer scroll down
the page because our main element has

6
00:00:18.841 --> 00:00:20.117
a maximum height.

7
00:00:20.117 --> 00:00:24.055
And we don't really want that, but we
cannot have a height on the main element

8
00:00:24.055 --> 00:00:26.236
when we've got an infinite loading page,

9
00:00:26.236 --> 00:00:29.828
because otherwise we'll never be
able to get that windowing effect.

10
00:00:29.828 --> 00:00:34.584
So we need to have some way of controlling
the layout based on what type of

11
00:00:34.584 --> 00:00:35.710
page we're on.

12
00:00:35.710 --> 00:00:40.222
And this is where SvelteKit's data
loading as a separate step from page

13
00:00:40.222 --> 00:00:42.485
rendering becomes really useful.

14
00:00:42.485 --> 00:00:46.460
We're gonna be able to distinguish
between two types of pages,

15
00:00:46.460 --> 00:00:50.815
pages that have an infinite loading
component and those that don't.

16
00:00:50.815 --> 00:00:56.728
So I'm gonna open the page.ts
that we were looking at before,

17
00:00:56.728 --> 00:01:01.203
and I'm gonna add a new value,
infinite true.

18
00:01:01.203 --> 00:01:06.551
And in our layout component,
we have access to

19
00:01:06.551 --> 00:01:12.183
the entire page data if
we import the page store.

20
00:01:12.183 --> 00:01:18.552
So let's do that,
import page from.apps/stores.

21
00:01:18.552 --> 00:01:24.236
If we add a class name to
the main element of infinite

22
00:01:26.227 --> 00:01:30.788
Which is gonna be true if any load
function that was involved in rendering

23
00:01:30.788 --> 00:01:33.941
the current page returned
an infinite property.

24
00:01:37.965 --> 00:01:41.338
And now the styles that we
applied to the main here,

25
00:01:41.338 --> 00:01:45.268
we're only are gonna apply these
if it is an infinite page.

26
00:01:51.115 --> 00:01:55.842
Right, so our our homepage is
now fixed apart from a glitch on

27
00:01:55.842 --> 00:01:59.284
the nav that I apparently just introduced.

28
00:01:59.284 --> 00:02:05.028
But the infinite loading
page works as we would hope.

29
00:02:05.028 --> 00:02:08.238
We've got a question from the crowd.

30
00:02:08.238 --> 00:02:14.455
&gt;&gt; Scrolling up and down causes
refetching, or is it cached somehow?

31
00:02:14.455 --> 00:02:18.030
&gt;&gt; So someone just asked
a really great question.

32
00:02:18.030 --> 00:02:22.957
Is the data cached or
are we fetching it anew each time?

33
00:02:22.957 --> 00:02:29.076
So we're keeping this stuff
in memory as we're scrolling.

34
00:02:29.076 --> 00:02:31.758
And so if we scroll all the way
down we are fetching more data,

35
00:02:31.758 --> 00:02:34.238
we're fetching more data,
we are fetching more data.

36
00:02:34.238 --> 00:02:38.700
But as we scroll back up we're
just rendering the data that we

37
00:02:38.700 --> 00:02:40.546
already have in memory.

38
00:02:40.546 --> 00:02:44.702
We're only gonna start loading more
data once we get to the end of the of

39
00:02:44.702 --> 00:02:45.906
the scroll window.

40
00:02:45.906 --> 00:02:49.191
And because we've already got all of this
data, we're not gonna get to the end of

41
00:02:49.191 --> 00:02:51.628
the scroll window until it is
in fact time to load more data.

42
00:02:51.628 --> 00:02:56.169
But there is a really useful thing
that we can do since we're controlling

43
00:02:56.169 --> 00:02:59.155
the data loading in
a universal load function.

44
00:02:59.155 --> 00:03:02.316
And that is we can add some
client side caching of our own.

45
00:03:02.316 --> 00:03:06.586
And that's useful because if you
look at this front page here,

46
00:03:06.586 --> 00:03:11.664
we're already making a request to
the trending API in the Now Playing API,

47
00:03:11.664 --> 00:03:13.854
and the upcoming API endpoint.

48
00:03:13.854 --> 00:03:18.584
And it would be nice if we could just
reuse that data when we navigate to

49
00:03:18.584 --> 00:03:19.575
these pages.

50
00:03:19.575 --> 00:03:22.581
So let's go into our API helper.

51
00:03:22.581 --> 00:03:24.738
And we'll actually go ahead and
implement that.

52
00:03:27.988 --> 00:03:30.348
So open lib api.ts.

53
00:03:32.270 --> 00:03:39.038
And inside this get function,
we can create a cache.

54
00:03:39.038 --> 00:03:42.851
This is gonna be a new map.

55
00:03:42.851 --> 00:03:44.359
Right, super naive.

56
00:03:44.359 --> 00:03:48.419
In a real app, you would have a little bit
more of a sophisticated caching policy

57
00:03:48.419 --> 00:03:50.494
than just add everything to a cache map.

58
00:03:50.494 --> 00:03:52.765
But it's perfectly fine for this demo.

59
00:03:52.765 --> 00:03:57.603
So, we're gonna create
a string which is a URL,

60
00:03:57.603 --> 00:04:01.970
and that's gonna be all
of that data there.

61
00:04:01.970 --> 00:04:07.646
And then we're going to replace
that with a reference.url.

62
00:04:07.646 --> 00:04:10.745
And now if we've cached this data already,

63
00:04:10.745 --> 00:04:14.865
then we're just gonna return
it directly from the cache.

64
00:04:14.865 --> 00:04:20.612
If cache.hasurl,
return cache.geturl otherwise

65
00:04:20.612 --> 00:04:25.718
we'll make an API call
by calling await fetch,

66
00:04:25.718 --> 00:04:31.719
get the data const data equals
await response,json and

67
00:04:31.719 --> 00:04:35.820
then we're gonna add that to the cache

68
00:04:41.570 --> 00:04:43.090
And for good measure,

69
00:04:43.090 --> 00:04:47.574
let's add some logging when we get
a cache hit versus a cache miss.

70
00:05:00.500 --> 00:05:03.221
We'll bring up the console.

71
00:05:03.221 --> 00:05:10.844
And so when we load this page,
we've got a bunch of cache misses.

72
00:05:10.844 --> 00:05:15.008
But that's okay because we're using
SvelteKit's built in fetch, and

73
00:05:15.008 --> 00:05:19.446
what's actually happening here is the data
is being fetched on the server and

74
00:05:19.446 --> 00:05:22.335
then the response is being
inlined into the HTML.

75
00:05:22.335 --> 00:05:25.314
So that when we fetch it in
the client during hydration it's just

76
00:05:25.314 --> 00:05:28.250
grabbing the same data that was
already fetched on the server.

77
00:05:28.250 --> 00:05:30.592
So we don't have a duplicate
network request and

78
00:05:30.592 --> 00:05:32.657
that allows us to guarantee consistency.

79
00:05:32.657 --> 00:05:37.818
Now if we just clear that and
navigate to the trending

80
00:05:37.818 --> 00:05:42.051
page then hopefully, we got a cache miss.

81
00:05:42.051 --> 00:05:43.186
So disappointing.

82
00:05:43.186 --> 00:05:48.397
That's because we have
a default page there.

83
00:05:48.397 --> 00:05:55.399
So let's get rid of the page equals one
in the case where no page is necessary,

84
00:05:55.399 --> 00:06:01.863
or alternatively, what we could do
is in our route page load function,

85
00:06:01.863 --> 00:06:06.203
we'll just always default
to page equals one.

86
00:06:06.203 --> 00:06:10.224
So go to the route page.ts over here.

87
00:06:10.224 --> 00:06:12.906
And in each of these,

88
00:06:12.906 --> 00:06:17.976
we're just gonna add page 1, like so.

89
00:06:24.167 --> 00:06:31.327
Right, let's go to the home page and
navigate to the trending page.

90
00:06:31.327 --> 00:06:35.641
All right, we've got a cache hit for
the first page and a cache miss for

91
00:06:35.641 --> 00:06:39.027
the second page And

92
00:06:39.027 --> 00:06:43.371
then we'll continue to get cache
misses for the subsequent pages.

93
00:06:43.371 --> 00:06:45.909
But if we now navigate
back to the homepage,

94
00:06:45.909 --> 00:06:48.387
we're not gonna be fetching any new data.

95
00:06:48.387 --> 00:06:50.458
We're getting all these lovely cache hits.

96
00:06:50.458 --> 00:06:53.831
So we're gonna get
instantaneous navigation.

97
00:06:53.831 --> 00:06:57.505
And this is something that you can
only really do in a framework that has

98
00:06:57.505 --> 00:07:01.490
universal load functions, as opposed
to making you go back to the server for

99
00:07:01.490 --> 00:07:02.247
everything.

100
00:07:02.247 --> 00:07:05.245
So obviously, there is a time and
a place for loading data from the server.

101
00:07:05.245 --> 00:07:08.775
But loading data directly from
the client is really good,

102
00:07:08.775 --> 00:07:13.037
particularly for stuff that involves
things like real time and so on.

103
00:07:13.037 --> 00:07:16.264
And so SvelteKit gives you
both of those options for

104
00:07:16.264 --> 00:07:19.502
whatever you need when
you're building your app.

105
00:07:22.462 --> 00:07:28.849
That was a great question that segues so
nicely into what I was about to cover.

