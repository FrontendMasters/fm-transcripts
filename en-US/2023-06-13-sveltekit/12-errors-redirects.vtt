WEBVTT

1
00:00:00.000 --> 00:00:04.162
So in the earlier chapter on routing, we
learned how to create routes with dynamic

2
00:00:04.162 --> 00:00:07.923
parameters, but sometimes it's
helpful to make a parameter optional.

3
00:00:07.923 --> 00:00:11.237
A really good example of this is when
you're using the pathname to determine

4
00:00:11.237 --> 00:00:11.819
the locale.

5
00:00:11.819 --> 00:00:15.935
So you might begin your routes
with /fr for your French users,

6
00:00:15.935 --> 00:00:18.507
/de for your German users, and so on.

7
00:00:18.507 --> 00:00:20.961
But you also want to
have a default locale.

8
00:00:20.961 --> 00:00:25.668
So at the moment, we're doubling things
up, we have our default page.svelte here,

9
00:00:25.668 --> 00:00:28.773
and then we also have the language
specific ones up here.

10
00:00:28.773 --> 00:00:32.905
And this one here is kind of duplicative,
we wanna get rid of that.

11
00:00:32.905 --> 00:00:37.222
So we can change this lang directory
here to use double brackets instead.

12
00:00:37.222 --> 00:00:39.386
And that makes that parameter optional.

13
00:00:39.386 --> 00:00:43.271
I'm just gonna hit
the rename button there and

14
00:00:43.271 --> 00:00:46.866
change that to lang with double brackets.

15
00:00:46.866 --> 00:00:51.841
And the app is now failing to
build because we have a conflict

16
00:00:51.841 --> 00:00:54.838
between this route and this route.

17
00:00:54.838 --> 00:00:56.823
In other words, it's ambiguous,

18
00:00:56.823 --> 00:01:01.271
Svelte doesn't know which of these is
supposed to apply if you hit the /route.

19
00:01:01.271 --> 00:01:03.774
So we're gonna just
delete this altogether.

20
00:01:06.731 --> 00:01:11.175
And finally,
we're gonna edit the page.server.js inside

21
00:01:11.175 --> 00:01:14.685
the lang directory to
specify a default locale.

22
00:01:14.685 --> 00:01:17.553
So here's our
internationalization data here,

23
00:01:17.553 --> 00:01:21.180
I'm just gonna add a full back here for
when lang is undefined.

24
00:01:30.262 --> 00:01:35.191
Sometimes you will have a route that
has an unknown number of path segments.

25
00:01:35.191 --> 00:01:39.205
And in these cases, we can use what's
called a rest parameter to match any

26
00:01:39.205 --> 00:01:41.553
number of segments from zero to whatever.

27
00:01:41.553 --> 00:01:46.019
And it's named after its resemblance
to the rest parameter in JavaScript.

28
00:01:46.019 --> 00:01:52.264
So let's take this src/routes/path
directory and rename it to ...path.

29
00:01:56.206 --> 00:02:00.739
Right, this will now match
any route whatsoever.

30
00:02:00.739 --> 00:02:03.262
So we can keep clicking this and

31
00:02:03.262 --> 00:02:08.613
it will still match the current
route until eventually we reset.

32
00:02:08.613 --> 00:02:10.507
And when you have a situation like this,

33
00:02:10.507 --> 00:02:12.859
other more specific routes
will be tested first.

34
00:02:12.859 --> 00:02:16.626
So the rest parameter is
essentially a catch-all.

35
00:02:16.626 --> 00:02:21.480
This is useful to have nested
inside other directories.

36
00:02:21.480 --> 00:02:25.933
For example, if you want custom 404 pages
for different parts of your app, then

37
00:02:25.933 --> 00:02:30.468
you can create a catch-all that has its
own error.svelte and its own data loading.

38
00:02:30.468 --> 00:02:34.923
Inside the load function,
you could throw in a 404 error, and

39
00:02:34.923 --> 00:02:39.542
it would render that error page
instead of the full back error page.

40
00:02:39.542 --> 00:02:42.538
Now, unlike in some frameworks,
you do not need to put your rest

41
00:02:42.538 --> 00:02:45.439
parameters at the end of the route,
you can have them inside.

42
00:02:45.439 --> 00:02:51.392
So something like /items/...path
/edit is a totally valid route,

43
00:02:51.392 --> 00:02:55.914
or /items/...path.json
is also totally valid.

44
00:02:55.914 --> 00:02:59.312
Sometimes we want to add some
matching logic to our routing.

45
00:02:59.312 --> 00:03:03.990
For example, you might want
a route like colors/value to

46
00:03:03.990 --> 00:03:08.202
match hex values like ff300 or 6767779.

47
00:03:08.202 --> 00:03:13.208
But you don't wanna match named
colors like colors/octarine or

48
00:03:13.208 --> 00:03:17.587
any other arbitrary input
like this invalid value here.

49
00:03:17.587 --> 00:03:20.094
And we can do that with
a thing called a matcher.

50
00:03:20.094 --> 00:03:24.138
First, we create a new file
in a directory called params.

51
00:03:27.616 --> 00:03:32.181
I'm gonna call this one hex.js,
and inside this module,

52
00:03:32.181 --> 00:03:35.574
I'm gonna export a function called match.

53
00:03:40.551 --> 00:03:44.187
And the job of this function
is to return true if

54
00:03:44.187 --> 00:03:48.858
the parameter is a successful match and
false if it's not.

55
00:03:48.858 --> 00:03:52.798
So the regular expression for
a hex code is,

56
00:03:52.798 --> 00:03:57.590
let's see,
we want the caret to match the start, and

57
00:03:57.590 --> 00:04:01.762
then we want to have any
number of 0 to 9a to f.

58
00:04:01.762 --> 00:04:07.342
Not ending, we want six of them,
followed by the end of the match string,

59
00:04:07.342 --> 00:04:13.262
and the test the value against that,
Right?

60
00:04:13.262 --> 00:04:16.070
And then to use the new matcher,

61
00:04:16.070 --> 00:04:21.174
we're gonna rename this color
directory to color=hex.

62
00:04:28.845 --> 00:04:33.734
Right, and so we can continue
navigating between the colors, but

63
00:04:33.734 --> 00:04:38.534
if we now navigate to the invalid route,
it's gonna be a 404,

64
00:04:38.534 --> 00:04:40.996
that does not match color=hex.

65
00:04:40.996 --> 00:04:44.578
So these matches, they run on the server
when you're doing routing on the server,

66
00:04:44.578 --> 00:04:45.975
and they also run in the client.

67
00:04:45.975 --> 00:04:50.028
So you need to make sure that you're not
accessing any server-side information

68
00:04:50.028 --> 00:04:51.166
inside your matches.

69
00:04:51.166 --> 00:04:55.286
As we saw earlier in the workshop, layouts
are a way to share user interface and

70
00:04:55.286 --> 00:04:58.860
data loading logic between different
routes of your application.

71
00:04:58.860 --> 00:05:03.289
Or sometimes it's useful to have
layouts that don't affect the route.

72
00:05:03.289 --> 00:05:07.996
For example, you might have a /app and
/account routes, and those need to be

73
00:05:07.996 --> 00:05:12.506
behind authentication while your /about
route page is open to the world.

74
00:05:12.506 --> 00:05:15.601
And we can do this with
a thing called a root group,

75
00:05:15.601 --> 00:05:17.979
which is a directory in parentheses.

76
00:05:17.979 --> 00:05:22.960
So first thing we're gonna do is we're
gonna rename the account directory here

77
00:05:22.960 --> 00:05:26.693
to (authed)/acount,
with the authed in parentheses.

78
00:05:32.002 --> 00:05:36.069
Right, and we can navigate to the account
page just as we could before.

79
00:05:36.069 --> 00:05:41.497
Nothing has changed, even though we
have this directory in the tree,

80
00:05:41.497 --> 00:05:45.365
that's not reflected in
the routing structure.

81
00:05:45.365 --> 00:05:47.847
We're gonna move app
into the same directory.

82
00:05:47.847 --> 00:05:53.900
Again, just gonna hit that rename button
and prefix it with authed in parentheses.

83
00:05:53.900 --> 00:05:56.191
Right, and
these two things are now grouped,

84
00:05:56.191 --> 00:05:59.320
and we can navigate to all the same
routes that we could before.

85
00:06:01.331 --> 00:06:04.622
But what we can do now,
now that we have that route group,

86
00:06:04.622 --> 00:06:09.288
is we can control access to those routes
by creating a layout.server.js inside

87
00:06:09.288 --> 00:06:10.670
the authed directory.

88
00:06:10.670 --> 00:06:16.460
So just click on that and
then create the layout.server.js file.

89
00:06:19.276 --> 00:06:22.816
And we're gonna redirect the user if
we detect that they're not logged in.

90
00:06:22.816 --> 00:06:25.754
Import the redirect helper from Sveltekit.

91
00:06:31.940 --> 00:06:33.993
Then we're gonna export a load function.

92
00:06:39.856 --> 00:06:44.059
And if the user doesn't
have the logged in cookie,

93
00:06:47.084 --> 00:06:51.732
Then we're gonna throw a redirect and
send them to the login page.

94
00:06:55.590 --> 00:06:59.984
But we're gonna redirect them once they do
log in back to wherever we currently are.

95
00:07:09.651 --> 00:07:13.687
Right, so
now if we try to visit the account page or

96
00:07:13.687 --> 00:07:18.604
the app page, it's gonna send
us to the login page instead.

97
00:07:18.604 --> 00:07:23.576
The login route has a form
action which sets the logged

98
00:07:23.576 --> 00:07:27.454
in cookie when we press the login button.

99
00:07:27.454 --> 00:07:31.927
I'm gonna hit that, and
now I go to the account page.

100
00:07:33.805 --> 00:07:38.685
We can add some UI to these two routes
that's distinct from the UIs on the rest

101
00:07:38.685 --> 00:07:43.730
of the app by adding a layout.svelte
component inside the authed directory.

102
00:07:43.730 --> 00:07:48.485
So I hit that button there and
create layout.svelte.

103
00:07:50.594 --> 00:07:55.847
And then inside here, we're gonna

104
00:07:55.847 --> 00:08:02.684
create a form method=POST action=logout.

105
00:08:11.527 --> 00:08:14.167
And create that logout button
followed by the slot so

106
00:08:14.167 --> 00:08:15.971
that we can put the page content in.

107
00:08:17.727 --> 00:08:21.466
So now if I'm on the account page or
the app page, I can logout and

108
00:08:21.466 --> 00:08:26.259
I'll get kicked back out to the homepage
where I don't need to be authenticated.

109
00:08:30.446 --> 00:08:34.020
So that's how you create a layout
group without affecting the route.

110
00:08:34.020 --> 00:08:36.003
Sometimes we need to
do the opposite thing,

111
00:08:36.003 --> 00:08:37.938
sometimes we need to break out of layouts.

112
00:08:37.938 --> 00:08:41.783
Ordinarily, every page inherits
every layout above it.

113
00:08:41.783 --> 00:08:46.005
So if we have a page
like a/b/c/page.svelte,

114
00:08:46.005 --> 00:08:51.230
then it will inherit all of these layouts,
the route layout,

115
00:08:51.230 --> 00:08:55.160
the a layout, the b layout,
and the c layout.

116
00:08:55.160 --> 00:09:00.260
And you can see that in this exercise if
we navigate between the different pages,

117
00:09:00.260 --> 00:09:03.410
each of these layouts is
getting applied in turn.

118
00:09:03.410 --> 00:09:08.009
And sometimes it's useful to be able to
break out of the current layout hierarchy.

119
00:09:08.009 --> 00:09:10.136
And we can do that by adding the @ sign,

120
00:09:10.136 --> 00:09:13.816
followed by the name of the parents
segment that we want to reset to.

121
00:09:13.816 --> 00:09:22.242
So for example, if you were to change this
file from +page.svelte to +page@b.svelte,

122
00:09:22.242 --> 00:09:28.843
then it will put the abc route inside
the b layout instead of the c layout.

123
00:09:28.843 --> 00:09:34.896
So now these two routes share a layout,
or we could change it to a.

124
00:09:37.496 --> 00:09:43.600
And so now we go from home to a to
the b layout back to the a layout.

125
00:09:43.600 --> 00:09:48.407
Or we could reset it all the way to
the top by specifying the empty string.

126
00:09:48.407 --> 00:09:53.212
And so now, we go home, a, b, and
then back to the route layout.

127
00:09:54.870 --> 00:09:59.075
Right, the route layout here,
this applies to every page of your app,

128
00:09:59.075 --> 00:10:01.540
you cannot break out of the route layout.

129
00:10:01.540 --> 00:10:06.303
So if you have some parts of your app that
shouldn't have any layout UI whatsoever,

130
00:10:06.303 --> 00:10:10.862
then what you'll need to do is put every
other part of your app inside a regroup,

131
00:10:10.862 --> 00:10:12.789
something like parenthesis@.

132
00:10:12.789 --> 00:10:15.629
And then put all your resets inside that,

133
00:10:15.629 --> 00:10:21.077
then you can use +page@ to reset all the
way to the blank layout at the very top.

134
00:10:21.077 --> 00:10:27.294
&gt;&gt; In these Sveltekit docs,
regarding the data Sveltekit preload code,

135
00:10:27.294 --> 00:10:33.423
hover and tap have the same description,
what's their difference?

136
00:10:33.423 --> 00:10:38.107
&gt;&gt; So the difference between hover and
tap is that if a link has

137
00:10:38.107 --> 00:10:42.696
the data Sveltekit preload
data attribute set to hover,

138
00:10:42.696 --> 00:10:46.613
then when the mouse comes
to rest over that link,

139
00:10:46.613 --> 00:10:52.276
Sveltekit will begin fetching the code and
the data for the next page.

140
00:10:52.276 --> 00:10:56.728
The assumption being that if the mouse
has come to arrest everything,

141
00:10:56.728 --> 00:11:01.569
there's a very high chance that the user
is about to initiate a navigation.

142
00:11:01.569 --> 00:11:03.909
But if you don't want that,
then you can specify tap.

143
00:11:03.909 --> 00:11:08.804
And in that case, the preloading won't
begin until there's a pointed down event.

144
00:11:09.847 --> 00:11:12.643
That doesn't give you quite
as much of a head start, but

145
00:11:12.643 --> 00:11:16.167
it does reduce the number of false
positives that you'll encounter.

146
00:11:16.167 --> 00:11:20.220
So if you're trying to save data,
then that's a good thing for you to do.

147
00:11:20.220 --> 00:11:23.124
But if you're trying to maximize
the speed of navigation,

148
00:11:23.124 --> 00:11:24.700
then you'll want to use hover.

149
00:11:24.700 --> 00:11:27.963
Obviously, hover only applies to desktop,
because on a mobile device,

150
00:11:27.963 --> 00:11:30.290
you don't have a mouse,
there are no hover events.

151
00:11:30.290 --> 00:11:34.365
So in that case, it will fall back
to the tap behavior in all cases.

152
00:11:34.365 --> 00:11:40.326
If you do have hover set, then if for
whatever reason the hover hasn't yet

153
00:11:40.326 --> 00:11:45.424
been triggered because the mouse
clicks on the link while it's

154
00:11:45.424 --> 00:11:51.505
still moving over the link, then it
will also initiate navigation on tap.

155
00:11:54.793 --> 00:12:01.787
&gt;&gt; Is the +page@.svelte
the same as +layout@.svelte?

156
00:12:01.787 --> 00:12:05.898
&gt;&gt; Yes, so you can apply a layout
reset to your layout components as

157
00:12:05.898 --> 00:12:09.554
well as to your page components
if you want a whole group of

158
00:12:09.554 --> 00:12:12.926
routes to be reset to
an earlier layout separately.

159
00:12:14.568 --> 00:12:19.281
Altogether, I guess, yeah,
I hope that makes sense.

160
00:12:19.281 --> 00:12:22.086
&gt;&gt; Is there a way to have named layouts?

161
00:12:23.870 --> 00:12:27.671
&gt;&gt; The way that you name a layout is
just by having it inside a segment.

162
00:12:27.671 --> 00:12:29.796
So wherever you are in the tree,

163
00:12:29.796 --> 00:12:34.442
you can refer to a layout above
the route that you're currently at just

164
00:12:34.442 --> 00:12:38.794
by referring to the name of
the directory in which that layout is.

165
00:12:38.794 --> 00:12:43.230
&gt;&gt; To be clear, are layout that you
can refer to that isn't route-based.

166
00:12:43.230 --> 00:12:48.356
&gt;&gt; No, because if you had something like
that, then the layouts would no longer be

167
00:12:48.356 --> 00:12:53.574
bound to the hierarchy and the behavior
would be very difficult to reason about.

168
00:12:53.574 --> 00:12:57.454
So the name of the layout
is always connected to

169
00:12:57.454 --> 00:13:01.046
the directory in which that layout lives.

170
00:13:01.046 --> 00:13:06.197
If we started having two ways of naming
layouts, then it would just add confusion,

171
00:13:06.197 --> 00:13:09.668
but you wouldn't actually
gain any expressive power.

172
00:13:09.668 --> 00:13:11.016
So we don't do that.

