WEBVTT

1
00:00:00.360 --> 00:00:02.654
Previously when we learned about loading,

2
00:00:02.654 --> 00:00:07.260
we loaded data from the server using
page.server.js and layout.server.js files.

3
00:00:07.260 --> 00:00:12.102
And this is very convenient if you need to
do things like getting data directly from

4
00:00:12.102 --> 00:00:15.120
a database or
reading cookies and and so on.

5
00:00:15.120 --> 00:00:17.170
But sometimes that isn't what you want.

6
00:00:17.170 --> 00:00:18.330
Sometimes it doesn't make sense.

7
00:00:19.680 --> 00:00:23.928
For example, if you're loading data from
an external API that is not your server,

8
00:00:23.928 --> 00:00:27.266
then there's no point going to your
server so that it can then go to

9
00:00:27.266 --> 00:00:31.210
the external API, get the data and
then send it back to the browser.

10
00:00:31.210 --> 00:00:34.570
The browser can just communicate
with that external API directly.

11
00:00:34.570 --> 00:00:38.470
Or maybe you want to use
in-memory data if it's available.

12
00:00:38.470 --> 00:00:41.258
Perhaps you want to delay navigation
until an image has been pre-loaded or

13
00:00:41.258 --> 00:00:42.770
something like that.

14
00:00:42.770 --> 00:00:45.751
Or finally, you might want to return
something from your load function

15
00:00:45.751 --> 00:00:47.730
that cannot be serialized.

16
00:00:47.730 --> 00:00:49.877
So in order to load data from the server,

17
00:00:49.877 --> 00:00:53.350
it needs to come over the network
in a serializable form.

18
00:00:53.350 --> 00:00:59.230
And the svelte kit uses a library called
D-value to turn server data into JSON.

19
00:00:59.230 --> 00:01:02.810
And that gives you more power
than a regular JSON object.

20
00:01:02.810 --> 00:01:06.200
You'd include things like dates and
begins and maps and sets and

21
00:01:06.200 --> 00:01:08.630
regular expressions and so on.

22
00:01:08.630 --> 00:01:12.190
But it can't serialize your own
custom classes and things like that.

23
00:01:13.870 --> 00:01:15.136
So in that situation,

24
00:01:15.136 --> 00:01:19.010
it would make sense to use what's
called a universal load function.

25
00:01:20.660 --> 00:01:25.300
So in this app,
we have a few server load functions

26
00:01:25.300 --> 00:01:29.287
inside these red, green, and blue apps.

27
00:01:29.287 --> 00:01:32.552
And what this load function is doing,

28
00:01:32.552 --> 00:01:37.180
it's importing a component,
namely red.svelte.

29
00:01:37.180 --> 00:01:41.620
And it's trying to return
that from the load function.

30
00:01:41.620 --> 00:01:43.672
But if we navigate to this page,

31
00:01:43.672 --> 00:01:47.168
we're gonna get an error
because a component is not one

32
00:01:47.168 --> 00:01:52.036
of the things that you can serialize and
send from the server to the browser.

33
00:01:54.720 --> 00:01:56.950
The same thing is true if you
navigate to the other pages.

34
00:01:58.070 --> 00:02:02.088
So we need to turn these load functions
into universal load functions, and

35
00:02:02.088 --> 00:02:04.980
we'll do that by renaming
pageservers js to page js.

36
00:02:06.810 --> 00:02:07.940
Like that.

37
00:02:07.940 --> 00:02:13.286
Do the same for green and
the same for blue.

38
00:02:16.496 --> 00:02:19.602
All right, and
now when we navigate to those pages,

39
00:02:19.602 --> 00:02:23.353
we are in fact returning
the component from the load function.

40
00:02:25.447 --> 00:02:31.305
So these load functions are just
like any other function in your app,

41
00:02:31.305 --> 00:02:35.060
you can use them anywhere in any module.

42
00:02:35.060 --> 00:02:38.970
You're not restricted as to
where you can use that data.

43
00:02:40.890 --> 00:02:45.243
So a cool thing that we can
do now that we're returning

44
00:02:45.243 --> 00:02:48.660
a component from our load function.

45
00:02:48.660 --> 00:02:53.214
Is we can use it inside the layout, even
though we're returning it from the page,

46
00:02:53.214 --> 00:02:57.400
because the data is available on
the page store as the data property.

47
00:02:57.400 --> 00:03:00.505
So inside our navigation
bar in the layout.svelte,

48
00:03:00.505 --> 00:03:04.166
we're gonna go down here, and
we're gonna add a new if block.

49
00:03:04.166 --> 00:03:08.708
If a component was returned
from the load function,

50
00:03:10.441 --> 00:03:14.790
And this can be any load function that was
involved in fetching data for this page.

51
00:03:16.760 --> 00:03:20.343
Then we can inject that component
into the navigation bar.

52
00:03:33.005 --> 00:03:37.599
Right, and this is something that's only
possible because we have this separation

53
00:03:37.599 --> 00:03:41.040
between the data fetching process and
the rendering process.

54
00:03:41.040 --> 00:03:44.487
It's something that you can use for
putting a custom menu inside your

55
00:03:44.487 --> 00:03:47.890
navigation bar or adding breadcrumbs and
things like that.

56
00:03:47.890 --> 00:03:52.310
Stuff that is really difficult to do
if you don't have that separation.

57
00:03:52.310 --> 00:03:54.902
In some scenarios you might want
to use a server load function and

58
00:03:54.902 --> 00:03:56.440
a universal load function together.

59
00:03:56.440 --> 00:04:00.427
For example, you might need to return some
data from the server, but you also need to

60
00:04:00.427 --> 00:04:04.040
return a value that cannot be serialized
as server data, like a component.

61
00:04:05.070 --> 00:04:06.490
So in this example,

62
00:04:06.490 --> 00:04:11.751
we want to return a different component
from our universal load function,

63
00:04:11.751 --> 00:04:16.522
based on whether some data that we
got from the server is cool or not.

64
00:04:16.522 --> 00:04:21.052
So in our page js file, we can access
the data that is returned from here,

65
00:04:23.350 --> 00:04:26.797
By grabbing the data
property from the event.

66
00:04:28.120 --> 00:04:33.750
And we'll just replace
this false with data.cool.

67
00:04:33.750 --> 00:04:37.512
Right, and because the data that we're
getting from the server is cool,

68
00:04:37.512 --> 00:04:41.530
we're now able to import the cool
component instead of the boring component.

69
00:04:42.730 --> 00:04:46.356
It's still saying to-do add
a message because the universal load

70
00:04:46.356 --> 00:04:50.860
function is replacing the data that was
returned from the server load function.

71
00:04:50.860 --> 00:04:52.730
They're not getting mixed together.

72
00:04:52.730 --> 00:04:59.077
So here we need to replace
the placeholder with data.message.

73
00:04:59.077 --> 00:05:02.827
And so now we have a universal load
function that is returning data directly

74
00:05:02.827 --> 00:05:03.729
from the server.

75
00:05:13.587 --> 00:05:17.307
Earlier when we were looking at layout
data, we saw that if a layout load

76
00:05:17.307 --> 00:05:21.275
function returns some data,
it's accessible within that layout.svelte

77
00:05:21.275 --> 00:05:25.740
component, but it's also accessible
within every child page.svelte component.

78
00:05:27.160 --> 00:05:28.680
But sometimes it's useful for

79
00:05:28.680 --> 00:05:32.716
the load functions themselves to be able
to get access to data from their parents,

80
00:05:32.716 --> 00:05:36.360
and this can be done with
something called await parent.

81
00:05:36.360 --> 00:05:37.372
And to show how this works,

82
00:05:37.372 --> 00:05:40.023
we're gonna sum two numbers that
come from different load functions.

83
00:05:40.023 --> 00:05:44.470
We have a layout load, and
then we have another layout load here, and

84
00:05:44.470 --> 00:05:46.090
then we have a page load.

85
00:05:46.090 --> 00:05:51.786
So inside our root layout server js,
we're gonna return a value.

86
00:05:56.095 --> 00:05:59.362
That is a : 1.

87
00:05:59.362 --> 00:06:01.885
Right, and so this sum page here,

88
00:06:01.885 --> 00:06:07.456
which is referring to the data that is
combined from the different layout and

89
00:06:07.456 --> 00:06:11.562
page load functions is showing
data.a now has a value.

90
00:06:13.708 --> 00:06:20.510
And we can get that data in our
sum/layout.js load function.

91
00:06:20.510 --> 00:06:23.450
First, grab the parent property.

92
00:06:25.960 --> 00:06:29.765
And then, get the value of
a from the parent layout load.

93
00:06:33.900 --> 00:06:37.730
And we can now return a value
that depends on that value.

94
00:06:37.730 --> 00:06:39.860
B is a plus one.

95
00:06:39.860 --> 00:06:45.850
And you'll see that b is now populating
data b and our page.svelte component.

96
00:06:47.580 --> 00:06:52.755
You'll notice here that the root layout
is using a layout server js file,

97
00:06:52.755 --> 00:06:57.960
ie, a server load function,
whereas the sumLayout is just layout.js.

98
00:06:57.960 --> 00:07:00.740
So this is a universal load function.

99
00:07:00.740 --> 00:07:05.335
A universal load function can get parent
data from a parent server load function,

100
00:07:05.335 --> 00:07:07.270
but the reverse is not true.

101
00:07:07.270 --> 00:07:12.035
If we had layout.js in the root and
layout.server.js inside the sum root,

102
00:07:12.035 --> 00:07:14.980
then we would not be able
to access parent data.

103
00:07:14.980 --> 00:07:18.178
And then finally,
in the page load function,

104
00:07:18.178 --> 00:07:23.470
we can get the parent data from
both of the parent load functions.

105
00:07:23.470 --> 00:07:30.260
Again, we're gonna grab parent here and

106
00:07:30.260 --> 00:07:36.280
we'll do [a, b] = await parent.

107
00:07:36.280 --> 00:07:40.772
And we'll return c is the value of a + b.

108
00:07:42.130 --> 00:07:43.560
Right, it's a bit of a contrived example.

109
00:07:43.560 --> 00:07:46.930
It's not something that you're
gonna encounter often, but

110
00:07:46.930 --> 00:07:50.920
it's a useful thing to have in
your toolkit when you do need it.

111
00:07:50.920 --> 00:07:54.227
One thing that you do need to be aware
of is that all of these load functions

112
00:07:54.227 --> 00:07:58.290
are running in parallel, that's so
that we get the data as fast as possible.

113
00:07:58.290 --> 00:08:00.405
But if you start using await parent,

114
00:08:00.405 --> 00:08:04.774
then that essentially means that
everything that happens after that line in

115
00:08:04.774 --> 00:08:10.040
your load function is waterfalled on the
completion of the parent load functions.

116
00:08:10.040 --> 00:08:13.005
And so if you're doing any other
asynchronous work inside your load

117
00:08:13.005 --> 00:08:16.593
function, like fetching data from an API
or something, then you're gonna wanna

118
00:08:16.593 --> 00:08:20.249
make sure that you do that before you call
await parent, if it's possible to do so.

119
00:08:20.249 --> 00:08:24.459
&gt;&gt; Are there any performance benefits
to loading components from a page.js,

120
00:08:24.459 --> 00:08:28.023
rather than importing them as
modules directly into the route?

121
00:08:28.023 --> 00:08:33.193
In SvelteKit 1, it was mentioned as
opposed to other frameworks like Next,

122
00:08:33.193 --> 00:08:36.296
SvelteKit defaults to
client side navigation

123
00:08:36.296 --> 00:08:39.860
after the initial server
rendered page load.

124
00:08:39.860 --> 00:08:43.661
Does that mean that on the initial load
Svelte will send the JavaScript for

125
00:08:43.661 --> 00:08:47.910
the entire site as opposed to Next where
you'll hit a server for each navigation?

126
00:08:49.480 --> 00:08:55.206
Or will it download the JavaScript for
that, for each route independently?

127
00:08:55.206 --> 00:08:59.653
&gt;&gt; We use route-based code splitting in
SvelteKit, so when you hit the first page,

128
00:08:59.653 --> 00:09:03.855
you will get the JavaScript that's
needed for any interaction on that page.

129
00:09:03.855 --> 00:09:08.410
And you'll get the client side router so
that SvelteKit can navigate to new pages,

130
00:09:08.410 --> 00:09:11.540
but you will not get the code for
subsequent route.

131
00:09:11.540 --> 00:09:14.520
You only get that once
the navigation begins.

132
00:09:14.520 --> 00:09:19.278
So it's all split up in a mathematically
optimal way so that you're getting

133
00:09:19.278 --> 00:09:24.450
the minimum amount of code that you
need to at each stage of the navigation.

134
00:09:24.450 --> 00:09:26.160
You can use a service worker or

135
00:09:26.160 --> 00:09:30.336
preloading to get more of your app if
you need to preload things eagerly,

136
00:09:30.336 --> 00:09:34.620
but the default behavior is to
only get code when you need it.

137
00:09:34.620 --> 00:09:38.338
&gt;&gt; Instead of doing import
component from component,

138
00:09:38.338 --> 00:09:43.838
we can import the component from page.js
in a load function, as we just saw.

139
00:09:43.838 --> 00:09:47.799
Are there any difference in performance
in terms of lazy loading components or

140
00:09:47.799 --> 00:09:48.826
any other concept?

141
00:09:51.400 --> 00:09:52.987
&gt;&gt; No, in either case,

142
00:09:52.987 --> 00:09:58.476
the the navigation is gonna be blocked
on that component being imported.

143
00:09:58.476 --> 00:10:02.203
And it really doesn't make any difference
whether it's a static import from

144
00:10:02.203 --> 00:10:05.585
within a component file or
a dynamic Input inside your load function,

145
00:10:05.585 --> 00:10:07.440
it's gonna have the same end result.

146
00:10:07.440 --> 00:10:14.280
It's just that the dynamic import is
gonna be more work and harder to do.

147
00:10:14.280 --> 00:10:18.778
So I would recommend using static imports
unless you have a reason to use a dynamic

148
00:10:18.778 --> 00:10:22.240
import, because you'll have
an easier time that way.

149
00:10:22.240 --> 00:10:25.987
So when the user navigates from one page
to another, SvelteKit calls your load

150
00:10:25.987 --> 00:10:29.020
functions, but only if it thinks
that something has changed.

151
00:10:30.450 --> 00:10:35.498
For example,
navigating between time zones in this

152
00:10:35.498 --> 00:10:40.554
app causes the load function
in our page js to rerun.

153
00:10:40.554 --> 00:10:45.424
So we see that we're getting
the time zone updated,

154
00:10:45.424 --> 00:10:50.195
which is being reflected
in the H1 element there.

155
00:10:50.195 --> 00:10:54.803
But the load function in our layout does
not rerun because as far as Svelte is

156
00:10:54.803 --> 00:10:58.500
concerned, it wasn't
invalidated by the navigation.

157
00:10:58.500 --> 00:11:03.431
It's not using anything here that is
relevant to that navigation between

158
00:11:03.431 --> 00:11:04.790
different routes.

159
00:11:06.220 --> 00:11:10.337
And we can fix that by manually
invalidating it using a function called

160
00:11:10.337 --> 00:11:15.620
invalidate, which takes a URL and reruns
any load functions that depend on it.

161
00:11:15.620 --> 00:11:20.867
So this load function here,
because we're calling fetch/api/now,

162
00:11:20.867 --> 00:11:27.155
we know that this load function depends
on that resource, thes /api/now resource.

163
00:11:27.155 --> 00:11:30.104
So let's go over to the page.svelte and

164
00:11:30.104 --> 00:11:35.845
we'll add an unmount callback that
invalidates that resource once a second.

165
00:11:38.884 --> 00:11:45.665
Import unMount from svelte.

166
00:11:45.665 --> 00:11:52.618
I'm gonna import the invalidate
function from $app/navigation.

167
00:11:58.656 --> 00:12:04.336
Then we'll create an unmount callback,
That sets up an interval.

168
00:12:08.716 --> 00:12:10.628
It's gonna run once a second.

169
00:12:19.677 --> 00:12:24.726
Make sure that you return
the clearance of all tear down.

170
00:12:28.495 --> 00:12:33.308
And inside that interval,
we're gonna invalidate that resource.

171
00:12:37.001 --> 00:12:42.256
Right, and
you'll see that the time is now updating.

172
00:12:42.256 --> 00:12:47.153
As we navigate around the site,
the time zone inside this

173
00:12:47.153 --> 00:12:52.154
function is being invalidated
independently of the other

174
00:12:52.154 --> 00:12:56.760
load function which depends
on the API Now resource.

175
00:12:56.760 --> 00:13:01.098
You can also pass a function to invalidate
instead of an individual string,

176
00:13:01.098 --> 00:13:05.434
in which case you can invalidate based
on all of the URLs that the current load

177
00:13:05.434 --> 00:13:06.742
functions depend on.

178
00:13:10.727 --> 00:13:14.727
So in that example that we just saw, we
were registering that API now resource as

179
00:13:14.727 --> 00:13:16.891
a dependency because we were fetching it.

180
00:13:16.891 --> 00:13:19.908
But sometimes it's not
appropriate to use fetch,

181
00:13:19.908 --> 00:13:24.906
in which case you can specify a dependency
manually with a function called depends.

182
00:13:27.525 --> 00:13:29.389
And depends takes a URL, but

183
00:13:29.389 --> 00:13:33.130
a URL doesn't need to be
an actual thing on the internet.

184
00:13:33.130 --> 00:13:36.020
It can be just a signifier that we create.

185
00:13:36.020 --> 00:13:39.699
So we can create custom
invalidation keys like data:now.

186
00:13:39.699 --> 00:13:47.570
Inside our layout js, we're gonna get rid
of the fetch and replace it with depends.

187
00:13:49.380 --> 00:13:54.701
And at the top of here,
we're gonna say depends data:now to tell

188
00:13:54.701 --> 00:14:00.860
SvelteKit that this load function
depends on the data:now resource.

189
00:14:00.860 --> 00:14:05.796
I'm just gonna get rid of all of
that stuff and just return date.now

190
00:14:05.796 --> 00:14:10.833
directly from the server load function,
or from the load function.

191
00:14:13.474 --> 00:14:16.526
And then we need to update the invalidate
call so that it's invalidating

192
00:14:16.526 --> 00:14:19.339
the resource that we just created
instead of the API now resource.

193
00:14:20.440 --> 00:14:27.768
So go into the interval and
change that to data:now.

194
00:14:27.768 --> 00:14:28.474
Right, and

195
00:14:28.474 --> 00:14:33.210
we're now invalidating that load function
without even hitting the network.

196
00:14:33.210 --> 00:14:34.790
We're not getting
anything from the server.

197
00:14:34.790 --> 00:14:37.955
We're just rerunning that
load function once a second.

198
00:14:42.418 --> 00:14:45.540
All right, then finally,
there's the nuclear option.

199
00:14:45.540 --> 00:14:49.482
We can invalidate everything on the page
in one go using a function called

200
00:14:49.482 --> 00:14:50.460
invalidateAll.

201
00:14:52.070 --> 00:14:55.800
So we'll get rid of the invalidate input
here, replace that with invalidateAll.

202
00:14:57.460 --> 00:15:01.428
And here,
we'll just get rid of that resource and

203
00:15:01.428 --> 00:15:04.690
specify invalidateAll instead.

204
00:15:04.690 --> 00:15:09.038
And now we can get rid of
that artificial resource.

205
00:15:11.355 --> 00:15:14.597
And now everything is
being reset once a second.

206
00:15:17.359 --> 00:15:21.844
This is what's happening behind the scenes
when you use a progressively enhanced

207
00:15:21.844 --> 00:15:22.690
form, right?

208
00:15:22.690 --> 00:15:25.630
You will post some data to the server,
you will get something back.

209
00:15:25.630 --> 00:15:29.441
SvelteKit is gonna conservatively assume
that something has changed in your app and

210
00:15:29.441 --> 00:15:33.380
that there's probably some data that needs
to be refreshed as a result of that.

211
00:15:33.380 --> 00:15:36.518
So anytime you submit data
with the use enhance action,

212
00:15:36.518 --> 00:15:40.805
SvelteKit is just gonna invalidate
everything, unless you tell it not to.

