WEBVTT

1
00:00:00.000 --> 00:00:03.803
[MUSIC]

2
00:00:03.803 --> 00:00:07.136
&gt;&gt; Brian Holt: Okay, so Hash Tables,
are actually really, really powerful and

3
00:00:07.136 --> 00:00:11.480
use extensively in programming languages,
and just about everywhere.

4
00:00:11.480 --> 00:00:12.880
There are key value stores, right?

5
00:00:12.880 --> 00:00:16.040
So we implement maps or, and or, sets, but

6
00:00:16.040 --> 00:00:20.470
the interesting thing
about hash tables is,

7
00:00:20.470 --> 00:00:26.000
we use the key itself, as to be
the index of where to find it in memory.

8
00:00:28.000 --> 00:00:31.120
And why that's really cool, is that,
as long as we know the key,

9
00:00:31.120 --> 00:00:32.920
we know exactly where it is in memory.

10
00:00:32.920 --> 00:00:34.210
Yeah.
&gt;&gt; Speaker 2: Just to follow up

11
00:00:34.210 --> 00:00:38.139
on that last question from Drew,
would it be faster to recreate the trees?

12
00:00:39.660 --> 00:00:42.850
&gt;&gt; Brian Holt: My guess is yes, but

13
00:00:42.850 --> 00:00:45.610
that's an ignorant guess, because I
don't know how else to do it personally.

14
00:00:48.600 --> 00:00:49.310
I don't know.

15
00:00:49.310 --> 00:00:50.370
Yeah I don't really know.

16
00:00:52.660 --> 00:00:53.650
Okay.

17
00:00:53.650 --> 00:00:58.830
So, the way that we, would hash tables
that we find where to put it in memory,

18
00:00:58.830 --> 00:01:00.830
is we run it through a hashing algorithm,
right?

19
00:01:00.830 --> 00:01:05.100
So basically we say, we run whatever
our key is, usually a string or

20
00:01:05.100 --> 00:01:06.110
a number of some sort.

21
00:01:06.110 --> 00:01:07.440
We run it through a hashing algorithm,

22
00:01:07.440 --> 00:01:12.730
and the hashing algorithm spits out
somewhere in memory to look, right.

23
00:01:12.730 --> 00:01:14.540
So the key is where it is, right?

24
00:01:14.540 --> 00:01:17.590
And such very powerful because,
if we know what the key is,

25
00:01:17.590 --> 00:01:20.599
we know where it is in memory, and
that makes it very fast for lookups.

26
00:01:22.750 --> 00:01:27.230
So, your language is underpinning like
JavaScript objects are implemented using

27
00:01:27.230 --> 00:01:28.050
hash tables.

28
00:01:28.050 --> 00:01:29.810
Databases uses, use hash tables.

29
00:01:29.810 --> 00:01:31.010
Caches use hash tables.

30
00:01:31.010 --> 00:01:34.450
A lot of stuff these hash tables, but

31
00:01:34.450 --> 00:01:37.640
they have constant lookup
time which is awesome, right?

32
00:01:37.640 --> 00:01:39.730
And to just to change
something the key-value store,

33
00:01:39.730 --> 00:01:41.950
all you have to do is Look it
up in memory and replace it.

34
00:01:41.950 --> 00:01:45.170
Or delete, you look up in memory and
delete that memory space and it's deleted.

35
00:01:45.170 --> 00:01:46.740
So it's super fast.

36
00:01:46.740 --> 00:01:50.140
That's why people really like them.

37
00:01:50.140 --> 00:01:52.880
But again, remember hash tables
have no concept of order, right?

38
00:01:52.880 --> 00:01:55.930
Because you're just telling it where it is
a memory you're not actually saying it.

39
00:01:55.930 --> 00:01:59.980
What order there is, so
you can't do order with hash tables.

40
00:02:02.070 --> 00:02:03.940
So, there's a couple things.

41
00:02:03.940 --> 00:02:10.780
You have to have a good hashing algorithm.
&gt;&gt; Brian Holt: We'll talk about.

42
00:02:10.780 --> 00:02:11.550
You need.
First of all,

43
00:02:11.550 --> 00:02:12.990
you need a large memory footprint, right?

44
00:02:12.990 --> 00:02:15.290
Because if you have a hashing algorithm,

45
00:02:15.290 --> 00:02:18.890
you need a sufficiently large
amount of spaces that you can have.

46
00:02:18.890 --> 00:02:23.440
A unique place to put every single object,
and they need to not collide, right?

47
00:02:23.440 --> 00:02:27.710
So, if I run object a, through my
hashing algorithm, and object b,

48
00:02:27.710 --> 00:02:31.700
and there are different objects, and they
should have different spaces in memory and

49
00:02:31.700 --> 00:02:34.084
the hashing algorithm makes
them the same spot memory.

50
00:02:34.084 --> 00:02:37.650
You're gonna accidentally overwrite it,
and that's a problem, right?

51
00:02:37.650 --> 00:02:40.190
So collisions are actually really,
really important,

52
00:02:40.190 --> 00:02:44.020
that your hashing algorithm is
good enough to spread them out.

53
00:02:45.440 --> 00:02:49.250
So let's look at a hashing
algorithm really quick.

54
00:02:50.510 --> 00:02:53.441
Like this one right here,
basically if we did, like,

55
00:02:53.441 --> 00:02:55.878
what's called a Caesarian cipher, right?

56
00:02:55.878 --> 00:02:58.865
Where we just say a is 1,
2 is b, 3 is c, right?

57
00:02:58.865 --> 00:03:00.530
All that stuff.

58
00:03:00.530 --> 00:03:01.590
And then we add them together,

59
00:03:01.590 --> 00:03:04.450
we take that as the index
of wherever it's gonna go.

60
00:03:04.450 --> 00:03:11.370
So 'az' would be, 27, but 'by' would also
be, 27, and 'za' would be 27, right?

61
00:03:11.370 --> 00:03:15.042
So, as you can see that would be
a problem, because a lot of, potentially

62
00:03:15.042 --> 00:03:19.730
similar, like, these similar strings
would end up with similar indexes, right?

63
00:03:19.730 --> 00:03:22.670
So you need to have a sufficiently
complicated algorithm,

64
00:03:22.670 --> 00:03:25.030
to be able to spread them out well.

65
00:03:26.060 --> 00:03:31.350
And so like, I wrote a slightly above
crappy hashing algorithm, and it's

66
00:03:31.350 --> 00:03:34.370
not a good algorithm, but it's better than
the one I just showed you right there.

67
00:03:38.040 --> 00:03:38.859
Hash, right here.

68
00:03:40.010 --> 00:03:43.323
So basically what I did here is,
I did the Caesar cipher, so

69
00:03:43.323 --> 00:03:47.567
I did the input charCodeAt, right,
which is gonna give you back a number for

70
00:03:47.567 --> 00:03:49.853
whatever character we're looking at.

71
00:03:49.853 --> 00:03:55.465
And then I typed it by it's index, so
if it's, a at value one is different

72
00:03:55.465 --> 00:04:00.370
than a at index two,
is different than a at index three, right?

73
00:04:00.370 --> 00:04:02.030
So they have these multiplication right?

74
00:04:03.960 --> 00:04:07.280
And then, what we're doing to make sure
that it always lands within the space of

75
00:04:07.280 --> 00:04:11.450
our hash table, is we're using
the modulus modulo operator.

76
00:04:12.450 --> 00:04:15.510
Which, if you're familiar
with long division, so

77
00:04:15.510 --> 00:04:17.434
if I do 10 divided by 3, right?

78
00:04:17.434 --> 00:04:19.368
It's gonna be, 3 remainder 1, right?

79
00:04:19.368 --> 00:04:21.410
Remember that from elementary school?

80
00:04:21.410 --> 00:04:24.610
What modulus basically says, I don't
actually care what the first number is,

81
00:04:24.610 --> 00:04:27.160
I don't care about the 3,
I just care about the remainder 1.

82
00:04:27.160 --> 00:04:32.260
Which is really interesting, because if I
have a table of length 3 and I do modulus,

83
00:04:32.260 --> 00:04:34.720
you can guarantee that they can be 0,
1 or 2, right?

84
00:04:34.720 --> 00:04:37.600
Because as soon as it comes 3,
then divides whole, it goes back to 0,

85
00:04:37.600 --> 00:04:39.900
so that makes it circular.

86
00:04:39.900 --> 00:04:40.980
Right, and that's exactly what we want.

87
00:04:40.980 --> 00:04:44.350
We wanna make sure that our index always
fall in the range of the hash table.

88
00:04:44.350 --> 00:04:46.669
That make sense?

89
00:04:46.669 --> 00:04:51.575
Okay.
&gt;&gt; Brian Holt: So,

90
00:04:51.575 --> 00:04:53.740
hashing algorithms have to
have a bunch of things.

91
00:04:53.740 --> 00:04:59.370
They need to be,
what we call idempotent or pure.

92
00:04:59.370 --> 00:05:04.600
There's a bunch of, so basically,
you just, if I call double here, 10

93
00:05:04.600 --> 00:05:09.540
billion times, with two, on the 10 billion
for the first time what I'm gonna get?

94
00:05:10.730 --> 00:05:13.310
Still gonna be four,
if I call it with two.

95
00:05:14.420 --> 00:05:16.090
That's because this
function is idempotent,

96
00:05:16.090 --> 00:05:18.160
it doesn't modify any state around it.

97
00:05:18.160 --> 00:05:20.550
It just does one thing and it's done.

98
00:05:20.550 --> 00:05:21.290
And modify it, yeah,

99
00:05:21.290 --> 00:05:24.620
doesn't modify any, has no side
effects is what we would call that.

100
00:05:25.710 --> 00:05:28.900
However, this one, if I call this
one ten billion times with two,

101
00:05:28.900 --> 00:05:31.140
what I'm gonna get on the ten
billionth and first time?

102
00:05:32.250 --> 00:05:33.940
Some insanely large number, right?

103
00:05:33.940 --> 00:05:38.260
Because this multiplier keeps changing
with every single time I call it.

104
00:05:38.260 --> 00:05:39.830
That's called the side effect.

105
00:05:39.830 --> 00:05:45.760
And we really are hashing algorithm cannot
have that, because if I give you object a,

106
00:05:45.760 --> 00:05:50.080
now and then I give it to you, you know
much later, I need to get the same answer

107
00:05:50.080 --> 00:05:52.110
out of you because I need to look
at the same space in memory.

108
00:05:53.250 --> 00:05:54.250
So that's important.

109
00:05:54.250 --> 00:06:00.010
And use to spread them out while,
we already talked about that a little bit.

110
00:06:00.010 --> 00:06:02.900
Yeah, question.
&gt;&gt; Speaker 2: Yes, Dave is

111
00:06:02.900 --> 00:06:06.900
asking if there's a way to maintain
constant lookup time with a hash table and

112
00:06:06.900 --> 00:06:11.770
maintain order?
&gt;&gt; Brian Holt: I don't

113
00:06:11.770 --> 00:06:13.220
know to be totally honest.

114
00:06:14.240 --> 00:06:21.040
I'm sure there's abstractions, you can
put on top of hash tables that do that.

115
00:06:21.040 --> 00:06:25.017
But a hash table in and of itself, like a
pure implemented hash table does not have

116
00:06:25.017 --> 00:06:32.906
order.
&gt;&gt; Brian Holt: Good question though.

117
00:06:32.906 --> 00:06:33.792
Okay.

118
00:06:36.180 --> 00:06:38.390
you just have a good distribution
of value, we talked about that.

119
00:06:39.900 --> 00:06:44.040
And the other thing is hash tables are
built to be really, really performance.

120
00:06:44.040 --> 00:06:47.500
So if your hashing algorithm
is cryptographically secure,

121
00:06:47.500 --> 00:06:50.670
which is means you're using extremely
large prime numbers to combinate to

122
00:06:50.670 --> 00:06:54.110
make these crazy things, you're
totally defeating the purpose, right?

123
00:06:54.110 --> 00:06:59.420
Because at that point, your hashing
algorithm is no longer performant.

124
00:06:59.420 --> 00:07:01.830
And thus,
your lookups are gonna be really gross,

125
00:07:01.830 --> 00:07:05.700
because you have to go through this crazy
algorithm to get the correct index.

126
00:07:05.700 --> 00:07:11.815
So making sure you have something
really fast is really important.

127
00:07:11.815 --> 00:07:15.395
In other words, you're not gonna use
something like, two fifty six or something

128
00:07:15.395 --> 00:07:18.668
like that, that's not a good one to use
for this, but you might use MD5, right?

129
00:07:18.668 --> 00:07:20.830
MD5 is actually pretty fast.

130
00:07:20.830 --> 00:07:26.238
So, okay, so
looking here at our hash table,

131
00:07:26.238 --> 00:07:31.520
we just create this new giant array,
right?

132
00:07:32.620 --> 00:07:37.240
And to add something we just say,
to our table hash whatever our input

133
00:07:37.240 --> 00:07:42.270
is, and
put that wherever it needs to go, right?

134
00:07:42.270 --> 00:07:45.940
And then check,
we just need to check is like,

135
00:07:45.940 --> 00:07:47.360
hey do you have something in memory there?

136
00:07:47.360 --> 00:07:50.090
So in this case we're implementing
a set using a hash table.

137
00:07:50.090 --> 00:07:52.650
You just ask,
hey do you have something there?

138
00:07:53.680 --> 00:07:54.320
Okay.
You do?

139
00:07:54.320 --> 00:07:55.660
Then yes, it's there.

140
00:07:55.660 --> 00:07:56.760
Otherwise, no, I don't.

141
00:07:56.760 --> 00:07:59.310
That's what the double
exclamation point means.

142
00:07:59.310 --> 00:08:01.580
It's just converting this to be true or
false.

143
00:08:01.580 --> 00:08:07.200
That's all.
&gt;&gt; Brian Holt: And then hash, right?

144
00:08:07.200 --> 00:08:09.520
I just did that hashing algorithm.

145
00:08:09.520 --> 00:08:12.350
Like I said, it's slightly above crappy.

146
00:08:12.350 --> 00:08:13.760
Definitely below mediocre.

147
00:08:15.650 --> 00:08:17.890
And yeah, just some test to make
sure that, that's the case.

148
00:08:20.580 --> 00:08:21.820
So, good stuff to know.

149
00:08:21.820 --> 00:08:23.260
Any questions about hash tables?

150
00:08:26.450 --> 00:08:28.820
Like if you're doing something that needs,
like, sets or

151
00:08:28.820 --> 00:08:31.280
maps, hash tables are definitely
a good way to go.

152
00:08:32.970 --> 00:08:34.870
Providing you have a good
hashing algorithm.

153
00:08:34.870 --> 00:08:37.460
That's kind of the key to a hash table
is your hashing has to be really great.

