WEBVTT

1
00:00:00.157 --> 00:00:04.179
&gt;&gt; Melkey: Let's quickly talk
about arrays and slices.

2
00:00:04.179 --> 00:00:08.032
When individuals think of an array,
they think of a list,

3
00:00:08.032 --> 00:00:11.267
and I think that's
an appropriate definition.

4
00:00:11.267 --> 00:00:13.508
It stores a bunch of values, right?

5
00:00:13.508 --> 00:00:18.122
An array could be fairly versatile,
it's a very powerful data structure.

6
00:00:18.122 --> 00:00:21.221
And slices might be a new terminology for

7
00:00:21.221 --> 00:00:25.334
some individuals,
depending on their background.

8
00:00:25.334 --> 00:00:29.137
For example, in Python,
an array is dynamic.

9
00:00:29.137 --> 00:00:32.895
You can continuously append to an array,
and Python just gives you a thumbs up and

10
00:00:32.895 --> 00:00:34.232
smiles all the way through.

11
00:00:34.232 --> 00:00:39.665
That's not necessarily the same case for
Go and other programming language, okay?

12
00:00:39.665 --> 00:00:44.444
So If you want to declare a array,
we're going to declare the name, so

13
00:00:44.444 --> 00:00:50.033
numbers are short form notation, and the
syntax for an array is square brackets,

14
00:00:50.033 --> 00:00:54.747
and then the capacity or
length of this array here, so five, right?

15
00:00:54.747 --> 00:00:59.929
This is telling the compiler we expect
this array to hold five values.

16
00:00:59.929 --> 00:01:03.728
The following argument or
the following definitions,

17
00:01:03.728 --> 00:01:05.921
what type R can that array hold?

18
00:01:05.921 --> 00:01:10.488
In Go, we cannot hold multi types in
an array, you can only have one array that

19
00:01:10.488 --> 00:01:15.649
holds ints, one array that holds structs,
one array that holds strings, etc, etc.

20
00:01:15.649 --> 00:01:17.573
So we can define it like so.

21
00:01:17.573 --> 00:01:21.315
So we have our numbers,
it's gonna hold five, and

22
00:01:21.315 --> 00:01:26.903
we can just Populate these with ten,
20, 30, 40, and 50, okay?

23
00:01:26.903 --> 00:01:31.061
If you try to put 60, the compiler says
index five is out of balance because it

24
00:01:31.061 --> 00:01:34.337
understands that this numbers
array can only hold five ints so

25
00:01:34.337 --> 00:01:35.918
we're gonna adhere to that.

26
00:01:35.918 --> 00:01:41.804
It's completely fine if we don't have
the full five matching the full capacity,

27
00:01:41.804 --> 00:01:46.154
we can append to it or
assign a more appropriate definition,

28
00:01:46.154 --> 00:01:49.224
be assigning that last slot to a value,
but

29
00:01:49.224 --> 00:01:54.382
here we'll just declare numbers as
the full array of integers, okay?

30
00:01:54.382 --> 00:01:59.472
And just for funsies, I know this can
be annoying, but if I put a string,

31
00:01:59.472 --> 00:02:03.660
obviously, the composite
cannot use string, all right?

32
00:02:06.291 --> 00:02:10.127
&gt;&gt; Melkey: So that's an array, and
arrays cannot change once it defined,

33
00:02:10.127 --> 00:02:11.984
it can only hold five, right?

34
00:02:11.984 --> 00:02:17.105
So I cannot add a six value to my numbers,

35
00:02:17.105 --> 00:02:21.637
or I cannot do numbers five=60.

36
00:02:21.637 --> 00:02:22.928
And there's no way you can change this.

37
00:02:22.928 --> 00:02:26.876
Once the array is defined and set,
that's the only capacity you can do.

38
00:02:26.876 --> 00:02:28.972
You can change values in the array, right?

39
00:02:28.972 --> 00:02:31.625
You can reassign the zeroth index, right?

40
00:02:31.625 --> 00:02:35.727
If I wanted to, to 60, that's all good,
everyone's happy about that.

41
00:02:35.727 --> 00:02:41.095
But adding more capacity to
the array is not possible,

42
00:02:41.095 --> 00:02:43.788
it's at definition time.

43
00:02:43.788 --> 00:02:48.462
Okay, we can print this array,
we can do format, we can do print F,

44
00:02:48.462 --> 00:02:51.415
I'll show the format specifier for this.

45
00:02:51.415 --> 00:02:56.224
We say this is our array, and
this would actually be modulo V.

46
00:02:56.224 --> 00:03:01.917
We can put a new line and
type in our numbers array like so.

47
00:03:01.917 --> 00:03:06.192
And see we have our array 10,
20, 30, 40, and 50.

48
00:03:06.192 --> 00:03:08.115
Okay, so
we can access values of the array.

49
00:03:08.115 --> 00:03:10.772
So we can do like zero to
access the zero value,

50
00:03:10.772 --> 00:03:13.031
we get the length of the array, right?

51
00:03:13.031 --> 00:03:16.604
So we can do something like
the keyword length, and

52
00:03:16.604 --> 00:03:19.023
type in numbers to get the length.

53
00:03:19.023 --> 00:03:22.519
So, there's a few ways we
can bounce around our array.

54
00:03:22.519 --> 00:03:27.129
These are typical functions you
would see in most implemented

55
00:03:27.129 --> 00:03:30.150
languages of how to navigate the array.

56
00:03:30.150 --> 00:03:36.101
So don't think there's
any hidden secrets there.

57
00:03:36.101 --> 00:03:40.906
If you want to access kind of the last
value, maybe one other thing of any array,

58
00:03:40.906 --> 00:03:44.299
you can do something like format,
just print the line.

59
00:03:44.299 --> 00:03:46.814
This is the last value.

60
00:03:46.814 --> 00:03:50.405
So if you wanna access the last value,
you can do numbers access it,

61
00:03:50.405 --> 00:03:51.917
and do something like this.

62
00:03:51.917 --> 00:03:58.192
So this hopefully would print 50, and
there you go, there's the last value 50.

63
00:03:58.192 --> 00:04:01.920
Cool, you could do one other trick,
I'll quickly show this.

64
00:04:01.920 --> 00:04:05.949
It's an array with size
determined at initialization.

65
00:04:05.949 --> 00:04:11.741
I personally have never
seen this useful ever but

66
00:04:11.741 --> 00:04:16.129
I'll just show you, numbers in it.

67
00:04:16.129 --> 00:04:23.474
So, instead of putting a five here,
you can explicitly do like this.

68
00:04:23.474 --> 00:04:30.346
It's like I personally don't truly
see how useful this could be.

69
00:04:30.346 --> 00:04:35.082
But, instead of writing explicitly five
if you know on initialization, again,

70
00:04:35.082 --> 00:04:38.375
how many values can be,
you can just write them all out and

71
00:04:38.375 --> 00:04:40.450
just put the three ellipses there.

72
00:04:40.450 --> 00:04:46.262
But again, for me,
I don't see too much value in that.

73
00:04:46.262 --> 00:04:48.383
I'm gonna comment it out.

74
00:04:48.383 --> 00:04:50.127
Yeah, so those are arrays.

75
00:04:50.127 --> 00:04:53.541
You can have multidimensional arrays too,
so like a matrix.

76
00:04:53.541 --> 00:04:55.552
I'll quickly show this before moving on.

77
00:04:55.552 --> 00:04:58.931
You can have a matrix and
it goes column row.

78
00:04:58.931 --> 00:05:03.804
So, something like two, three, and
then you can initialize it with the type,

79
00:05:03.804 --> 00:05:06.591
and then individual brackets here, right?

80
00:05:06.591 --> 00:05:12.040
So, if I were to just have the function
like so, this would not be valid Go,

81
00:05:12.040 --> 00:05:16.032
it would not be specified on
the correct column index.

82
00:05:16.032 --> 00:05:20.661
You have to put an additional curly
braces followed by the comma cuz

83
00:05:20.661 --> 00:05:25.136
the compile yells at you and
then following another one like so.

84
00:05:25.136 --> 00:05:29.404
We can put some values here,
we can put one, two, and three, and

85
00:05:29.404 --> 00:05:31.897
then we can put four, five, and six.

86
00:05:31.897 --> 00:05:34.942
We can save this, and
then right here, we can do format.

87
00:05:34.942 --> 00:05:38.194
We can use our Printf with
our format specifier.

88
00:05:38.194 --> 00:05:40.730
This is our Matrix.

89
00:05:40.730 --> 00:05:45.144
I'm gonna do modular V, break the line and
put the matrix like so.

90
00:05:51.231 --> 00:05:52.151
&gt;&gt; Melkey: So there you go.

91
00:05:52.151 --> 00:05:58.202
All right, again, just some, I guess,
derivatives on an array type,

92
00:05:58.202 --> 00:06:04.178
I just wanna make sure I show as many
things I could think of with a raise.

