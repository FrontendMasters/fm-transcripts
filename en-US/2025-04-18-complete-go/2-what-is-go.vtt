WEBVTT

1
00:00:00.000 --> 00:00:04.086
&gt;&gt; Melkey: Go is a statically typed
compiled programming language.

2
00:00:04.086 --> 00:00:06.536
It's a general purpose language, so

3
00:00:06.536 --> 00:00:11.908
I know a lot of the time certain languages
are catered for certain aspects, right?

4
00:00:11.908 --> 00:00:16.135
If you think of Typescript, Typescript is
also like a general purpose language, but

5
00:00:16.135 --> 00:00:18.259
its primary use case is in web dev, right?

6
00:00:18.259 --> 00:00:22.034
A lot of people use Typescript Interacting
with front end libraries.

7
00:00:22.034 --> 00:00:26.304
It's probably one of the best options for
that aspect of work.

8
00:00:26.304 --> 00:00:30.560
In Go, Go is labeled as
a general purpose language, and

9
00:00:30.560 --> 00:00:36.097
I think you'll see why, because
there's great tooling built with Go.

10
00:00:36.097 --> 00:00:39.495
Whether that's developer tool like
CLI apps or something like that.

11
00:00:39.495 --> 00:00:42.394
You can build version managers with Go.

12
00:00:42.394 --> 00:00:45.098
You can build backend servers with Go.

13
00:00:45.098 --> 00:00:47.864
Microservices, the list goes on and
on and on.

14
00:00:47.864 --> 00:00:52.201
It's a compiled programming language,
so it compiles to an executable binary.

15
00:00:52.201 --> 00:00:53.731
I'll show you guys how you can do that.

16
00:00:53.731 --> 00:00:54.879
And it's statically typed.

17
00:00:54.879 --> 00:00:57.638
So at the beginning when I was saying,
Javascript and

18
00:00:57.638 --> 00:01:01.885
Python are typically seen as the first
language you should learn or recommended.

19
00:01:01.885 --> 00:01:04.026
Like, yeah,
those are great languages, right?

20
00:01:04.026 --> 00:01:07.204
We can make the argument that
JavaScript and Python are good.

21
00:01:07.204 --> 00:01:12.527
They are good intros, but
a lot of time people gloss over the fact

22
00:01:12.527 --> 00:01:19.448
that language can be statically typed,
and how important type safety is, right?

23
00:01:19.448 --> 00:01:22.013
And other concepts that,
I think Go introduced, so

24
00:01:22.013 --> 00:01:23.716
these being a few of them, right?

25
00:01:23.716 --> 00:01:25.541
So that's kind of why I'm a big fan of Go.

26
00:01:25.541 --> 00:01:29.710
I actually started as a Python developer,
and then I was introduced to Go and

27
00:01:29.710 --> 00:01:31.349
I haven't really gone back.

28
00:01:31.349 --> 00:01:33.630
I just think Go is far superior.

29
00:01:33.630 --> 00:01:37.244
But on that same topic, Python is
the language of machine learning, right?

30
00:01:37.244 --> 00:01:43.491
So, there's certain aspects of when
to use a tool and why to use a tool.

31
00:01:43.491 --> 00:01:47.252
It was designed at Google
by a fairly large team.

32
00:01:47.252 --> 00:01:51.787
I think it was, 10 to 15 people.

33
00:01:51.787 --> 00:01:56.653
But three individuals that I would
like to highlight are Robert Grasmer,

34
00:01:56.653 --> 00:01:58.623
Rob Pike, and Ken Thompson.

35
00:01:58.623 --> 00:02:04.339
So, it was designed at Google in two 2007,
it was publicly announced in 09,

36
00:02:04.339 --> 00:02:07.618
and then version 1.0 released in 2012.

37
00:02:07.618 --> 00:02:11.635
So it was in the works for a long time.

38
00:02:11.635 --> 00:02:15.362
And Go itself is known for
its simplicity, efficiency,

39
00:02:15.362 --> 00:02:18.635
and strong support for
concurrent programming.

40
00:02:18.635 --> 00:02:20.249
Okay, why is go important?

41
00:02:20.249 --> 00:02:23.104
It could open a lot of doors for
a lot of people, like I've already said.

42
00:02:23.104 --> 00:02:25.646
People who are new to programming,

43
00:02:25.646 --> 00:02:29.301
people who wanna switch
from front end to back end.

44
00:02:29.301 --> 00:02:33.441
I always get these questions like,
I've been in web dev for so many years, or

45
00:02:33.441 --> 00:02:37.221
I've been in web dev for the first two
years of my career, and it's great,

46
00:02:37.221 --> 00:02:39.757
I like it, but
I wanna get more into back end, Go.

47
00:02:39.757 --> 00:02:42.567
People wanna switch from
different languages, Go, right?

48
00:02:42.567 --> 00:02:45.740
And not just saying front-end
languages to back-end languages,

49
00:02:45.740 --> 00:02:49.815
let's say even a PHP developer, or a.net
developer, and you wanna switch, right?

50
00:02:49.815 --> 00:02:51.709
I think Go is great.

51
00:02:51.709 --> 00:02:55.340
I think it's gonna be a great
answer to these questions.

52
00:02:55.340 --> 00:02:59.940
It's really good at a lot of different
things, like we've seen, dev tooling,

53
00:02:59.940 --> 00:03:04.475
creating CLIs, infrastructure,
networking, like we've just discussed in

54
00:03:04.475 --> 00:03:08.148
the 32nd conversation,
all the things go is good at, right?

55
00:03:08.148 --> 00:03:08.841
And then,

56
00:03:08.841 --> 00:03:13.774
one thing I really wanted to highlight
on this slide is developer velocity.

57
00:03:13.774 --> 00:03:15.753
Developer velocity, to me,

58
00:03:15.753 --> 00:03:19.482
does not mean how fast you can
get a feature out the door.

59
00:03:19.482 --> 00:03:24.352
Because, let's say, you've been a goal
developer for 2 or 3 years, but

60
00:03:24.352 --> 00:03:29.318
you face off with this wizard in C,
who's been writing C for 20 plus years.

61
00:03:29.318 --> 00:03:32.204
You're both asked to create a feature,
who's gonna do it faster?

62
00:03:32.204 --> 00:03:34.276
I'm gonna put my money on the wizard,
all right?

63
00:03:34.276 --> 00:03:39.208
Not to insult anyone's skill, but that
just shows why that previous definition

64
00:03:39.208 --> 00:03:41.760
of developer velocity has a bit of a flaw.

65
00:03:41.760 --> 00:03:46.913
The way I view developer velocity is,
how much tooling can we provide for

66
00:03:46.913 --> 00:03:49.879
the developer to not be blocked, right?

67
00:03:49.879 --> 00:03:54.252
What are all the things that we can give
someone to make sure that they can execute

68
00:03:54.252 --> 00:03:57.924
their task however long it is,
right, from start to completion?

69
00:03:57.924 --> 00:04:01.192
And I think Go has a great
developer velocity for

70
00:04:01.192 --> 00:04:06.096
people to jump right into a language,
understand what's happening,

71
00:04:06.096 --> 00:04:11.264
start using it, go into repo, and
start understanding what's going on.

72
00:04:11.264 --> 00:04:16.038
And this last one, a strong option for
cloud computing infrastructure.

73
00:04:16.038 --> 00:04:19.983
So I get asked a fair amount of time,
hey, Melkey, I'm nervous, right?

74
00:04:19.983 --> 00:04:25.884
AI is taking my job, all this stuff
is happening, what should I do?

75
00:04:25.884 --> 00:04:28.483
Should I continue to be a programmer or
should I continue to be a web dev?

76
00:04:28.483 --> 00:04:29.981
Should just be a back end?

77
00:04:29.981 --> 00:04:34.063
My answer, then again, take it with
a grain of salt, this is just my opinion.

78
00:04:34.063 --> 00:04:38.069
I think everyone should learn cloud
computing, cloud infrastructure,

79
00:04:38.069 --> 00:04:40.790
something like AWS, GCP,
Azure, Cloud Flare.

80
00:04:40.790 --> 00:04:43.795
I think are great things to
learn right now for people,

81
00:04:43.795 --> 00:04:47.077
because as you saw with LLMs,
create this function for me.

82
00:04:47.077 --> 00:04:48.902
Sure, [SOUND] Copy Paste.

83
00:04:48.902 --> 00:04:50.096
Okay, cool.

84
00:04:50.096 --> 00:04:51.123
A lot of people can do that.

85
00:04:51.123 --> 00:04:56.206
Understanding the inner workings of
certain tooling that cloud offers and

86
00:04:56.206 --> 00:05:01.703
why to use them, I think is so important
that I don't think LLMs can do right now.

87
00:05:01.703 --> 00:05:05.170
Because I think at that point the
conversation becomes from a programmer to

88
00:05:05.170 --> 00:05:07.048
an architect, to assistant designer.

89
00:05:07.048 --> 00:05:10.975
I think those skills are gonna
be harder and harder for

90
00:05:10.975 --> 00:05:14.212
any LLM to even make a case against,
right?

91
00:05:14.212 --> 00:05:17.726
And, Go is great for
cloud computing infrastructure.

92
00:05:17.726 --> 00:05:19.988
Like I've said previously,
the SDKs are phenomenal.

93
00:05:19.988 --> 00:05:24.472
A lot of teams, a lot of companies,
all those cloud companies create SDKs

94
00:05:24.472 --> 00:05:28.251
using Go, and even create some
of the services in Go, right?

95
00:05:28.251 --> 00:05:32.777
So, yeah, I think if you really kind
of ask me why do I recommend Go, for

96
00:05:32.777 --> 00:05:38.067
someone's career, someone's growth,
I think cloud computing is the way to go.

