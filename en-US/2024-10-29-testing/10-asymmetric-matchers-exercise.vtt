WEBVTT

1
00:00:00.000 --> 00:00:02.109
&gt;&gt; Steve Kinney: But now,
what I'm gonna challenge you with is,

2
00:00:02.109 --> 00:00:03.350
that's our little person.

3
00:00:03.350 --> 00:00:04.550
It's great, it's wonderful.

4
00:00:04.550 --> 00:00:07.965
We've also got these characters.

5
00:00:07.965 --> 00:00:11.244
I've never played Dungeons &amp; Dragons, so

6
00:00:11.244 --> 00:00:16.394
no one fact-checked me on this at all or
what any of this stuff means.

7
00:00:16.394 --> 00:00:20.457
I did Google, like, what the kind
of diet you might use was, and

8
00:00:20.457 --> 00:00:24.308
that was about but
we've got this rollDice function right.

9
00:00:24.308 --> 00:00:28.012
And I believe it takes 4,6 sided.

10
00:00:28.012 --> 00:00:29.650
I don't know what I'm doing here, okay?

11
00:00:29.650 --> 00:00:31.618
I'm getting nods from the group,
which means,

12
00:00:31.618 --> 00:00:34.464
like this is I might as well be making
a sports reference at this point.

13
00:00:34.464 --> 00:00:38.835
So ideally we're gonna generate
a whole bunch of random

14
00:00:38.835 --> 00:00:43.671
numbers as well as a new date just
to make our lives extra hard.

15
00:00:43.671 --> 00:00:49.262
And then some things that should
definitely be what we passed in, right?

16
00:00:49.262 --> 00:00:54.477
And so
your job is to the best of your ability,

17
00:00:54.477 --> 00:00:58.195
can you get these tests to pass?

18
00:00:58.195 --> 00:01:01.612
What, he's not gonna walk me
through this and hold my hand no,

19
00:01:01.612 --> 00:01:03.233
I'm not gonna do it anymore.

20
00:01:03.233 --> 00:01:07.568
This one, you're gonna take a run at it,
get frustrated and sad, and

21
00:01:07.568 --> 00:01:11.038
then I will swoop in with
the answers I wrote in advance.

22
00:01:16.067 --> 00:01:17.328
&gt;&gt; Steve Kinney: We're gonna look
at it from three different ways.

23
00:01:17.328 --> 00:01:22.697
The right answer is whichever
one feels best to you, right?

24
00:01:22.697 --> 00:01:24.694
So we'll go ahead.

25
00:01:24.694 --> 00:01:25.548
We'll mark this.

26
00:01:25.548 --> 00:01:32.250
It technically passes only
if we're running our tests.

27
00:01:32.250 --> 00:01:33.438
Technically, it passes.

28
00:01:33.438 --> 00:01:34.545
Why does it pass?

29
00:01:34.545 --> 00:01:36.164
Because it doesn't fail.

30
00:01:36.164 --> 00:01:39.176
And that is the only
prerequisite to passing.

31
00:01:39.176 --> 00:01:46.522
Cool, so we'll go ahead and
we'll make a character and

32
00:01:46.522 --> 00:01:52.618
that will be a new Character
let's call Ada and

33
00:01:52.618 --> 00:01:59.202
then correct me this is a real D&amp;D class,
right?

34
00:01:59.202 --> 00:02:03.356
Kind of like a necromancer I
believe If I'm not mistaken.

35
00:02:03.356 --> 00:02:05.022
We've got this computer scientist.

36
00:02:05.022 --> 00:02:08.298
And like I said, of the different
ways we can tackle this one,

37
00:02:08.298 --> 00:02:11.458
we're gonna start with just
the silliest or the simplest.

38
00:02:11.458 --> 00:02:12.694
Not silly, it's simple.

39
00:02:12.694 --> 00:02:13.837
It's very serious.

40
00:02:13.837 --> 00:02:19.887
It's just simple, which gets the job done
and thereby is a right answer that counts.

41
00:02:19.887 --> 00:02:25.106
Which is to say expect
that character.firstName,

42
00:02:25.106 --> 00:02:30.559
very similar to what we were doing before,
to be as long

43
00:02:30.559 --> 00:02:37.688
as you accomplish what you said you
were gonna do on the tin, all right?

44
00:02:37.688 --> 00:02:41.347
If you say you're gonna verify, it has
these three things you only verify two,

45
00:02:41.347 --> 00:02:43.046
then you technically lose, right?

46
00:02:43.046 --> 00:02:48.425
But if, as long as you check all three,
you win.

47
00:02:48.425 --> 00:02:52.257
And then we'll talk about some other
ways that we can handle this as well.

48
00:02:55.357 --> 00:03:04.008
&gt;&gt; Steve Kinney: Cool,
&gt;&gt; Steve Kinney: Roll,

49
00:03:08.161 --> 00:03:09.679
&gt;&gt; Steve Kinney: To be computer

50
00:03:09.679 --> 00:03:12.085
scientists, right?

51
00:03:12.085 --> 00:03:16.625
Now, things that I might
choose to do here,

52
00:03:16.625 --> 00:03:21.658
depending, which is what
you don't want is this

53
00:03:21.658 --> 00:03:26.348
test to fail because you made a typo,
right?

54
00:03:26.348 --> 00:03:30.054
Which arguably is not bad for
the long-term health of your code base

55
00:03:30.054 --> 00:03:32.654
cuz you will find the typo
when your tests fail,

56
00:03:32.654 --> 00:03:36.833
but it is probably important to your
short-term mental health sometimes.

57
00:03:36.833 --> 00:03:40.106
So what you could do do for instance,
and I think for a larger thing,

58
00:03:40.106 --> 00:03:41.378
it might make more sense.

59
00:03:41.378 --> 00:03:43.017
You could do something like firstName.

60
00:03:51.074 --> 00:03:53.581
&gt;&gt; Steve Kinney: And this is also
useful if you're gonna do like

61
00:03:53.581 --> 00:03:56.670
a lot of tests and
maybe start using semicolons instead of

62
00:03:56.670 --> 00:04:01.155
commas
&gt;&gt; Steve Kinney: Which is I'm just

63
00:04:01.155 --> 00:04:05.775
gonna verify that they are the same and
I don't wanna type these things over and

64
00:04:05.775 --> 00:04:06.548
over again.

65
00:04:06.548 --> 00:04:09.066
This will just stop you from making typos,
that's all.

66
00:04:09.066 --> 00:04:10.786
So you can do firstName.

67
00:04:13.850 --> 00:04:16.310
&gt;&gt; Steve Kinney: And
then here you can kinda do the same thing.

68
00:04:21.339 --> 00:04:24.018
&gt;&gt; Steve Kinney: Definitely more
useful for bigger objects, but

69
00:04:24.018 --> 00:04:28.673
the principle works regardless if you've
made an overly contrived example or not.

70
00:04:28.673 --> 00:04:30.124
Cool, so that'll work.

71
00:04:30.124 --> 00:04:35.074
The other thing that we can do is start
to bring in some of those things that we

72
00:04:35.074 --> 00:04:36.025
saw earlier.

73
00:04:36.025 --> 00:04:38.307
There's some ones that we
didn't talk about here as well.

74
00:04:38.307 --> 00:04:44.316
So if we did something, and this will show
you like kind of the nature of toEqual.

75
00:04:44.316 --> 00:04:47.050
So we'll say expect character.

76
00:04:47.050 --> 00:04:49.573
Let's start with a test
that is gonna fail.

77
00:04:49.573 --> 00:04:54.890
toEqual, and we're gonna say

78
00:04:54.890 --> 00:05:00.624
firstName, lastName and roll.

79
00:05:00.624 --> 00:05:06.347
And while those are all true, the issue
is that we have many more things, right?

80
00:05:06.347 --> 00:05:10.709
And so, that's they're not technically
equal because there's a bunch

81
00:05:10.709 --> 00:05:15.362
of additional values here that you're
not necessarily looking for, right?

82
00:05:15.362 --> 00:05:20.794
Now you have a bunch of ways you
can handle this we saw before there

83
00:05:20.794 --> 00:05:26.430
was that object or expect array
containing or object containing,

84
00:05:26.430 --> 00:05:32.385
so we could do expect object containing,
that one will pass, right?

85
00:05:32.385 --> 00:05:37.546
This will basically say,
hey this character we want to equal.

86
00:05:37.546 --> 00:05:40.781
Some object that has the right first and
lastName and role.

87
00:05:40.781 --> 00:05:47.188
And so, for instance
&gt;&gt; Steve Kinney: This

88
00:05:47.188 --> 00:05:50.097
one fulfills the nature of
the test as well, right?

89
00:05:50.097 --> 00:05:53.792
Where if something became not what we
expected of the three things we're looking

90
00:05:53.792 --> 00:05:55.764
for in the name of this test,
then we fail.

91
00:05:55.764 --> 00:05:58.064
But honestly,
as long as it has these three properties.

92
00:05:58.064 --> 00:06:02.172
We don't necessarily care about
the other things that it has, right?

93
00:06:02.172 --> 00:06:05.938
This is good for like really gigantic
API requests or something like that,

94
00:06:05.938 --> 00:06:08.327
or in some cases where you
have a giant object and

95
00:06:08.327 --> 00:06:12.237
you're only trying to add one new
property to it, like what you don't want.

96
00:06:12.237 --> 00:06:16.352
Let's say that object came from somewhere
else in the code base you're just trying

97
00:06:16.352 --> 00:06:19.020
to add maybe a create date or
last modified date to it.

98
00:06:19.020 --> 00:06:21.676
What you don't want is that
object changing somewhere else.

99
00:06:21.676 --> 00:06:24.294
If all we're supposed to do is add
one new property to it, right?

100
00:06:24.294 --> 00:06:26.838
You're like,
I don't care what else is in this object,

101
00:06:26.838 --> 00:06:29.970
as long as it has a new property that
I expect to come out of this, cool.

102
00:06:29.970 --> 00:06:33.379
And that's a way to make your test not,
cuz if your tests are failing all over

103
00:06:33.379 --> 00:06:36.541
the place for reasons that are not
important, what you're gonna do?

104
00:06:36.541 --> 00:06:39.110
You're gonna stop writing tests,
or you start removing them or

105
00:06:39.110 --> 00:06:40.167
stuff along those lines.

106
00:06:40.167 --> 00:06:45.225
Sometimes these strategies are you could
argue, well, is this not as exactly cool?

107
00:06:45.225 --> 00:06:46.878
Were you gonna delete the test, otherwise?

108
00:06:46.878 --> 00:06:53.855
You were, and so sometimes it's about
stopping your own worst desires.

109
00:06:53.855 --> 00:06:55.137
So this will solve for it.

110
00:06:55.137 --> 00:07:00.307
To show you some other ways that we
could do it, we could do something

111
00:07:00.307 --> 00:07:05.114
like we can do that firstName,
lastName, and roll again, and

112
00:07:05.114 --> 00:07:10.670
that is gonna fail because we've got
all these additional properties.

113
00:07:10.670 --> 00:07:16.060
What we could also do is to say
something along the lines for

114
00:07:16.060 --> 00:07:18.810
instance, strength Night,

115
00:07:18.810 --> 00:07:24.319
we'll decide if we want to watch
me go all the way with this.

116
00:07:26.769 --> 00:07:33.191
&gt;&gt; Steve Kinney: We can do expect,
&gt;&gt; Steve Kinney: Which

117
00:07:33.191 --> 00:07:36.182
is to say we'll take
anything of this type.

118
00:07:36.182 --> 00:07:38.754
So like, expect any number, right?

119
00:07:38.754 --> 00:07:40.240
Because we're getting
it's a random number,

120
00:07:40.240 --> 00:07:41.434
we don't really know what to do here.

121
00:07:41.434 --> 00:07:45.106
So now you can see that in terms
of things that don't match,

122
00:07:45.106 --> 00:07:48.274
as long as this is a number,
we don't really care.

123
00:07:48.274 --> 00:07:51.386
That way, we can control for
the randomness as well.

124
00:07:51.386 --> 00:07:56.351
Can he remember all of the D&amp;D
properties on his own?

125
00:07:56.351 --> 00:07:58.620
We'll find out together.

126
00:07:58.620 --> 00:08:01.150
Austerity, that's one.

127
00:08:03.790 --> 00:08:09.149
&gt;&gt; Steve Kinney: Intelligence,
that's why I have an audience.

128
00:08:09.149 --> 00:08:10.979
Was it, I can also look it up.

129
00:08:10.979 --> 00:08:15.716
[INAUDIBLE]
&gt;&gt; Steve Kinney: You ever

130
00:08:15.716 --> 00:08:19.157
try to spell while
people are watching you?

131
00:08:19.157 --> 00:08:20.301
Cool, cool, cool.

132
00:08:20.301 --> 00:08:23.862
&gt;&gt; Speaker 2: Charisma
&gt;&gt; Steve Kinney: Charisma, now,

133
00:08:23.862 --> 00:08:29.417
are we going for a victory lap
over what this test actually says?

134
00:08:29.417 --> 00:08:32.700
Okay, so, some interesting ones in here.

135
00:08:32.700 --> 00:08:34.215
Level, we do wanna be one, right?

136
00:08:34.215 --> 00:08:35.339
Because they should start at level one.

137
00:08:35.339 --> 00:08:37.349
I should probably rename
the test at some point, but

138
00:08:37.349 --> 00:08:40.241
we could say that level, that one we
care about, that should be a default.

139
00:08:40.241 --> 00:08:42.420
I might change this one, like,

140
00:08:42.420 --> 00:08:46.390
it should start out with
the correct initial properties.

141
00:08:46.390 --> 00:08:47.704
The problem with this test is,

142
00:08:47.704 --> 00:08:50.486
if one thing breaks, you now have
to squint at a very big diff, and

143
00:08:50.486 --> 00:08:53.488
there's an argument of breaking
this out into little tests, right?

144
00:08:53.488 --> 00:08:58.060
Cuz you will know exactly which one
failed if you break it out into

145
00:08:58.060 --> 00:08:59.929
a bunch of smaller tests.

146
00:08:59.929 --> 00:09:03.741
It might feel tedious,
future you will be happier.

147
00:09:03.741 --> 00:09:07.853
And so, the interesting thing about that,
expect at any, is we're looking for

148
00:09:07.853 --> 00:09:08.830
numbers, right?

149
00:09:08.830 --> 00:09:12.833
Obviously, in this case,

150
00:09:12.833 --> 00:09:20.674
we might say that last modified is,
expect any date.

151
00:09:20.674 --> 00:09:25.294
All right, so
as long as it's basically a type of, or

152
00:09:25.294 --> 00:09:29.104
instance of, in this case, you're good.

153
00:09:29.104 --> 00:09:32.298
And so at that point, we should only

154
00:09:32.298 --> 00:09:37.200
have that one that we saw earlier,
create at created.

155
00:09:39.747 --> 00:09:43.080
&gt;&gt; Steve Kinney: Awesome, and
now it's just that person, or the ID,

156
00:09:43.080 --> 00:09:46.723
which we saw in the previous example,
which is ID expect.

157
00:09:46.723 --> 00:09:49.847
I could do any kind of string, but again,

158
00:09:49.847 --> 00:09:54.594
in this one, I'll probably do,
and it'll pass this way too.

159
00:09:54.594 --> 00:09:56.939
Now, we can argue this is a bit much,

160
00:09:56.939 --> 00:10:00.967
maybe breaking it down to smaller
tests makes sense, I agree.

161
00:10:00.967 --> 00:10:05.618
The point that I'm trying to make is that,
when you just wanna verify that it is

162
00:10:05.618 --> 00:10:09.153
a date and not be particularly
caring about what date it is.

163
00:10:09.153 --> 00:10:14.857
Now, I will tell you, can you make
the random number the same every time?

164
00:10:14.857 --> 00:10:15.653
You absolutely can.

165
00:10:15.653 --> 00:10:19.771
Can you stop time in your test suite,
as a human,

166
00:10:19.771 --> 00:10:25.309
can you stop timing your test suite and
set the time to something?

167
00:10:25.309 --> 00:10:26.665
You absolutely can.

168
00:10:26.665 --> 00:10:28.010
You can do all those things.

169
00:10:28.010 --> 00:10:30.494
But there's a question the very
beginning of this workshop of,

170
00:10:30.494 --> 00:10:32.111
at what point do you take mocking too far?

171
00:10:32.111 --> 00:10:33.761
At a certain point, the more you mock,

172
00:10:33.761 --> 00:10:36.562
the more you are intentionally
divorcing yourself from reality,

173
00:10:36.562 --> 00:10:39.325
which sometimes means you've
divorced yourself from reality.

174
00:10:39.325 --> 00:10:43.299
So in this one we're saying, listen,
I don't care what number it is,

175
00:10:43.299 --> 00:10:44.704
as long as it is a number.

176
00:10:44.704 --> 00:10:48.876
And depending on what we care about,
we can fine-tune it a little bit more.

177
00:10:48.876 --> 00:10:53.568
Some other strategies we can
take when we don't totally know

178
00:10:53.568 --> 00:10:58.168
what everything's gonna be is,
this one's pretty easy.

179
00:10:58.168 --> 00:11:00.813
This is mostly a sanity test, right?

180
00:11:00.813 --> 00:11:09.454
We could say,
&gt;&gt; Steve Kinney: I

181
00:11:09.454 --> 00:11:11.588
don't have these values in here.

182
00:11:11.588 --> 00:11:14.201
What I'm gonna do real quick,
for my own sanity,

183
00:11:14.201 --> 00:11:18.321
I'm just gonna move these up to the outer
scope, so I've got them available.

184
00:11:22.801 --> 00:11:25.143
&gt;&gt; Steve Kinney: First name,
last name, and role.

185
00:11:25.143 --> 00:11:34.414
And we can say,
&gt;&gt; Steve Kinney: Level up.

186
00:11:34.414 --> 00:11:35.469
We could expect,

187
00:11:43.928 --> 00:11:45.428
&gt;&gt; Steve Kinney: Cool, it passes.

188
00:11:45.428 --> 00:11:48.549
And then, this is an interesting one,
cuz again,

189
00:11:48.549 --> 00:11:52.114
it should update the last
modified date when leveling up.

190
00:11:52.114 --> 00:11:56.888
Now, later on I'll tell you about how
to set the time to recurrent time and

191
00:11:56.888 --> 00:12:00.892
how to, you could basically set the time,
create the thing,

192
00:12:00.892 --> 00:12:04.743
move the time forward a second,
and verify all that stuff.

193
00:12:04.743 --> 00:12:09.180
Really like, if I know that my
implementation is new date,

194
00:12:09.180 --> 00:12:15.242
I could assume some things about time,
is it tends to go into the future, right?

195
00:12:15.242 --> 00:12:19.664
You can choose your metaphor in this case,
which is, time keeps on taking into

196
00:12:19.664 --> 00:12:24.563
the future, or cuz we're in Minneapolis,
times are a changing, whatever you want.

197
00:12:24.563 --> 00:12:25.673
And so, for this one,

198
00:12:25.673 --> 00:12:29.368
this is where I might choose to use that
not thing that I showed you earlier.

199
00:12:29.368 --> 00:12:31.068
Again, under things that are helpful,

200
00:12:31.068 --> 00:12:33.026
depending on what you're
trying to achieve.

201
00:12:33.026 --> 00:12:34.957
And I will remind you,
what is the right answer?

202
00:12:34.957 --> 00:12:38.074
The right answer is whatever makes you
feel good about refactoring your code.

203
00:12:38.074 --> 00:12:39.014
If you're on a team,

204
00:12:39.014 --> 00:12:42.164
then it's more democratized of
whatever makes your team feel better.

205
00:12:42.164 --> 00:12:47.936
But generally speaking, it's about getting
to the thing that makes you comfortable,

206
00:12:47.936 --> 00:12:50.672
not some kind of, weird rite of passage.

207
00:12:50.672 --> 00:12:56.488
Cool, so
we can do character = new Character.

208
00:12:56.488 --> 00:13:00.834
First name, last name, and role, and

209
00:13:00.834 --> 00:13:05.576
then we can expect the, we'll go ahead and

210
00:13:05.576 --> 00:13:09.288
we'll level that character up.

211
00:13:14.275 --> 00:13:17.025
&gt;&gt; Steve Kinney: And really what we're
assuming is that we've now modified

212
00:13:17.025 --> 00:13:19.940
the character, so that created
at time should not be the same,

213
00:13:19.940 --> 00:13:21.592
as the last modified time, right?

214
00:13:21.592 --> 00:13:24.588
So that's a case where I
might choose to use that not.

215
00:13:24.588 --> 00:13:29.738
So then we expect,
&gt;&gt; Steve Kinney: Character.lastModified.

216
00:13:33.787 --> 00:13:39.832
&gt;&gt; Steve Kinney: Not to be,

217
00:13:44.353 --> 00:13:45.262
&gt;&gt; Steve Kinney: What I'll probably do is,

218
00:13:45.262 --> 00:13:46.175
I want the same reference.

219
00:13:46.175 --> 00:13:48.123
I could stringify it, but let me do this,

220
00:14:02.285 --> 00:14:03.704
&gt;&gt; Steve Kinney: So,
we make the character,

221
00:14:03.704 --> 00:14:07.858
we're gonna store on to their initial last
modified date, just put in a variable.

222
00:14:07.858 --> 00:14:09.008
And then we're gonna level them up.

223
00:14:09.008 --> 00:14:14.305
And what really,
all we wanna make sure is that the new

224
00:14:14.305 --> 00:14:19.503
last modified date is not
the original one, right?

225
00:14:19.503 --> 00:14:23.524
And again, because we can make
some assumptions about time,

226
00:14:23.524 --> 00:14:26.631
we can assume that it's in the future,
right?

227
00:14:26.631 --> 00:14:32.006
If it were some other value, you might
also choose not to do that as well.

228
00:14:32.006 --> 00:14:36.158
And there's nothing stopping you from
verifying stuff before and after.

229
00:14:36.158 --> 00:14:40.798
Most tests fall with this thing called
a triple A pattern, there's the arrange,

230
00:14:40.798 --> 00:14:45.656
act, and then assert, which is effectively
kind of what I'm doing in these spaces.

231
00:14:45.656 --> 00:14:47.792
There's no rule that you have to do that,

232
00:14:47.792 --> 00:14:50.672
it's just a way to kinda
think about your test, right?

233
00:14:50.672 --> 00:14:54.180
We get everything in place,
we do something, and then we verify stuff.

234
00:14:54.180 --> 00:14:57.547
But if it's helpful to you,
you could do something like,

235
00:14:57.547 --> 00:15:00.434
I might break this out
into two tests personally,

236
00:15:00.434 --> 00:15:03.821
cuz if i test fails,
I want to immediately know what it is.

237
00:15:03.821 --> 00:15:07.595
But theoretically,
have I done this before in my code base?

238
00:15:07.595 --> 00:15:11.639
100% I have, which is,
make a new character,

239
00:15:11.639 --> 00:15:15.882
expect it to be level one,
then up them to a level two.

240
00:15:15.882 --> 00:15:19.039
Again, it's all about what makes sense for
you and your code.

241
00:15:19.039 --> 00:15:22.575
You could also choose to, like,
we already have that kind of,

242
00:15:22.575 --> 00:15:24.254
in this test as well, right?

243
00:15:24.254 --> 00:15:26.785
And what I don't need is two test
breaking for the same reason.

244
00:15:26.785 --> 00:15:28.815
So how you break this stuff up is, again,

245
00:15:28.815 --> 00:15:31.790
going to be case by case based
on what is most helpful for you.

246
00:15:31.790 --> 00:15:34.461
But again, breaking stuff up into small,

247
00:15:34.461 --> 00:15:37.665
well-named things has never hurt anyone,
ever.

248
00:15:37.665 --> 00:15:41.095
We're just trying to make sure they're
not the same object in memory, right?

249
00:15:41.095 --> 00:15:45.131
Which is like, that was a data object,
we're placing it, right?

250
00:15:45.131 --> 00:15:48.769
With numbers though,
you could do something to,

251
00:15:48.769 --> 00:15:53.878
like if we wanted to take that
suggestion and apply it somewhere else,

252
00:15:53.878 --> 00:15:59.940
we could do something like
&gt;&gt; Steve Kinney: const.

253
00:15:59.940 --> 00:16:01.544
Initial level.

254
00:16:01.544 --> 00:16:05.964
And little weird for this example, but you
can think of plenty of cases in a business

255
00:16:05.964 --> 00:16:08.507
logic application,
where this might be true.

256
00:16:08.507 --> 00:16:12.128
Whereas initial level is character.level.

257
00:16:12.128 --> 00:16:17.219
We level the character up,
and then we say we

258
00:16:17.219 --> 00:16:24.111
want the character level to be
greater than initial level.

259
00:16:26.063 --> 00:16:27.151
&gt;&gt; Steve Kinney: And that one does work.

260
00:16:27.151 --> 00:16:31.752
And so now all of a sudden,
isn't companies like Microsoft,

261
00:16:31.752 --> 00:16:36.453
the first engineering level is
a level 55 engineer, right?

262
00:16:36.453 --> 00:16:38.827
So now if people like,
if you change the rules of the game,

263
00:16:38.827 --> 00:16:40.272
we don't start at level one.

264
00:16:40.272 --> 00:16:45.240
You start at level 55,
this test will still pass, right?

265
00:16:45.240 --> 00:16:47.617
In this exact example, little silly, but

266
00:16:47.617 --> 00:16:52.252
you can see words where it's as long as it
is higher or something along those lines.

267
00:16:52.252 --> 00:16:55.042
There are some helpers for
those kinds of things.

268
00:16:55.042 --> 00:16:56.464
At the end of the day,

269
00:16:56.464 --> 00:17:02.161
you could always do something like expect
character level greater than 0 to be true.

270
00:17:02.161 --> 00:17:03.550
Like in a pinch,

271
00:17:03.550 --> 00:17:09.372
these are all just helpers around
as simple logical statement.

272
00:17:09.372 --> 00:17:11.177
But these are also a lot prettier.

273
00:17:11.177 --> 00:17:11.721
&gt;&gt; Speaker 2: Good question.

274
00:17:11.721 --> 00:17:12.310
&gt;&gt; Steve Kinney: Yeah.

275
00:17:12.310 --> 00:17:16.899
&gt;&gt; Speaker 2: So this new level up test
right here, if you modify the original

276
00:17:16.899 --> 00:17:23.150
function to incorporate a starting level,
this test would cover that refactoring.

277
00:17:23.150 --> 00:17:24.406
&gt;&gt; Steve Kinney: Yeah, right, let's do it.

278
00:17:25.786 --> 00:17:28.902
So we'll actually have this
also take a level, and

279
00:17:28.902 --> 00:17:31.302
we're gonna say that that level is 1.

280
00:17:35.954 --> 00:17:37.728
&gt;&gt; Steve Kinney: And what's cool
about that is all my tests pass.

281
00:17:37.728 --> 00:17:41.497
So I had tests I refactored I know that I
haven't broken anything that at least I

282
00:17:41.497 --> 00:17:42.133
tested for.

283
00:17:42.133 --> 00:17:45.887
I might have broken stuff, but nothing
that I tested for, and now we can set

284
00:17:45.887 --> 00:17:50.133
that and like that, that test will still
work where it might have broken otherwise.

285
00:17:50.133 --> 00:17:54.083
And the breaking test isn't bad if you
know you were changing something, right?

286
00:17:54.083 --> 00:17:56.293
But in this case,
our test is more resilient to that change.

287
00:17:56.293 --> 00:17:58.963
That's a great point.

288
00:17:58.963 --> 00:18:04.921
Yeah and so, and that's kind of
gives us at least a reasonable

289
00:18:04.921 --> 00:18:10.763
reason to talk about a concept
that we will touch upon several

290
00:18:10.763 --> 00:18:16.859
more times later,
which is when we can't control stuff.

291
00:18:16.859 --> 00:18:20.579
There is also this pattern in software,
that's not just about testing,

292
00:18:20.579 --> 00:18:23.107
called dependency injection.

293
00:18:23.107 --> 00:18:26.055
Code that is not testable
is because there is stuff,

294
00:18:26.055 --> 00:18:28.336
if we go back to this character, right?

295
00:18:28.336 --> 00:18:30.945
Roll dice is imported in the module, and

296
00:18:30.945 --> 00:18:34.861
it just lives inside of this
constructor function, right,

297
00:18:34.861 --> 00:18:39.297
which means it is real hard for
us to get our fingers on it, right?

298
00:18:39.297 --> 00:18:42.587
We'll look later at mocking stuff,
totally.

299
00:18:42.587 --> 00:18:45.647
We'll look later under the hood,
they call math.random.

300
00:18:45.647 --> 00:18:49.761
We can look at all those things, but
one pattern that works really well,

301
00:18:49.761 --> 00:18:54.211
and it's not necessarily a testing
pattern, it's just a software pattern,

302
00:18:54.211 --> 00:18:57.317
is what's called dependency injection,
right?

303
00:18:57.317 --> 00:19:00.703
Which is every function
that this thing might use,

304
00:19:00.703 --> 00:19:03.937
you could theoretically pass in, right?

305
00:19:03.937 --> 00:19:08.671
And so for instance,
an example of this might be,

306
00:19:08.671 --> 00:19:14.897
we could do something like roll
in this case = rollDice, right?

307
00:19:14.897 --> 00:19:17.919
Test pass because if we don't
pass the roll function,

308
00:19:17.919 --> 00:19:21.530
it's gonna use that roll dice
that we passed in, right?

309
00:19:21.530 --> 00:19:28.490
But for instance, now we could
theoretically say that last one.

310
00:19:28.490 --> 00:19:31.780
It's nice that I have both a roll
with an e and a roll with two l's.

311
00:19:31.780 --> 00:19:34.450
As you can tell, this was not the example
I had planned on this for, but it works.

312
00:19:35.930 --> 00:19:41.782
Which is to say that roll is
just going to be a function

313
00:19:41.782 --> 00:19:46.575
that is always gonna return 15, right?

314
00:19:46.575 --> 00:19:47.833
What you mad about?

315
00:19:50.943 --> 00:19:55.886
&gt;&gt; Steve Kinney: There was that level,
was the argument first.

316
00:19:55.886 --> 00:19:59.073
So now theoretically,
if I got rid of all of these.

317
00:20:06.844 --> 00:20:10.548
&gt;&gt; Steve Kinney: Watch multi
cursor action, there we go.

318
00:20:18.215 --> 00:20:22.453
&gt;&gt; Steve Kinney: But
did I not replace them all?

319
00:20:22.453 --> 00:20:24.240
These are all still roll dice.

320
00:20:26.591 --> 00:20:28.409
&gt;&gt; Steve Kinney: We'll take
the one that was passed in.

321
00:20:28.409 --> 00:20:32.836
Okay, somewhat silly for this example,
but it came up, so we did it.

322
00:20:32.836 --> 00:20:37.026
More useful is,
let's say you have a React component that,

323
00:20:37.026 --> 00:20:41.158
when it mounts,
it goes to fetch from an API, right?

324
00:20:41.158 --> 00:20:45.619
If that's just a use effect that
is hard coded in there, well,

325
00:20:45.619 --> 00:20:50.238
good luck mounting that without
calling the API, right?

326
00:20:50.238 --> 00:20:55.868
But maybe your reaction component instead
takes a prop called fetch data, right?

327
00:20:55.868 --> 00:20:59.880
And that fetch data by default, if you
know what the fetch data is passed in for

328
00:20:59.880 --> 00:21:01.939
that prop calls the API, right?

329
00:21:01.939 --> 00:21:05.811
But it allows you if you take that
component now in your test suite,

330
00:21:05.811 --> 00:21:10.449
you can pass in one that just returns
an object that fulfills the contract.

331
00:21:10.449 --> 00:21:12.948
And now you don't have to mock
anything out or stub anything,

332
00:21:12.948 --> 00:21:14.936
which we'll talk about in a little bit,
right?

333
00:21:14.936 --> 00:21:17.149
&gt;&gt; Speaker 2: You have an example
of that hopefully [LAUGH]

334
00:21:17.149 --> 00:21:18.097
&gt;&gt; Steve Kinney: Of course we will.

335
00:21:18.097 --> 00:21:18.745
&gt;&gt; [LAUGH]
&gt;&gt; Steve Kinney: We just got to

336
00:21:18.745 --> 00:21:21.348
a little bit early,
we're just ahead of schedule.

337
00:21:21.348 --> 00:21:25.948
Absolutely, that is almost a crescendo.

338
00:21:25.948 --> 00:21:28.848
But it was a good excuse to
bring it in a little bit early.

339
00:21:28.848 --> 00:21:30.328
So if that stresses you out, don't worry.

340
00:21:30.328 --> 00:21:31.528
We'll cover it again.

341
00:21:31.528 --> 00:21:35.622
But the concept is basically take all
the things that maybe you can't control or

342
00:21:35.622 --> 00:21:39.796
that you don't have access to and allow
yourself to pass in those things as well.

343
00:21:41.886 --> 00:21:45.412
Cool, cuz we don't really care about,
in this case,

344
00:21:45.412 --> 00:21:47.796
roll dice becoming a random number.

345
00:21:47.796 --> 00:21:49.736
We could test that function separately.

346
00:21:49.736 --> 00:21:53.190
We just care that this thing gets
back the properties it ought to, and

347
00:21:53.190 --> 00:21:54.331
the shape that it has.

