WEBVTT

1
00:00:00.260 --> 00:00:01.020
&gt;&gt; Brian Holt: Yeah.
&gt;&gt; Speaker 2: Do you have any

2
00:00:01.020 --> 00:00:04.268
preferred methods for sorting arrays?

3
00:00:04.268 --> 00:00:05.590
&gt;&gt; Brian Holt: Sort.

4
00:00:05.590 --> 00:00:07.010
[LAUGH] So that's a good question.

5
00:00:07.010 --> 00:00:11.180
Let's let's take a look at that,
like here.

6
00:00:11.180 --> 00:00:14.260
Let's say we wanted to organize this.

7
00:00:15.520 --> 00:00:17.060
Well, let's start with the prime numbers.

8
00:00:18.120 --> 00:00:19.316
These are already sorted, but

9
00:00:19.316 --> 00:00:24.312
let's say we wanted to
&gt;&gt; Brian Holt: Just add

10
00:00:24.312 --> 00:00:27.182
some extra noise here,
like let's put 10 here in the front.

11
00:00:30.524 --> 00:00:34.890
&gt;&gt; Brian Holt: So there is
a JavaScript function called sort.

12
00:00:34.890 --> 00:00:41.624
I say prime numbers dot sort
&gt;&gt; Brian Holt: That's right.

13
00:00:41.624 --> 00:00:43.980
This will sort it by string, right?

14
00:00:43.980 --> 00:00:45.640
It assumes everything is a string.

15
00:00:45.640 --> 00:00:47.715
So this is technically
sorted by string right?

16
00:00:47.715 --> 00:00:51.240
One comes before 10, before 11, and
then two comes after that, right?

17
00:00:51.240 --> 00:00:57.550
Because one comes first in the alphabet.

18
00:00:57.550 --> 00:01:01.825
Right so what if you wanna
start this by number right?

19
00:01:01.825 --> 00:01:05.980
That's follows so
just like we can pass a function

20
00:01:07.030 --> 00:01:13.040
to map or for each or anything that
we can pass a function to this.

21
00:01:13.040 --> 00:01:16.863
This returns a number one or
has a number one and

22
00:01:16.863 --> 00:01:22.107
a number two
&gt;&gt; Brian Holt: Okay,

23
00:01:22.107 --> 00:01:26.120
and this is just something you have
to know, about how this works.

24
00:01:26.120 --> 00:01:30.490
If you return a positive number,
it means the first one is larger.

25
00:01:30.490 --> 00:01:34.480
If you return a negative number,
means the second one is larger.

26
00:01:34.480 --> 00:01:36.376
And if you return zero,
it means that they're equal.

27
00:01:39.161 --> 00:01:43.769
&gt;&gt; Brian Holt: So if num1 is greater than

28
00:01:43.769 --> 00:01:49.057
num2,
&gt;&gt; Brian Holt: Return

29
00:01:49.057 --> 00:01:50.440
some positive number.

30
00:01:50.440 --> 00:01:51.390
It doesn't matter what it is.

31
00:01:51.390 --> 00:01:54.080
It could be one, it could be 100.

32
00:01:54.080 --> 00:01:58.222
Else if num2 is greater than num1,

33
00:02:01.568 --> 00:02:04.154
&gt;&gt; Brian Holt: return -1.

34
00:02:04.154 --> 00:02:07.940
Otherwise you just return zero.

35
00:02:07.940 --> 00:02:12.040
And what did I forget here?

36
00:02:12.040 --> 00:02:18.170
I think I need another, okay,
cool, and I got it right.

37
00:02:18.170 --> 00:02:18.912
Sometimes I forget.

38
00:02:18.912 --> 00:02:22.815
[LAUGH]
&gt;&gt; Brian Holt: So this is a comparator,

39
00:02:22.815 --> 00:02:26.817
it's actually the name of what you would
call that function not that you would ever

40
00:02:26.817 --> 00:02:27.950
have to know that.

41
00:02:27.950 --> 00:02:32.050
I hope you never have to know that,
but every time that it

42
00:02:32.050 --> 00:02:35.170
runs a comparison between the two it
runs some sort of internal algorithm.

43
00:02:35.170 --> 00:02:38.000
It depends on which JavaScript
engine that you're running.

44
00:02:38.000 --> 00:02:40.470
Most of them run an algorithm
called quick-sort.

45
00:02:40.470 --> 00:02:43.249
Again not something that you
ever have to care about or

46
00:02:43.249 --> 00:02:45.979
actually is usually merge-sort but
nonetheless.

47
00:02:48.336 --> 00:02:50.332
&gt;&gt; Brian Holt: But
every time it goes to compare to numbers,

48
00:02:50.332 --> 00:02:52.336
says is this one bigger or
is this one bigger?

49
00:02:54.549 --> 00:02:58.080
&gt;&gt; Brian Holt: It will run your function
to figure out which number is bigger.

50
00:02:59.220 --> 00:03:00.030
Do we follow so far?

51
00:03:00.030 --> 00:03:00.940
Does that make sense?

52
00:03:00.940 --> 00:03:05.120
Okay, in this particular case,
we're comparing by number.

53
00:03:05.120 --> 00:03:07.630
So if number one is bigger,
then you return 1.

54
00:03:07.630 --> 00:03:10.660
If number two is bigger,
then you return -1.

55
00:03:10.660 --> 00:03:13.120
And again, I could put -100 or 10.

56
00:03:13.120 --> 00:03:15.200
It doesn't affect anything here.

57
00:03:15.200 --> 00:03:22.106
Otherwise you return zero to let
the thing know that they're equal.

58
00:03:22.106 --> 00:03:24.990
Now what happens if I wanted
to reverse sorted right?

59
00:03:24.990 --> 00:03:28.567
Well, then I would just reverse these.

60
00:03:31.217 --> 00:03:32.450
&gt;&gt; Brian Holt: And
now it's reverse sorted.

61
00:03:36.490 --> 00:03:37.170
Question?

62
00:03:37.170 --> 00:03:40.530
&gt;&gt; Speaker 3: So
is the sort method in there,

63
00:03:40.530 --> 00:03:45.890
what like I guess actually sorts it
like you're writing the logic for it.

64
00:03:45.890 --> 00:03:50.740
So, I guess my question is,
why aren't there, why isn't there one and

65
00:03:50.740 --> 00:03:53.320
negative 100 or
zero a bunch times in the result?

66
00:03:53.320 --> 00:03:56.450
&gt;&gt; Brian Holt: Because it's not actually
inserting those into the array.

67
00:03:56.450 --> 00:03:59.210
The only thing that you're letting
the sorting algorithm know is

68
00:03:59.210 --> 00:04:01.000
this one's bigger or this one smaller.

69
00:04:01.000 --> 00:04:01.630
Right?

70
00:04:01.630 --> 00:04:03.840
And true and false is not enough
to capture everything because they

71
00:04:03.840 --> 00:04:04.610
can be equal.

72
00:04:04.610 --> 00:04:06.720
So that's why they resorted to numbers.

73
00:04:08.090 --> 00:04:12.110
&gt;&gt; Speaker 3: So this sort function is
taking that either one or less than zero,

74
00:04:12.110 --> 00:04:13.150
placing it in right?

75
00:04:13.150 --> 00:04:13.920
&gt;&gt; Brian Holt: Correct.

76
00:04:13.920 --> 00:04:20.092
In fact if you want to see what it's
actually doing underneath the hood,

77
00:04:20.092 --> 00:04:22.360
this is another course that
I have in front of masters.

78
00:04:22.360 --> 00:04:23.268
Shameless self plug.

79
00:04:23.268 --> 00:04:24.041
Just kidding.

80
00:04:24.041 --> 00:04:30.280
[LAUGH] In here actually I teach you
how to write these things from scratch.

81
00:04:30.280 --> 00:04:35.090
The one that it is running
in Firefox is this one.

82
00:04:35.090 --> 00:04:37.100
So this is what it's actually
doing underneath the hood,

83
00:04:38.740 --> 00:04:40.520
which looks kind of crazy right?

84
00:04:40.520 --> 00:04:43.556
They are basically dividing the list into
smaller and smaller and smaller less and

85
00:04:43.556 --> 00:04:46.033
then combining them back into bigger and
bigger and bigger lists.

86
00:04:48.624 --> 00:04:53.398
&gt;&gt; Brian Holt: And the code,
surprisingly, is not so complicated.

87
00:04:53.398 --> 00:04:58.486
It's about 50-ish lines of code,

88
00:04:58.486 --> 00:05:03.103
but that's code for another day.

89
00:05:08.042 --> 00:05:09.107
&gt;&gt; Brian Holt: Questions about that?

90
00:05:11.123 --> 00:05:15.294
&gt;&gt; Speaker 4: Could you use
parseInt in there somewhere to make

91
00:05:15.294 --> 00:05:19.980
the string a number,
like we did in other situations?

92
00:05:19.980 --> 00:05:21.299
Or this is the preferred method?

93
00:05:28.084 --> 00:05:29.810
&gt;&gt; Brian Holt: Let me think about that.

94
00:05:29.810 --> 00:05:36.290
I don't think so,
because you're not actually, yeah.

95
00:05:36.290 --> 00:05:40.810
So the sort function has,
if you don't give it any sort of function,

96
00:05:40.810 --> 00:05:43.640
has a default function that it runs
that does string comparison, right?

97
00:05:43.640 --> 00:05:45.950
So if this was a list of strings,

98
00:05:45.950 --> 00:05:51.350
let's actually just look at
what that would look like.

99
00:05:51.350 --> 00:05:53.390
So if this was a list of strings,
it would get it right.

100
00:05:53.390 --> 00:06:03.227
So A, C, B, D, E, something like that.

101
00:06:03.227 --> 00:06:08.110
And the function that runs by
default is the string comparison

102
00:06:08.110 --> 00:06:10.580
method to alphabetically sort things.

103
00:06:10.580 --> 00:06:14.939
And so if you don't fall into that use
case then you have to write your own.

104
00:06:16.500 --> 00:06:19.940
So like, I see where you're going and
it's a good train of thought.

105
00:06:19.940 --> 00:06:22.508
But in this particular
case that wouldn't work.

106
00:06:25.379 --> 00:06:27.670
&gt;&gt; Brian Holt: So const strings.

107
00:06:27.670 --> 00:06:29.757
And then here if I strings dot sort,

108
00:06:29.757 --> 00:06:33.736
this should sort into a correct
order based on alphabetical order.

109
00:06:35.363 --> 00:06:36.240
&gt;&gt; Brian Holt: But things get weird.

110
00:06:36.240 --> 00:06:37.830
Like what happens if there's capital B's?

111
00:06:37.830 --> 00:06:42.180
Well turns out capitals come before
lowercase if you're doing string

112
00:06:42.180 --> 00:06:46.110
comparisons, so there's definitely
caveats to this as well.

113
00:06:47.370 --> 00:06:51.190
&gt;&gt; Speaker 3: What about if you
put like dot two uppercase,

114
00:06:51.190 --> 00:06:54.220
in either the strings or the sort?

115
00:06:54.220 --> 00:06:55.140
So that it would still work.

116
00:06:57.700 --> 00:07:03.630
&gt;&gt; Brian Holt: So,
I mean something kind of fun you

117
00:07:03.630 --> 00:07:09.363
could do is could do dot map here and

118
00:07:09.363 --> 00:07:14.308
you do function string return

119
00:07:14.308 --> 00:07:18.478
string.toUppercase.

120
00:07:22.968 --> 00:07:25.604
&gt;&gt; Brian Holt: So this is why functional
program is really cool cuz then you can

121
00:07:25.604 --> 00:07:28.791
start changing things together because
this array returns another array,

122
00:07:28.791 --> 00:07:32.025
which then you operate on that array,
and then you return another array, and

123
00:07:32.025 --> 00:07:33.190
you operate on that array.

124
00:07:33.190 --> 00:07:35.865
And you can just chain these functions
together to get these really powerful

125
00:07:35.865 --> 00:07:36.590
transformations.

126
00:07:39.018 --> 00:07:40.748
&gt;&gt; Brian Holt: So I don't think I
really answered your question but

127
00:07:40.748 --> 00:07:41.685
I still think this is cool.

128
00:07:41.685 --> 00:07:46.060
&gt;&gt; Speaker 3: [LAUGH] Yeah, it's cool.

129
00:07:46.060 --> 00:07:47.990
&gt;&gt; Brian Holt: An It's also probably not
necessarily you're looking for, right?

130
00:07:47.990 --> 00:07:50.790
Because in the process,
I've destroyed data, right?

131
00:07:50.790 --> 00:07:54.472
Like now we no longer know if these
were uppercase or lowercase beforehand.

132
00:07:59.262 --> 00:08:00.423
&gt;&gt; Brian Holt: But I don't care.

133
00:08:00.423 --> 00:08:06.801
[LAUGH] Like it wouldn't work, like
what happens if I have this in there or

134
00:08:10.642 --> 00:08:12.640
&gt;&gt; Brian Holt: I don't know, sweaty face?

135
00:08:12.640 --> 00:08:16.320
I don't know where did
those come in sorting?

136
00:08:16.320 --> 00:08:17.110
Comes at the end apparently.

137
00:08:19.900 --> 00:08:21.430
I believe was actually doing anything,

138
00:08:21.430 --> 00:08:26.630
if you're curious is it's
sorting by Unicode codes, right?

139
00:08:26.630 --> 00:08:32.260
So there's basically codes that represent
characters at like a lower level and

140
00:08:32.260 --> 00:08:33.860
it is sorting based on those so

141
00:08:33.860 --> 00:08:39.540
it turns out emojis come after letters but
punctuation comes before.

142
00:08:42.330 --> 00:08:46.184
Again not typically or hopefully
something that you ever need to know but.

143
00:08:48.423 --> 00:08:53.225
&gt;&gt; Brian Holt: So,
&gt;&gt; Brian Holt: This is typically how you

144
00:08:53.225 --> 00:08:54.399
would structure this.

145
00:08:54.399 --> 00:08:56.386
So you would have multiple lines here so

146
00:08:56.386 --> 00:09:00.230
it gets a lot clearer to read
the transformations over time.

147
00:09:00.230 --> 00:09:04.620
Let's just show you
a little shortcut here.

148
00:09:04.620 --> 00:09:08.510
I've shown you so far just using the
function key word, there's a thing called

149
00:09:08.510 --> 00:09:14.800
arrow functions, so this is combining
them here, but if I hit space,

150
00:09:14.800 --> 00:09:19.720
it's just equals and angle bracket, and
then my font combines them together.

151
00:09:19.720 --> 00:09:22.040
So that's why it looks like an arrow.

152
00:09:23.050 --> 00:09:24.220
So this actually works.

153
00:09:25.480 --> 00:09:26.890
This is called an arrow function.

154
00:09:26.890 --> 00:09:31.940
99% the same as just using
the function key word.

155
00:09:31.940 --> 00:09:33.400
It's just a little bit shorter.

156
00:09:33.400 --> 00:09:35.790
This is also new to JavaScript as well.

157
00:09:35.790 --> 00:09:37.780
But we can actually
make this even shorter.

158
00:09:39.630 --> 00:09:43.878
So if I leave off the curly braces,
there's what's called an implicit return.

159
00:09:49.090 --> 00:09:50.184
&gt;&gt; Brian Holt: So whatever I put here,

160
00:09:50.184 --> 00:09:53.430
if I don't put curly braces means I
can only do one statement, right?

161
00:09:53.430 --> 00:09:56.480
So I can't put a semi colon after this and
do more stuff.

162
00:09:56.480 --> 00:09:58.240
You get one line or nothing, right?

163
00:09:59.490 --> 00:10:03.880
But because I did that now it's
implicitly calling return for you.

164
00:10:03.880 --> 00:10:04.780
Does that make sense?

165
00:10:06.410 --> 00:10:09.290
If you're coming from Ruby or
something like that this will

166
00:10:09.290 --> 00:10:12.050
make a ton of sense because
Ruby does that everywhere.

167
00:10:12.050 --> 00:10:15.540
But I like this because this
got a lot more concise, right?

168
00:10:17.890 --> 00:10:20.860
We can actually make this even shorter.

169
00:10:20.860 --> 00:10:24.850
So notice I have parentheses
around the parameters here.

170
00:10:24.850 --> 00:10:28.150
If you have exactly one parameter,
which I don't know why this is a rule but

171
00:10:28.150 --> 00:10:32.420
it is, if you have exactly one parameter,
parentheses are optional.

172
00:10:33.730 --> 00:10:36.464
But if you have zero or two,
they are no longer optional.

