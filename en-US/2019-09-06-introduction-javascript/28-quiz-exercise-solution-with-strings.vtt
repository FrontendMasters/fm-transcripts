WEBVTT

1
00:00:00.070 --> 00:00:04.339
&gt;&gt; Brian Holt: You all should have at
least, hopefully, attempted the exercise.

2
00:00:04.339 --> 00:00:08.669
And today we're gonna go over the answers.

3
00:00:12.243 --> 00:00:17.042
&gt;&gt; Brian Holt: Just before we get into all
these sort of things, again, this is hard.

4
00:00:17.042 --> 00:00:21.496
For many of you, this was your very
first exposure to programming, and

5
00:00:21.496 --> 00:00:23.064
that's tough, right?

6
00:00:23.064 --> 00:00:27.061
If you feel like it's hard or if you have
people telling you they can't do it,

7
00:00:27.061 --> 00:00:28.056
screw them right?

8
00:00:28.056 --> 00:00:29.244
You can definitely do this.

9
00:00:29.244 --> 00:00:31.648
This is just a matter of persistence,
right?

10
00:00:31.648 --> 00:00:36.062
I remember I tried multiple times to learn
a foreign language, and it took me like my

11
00:00:36.062 --> 00:00:40.241
third or fourth time before I finally
found a language that I could figure out.

12
00:00:40.241 --> 00:00:45.224
[LAUGH] So you can definitely do this,
let's just do this together.

13
00:00:47.597 --> 00:00:51.191
&gt;&gt; Brian Holt: The person that's
persistent is usually the one that figures

14
00:00:51.191 --> 00:00:52.372
all this stuff out.

15
00:00:52.372 --> 00:00:54.484
So let's go do this exercise together.

16
00:00:58.788 --> 00:01:00.483
&gt;&gt; Brian Holt: All right, cool.

17
00:01:00.483 --> 00:01:03.970
So here we have the first one, Australia.

18
00:01:03.970 --> 00:01:09.295
Which hopefully was a good example for
you.

19
00:01:09.295 --> 00:01:12.739
I'm not doing anything being case,

20
00:01:12.739 --> 00:01:16.971
actually, I'm being case sensitive here.

21
00:01:16.971 --> 00:01:22.920
If you wanted to go the extra mile,
you could have said here,

22
00:01:22.920 --> 00:01:26.547
toUpperCase === 'CANBERRA'.

23
00:01:26.547 --> 00:01:28.790
Or, yeah, that would have been fine, too.

24
00:01:28.790 --> 00:01:32.103
And then here,
I'm adding 100 to the point total, right?

25
00:01:32.103 --> 00:01:33.910
So only if they got it correct.

26
00:01:33.910 --> 00:01:38.902
I think something I failed to mention
previously is that as soon as

27
00:01:38.902 --> 00:01:42.183
you call return, the function finishes.

28
00:01:42.183 --> 00:01:43.680
It doesn't do anything beyond that.

29
00:01:43.680 --> 00:01:48.458
So if I come up here and say,
return isCorrect, right here,

30
00:01:48.458 --> 00:01:52.688
none of that stuff underneath
is gonna get executed.

31
00:01:52.688 --> 00:01:55.294
So that's something to
keep in mind as well.

32
00:01:55.294 --> 00:01:56.522
&gt;&gt; Speaker 2: Just inside
the curly brackets?

33
00:01:56.522 --> 00:01:59.535
&gt;&gt; Brian Holt: As soon as it
runs into a return statement,

34
00:01:59.535 --> 00:02:01.469
the function is finished.

35
00:02:01.469 --> 00:02:07.371
So that's both useful if you
are trying to finish it early and

36
00:02:07.371 --> 00:02:10.041
not useful if you're not.

37
00:02:12.235 --> 00:02:17.058
&gt;&gt; Brian Holt: Okay, so let's go do,
what is the capital of Canada?

38
00:02:17.058 --> 00:02:19.063
If you said Toronto, you are incorrect.

39
00:02:19.063 --> 00:02:23.863
So, const isCorrect =

40
00:02:23.863 --> 00:02:30.583
UserAnswer === 'OTTAWA'.

41
00:02:32.695 --> 00:02:38.136
&gt;&gt; Brian Holt: if (isCorrect),
&gt;&gt; Brian Holt: points

42
00:02:38.136 --> 00:02:44.893
+= 100;, return isCorrect.

43
00:02:47.318 --> 00:02:49.006
&gt;&gt; Brian Holt: Okay,
that should be enough for that one.

44
00:02:49.006 --> 00:02:52.536
&gt;&gt; Speaker 3: Don't you
need to do toUpperCase?

45
00:02:52.536 --> 00:02:53.799
&gt;&gt; Brian Holt: You can.

46
00:02:53.799 --> 00:02:58.144
Yeah, in this case though,
you'd have to, cuz I did that.

47
00:02:59.704 --> 00:03:00.588
&gt;&gt; Brian Holt: Yep.

48
00:03:04.838 --> 00:03:07.836
&gt;&gt; Brian Holt: In all honestly,
I don't actually care if you do this part.

49
00:03:07.836 --> 00:03:12.003
It's probably useful, because if
someone types Ottawa with lowercase,

50
00:03:12.003 --> 00:03:14.858
though, it's gonna be
frustrating on your quiz.

51
00:03:14.858 --> 00:03:17.928
But as long as you're getting the
programming principles here, I'm happy.

52
00:03:17.928 --> 00:03:19.174
&gt;&gt; Speaker 4: Is there a best practice for

53
00:03:19.174 --> 00:03:21.676
this if you're working with
user answers and forums?

54
00:03:21.676 --> 00:03:26.304
&gt;&gt; Brian Holt: I think you gotta take
that one on a case-by-case basis.

55
00:03:26.304 --> 00:03:29.429
Some things you would expect
to be insensitive, right?

56
00:03:29.429 --> 00:03:32.554
But it's probably pretty,
like emails, right?

57
00:03:32.554 --> 00:03:34.276
Emails are case insensitive.

58
00:03:34.276 --> 00:03:39.655
But something like maybe first names,
right, probably are case sensitive.

59
00:03:39.655 --> 00:03:40.682
So it depends.

60
00:03:40.682 --> 00:03:42.021
It's good question.

61
00:03:45.612 --> 00:03:46.902
&gt;&gt; Brian Holt: Okay, function uppercase.

62
00:03:46.902 --> 00:03:47.412
I do care in this case.

63
00:03:47.412 --> 00:03:54.346
[LAUGH] So,
const isCorrect = userAnswer.toUpperCase,

64
00:03:54.346 --> 00:03:58.237
or rather that's their answer.

65
00:03:58.237 --> 00:04:02.218
So you wanna check if
word is to.UpperCase.

66
00:04:02.218 --> 00:04:06.963
UpperCase, right, cuz this is what
you're getting back from the user.

67
00:04:06.963 --> 00:04:08.913
You expect it to be uppercase, otherwise,

68
00:04:08.913 --> 00:04:11.245
they would have gotten the question wrong,
right?

69
00:04:12.935 --> 00:04:15.350
&gt;&gt; Brian Holt: Then, if(isCorrect),

70
00:04:18.815 --> 00:04:23.584
&gt;&gt; Brian Holt: points += 200.

71
00:04:23.584 --> 00:04:31.392
And then you're gonna return isCorrect,
&gt;&gt; Brian Holt: Okay?

72
00:04:36.059 --> 00:04:36.902
&gt;&gt; Brian Holt: First three letters.

73
00:04:40.651 --> 00:04:49.561
&gt;&gt; Brian Holt: const isCorrect =,
&gt;&gt; Brian Holt: userAnswer === word.

74
00:04:49.561 --> 00:04:52.794
And there's couple of ways
you could have done this.

75
00:04:52.794 --> 00:04:58.375
The way I chose to do was with substr
from zero, and you go, length 3.

76
00:04:58.375 --> 00:05:01.684
But you could have used the other one,

77
00:05:01.684 --> 00:05:05.936
which would have been,
I think, substring 0.

78
00:05:05.936 --> 00:05:08.410
Actually, it probably was the same thing.

79
00:05:09.749 --> 00:05:10.683
&gt;&gt; Brian Holt: Let's check.

80
00:05:14.244 --> 00:05:15.327
&gt;&gt; Brian Holt: Actually,

81
00:05:15.327 --> 00:05:18.201
I think it would be 0 to 2,
&gt;&gt; Brian Holt: So,

82
00:05:22.103 --> 00:05:22.866
&gt;&gt; Brian Holt: I'll try that.

83
00:05:22.866 --> 00:05:24.967
This is cool.

84
00:05:27.750 --> 00:05:30.778
&gt;&gt; Brian Holt: So there's another
one called substring, like this.

85
00:05:30.778 --> 00:05:35.184
And if you did 0 to 2, I think that
would give you the same thing.

86
00:05:35.184 --> 00:05:36.678
Nope, it is 0, 3.

87
00:05:36.678 --> 00:05:39.115
So in this case, it doesn't matter.

88
00:05:39.115 --> 00:05:41.414
You could have used substr or
substring, and

89
00:05:41.414 --> 00:05:43.965
the parameters would have
been exactly the same.

90
00:05:43.965 --> 00:05:45.735
Just to explain to you
why that's different,

91
00:05:54.141 --> 00:05:55.144
&gt;&gt; Brian Holt: This one, substr,

92
00:05:55.144 --> 00:05:58.156
which I had looked this up,
by the way, before coming here.

93
00:05:58.156 --> 00:06:00.186
So I do not have this memorized.

94
00:06:00.186 --> 00:06:07.057
This one starts at index whatever, and
then this goes for 3 length, right?

95
00:06:07.057 --> 00:06:09.759
So starts at index 0 and goes for 3.

96
00:06:09.759 --> 00:06:13.886
This one starts at index 0 and
ends at index 3.

97
00:06:13.886 --> 00:06:19.933
And when I say index, 0,
1, 2, 3, and so on, right?

98
00:06:19.933 --> 00:06:22.278
So-
&gt;&gt; Speaker 4: Say that again,

99
00:06:22.278 --> 00:06:23.772
is there a difference?

100
00:06:23.772 --> 00:06:29.347
They both start at whatever index and end
at index 3, and they're both exclusive.

101
00:06:29.347 --> 00:06:33.614
Meaning that it doesn't actually-
&gt;&gt; Brian Holt: Okay, yeah,

102
00:06:33.614 --> 00:06:36.169
I see what you're saying.

103
00:06:36.169 --> 00:06:40.387
So substring, if I change this to 3, okay?

104
00:06:40.387 --> 00:06:43.825
This would start on index 3 and
go for length 3.

105
00:06:43.825 --> 00:06:46.966
So I have this and i, right there.

106
00:06:48.341 --> 00:06:52.101
&gt;&gt; Brian Holt: Whereas if I did
substring and I did the same parameters,

107
00:06:52.101 --> 00:06:56.347
it would give me one character I think,
one or zero characters.

108
00:06:56.347 --> 00:07:00.616
Yeah, it gives me zero characters, cuz it
starts at index 3 and ends at index 3.

109
00:07:00.616 --> 00:07:01.159
&gt;&gt; Speaker 4: Okay.

110
00:07:01.159 --> 00:07:02.348
&gt;&gt; Brian Holt: That make sense?

111
00:07:02.348 --> 00:07:03.320
&gt;&gt; Speaker 4: Yes.

112
00:07:03.320 --> 00:07:05.632
&gt;&gt; Brian Holt: I think
substring is the preferred way,

113
00:07:05.632 --> 00:07:07.879
but honestly, you can use either one.

114
00:07:07.879 --> 00:07:10.933
I've been using this one because
that's the one I can remember.

115
00:07:10.933 --> 00:07:13.559
[LAUGH] So either way.

116
00:07:15.651 --> 00:07:19.836
&gt;&gt; Brian Holt: You'll find there's very
rarely one answer to these questions.

117
00:07:19.836 --> 00:07:21.806
There's many ways to do this.

118
00:07:21.806 --> 00:07:25.520
And often, not one of them is
more correct than the other.

