WEBVTT

1
00:00:00.140 --> 00:00:03.727
&gt;&gt; Speaker 1: And
reveal that actually some magic happened.

2
00:00:03.727 --> 00:00:08.870
Some amazing, precise magic happened when

3
00:00:08.870 --> 00:00:13.493
I,
&gt;&gt; Speaker 1: We already said

4
00:00:13.493 --> 00:00:18.442
where I define my function determines.

5
00:00:18.442 --> 00:00:20.456
What did it say?
Where you define your function determines

6
00:00:20.456 --> 00:00:23.470
what variables your function have
access to when you call the function.

7
00:00:23.470 --> 00:00:26.200
That's our overarching message.

8
00:00:26.200 --> 00:00:30.420
Where you define determines.

9
00:00:30.420 --> 00:00:31.550
But hold on.

10
00:00:31.550 --> 00:00:34.838
[INAUDIBLE] was to find inside of outer.

11
00:00:34.838 --> 00:00:36.392
But we said outer's gone.

12
00:00:36.392 --> 00:00:40.064
But we're saying also, where you define
what determines what variables function of

13
00:00:40.064 --> 00:00:41.594
assets when you call the function.

14
00:00:41.594 --> 00:00:44.434
How can these two things be reconciled?

15
00:00:44.434 --> 00:00:46.210
Okay, let's see.

16
00:00:46.210 --> 00:00:50.229
When I define the increment counter,
when I was running out, so

17
00:00:50.229 --> 00:00:55.141
we are right now inside the quarter outer,
we're inside the quarter outer and

18
00:00:55.141 --> 00:00:58.878
the first thing we didn't saw
it was declare counter is 0.

19
00:00:58.878 --> 00:01:01.238
Then increment counter is a function.

20
00:01:01.238 --> 00:01:04.118
When I declare the increment
counter as a function,

21
00:01:04.118 --> 00:01:06.418
I didn't just declare it was a function.

22
00:01:06.418 --> 00:01:10.236
Behind the scenes,
JavaScript did something very special.

23
00:01:10.236 --> 00:01:12.192
We're gonna learn how
it worked in a second.

24
00:01:12.192 --> 00:01:14.350
But for now, what I'm gonna say?

25
00:01:14.350 --> 00:01:17.550
Is when I define increment counter,
I said define increment counter,

26
00:01:17.550 --> 00:01:19.645
determines what things
are gonna be available.

27
00:01:19.645 --> 00:01:24.620
Where I define my function determines
what data will be available when I end up

28
00:01:24.620 --> 00:01:28.100
calling that function,
wherever I call it, wherever I invoke it,

29
00:01:28.100 --> 00:01:29.550
wherever I execute it.

30
00:01:29.550 --> 00:01:34.194
Where I defined it determines what data,
when I call it, it will have access to.

31
00:01:34.194 --> 00:01:37.216
So I defined an increment counter here,
I did something else.

32
00:01:37.216 --> 00:01:40.552
I didn't just define it,
I didn't just store its description,

33
00:01:40.552 --> 00:01:43.778
increment counter plus plus in memory,
I did something else.

34
00:01:43.778 --> 00:01:48.806
I made a special bond to the immediate

35
00:01:48.806 --> 00:01:53.678
total surround live local memory.

36
00:01:53.678 --> 00:02:02.290
I said this function Gets a special
bond to all these surrounding data.

37
00:02:02.290 --> 00:02:05.950
Gets a special bond to
all my surrounding data,

38
00:02:07.980 --> 00:02:10.720
increment counter is not just a function.

39
00:02:10.720 --> 00:02:15.370
It's a function plus a special
bond To little reference to

40
00:02:15.370 --> 00:02:19.350
all my surrounding data, counter at zero,
increment count as a function.

41
00:02:19.350 --> 00:02:22.650
It gets a reference to
the whole surrounding data.

42
00:02:22.650 --> 00:02:24.350
When it gets to find.

43
00:02:24.350 --> 00:02:30.195
Meaning when I return that function out,
do I just get the function?

44
00:02:30.195 --> 00:02:32.140
Nuh-uh.

45
00:02:32.140 --> 00:02:35.730
I get the function plus that special bond

46
00:02:37.720 --> 00:02:43.010
to the surrounding data from
when that function was born.

47
00:02:43.010 --> 00:02:44.810
And what is in that surrounding data?

48
00:02:44.810 --> 00:02:50.980
That surrounding live store of data,
but not counted could be zero.

49
00:02:50.980 --> 00:02:56.690
But literally Counter is 0.

50
00:02:56.690 --> 00:03:01.440
There it is,
attached to my function definition.

51
00:03:01.440 --> 00:03:03.070
I return out the function value.

52
00:03:03.070 --> 00:03:07.996
Increment counter is a function with
a reference to the surrounding data hidden

53
00:03:07.996 --> 00:03:12.332
on the back of the function, and
when I return my function out, well,

54
00:03:12.332 --> 00:03:17.258
on the back of the function comes with it
Itâ€™s surrounding data from where it was

55
00:03:17.258 --> 00:03:22.068
defined and there it is, and so that
function that gets now given a new label.

56
00:03:22.068 --> 00:03:24.196
New label is my new function.

57
00:03:24.196 --> 00:03:25.227
Just a function.

58
00:03:25.227 --> 00:03:30.747
It's a function with a bond to
its surrounding data [SOUND] And

59
00:03:30.747 --> 00:03:35.183
now, so we code my new function,
it's code said

60
00:03:35.183 --> 00:03:40.052
counter plus plus,
there was no counter, in local,

61
00:03:40.052 --> 00:03:45.140
everything will suggest the next
place will look at down

62
00:03:45.140 --> 00:03:50.336
our call stack sought of we're
calling my new function,

63
00:03:50.336 --> 00:03:55.677
In global, so we go out and
look in global for the counter.

64
00:03:57.573 --> 00:04:00.103
&gt;&gt; Speaker 1: Where do you think
we actually go and look, Andrea,

65
00:04:00.103 --> 00:04:01.990
before we go look in global?

66
00:04:01.990 --> 00:04:04.180
&gt;&gt; Speaker 2: We look in-
&gt;&gt; Speaker 1: In the orange box.

67
00:04:04.180 --> 00:04:04.680
&gt;&gt; Speaker 2: Yeah.

68
00:04:05.690 --> 00:04:09.287
&gt;&gt; Speaker 1: [LAUGH] So
I like to call this orange box a backpack.

69
00:04:09.287 --> 00:04:14.529
Now, this is definitely not
the technical term For this orange box.

70
00:04:14.529 --> 00:04:15.050
There are.

71
00:04:15.050 --> 00:04:18.174
We're gonna give you a whole bunch of
sophisticated technical terms for them.

72
00:04:18.174 --> 00:04:20.276
But note that in many ways
it's like a backpack.

73
00:04:20.276 --> 00:04:24.151
That function got a little bond to
its surrounding live store of data on

74
00:04:24.151 --> 00:04:24.749
its back.

75
00:04:24.749 --> 00:04:27.648
And out came the function
stored in my new function, and

76
00:04:27.648 --> 00:04:31.628
with it came its backpack of live
data from when it was defined.

77
00:04:31.628 --> 00:04:34.044
Not a bad name for it.

78
00:04:34.044 --> 00:04:37.507
Unfortunately, it's not the name,
unfortunately.

79
00:04:37.507 --> 00:04:39.754
We're gonna see what the real name for
it is in a moment.

80
00:04:39.754 --> 00:04:42.122
First let's just see
what actually happens.

81
00:04:42.122 --> 00:04:44.735
Andrea, didn't find counter in local.

82
00:04:44.735 --> 00:04:48.220
Where did I actually go look
before I looked in global?

83
00:04:48.220 --> 00:04:50.730
Andrea, where do I actually go look?

84
00:04:50.730 --> 00:04:53.580
&gt;&gt; Speaker 2: You data
that in the backpack?

85
00:04:53.580 --> 00:04:55.996
&gt;&gt; Speaker 1: In the backpack,
thank you, Andrea for indulging me.

86
00:04:55.996 --> 00:04:59.040
[LAUGH] green one.

87
00:04:59.040 --> 00:05:04.250
In the backpack, say it proud and
loud and say it in your interviews and

88
00:05:04.250 --> 00:05:07.784
look distress When they look at you and
say, mm-mm.

89
00:05:07.784 --> 00:05:10.010
[LAUGH] All right, though,
what do we find, counter at 0?

90
00:05:10.010 --> 00:05:10.890
What do we do with, Andrea?

91
00:05:10.890 --> 00:05:13.160
What do we say we're gonna do with it?

92
00:05:13.160 --> 00:05:15.990
&gt;&gt; Speaker 2: We're gonna increment it.

93
00:05:15.990 --> 00:05:16.510
&gt;&gt; Speaker 1: Increment it.

94
00:05:16.510 --> 00:05:18.020
This is the same thing.

95
00:05:18.020 --> 00:05:20.410
Increment it to 1, ha.

96
00:05:22.380 --> 00:05:23.354
Increment it to 1.

97
00:05:25.339 --> 00:05:29.780
&gt;&gt; Speaker 1: Not in our local memory,
but in this live data store.

98
00:05:29.780 --> 00:05:32.280
This backpack attached to
the function definition.

99
00:05:32.280 --> 00:05:36.030
Okay, before we talk about how this is
possible, all the ins and outs of this.

100
00:05:36.030 --> 00:05:39.000
We finish running my new function,
we hit a counter, it was zero.

101
00:05:39.000 --> 00:05:39.580
We incremented to one.

102
00:05:39.580 --> 00:05:41.610
What happens to this execution context?

103
00:05:41.610 --> 00:05:46.260
Andrea?
&gt;&gt; Speaker 2: It gets garbage collected.

104
00:05:46.260 --> 00:05:47.608
&gt;&gt; Speaker 1: No, the data does.

105
00:05:47.608 --> 00:05:51.782
The execution context gets
Popped off the call stack.

106
00:05:51.782 --> 00:05:54.876
It's gone and we go back to global,

107
00:05:54.876 --> 00:05:59.425
where what's the next line we encounter,
Andrea?

108
00:05:59.425 --> 00:06:01.153
Gonna call [INAUDIBLE] function again,
basically.

109
00:06:01.153 --> 00:06:03.665
&gt;&gt; [INAUDIBLE]
&gt;&gt; Speaker 1: Let's call it again.

110
00:06:03.665 --> 00:06:07.953
My new function.

111
00:06:07.953 --> 00:06:09.496
Let's call it again.

112
00:06:09.496 --> 00:06:10.515
Everybody?

113
00:06:10.515 --> 00:06:12.289
Actually, just Art.

114
00:06:12.289 --> 00:06:13.977
I'm calling my new function.

115
00:06:13.977 --> 00:06:16.722
Okay, then just.

116
00:06:16.722 --> 00:06:18.122
Griffin.

117
00:06:18.122 --> 00:06:20.385
Griffin, I'm calling my new function.

118
00:06:20.385 --> 00:06:22.025
What do I create a new?

119
00:06:22.025 --> 00:06:25.298
&gt;&gt; [INAUDIBLE]
&gt;&gt; Speaker 1: Are people really good

120
00:06:25.298 --> 00:06:28.137
together doing it really under
the pressure of the individual person?

121
00:06:28.137 --> 00:06:30.692
&gt;&gt; Speaker 2: [LAUGH]
&gt;&gt; Speaker 3: Execution content.

122
00:06:30.692 --> 00:06:31.211
&gt;&gt; Speaker 1: Good job, man.

123
00:06:31.211 --> 00:06:32.202
Yeah.
Exactly.

124
00:06:32.202 --> 00:06:33.346
Push it to the call stack, right?

125
00:06:33.346 --> 00:06:34.676
&gt;&gt; Speaker 3: Yep.

126
00:06:34.676 --> 00:06:36.850
&gt;&gt; Speaker 1: Pass the call
to my new function.

127
00:06:36.850 --> 00:06:41.823
So the call stack for
this level of communication may

128
00:06:41.823 --> 00:06:46.005
seem pedantic, but I was telling Lindsay,

129
00:06:46.005 --> 00:06:50.751
telling Bob,
I think I was telling Carol as well,

130
00:06:50.751 --> 00:06:54.837
this is the stuff Of seasoned developers.

131
00:06:54.837 --> 00:06:59.858
There is little explanation why
codesmith folk grads get senior jobs.

132
00:06:59.858 --> 00:07:03.116
If there's one explanation,
it's Tentacle Communication.

133
00:07:03.116 --> 00:07:08.682
So I've all ready seen a resounding
leveling up even today.

134
00:07:08.682 --> 00:07:12.540
So even though it feels I go,
God, I know what context is.

135
00:07:12.540 --> 00:07:15.430
That level of precision,
it makes a world of difference.

136
00:07:15.430 --> 00:07:17.870
So here we go, and
what's the first line in side C?

137
00:07:17.870 --> 00:07:19.238
&gt;&gt; Speaker 3: It's counter-plus-plus.

138
00:07:19.238 --> 00:07:20.240
&gt;&gt; Speaker 1: Couner-plus-plus.

139
00:07:20.240 --> 00:07:23.710
Now, where do I look for counter first?

140
00:07:23.710 --> 00:07:25.530
&gt;&gt; Speaker 3: At first in local?

141
00:07:25.530 --> 00:07:26.310
&gt;&gt; Speaker 1: Do I find it?

142
00:07:26.310 --> 00:07:26.950
&gt;&gt; Speaker 3: No.

143
00:07:26.950 --> 00:07:28.180
&gt;&gt; Speaker 1: No, just like that.

144
00:07:28.180 --> 00:07:30.245
This byte gets it gone,
by the way, but yeah.

145
00:07:30.245 --> 00:07:31.989
I've got a new empty local memory.

146
00:07:31.989 --> 00:07:33.437
Where would I look next?

147
00:07:33.437 --> 00:07:35.901
Where would my call stack
sort of simplicity?

148
00:07:35.901 --> 00:07:39.817
Given I'm calling my new function in
global, one might think I'd look next in?

149
00:07:39.817 --> 00:07:40.507
&gt;&gt; Speaker 3: Global.

150
00:07:40.507 --> 00:07:41.753
&gt;&gt; Speaker 1: But
where do I actually look?

151
00:07:41.753 --> 00:07:43.025
&gt;&gt; Speaker 3: You go into your backpack.

152
00:07:43.025 --> 00:07:45.761
&gt;&gt; Speaker 1: Into my,
beautiful music to my ears.

153
00:07:45.761 --> 00:07:46.849
&gt;&gt; Speaker 3: Dora explore it.

154
00:07:46.849 --> 00:07:48.683
&gt;&gt; Speaker 2: [LAUGH]
&gt;&gt; Speaker 1: Yeah.

155
00:07:48.683 --> 00:07:50.305
&gt;&gt; Speaker 3: [LAUGH]
&gt;&gt; Speaker 1: Dora explorer,

156
00:07:50.305 --> 00:07:51.567
I like that actually, she's nice.

157
00:07:51.567 --> 00:07:52.962
Okay, and what do we find?

158
00:07:52.962 --> 00:07:55.180
One, and what do we do to it?

159
00:07:55.180 --> 00:07:56.280
&gt;&gt; Speaker 3: You add one to it.

160
00:07:56.280 --> 00:07:57.360
&gt;&gt; Speaker 1: And we get two okay.

161
00:07:57.360 --> 00:08:01.290
[INAUDIBLE] my bag pack is persistent.

162
00:08:01.290 --> 00:08:03.124
It holds on to that data live.

163
00:08:03.124 --> 00:08:05.728
Man we've answered that thing,

164
00:08:05.728 --> 00:08:11.150
what if our functions have persistent
memory in between [INAUDIBLE]?

165
00:08:11.150 --> 00:08:16.390
Anything are declared inside my new
function fills in the local memory but

166
00:08:16.390 --> 00:08:17.680
[INAUDIBLE] function?

167
00:08:17.680 --> 00:08:19.670
Start again, it's gonna have
to fit it in all there again.

168
00:08:19.670 --> 00:08:22.120
There's no memory between
these function calls.

169
00:08:22.120 --> 00:08:23.000
But hold on,

170
00:08:23.000 --> 00:08:27.770
this backpack of data is attached to
the function definition, persists.

171
00:08:27.770 --> 00:08:32.177
It sticks on the back of the function
definition, in between function calls.

172
00:08:32.177 --> 00:08:35.896
Our function, myNewFunction,
is not just a function,

173
00:08:35.896 --> 00:08:39.084
it's a function With a store
of data on its back.

174
00:08:39.084 --> 00:08:43.349
This is for me the most beautiful
concept in all of JavaScript.

175
00:08:43.349 --> 00:08:45.556
It is the most profound.

176
00:08:45.556 --> 00:08:47.474
We're gonna see OOP tomorrow.

177
00:08:47.474 --> 00:08:48.858
We're gonna see asynchronicity.

178
00:08:48.858 --> 00:08:49.730
Asynchronicity.

179
00:08:49.730 --> 00:08:50.626
Lists of rules.

180
00:08:50.626 --> 00:08:51.562
OOP.

181
00:08:51.562 --> 00:08:53.219
Lists of techniques.

182
00:08:53.219 --> 00:09:00.397
Closure conceptually beautiful and
empowering approach in JavaScript.

