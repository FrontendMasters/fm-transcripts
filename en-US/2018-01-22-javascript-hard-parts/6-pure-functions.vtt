WEBVTT

1
00:00:00.320 --> 00:00:01.740
&gt;&gt; Will Sentance: Functional programming.

2
00:00:01.740 --> 00:00:05.660
Welcome to the next big section
of hard parts as a footnote.

3
00:00:05.660 --> 00:00:06.505
There you go.

4
00:00:06.505 --> 00:00:09.460
[LAUGH] So, functional programming,
core features.

5
00:00:09.460 --> 00:00:11.490
Who thinks they have an idea?

6
00:00:11.490 --> 00:00:12.410
Amine?

7
00:00:12.410 --> 00:00:14.690
Give me something that functional
programming core categories.

8
00:00:14.690 --> 00:00:16.700
There are quite a few,
we're gonna focus on two.

9
00:00:16.700 --> 00:00:18.430
Give me two that stand out to you.

10
00:00:18.430 --> 00:00:20.360
Or give me one that stands out to you,
I mean.

11
00:00:20.360 --> 00:00:21.660
A functional programming.

12
00:00:21.660 --> 00:00:23.150
&gt;&gt; Amine: Function as
a first class citizen.

13
00:00:24.360 --> 00:00:27.090
&gt;&gt; Will Sentance: Good answer,
man, very nice.

14
00:00:27.090 --> 00:00:30.600
So we've already laid out
the underlying principles.

15
00:00:30.600 --> 00:00:34.200
We're now gonna move into
functional programming.

16
00:00:34.200 --> 00:00:37.800
Functional programming is a paradigm.

17
00:00:37.800 --> 00:00:45.120
A means of structuring and thinking
about how we write our code at scale.

18
00:00:45.120 --> 00:00:48.550
So when we're writing code for
other developers to pick up,

19
00:00:48.550 --> 00:00:55.820
when we're writing code for the ability to
add many features in the coming months.

20
00:00:55.820 --> 00:01:00.030
We need a predictable way of
being able to add new features.

21
00:01:00.030 --> 00:01:03.220
We need a way that ensures when someone
else sees our code they can go,

22
00:01:03.220 --> 00:01:04.900
I can reason through this.

23
00:01:04.900 --> 00:01:08.950
Often we think this scale is
about efficiency and performance.

24
00:01:08.950 --> 00:01:13.661
Actually scale is often about,
can other developers see my code and

25
00:01:13.661 --> 00:01:17.876
quickly add features to it because
it was written in a clean,

26
00:01:17.876 --> 00:01:21.450
standardized manner, or
one of those paradigms?

27
00:01:21.450 --> 00:01:24.009
Well what was the most popular
paradigm for writing code?

28
00:01:24.009 --> 00:01:27.369
What was the most popular sort
of prominent paradigm for

29
00:01:27.369 --> 00:01:29.594
writing code in the past 25 years?

30
00:01:29.594 --> 00:01:31.299
It wasn't Functional Programming,
it was something else.

31
00:01:31.299 --> 00:01:33.774
What was it, Griffin?

32
00:01:33.774 --> 00:01:35.560
What was it in the last 20 years?

33
00:01:35.560 --> 00:01:37.349
Most popular paradigm for writing code?

34
00:01:38.450 --> 00:01:40.500
Not Functional Programming,
but something else.

35
00:01:40.500 --> 00:01:41.070
&gt;&gt; Amine: Object oriented.

36
00:01:41.070 --> 00:01:42.173
&gt;&gt; Will Sentance: Object oriented.

37
00:01:42.173 --> 00:01:43.748
That has been the most
popular way of thinking.

38
00:01:43.748 --> 00:01:47.762
We're gonna see that tomorrow in
JavaScript, what it looks like, or

39
00:01:47.762 --> 00:01:51.310
JavaScript sort of version of
object oriented programming.

40
00:01:51.310 --> 00:01:56.970
It's very much a version,
but burgeoning interest

41
00:01:56.970 --> 00:02:02.000
has formed around this paradigm
known as functional programming.

42
00:02:03.176 --> 00:02:07.737
And it's a alternative way of
thinking about structuring our code,

43
00:02:07.737 --> 00:02:12.990
such that it's easy to think about,
reason about and understand and

44
00:02:14.220 --> 00:02:18.490
to add features to other
developers to pick up etc, etc.

45
00:02:18.490 --> 00:02:22.120
There are a number of
core principles to it.

46
00:02:22.120 --> 00:02:25.030
Our friend Amine just
shouted one of them out.

47
00:02:25.030 --> 00:02:29.390
Functions are first class citizens.

48
00:02:29.390 --> 00:02:30.480
We're gonna see what that means.

49
00:02:30.480 --> 00:02:33.180
I'm not gonna go into that yet, we're
gonna see exactly what that means ahead.

50
00:02:34.250 --> 00:02:37.040
But what else?
What's another classic characteristic of

51
00:02:37.040 --> 00:02:37.880
functional programming?

52
00:02:37.880 --> 00:02:40.220
Clara, do you have an idea?

53
00:02:40.220 --> 00:02:41.290
&gt;&gt; Clara: Immutability?

54
00:02:41.290 --> 00:02:42.830
&gt;&gt; Will Sentance: What's
immutability mean?

55
00:02:42.830 --> 00:02:47.190
&gt;&gt; Clara: It's when you create a variable
with some data in it, you can't change it.

56
00:02:48.730 --> 00:02:50.300
&gt;&gt; Will Sentance: That's absolutely right.

57
00:02:50.300 --> 00:02:54.610
Let's even add along to
that pure functions.

58
00:02:54.610 --> 00:02:56.170
What does pure functions mean, Clara?

59
00:02:57.860 --> 00:02:58.830
&gt;&gt; Clara: So no side effects.

60
00:02:58.830 --> 00:03:03.170
So if you have a call of
function you don't then change

61
00:03:03.170 --> 00:03:04.300
other parts of the program.

62
00:03:04.300 --> 00:03:06.060
&gt;&gt; Will Sentance: That's very nicely put.

63
00:03:06.060 --> 00:03:08.590
You do have one consequence.

64
00:03:08.590 --> 00:03:12.830
It's no side effects but you do have one
consequence from calling your functions.

65
00:03:12.830 --> 00:03:16.892
Pure functions and high order functions,
which is what Amine was shouting out,

66
00:03:16.892 --> 00:03:18.997
weâ€™re going to come to those in a moment.

67
00:03:18.997 --> 00:03:23.760
But pure functions no side effects,
means when I run a function its

68
00:03:23.760 --> 00:03:27.843
only consequence,
because it will have a consequence,

69
00:03:27.843 --> 00:03:31.770
its only consequence is
determined by what, Claire?

70
00:03:33.150 --> 00:03:36.000
&gt;&gt; Clara: From the data you give
the parameters of that function.

71
00:03:36.000 --> 00:03:39.720
&gt;&gt; Will Sentance: Is there any consequence
for the little bit at the bottom, return?

72
00:03:39.720 --> 00:03:42.210
It's only consequence is the return value.

73
00:03:42.210 --> 00:03:46.920
That's passing out to an execution
context above some change.

74
00:03:46.920 --> 00:03:51.290
But it's not mutating
anything in global memory.

75
00:03:51.290 --> 00:03:54.170
It's not mutating,
mutating is a posh word for changing.

76
00:03:54.170 --> 00:03:58.620
I don't know why we need a fancy word
when we can just use the word change.

77
00:03:58.620 --> 00:04:03.380
I think people adopt
words to compensate for

78
00:04:03.380 --> 00:04:05.550
not knowing the stuff inside their heart.

79
00:04:05.550 --> 00:04:07.990
So you say fancy words to mask it.

80
00:04:07.990 --> 00:04:12.560
So when we run a function,
in our functional programming land

81
00:04:12.560 --> 00:04:15.700
we do not want the function
to have any consequences,

82
00:04:15.700 --> 00:04:19.640
besides what is determined
in the return statement.

83
00:04:19.640 --> 00:04:24.650
We do not want, inside here to
write something like num plus plus.

84
00:04:24.650 --> 00:04:27.263
And try to speak to num in global memory.

85
00:04:27.263 --> 00:04:34.850
Cause that makes writing tests to
evaluate, is our code working, very hard.

86
00:04:34.850 --> 00:04:39.753
If my only consequence in running my
function is whatever gets returned,

87
00:04:39.753 --> 00:04:44.190
then that means that this function
evaluates to the return value.

88
00:04:44.190 --> 00:04:47.803
Cuz this little block of code will
literally become the code multiplied by

89
00:04:47.803 --> 00:04:50.494
two, will literally
become a value of eight.

90
00:04:50.494 --> 00:04:54.554
This block of code here, evaluating or

91
00:04:54.554 --> 00:04:58.497
testing that is all we will need to do.

92
00:04:58.497 --> 00:05:01.478
Whereas if we have little side effects,
it's very hard to test.

93
00:05:01.478 --> 00:05:05.443
Wow do I possibly write test to check
what my function is doing if inside

94
00:05:05.443 --> 00:05:09.962
the function I'm having effects on my
global memory from within the function?

95
00:05:09.962 --> 00:05:11.603
That's very hard to test.

96
00:05:11.603 --> 00:05:14.880
Very hard to evaluate, so
we don't wanna do that.

97
00:05:14.880 --> 00:05:17.280
Another aspect of pure functions,
and we'll see this in a moment,

98
00:05:17.280 --> 00:05:20.440
is that if I pass in
an input like an array or

99
00:05:20.440 --> 00:05:25.210
an object to my function that's
being passed by reference.

100
00:05:25.210 --> 00:05:29.890
It's referencing the globally defined
object or array and passing it in.

101
00:05:29.890 --> 00:05:35.070
If I mutate that object or
array directly inside of my function body,

102
00:05:35.070 --> 00:05:36.880
I'll actually be mutating, or

103
00:05:36.880 --> 00:05:41.610
altering, the globally defined version
of that object or array as well.

104
00:05:41.610 --> 00:05:43.680
Again, super problematic.

105
00:05:43.680 --> 00:05:44.530
Makes it very hard for

106
00:05:44.530 --> 00:05:49.110
me to know what my function's gonna do,
if it's gonna perform in the way I expect.

107
00:05:49.110 --> 00:05:52.930
Whereas if I can just know that its
only consequences are bundled up

108
00:05:52.930 --> 00:05:54.860
in this return statement, I'm very happy.

