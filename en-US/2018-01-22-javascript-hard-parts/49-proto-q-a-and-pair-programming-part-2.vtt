WEBVTT

1
00:00:00.000 --> 00:00:01.578
&gt;&gt; Will Sentance: All right,
let's have thumbs.

2
00:00:01.578 --> 00:00:04.465
This is solution two, and
by the way, solution three and four,

3
00:00:04.465 --> 00:00:06.027
they are only gonna do this stuff.

4
00:00:06.027 --> 00:00:09.644
We're gonna see some fancy keywords
that you all have heard of and

5
00:00:09.644 --> 00:00:12.560
probably tried to use,
and use effectively maybe.

6
00:00:12.560 --> 00:00:17.432
But those fancy keywords, they're all
just gonna take some of these lines

7
00:00:17.432 --> 00:00:21.229
that we've handwritten here,
and automate them for us.

8
00:00:21.229 --> 00:00:23.407
That's they're gonna do.

9
00:00:23.407 --> 00:00:28.984
We have seen here the essence of how
OOP is implemented in JavaScript.

10
00:00:28.984 --> 00:00:33.277
Using this special
prototypo _proto_bond to

11
00:00:33.277 --> 00:00:38.319
an object above that JavaScript
knows to go and look at,

12
00:00:38.319 --> 00:00:44.989
when it hits an object property that
ain't there on the object directly.

13
00:00:44.989 --> 00:00:47.704
It knows to go check through
its prototypal feature,

14
00:00:47.704 --> 00:00:50.533
it's prototypal nature.
&gt;&gt; Speaker 2: I was kinda wondering if

15
00:00:50.533 --> 00:00:54.466
you can have multiple prototypes.
&gt;&gt; Will Sentance: Great question, so

16
00:00:54.466 --> 00:01:00.319
you you're sort of saying could I
parse in these function store and

17
00:01:00.319 --> 00:01:03.988
then At's function store No you cannot.

18
00:01:03.988 --> 00:01:07.948
You can only have one direct parent but,
of course,

19
00:01:07.948 --> 00:01:14.354
you could then have another parent of that
object and another parent of that object.

20
00:01:14.354 --> 00:01:19.244
And you can have multiple different
children of different types coming

21
00:01:19.244 --> 00:01:22.761
from the same parent that
is known as subclassing.

22
00:01:22.761 --> 00:01:25.959
We're not gonna cover that today.

23
00:01:25.959 --> 00:01:27.875
There is talk I have on that.

24
00:01:27.875 --> 00:01:30.304
Maybe one day we'll do it for the Masters.

25
00:01:30.304 --> 00:01:31.753
It does sub classing in all of OOP.

26
00:01:31.753 --> 00:01:33.572
It is a brutal talk.

27
00:01:33.572 --> 00:01:35.530
There's no way we're
gonna do it right now.

28
00:01:35.530 --> 00:01:40.091
Because, we are more than doing
enough with pure OOP here.

29
00:01:40.091 --> 00:01:45.524
But, yes you not have multiple but you
can have multiple hierarchically up and

30
00:01:45.524 --> 00:01:48.415
they can have multiple descendants out.

31
00:01:48.415 --> 00:01:50.996
One can only have one parent, okay,

32
00:01:50.996 --> 00:01:51.839
Andrew?
&gt;&gt; Andrew: So

33
00:01:51.839 --> 00:01:55.246
does it only create the prototype,
like that,

34
00:01:55.246 --> 00:01:59.248
if you use the object create?
&gt;&gt; Will Sentance: That's not the only way

35
00:01:59.248 --> 00:02:01.023
we can make that bond.

36
00:02:01.023 --> 00:02:05.647
Actually, all objects have
some automatic bonds.

37
00:02:05.647 --> 00:02:09.100
At the top of the chain, so
above userFunctionStore,

38
00:02:09.100 --> 00:02:11.060
userFunctionStore also has.

39
00:02:11.060 --> 00:02:13.711
I don't want to get into this too much,
Andrew, but

40
00:02:13.711 --> 00:02:16.258
it's a little preview also
has a proto bond on it.

41
00:02:16.258 --> 00:02:21.756
Which points up to JavaScript's,
for this one, default object.

42
00:02:21.756 --> 00:02:24.943
Which has a whole bunch of
shared functions of it's own.

43
00:02:24.943 --> 00:02:29.909
Things like get prototype of all
the functions you could ever call

44
00:02:29.909 --> 00:02:30.996
on an object.

45
00:02:30.996 --> 00:02:33.560
JavaScript dog foods
it's own functionality,

46
00:02:33.560 --> 00:02:36.192
it uses it's own built in
prototype chain to let.

47
00:02:36.192 --> 00:02:41.303
When you do an array.push,
that push is actually stored

48
00:02:41.303 --> 00:02:46.518
on any array that gets created
it has it's own parent which

49
00:02:46.518 --> 00:02:51.639
is all the bonus functionality
that we can use on arrays.

50
00:02:51.639 --> 00:02:56.965
So when you do an array.push,
array is an array.

51
00:02:56.965 --> 00:03:02.059
Well that guy here has his own
because really an array is

52
00:03:02.059 --> 00:03:08.703
just actually an object, has its own
proto bond, to the array object,

53
00:03:08.703 --> 00:03:14.610
that has all of the shared
functionality that all arrays have.

54
00:03:14.610 --> 00:03:16.060
Push, pop, all of these.

55
00:03:16.060 --> 00:03:20.049
I won't go into that too much but
Andrew, as a preview there,

56
00:03:20.049 --> 00:03:23.289
all of these objects have
a proto bond by default.

57
00:03:23.289 --> 00:03:26.312
What we're really doing here is
inserting our own in the way.

58
00:03:26.312 --> 00:03:32.822
So there's a default one here which is all
objects proto is just the overall object,

59
00:03:32.822 --> 00:03:36.674
which has on it's own
a bunch of properties like,

60
00:03:36.674 --> 00:03:41.827
get prototype of all of these
functions can be used on all objects.

61
00:03:41.827 --> 00:03:44.162
Because they are all available
up the prototype chain.

62
00:03:44.162 --> 00:03:48.784
But we are just inserting
ourselves in the way here,

63
00:03:48.784 --> 00:03:54.991
to set our own user functions in
the entrance, so we check that first.

64
00:03:54.991 --> 00:03:58.115
Does that make sense,
|I don't want that too much if your mind.

65
00:03:58.115 --> 00:04:01.388
I don't wanna go in too
much if you don't mind.

66
00:04:01.388 --> 00:04:04.980
But just know that every object
has an underscore proto.

67
00:04:04.980 --> 00:04:09.950
Underscore is just that we're
overriding the standard one here,

68
00:04:09.950 --> 00:04:12.798
with our own set of shared functions.

69
00:04:12.798 --> 00:04:18.050
All of our objects that were created by
user creator have access to, okay, Andrew?

70
00:04:18.050 --> 00:04:21.534
There's more clarifications, Katie?
&gt;&gt; Katie: I'm clarified now.

71
00:04:21.534 --> 00:04:22.512
&gt;&gt; Will Sentance: You are, there we go.

72
00:04:22.512 --> 00:04:26.969
Griffin first, Griffin first.
&gt;&gt; Griffin: You says like it's overriding

73
00:04:26.969 --> 00:04:30.418
the object one,
you can still get to the object, right?

74
00:04:30.418 --> 00:04:32.090
&gt;&gt; Will Sentance: Because we're overriding

75
00:04:32.090 --> 00:04:35.291
it with an object which
who's object prototype is?

76
00:04:35.291 --> 00:04:35.826
&gt;&gt; Griffin: Is-

77
00:04:35.826 --> 00:04:36.630
&gt;&gt; Will Sentance: The main one yeah,

78
00:04:36.630 --> 00:04:38.877
exactly, so it's a chain all the way up.
&gt;&gt; Griffin: Okay.

79
00:04:38.877 --> 00:04:39.929
&gt;&gt; Will Sentance: Great clarification,

80
00:04:39.929 --> 00:04:42.139
Griffin, Dave?
&gt;&gt; Dave: That second line up there,

81
00:04:42.139 --> 00:04:44.876
that let new user = object.create user-
&gt;&gt; Will Sentance: Yeah.

82
00:04:44.876 --> 00:04:45.782
&gt;&gt; Dave: How do you say that in English-

83
00:04:45.782 --> 00:04:47.134
&gt;&gt; Will Sentance: What's the right kind

84
00:04:47.134 --> 00:04:48.890
of communication?
&gt;&gt; Dave: Yeah.

85
00:04:48.890 --> 00:04:49.592
&gt;&gt; Will Sentance: We are declaring.

86
00:04:49.592 --> 00:04:50.735
Okay, very nice.

87
00:04:50.735 --> 00:04:51.456
I like that question, Dave.

88
00:04:51.456 --> 00:04:52.372
Very thoughtful question.

89
00:04:52.372 --> 00:04:56.420
We are declaring an object.

90
00:04:56.420 --> 00:05:02.091
We're declaring new user and
assigning to it,

91
00:05:02.091 --> 00:05:10.191
an empty object with the prototype
of it being user function store.

92
00:05:10.191 --> 00:05:13.131
Now again,
I hate this with the prototype okay,

93
00:05:13.131 --> 00:05:15.869
I wish we said with
the _proto_ of it being.

94
00:05:15.869 --> 00:05:18.309
But _proto_ is the label we give to.

95
00:05:18.309 --> 00:05:23.286
The prototype, we call whatever is
here the prototype of this object, but

96
00:05:23.286 --> 00:05:26.841
it's not stored in a property
called the prototype,

97
00:05:26.841 --> 00:05:29.938
it's stored in a property called _proto_.

98
00:05:29.938 --> 00:05:33.559
It is what it is but
it causes a humongous amount of confusion.

99
00:05:33.559 --> 00:05:37.463
I'm gonna see why in a moment, but
there is a property called, prototype,

100
00:05:37.463 --> 00:05:41.379
and it ain't this one, and it ain't
behaving the way this one is behaving.

101
00:05:41.379 --> 00:05:45.900
That's why I don't like the fact we call
this guy the prototype of this object,

102
00:05:45.900 --> 00:05:48.006
because it's stored in _proto_.

103
00:05:48.006 --> 00:05:49.360
It's the _proto_,

104
00:05:49.360 --> 00:05:53.572
so I just say it's the object that's
one step up the prototype chain.

105
00:05:53.572 --> 00:05:54.718
Not exactly a catchy phrase.

106
00:05:54.718 --> 00:05:57.070
If you wanted to say that,
you could say declare new user,

107
00:05:57.070 --> 00:05:58.183
assign to an empty object.

108
00:05:58.183 --> 00:06:01.043
We've view the function store says
as the object that's one step

109
00:06:01.043 --> 00:06:02.142
up the prototype chain.

110
00:06:02.142 --> 00:06:03.628
If you wanna be super intuitive.

111
00:06:03.628 --> 00:06:08.987
But the typical ways, we've use
the function store as new users prototype.

112
00:06:08.987 --> 00:06:12.194
Okay, ask the question, Dave.
&gt;&gt; Dave: Yeah.

113
00:06:12.194 --> 00:06:12.976
&gt;&gt; Will Sentance: You wanna try again?

114
00:06:12.976 --> 00:06:16.743
&gt;&gt; Dave: The distinction between prototype

115
00:06:16.743 --> 00:06:20.008
and inherit from-
&gt;&gt; Will Sentance: In JavaScript,

116
00:06:20.008 --> 00:06:20.704
by the way,

117
00:06:20.704 --> 00:06:25.305
I actually wrote a little note to myself
when I first started giving this talk.

118
00:06:25.305 --> 00:06:28.619
I hate the word inherit,
describing what we're doing here.

119
00:06:28.619 --> 00:06:33.072
Does inherit make it feel like you've
actually copied down the functionality on

120
00:06:33.072 --> 00:06:33.929
to the object?

121
00:06:33.929 --> 00:06:35.070
It does to me a bit.

122
00:06:35.070 --> 00:06:41.713
This here, increment, so
user1 inherits from userFunctionStore,

123
00:06:41.713 --> 00:06:46.925
when we say inherit in JavaScript,
that is all we mean.

124
00:06:46.925 --> 00:06:49.906
Now are we copying those
functions down to user1?

125
00:06:49.906 --> 00:06:54.654
No, inheritance is a weird ass
word to use for this process.

126
00:06:54.654 --> 00:06:59.623
What actually happens is when we run User1
with a function reference on it that

127
00:06:59.623 --> 00:07:03.086
isn't in user1,
we check it's proto, _proto_,

128
00:07:03.086 --> 00:07:06.572
where we find this other object,
use function store.

129
00:07:06.572 --> 00:07:10.793
And we look up to it and go,
there's an increment function there.

130
00:07:10.793 --> 00:07:16.416
Now does that mean in a sense that
user1 inherits increment function?

131
00:07:16.416 --> 00:07:20.680
I guess it feels like it does but
that is not being copied down,

132
00:07:20.680 --> 00:07:26.010
JavaScript at the run time is going to
look up at that stuff and finds it there.

133
00:07:26.010 --> 00:07:29.224
But when you hear people saying
user1 inherited increment,

134
00:07:29.224 --> 00:07:31.521
that's exactly what it's saying, okay?

135
00:07:31.521 --> 00:07:35.347
So we're gonna do another block of
pairing, just to cement some of these

136
00:07:35.347 --> 00:07:39.503
stuff, and in a moment after that we're
gonna come back and say you know what?

137
00:07:39.503 --> 00:07:44.502
All this writing, object.create,
new user, return new user.

138
00:07:44.502 --> 00:07:49.922
We're gonna automate it all away,
with the insertion of a magic key word.

139
00:07:49.922 --> 00:07:52.585
What's that magic key word do we think?
&gt;&gt; Dave: Prototype.

140
00:07:52.585 --> 00:07:53.497
&gt;&gt; Will Sentance: No.

141
00:07:53.497 --> 00:07:54.384
[LAUGH]

142
00:07:54.384 --> 00:07:55.703
&gt;&gt; Dave: [LAUGH]
&gt;&gt; Will Sentance: Give me

143
00:07:55.703 --> 00:07:56.606
three letters, new, exactly.

144
00:07:56.606 --> 00:08:01.353
That's gonna automate a tonne
of all these work for us.

145
00:08:01.353 --> 00:08:04.747
That work of creating an object, but

146
00:08:04.747 --> 00:08:09.453
when it gets returned out
give it a label get somehow

147
00:08:09.453 --> 00:08:14.605
a special secret bond to
the shared store of functions.

148
00:08:14.605 --> 00:08:18.711
We're gonna automate so
much of these with the keyword new.

149
00:08:18.711 --> 00:08:22.803
But for now folk back to the challenges.

