WEBVTT

1
00:00:00.000 --> 00:00:05.075
So we're gonna do thumbs in a second and
really hold yourself accountable.

2
00:00:05.075 --> 00:00:09.677
There's [INAUDIBLE] fantastic
clarifications to be asked about hold

3
00:00:09.677 --> 00:00:14.039
on how is this even,
working what's going on here.Griffin will

4
00:00:14.039 --> 00:00:18.876
you kick us off with your clarification.
&gt;&gt; Does this stay via like through

5
00:00:18.876 --> 00:00:19.940
page reloads.

6
00:00:19.940 --> 00:00:21.540
Through page reloads.

7
00:00:21.540 --> 00:00:24.900
If you are totally refreshing your page,
I mean,

8
00:00:24.900 --> 00:00:28.740
you will restart your JavaScript
loading from scratch.

9
00:00:28.740 --> 00:00:33.940
Now, if you are, you know, typically
doing that a lot of the time nowadays,

10
00:00:33.940 --> 00:00:38.749
if you are doing what you more typically
doing, which is like, You know,

11
00:00:38.749 --> 00:00:41.738
collecting more tweets.
&gt;&gt; Changing the state of [CROSSTALK]

12
00:00:41.738 --> 00:00:43.629
&gt;&gt; The state of the page, absolutely.

13
00:00:43.629 --> 00:00:47.533
But if you're refreshing your JavaScript
file is reloading from scratch.

14
00:00:47.533 --> 00:00:49.790
You're starting at the top all over again.

15
00:00:49.790 --> 00:00:53.328
Good question, I've never had
that question before, it's nice.

16
00:00:53.328 --> 00:00:54.243
&gt;&gt; Is there a way to,

17
00:00:54.243 --> 00:00:56.744
how can I locate that data
if I wanted to save it for

18
00:00:56.744 --> 00:00:59.367
a page reload that I could load back in?
&gt;&gt; Yeah.

19
00:00:59.367 --> 00:01:00.404
Where is this data?

20
00:01:00.404 --> 00:01:02.870
Can I just do
myFunction.counter do we think?

21
00:01:02.870 --> 00:01:07.718
Uh-uh, this is not sitting as
a property or minute function.

22
00:01:07.718 --> 00:01:08.633
This is no.

23
00:01:08.633 --> 00:01:12.749
Actually, let's now add
where this data is stored.

24
00:01:12.749 --> 00:01:17.504
I don't know where it's stored,
but how the bond gets made.

25
00:01:17.504 --> 00:01:20.888
I said that when increment
counter is to find

26
00:01:20.888 --> 00:01:23.597
inside of the outer Execution context.

27
00:01:23.597 --> 00:01:27.718
When we're running outer, when we
run outer we create a counter zero.

28
00:01:27.718 --> 00:01:29.642
Increment count as a function and

29
00:01:29.642 --> 00:01:33.627
then we return this increment count
function out to my new function.

30
00:01:33.627 --> 00:01:35.755
And we call my new function and so on.

31
00:01:35.755 --> 00:01:37.679
When we define increment count,

32
00:01:37.679 --> 00:01:41.595
we just said we make a bond between
the increment counter function.

33
00:01:41.595 --> 00:01:45.763
Make a bond between it And
it's surrounding life data.

34
00:01:45.763 --> 00:01:47.458
Where is that bond?

35
00:01:47.458 --> 00:01:49.053
What is that bond?

36
00:01:49.053 --> 00:01:55.335
Or if you look in the JavaScript specs
it's defined we don't get to see it.

37
00:01:55.335 --> 00:01:59.526
We can not do that increment
counter.backpack or

38
00:01:59.526 --> 00:02:02.250
whatever it is not in that book.

39
00:02:02.250 --> 00:02:06.758
It makes the bond using this
special property called,

40
00:02:06.758 --> 00:02:11.169
does anyone know?
&gt;&gt; It's not that,

41
00:02:11.169 --> 00:02:15.873
it's this guy here,
square bracket, square bracket,

42
00:02:15.873 --> 00:02:19.499
scope, square bracket, square bracket.

43
00:02:19.499 --> 00:02:23.657
The function gets a hidden
property Behind the scenes of it.

44
00:02:23.657 --> 00:02:25.880
So if I were to console
log incrementCounter,

45
00:02:25.880 --> 00:02:27.419
this is a function definition.

46
00:02:27.419 --> 00:02:31.238
There's no dot, square bracket,
square bracket, scope, square bracket,

47
00:02:31.238 --> 00:02:32.093
square bracket.

48
00:02:32.093 --> 00:02:33.347
It's just a definition.

49
00:02:33.347 --> 00:02:35.285
Behind the scenes it has a special bond.

50
00:02:35.285 --> 00:02:39.560
Square bracket, square bracket, square
bracket, square bracket, square bracket.

51
00:02:39.560 --> 00:02:41.042
Yeah, that thing I just said.

52
00:02:41.042 --> 00:02:42.760
Square bracket, square bracket.

53
00:02:42.760 --> 00:02:49.422
So, scope-square bracket-square bracket is
a hidden bond of the back of the function

54
00:02:49.422 --> 00:02:54.732
definition where we make a bond to
the surrounding store of live data.

55
00:02:54.732 --> 00:02:57.162
Now, that is only accessible.

56
00:02:57.162 --> 00:03:00.222
How can I access that live store of data?

57
00:03:00.222 --> 00:03:05.173
By call answers it by doing my new
function .scope.counter Is not

58
00:03:05.173 --> 00:03:06.274
available there.

59
00:03:06.274 --> 00:03:09.508
It's only available from where, Aman?

60
00:03:09.508 --> 00:03:12.257
Where is it available from?
&gt;&gt; That was gonna be my

61
00:03:12.257 --> 00:03:15.351
question.
&gt;&gt; It's only available from the call to

62
00:03:15.351 --> 00:03:16.314
this function.

63
00:03:16.314 --> 00:03:20.781
I want to access this data, I've got to
call my new function inside of which,

64
00:03:20.781 --> 00:03:24.564
if I make reference to something
that's not available in local,

65
00:03:24.564 --> 00:03:29.724
I get access To the back pack,
to the square bracket, square bracket,

66
00:03:29.724 --> 00:03:36.597
square bracket, square bracket, JavaScript
has something, what weâ€™ll see in a second,

67
00:03:36.597 --> 00:03:41.616
but for now, this pond her is made
behind the scenes, the state to it

68
00:03:41.616 --> 00:03:46.930
is only accessible when I call
the function, I have to write my function

69
00:03:46.930 --> 00:03:51.864
In this case we've got a increment counter
in a really smart way such that it can be,

70
00:03:51.864 --> 00:03:56.236
has all the functionality that I ever
want to interact with the backpack.

71
00:03:56.236 --> 00:03:57.364
So I might write for

72
00:03:57.364 --> 00:04:01.455
example increment counter takes in
a parameter which when I call it.

73
00:04:01.455 --> 00:04:03.993
Refers to something that
is not in local but

74
00:04:03.993 --> 00:04:08.970
refers to the backpack value of counter
and updates the backpack value of counter.

75
00:04:08.970 --> 00:04:14.162
If I wanna get my backpack data out,
I'm gonna make sure that I return counter.

76
00:04:14.162 --> 00:04:17.418
Well counter isn't in local,
it's out here, so

77
00:04:17.418 --> 00:04:21.757
I'm gonna get that backpack value
out the bottom of the function.

78
00:04:21.757 --> 00:04:23.771
That's how I get access to it.

79
00:04:23.771 --> 00:04:26.639
But this bundled up
data here is protected.

80
00:04:26.639 --> 00:04:30.125
I can only get access to it
from inside my function call

81
00:04:30.125 --> 00:04:34.423
when I call the function that
has The backpack bond to it.

82
00:04:34.423 --> 00:04:36.905
All right, so that's one.

83
00:04:36.905 --> 00:04:41.354
Still there's more
clarifications which can draw

84
00:04:41.354 --> 00:04:44.458
out more of the subtleties of this.

85
00:04:44.458 --> 00:04:48.286
Katie?
&gt;&gt; That was part of my clarification.

86
00:04:48.286 --> 00:04:53.470
I was trying to understand if
when you call, my new function

87
00:04:53.470 --> 00:04:58.602
If it's really just referencing
that?&gt;&gt; When we return

88
00:04:58.602 --> 00:05:04.760
out the icnrement counter funtion
with it's little backpack of data.

89
00:05:04.760 --> 00:05:08.160
That backpack is defintely not a copy.

90
00:05:08.160 --> 00:05:10.495
It's the original data
that was created in here.

91
00:05:10.495 --> 00:05:14.611
But instead of normally when we finish
running what happens to all this data?

92
00:05:14.611 --> 00:05:15.500
Somebody said it.

93
00:05:15.500 --> 00:05:19.226
Andrea, when we finish running what
happens with all this all data?

94
00:05:19.226 --> 00:05:20.005
&gt;&gt; It's garbage.

95
00:05:20.005 --> 00:05:20.896
&gt;&gt; Garbage.

96
00:05:20.896 --> 00:05:22.452
JavaScript goes, hold on.

97
00:05:22.452 --> 00:05:24.620
Hold on.
The function that got returned out.

98
00:05:24.620 --> 00:05:26.064
If it gets called, shit,

99
00:05:26.064 --> 00:05:29.790
it's gonna make reference to something
that was still defined in here.

100
00:05:29.790 --> 00:05:32.103
I better not let garbage collect that.

101
00:05:32.103 --> 00:05:34.274
I better leave that in the back half.

102
00:05:34.274 --> 00:05:38.339
And that brings me to a real subtlety,
JavaScript's engines try and

103
00:05:38.339 --> 00:05:39.320
optimize this.

104
00:05:39.320 --> 00:05:43.106
Suppose we defined 100 different
variables inside of here,

105
00:05:43.106 --> 00:05:45.629
each with different numbers or whatever.

106
00:05:45.629 --> 00:05:47.660
I mean only ever refer to counter,

107
00:05:47.660 --> 00:05:50.640
do we want all that data
kept around in a backpack?

108
00:05:50.640 --> 00:05:54.842
No, so JavaScript will actually,
the bond is when the function's

109
00:05:54.842 --> 00:05:58.972
defined is made to the entire
surrounding variable environment.

110
00:05:58.972 --> 00:06:00.890
It's surrounding live data.

111
00:06:00.890 --> 00:06:05.684
But when that function gets passed out,
JavaScript does it's usual garbage

112
00:06:05.684 --> 00:06:10.330
collection like hold on everything,
we've got some references to data.

113
00:06:10.330 --> 00:06:12.790
If I run my new function, if I run this.

114
00:06:12.790 --> 00:06:16.683
Increment counter function under
it's new label myNewFunction.

115
00:06:16.683 --> 00:06:19.480
Inside of it,
it references counter, ah-ah,

116
00:06:19.480 --> 00:06:24.460
we better make sure we hold on to the data
in the backpack that could be referenced.

117
00:06:24.460 --> 00:06:29.169
But there's 99 variables here like,
I don't know, counter 1, counter 2,

118
00:06:29.169 --> 00:06:31.050
counter 3 that are never used.

119
00:06:31.050 --> 00:06:32.775
Remove those from memory.

120
00:06:32.775 --> 00:06:34.275
You don't need those.

121
00:06:34.275 --> 00:06:39.229
So Java is actually only going to hold
to the increment counter function here.

122
00:06:39.229 --> 00:06:41.855
That ain't used inside my new function.

123
00:06:41.855 --> 00:06:45.458
So increment counter will not
be stored in the backpack.

124
00:06:45.458 --> 00:06:50.110
It takes only the data, takes the whole
backpack, the whole surrounding

125
00:06:50.110 --> 00:06:54.887
variable enviroment but only persists
Only holds onto the stuff that could ever

126
00:06:54.887 --> 00:06:59.222
be referred from inside the returned out
function, cuz we can only access its

127
00:06:59.222 --> 00:07:02.757
backpack data from where?
&gt;&gt; From the function itself.

128
00:07:02.757 --> 00:07:04.557
&gt;&gt; From the calls of the function.

129
00:07:04.557 --> 00:07:09.024
So if we didn't write this function,
we defined this function inside of here.

130
00:07:09.024 --> 00:07:11.756
So we didn't write it to
refer to anything else,

131
00:07:11.756 --> 00:07:14.948
no one's gonna access that live data But
look at this.

132
00:07:14.948 --> 00:07:17.219
Our function that got returned out,

133
00:07:17.219 --> 00:07:20.883
my new function that's called
increment counter inside.

134
00:07:20.883 --> 00:07:22.127
We returned it out.

135
00:07:22.127 --> 00:07:24.251
We did not just get a function out.

136
00:07:24.251 --> 00:07:29.231
Now do we see why it's so powerful to
design a function inside another function.

137
00:07:29.231 --> 00:07:31.428
We didn't just get a function out.

138
00:07:31.428 --> 00:07:34.320
We got a function plus
a backpack of live data.

139
00:07:34.320 --> 00:07:38.255
And now I think it's time to reveal
what people actually call the backpack,

140
00:07:38.255 --> 00:07:40.777
because obviously you
can't say that forever.

141
00:07:40.777 --> 00:07:44.775
People actually call it, colloquially,
I hate the colloquial term for it.

142
00:07:44.775 --> 00:07:48.403
People call it, they say,
this is the closure, or this is a closure.

143
00:07:48.403 --> 00:07:52.523
I hate that, some people call the whole
concept closure and they're not sure,

144
00:07:52.523 --> 00:07:54.280
they don't mean the backpacks.

145
00:07:54.280 --> 00:07:58.895
But people would typically colloquially
say my new functions closure.

146
00:07:58.895 --> 00:08:00.256
This is the closure.

147
00:08:00.256 --> 00:08:01.388
I love this term.

148
00:08:01.388 --> 00:08:03.278
I think it's super precise.

149
00:08:03.278 --> 00:08:06.831
I like to call it the closed
over variable environment.

150
00:08:06.831 --> 00:08:09.403
The closed over variable environment.

151
00:08:09.403 --> 00:08:10.311
C-O-V-E.

152
00:08:10.311 --> 00:08:13.484
The cove,
I'm going to make that one big as well.

153
00:08:13.484 --> 00:08:14.200
The COVE.

154
00:08:14.200 --> 00:08:15.982
This guy here is the code.

155
00:08:15.982 --> 00:08:18.738
You can also call it this.

156
00:08:18.738 --> 00:08:20.520
You can also call it this.

157
00:08:20.520 --> 00:08:22.466
When a function is defined,

158
00:08:22.466 --> 00:08:26.440
increment counter is defined
inside of the called outer.

159
00:08:26.440 --> 00:08:31.225
It gets a square bracket,
square bracket, scope, square bracket,

160
00:08:31.225 --> 00:08:35.850
square bracket, hidden property
The reference is its local memory or

161
00:08:35.850 --> 00:08:40.200
variable environment, the same thing,
where it has been defined.

162
00:08:40.200 --> 00:08:42.750
So when I then return out that function,

163
00:08:42.750 --> 00:08:47.775
as we do when we call we return our
incrementCounter and store it where?

164
00:08:47.775 --> 00:08:53.175
Lindsay, when I call it when I run and
create incrementCounter inside of it,

165
00:08:53.175 --> 00:08:56.640
where do I then store
the incrementCounter function?

166
00:08:56.640 --> 00:09:00.195
In my new function.
&gt;&gt; Excellent, my new function.

167
00:09:00.195 --> 00:09:02.842
Wherever I call that functionality,

168
00:09:02.842 --> 00:09:08.632
wherever I run invoke execute that
functionality, increment counter function,

169
00:09:08.632 --> 00:09:12.600
it will always look first in
its immediate local memory.

170
00:09:12.600 --> 00:09:14.088
Fine, we know that.

171
00:09:14.088 --> 00:09:19.272
But then, before it looks in the next
execution context out It will look

172
00:09:19.272 --> 00:09:24.384
in its scope, its square bracket,
square bracket scope,

173
00:09:24.384 --> 00:09:29.803
square bracket, square bracket property,
in its backpack.

174
00:09:29.803 --> 00:09:33.992
Or we could [SOUND] call it,
in its lexical scope.

175
00:09:33.992 --> 00:09:40.679
Because this bond here, to the surrounding
live data, is known as Lexical scope.

176
00:09:40.679 --> 00:09:44.366
It's the I am determined,
my functionality when it gets calls,

177
00:09:44.366 --> 00:09:49.060
values that are available, variables that
are available to it are determined from

178
00:09:49.060 --> 00:09:51.875
where I was defined,
not from where I was called.

179
00:09:51.875 --> 00:09:53.751
I'm being called in global, but

180
00:09:53.751 --> 00:09:57.239
that's not telling me what
data's gonna be available to me.

181
00:09:57.239 --> 00:10:01.887
What's telling me what data's gonna be
available to me is where I was defined And

182
00:10:01.887 --> 00:10:05.405
there, JavaScript static or
lexical scoping.

183
00:10:05.405 --> 00:10:09.607
This is what it means when we
say JavaScript is lexically or

184
00:10:09.607 --> 00:10:11.152
statically scoped.

185
00:10:11.152 --> 00:10:16.128
That means, lexical means the position
of my function definition,

186
00:10:16.128 --> 00:10:21.103
not where it gets invoked,
is ultimately what determines what data I

187
00:10:21.103 --> 00:10:25.520
will have available to me when
my function does get invoked.

188
00:10:25.520 --> 00:10:29.524
So we might think where I run
the functionality, it was born in here,

189
00:10:29.524 --> 00:10:31.803
out here, and it references counter.

190
00:10:31.803 --> 00:10:36.224
If I'm local, my next function's
being run in global, we're in global.

191
00:10:36.224 --> 00:10:39.816
But we don't look at global
first because our lexical scope,

192
00:10:39.816 --> 00:10:43.062
the available live data when
our function was defined,

193
00:10:43.062 --> 00:10:46.930
the available live data around me
is what determines our available

194
00:10:46.930 --> 00:10:51.211
variable Variables and
the prioritization at function execution.

195
00:10:51.211 --> 00:10:53.424
Not where our function was called.

196
00:10:53.424 --> 00:10:57.112
My new function was called here,
but because it was defined

197
00:10:57.112 --> 00:11:02.055
long ago inside the called author,
it never lost its lexical scope reference.

198
00:11:02.055 --> 00:11:06.847
So that when I call the function, I always
go look in the local first recalls.

199
00:11:06.847 --> 00:11:12.060
But I always go look in my let's go scope
reference, my let's go scope reference.

200
00:11:12.060 --> 00:11:16.032
Backpack before I ever
look another layer out.

201
00:11:16.032 --> 00:11:21.989
I always look in my backpack first,
my lexical scope reference first,

202
00:11:21.989 --> 00:11:26.158
or I call my new function
with my [INAUDIBLE] first.

203
00:11:26.158 --> 00:11:30.727
My close over variable
environment got closed over and

204
00:11:30.727 --> 00:11:34.230
pulled out of the variable environment.

205
00:11:34.230 --> 00:11:39.615
Or the colloquial term that I don't love,
my closure.

206
00:11:39.615 --> 00:11:44.771
And the colloquial term that I do love,
my backpack.

207
00:11:44.771 --> 00:11:47.865
There's a lot of terms for it but

208
00:11:47.865 --> 00:11:53.250
I guess the most precise is
my lexical scope reference.

209
00:11:53.250 --> 00:11:59.747
That's the guy that refers to The little
bond that refers to the surrounding data.

210
00:11:59.747 --> 00:12:04.797
Closed over, variable environment,
closure, the function comes out.

211
00:12:04.797 --> 00:12:09.126
And it's still got it's back
pack on until yeah, it's there.

212
00:12:09.126 --> 00:12:11.932
It's attached to the function.

213
00:12:11.932 --> 00:12:12.752
All right.

