WEBVTT

1
00:00:00.090 --> 00:00:01.990
&gt;&gt; Will: There you go, so
there's more stuff to add.

2
00:00:01.990 --> 00:00:06.670
Now, we are now, I think, reaching
most of the key pieces being added.

3
00:00:06.670 --> 00:00:08.640
Do we still have some medium thumbs?

4
00:00:08.640 --> 00:00:10.100
Andrea, go ahead.

5
00:00:10.100 --> 00:00:14.292
&gt;&gt; Andrea: So how do you properly
garbage collect the live data?

6
00:00:14.292 --> 00:00:19.170
Does it just, as long as there is
a minding function it stays there, right?

7
00:00:19.170 --> 00:00:21.420
I guess I'm a little.

8
00:00:21.420 --> 00:00:24.570
&gt;&gt; Will: So the reason you're doing
this is because you want this.

9
00:00:24.570 --> 00:00:25.910
You mean this live data here?

10
00:00:25.910 --> 00:00:26.481
&gt;&gt; Andrea: Yeah [CROSSTALK].

11
00:00:26.481 --> 00:00:29.020
&gt;&gt; Will: But the reason you're doing this
is you want that data to stick around.

12
00:00:29.020 --> 00:00:30.524
&gt;&gt; Andrea: Right, so
let's say you're done,

13
00:00:30.524 --> 00:00:33.880
let's say you're doing a big program and
you don't want it to have a memory link.

14
00:00:33.880 --> 00:00:35.630
&gt;&gt; Will: Spot on, very,
very fair question.

15
00:00:35.630 --> 00:00:38.590
Well, where is this scope
property attached to?

16
00:00:38.590 --> 00:00:39.980
&gt;&gt; Andrea: To the function.

17
00:00:39.980 --> 00:00:42.080
&gt;&gt; Will: To the function value.

18
00:00:42.080 --> 00:00:43.090
&gt;&gt; Andrea: Value, okay.

19
00:00:43.090 --> 00:00:46.920
&gt;&gt; Will: So what could I do to change out
the value attached to my new function?

20
00:00:47.940 --> 00:00:50.380
Java script is a dynamic language,
what could I do?

21
00:00:50.380 --> 00:00:51.350
&gt;&gt; Andrea: Assign it something else?

22
00:00:51.350 --> 00:00:52.200
&gt;&gt; Will: Assign it something else.

23
00:00:52.200 --> 00:00:55.840
Overwrite everything, including the hidden
scope property included into the map pack.

24
00:00:55.840 --> 00:00:56.800
Great question, Andrea.

25
00:00:56.800 --> 00:01:02.380
What a fantastic question,
never had that question before.

26
00:01:02.380 --> 00:01:03.804
Katie?
&gt;&gt; Katie: [LAUGH] Now I have

27
00:01:03.804 --> 00:01:04.966
another one so.

28
00:01:04.966 --> 00:01:07.949
[CROSSTALK] Okay so what if we do want,

29
00:01:07.949 --> 00:01:14.032
I know that we don't have access to
that counter but then what is the point?

30
00:01:14.032 --> 00:01:17.800
&gt;&gt; Will: Well we do have access,
where do we have access to it from?

31
00:01:17.800 --> 00:01:21.390
By running this function and making sure
that the function was written in such

32
00:01:21.390 --> 00:01:24.650
a way that it refers to
something that ain't defined.

33
00:01:24.650 --> 00:01:27.240
So if we look, so let's see this.

34
00:01:28.460 --> 00:01:31.880
What is my new function,
the functionality of?

35
00:01:32.900 --> 00:01:33.420
Katie?
&gt;&gt; Katie: The increment.

36
00:01:34.920 --> 00:01:35.900
&gt;&gt; Will: Increment counter.

37
00:01:35.900 --> 00:01:39.080
Do we define anything inside increment
counter, now known as my new function?

38
00:01:40.080 --> 00:01:40.940
No we don't, right?

39
00:01:40.940 --> 00:01:43.010
All we do is refer to this counter thing.

40
00:01:43.010 --> 00:01:45.947
Well that means we go looking for
it in local.

41
00:01:45.947 --> 00:01:50.353
We didn't define anything in local,
right, so

42
00:01:50.353 --> 00:01:56.380
we look next up in the backpack that
came out on the my new function.

43
00:01:56.380 --> 00:01:57.905
On the increment counter function
stored in my new function.

44
00:01:57.905 --> 00:02:01.160
Had a little backpack on it
where counter is zero in it and

45
00:02:01.160 --> 00:02:04.361
so we can go and interact and
increment counter to one.

46
00:02:04.361 --> 00:02:06.556
Katie?

47
00:02:06.556 --> 00:02:11.254
&gt;&gt; Katie: What if I want
to use that outside

48
00:02:11.254 --> 00:02:15.159
[CROSSTALK]
&gt;&gt; Will: It's sort of bundled up inside

49
00:02:15.159 --> 00:02:16.424
there, right?

50
00:02:16.424 --> 00:02:17.167
&gt;&gt; Katie: Yeah.

51
00:02:17.167 --> 00:02:20.010
&gt;&gt; Will: Well then let's write
a really useful statement.

52
00:02:20.010 --> 00:02:24.510
Let's change the definition of increment
counter to counter plus-plus, sure,

53
00:02:24.510 --> 00:02:29.430
but then add a line in it that says,
return counter.

54
00:02:30.860 --> 00:02:34.490
So now, if I ran my new function,
counter plus-plus,

55
00:02:34.490 --> 00:02:35.980
do I find counter in my local memory?

56
00:02:37.610 --> 00:02:38.990
No?
Where do I look next, Muhammad?

57
00:02:40.050 --> 00:02:40.650
&gt;&gt; Muhammad: In the backpack.

58
00:02:40.650 --> 00:02:41.250
&gt;&gt; Will: In the backpack.

59
00:02:41.250 --> 00:02:43.250
See, tell me that isn't the best term for
it.

60
00:02:43.250 --> 00:02:44.560
&gt;&gt; [LAUGH]
&gt;&gt; Will: In the backpack what do I find?

61
00:02:44.560 --> 00:02:46.745
Well, let's pretend we haven't run it yet,
what do I find, Mohammad?

62
00:02:46.745 --> 00:02:47.250
&gt;&gt; Muhammad: Zero.

63
00:02:47.250 --> 00:02:49.804
&gt;&gt; Will: Zero, yeah,
counter is zero increment to one, and

64
00:02:49.804 --> 00:02:53.380
then the next line I hit inside
the myNewFunction call says return?

65
00:02:53.380 --> 00:02:54.320
&gt;&gt; Muhammad: Counter.
&gt;&gt; Will: Where do I find,

66
00:02:54.320 --> 00:02:55.880
where do I look for counter first?

67
00:02:55.880 --> 00:02:56.380
&gt;&gt; Muhammad: Local.

68
00:02:56.380 --> 00:02:57.070
&gt;&gt; Will: Do I find it?

69
00:02:57.070 --> 00:02:57.570
&gt;&gt; Muhammad: Yeah.

70
00:02:58.800 --> 00:03:00.010
Well no, I guess.

71
00:03:00.010 --> 00:03:01.770
It's still gonna [INAUDIBLE]
&gt;&gt; Will: No, I go up here, what do I find?

72
00:03:01.770 --> 00:03:03.970
One, and so what do I return out?

73
00:03:03.970 --> 00:03:06.760
One, and the one returns out.

74
00:03:06.760 --> 00:03:11.550
Okay, do you see, now I'm putting it
back into my sort of regular land.

75
00:03:11.550 --> 00:03:13.700
So I just write this
function in a smart way.

76
00:03:13.700 --> 00:03:15.958
I can also make my
increment counter function,

77
00:03:15.958 --> 00:03:18.730
not an increment counter function but
just a increase by.

78
00:03:18.730 --> 00:03:21.690
And pass in a num to the definition.

79
00:03:21.690 --> 00:03:25.565
Which, then when it gets called,
could have a 3 and

80
00:03:25.565 --> 00:03:29.717
make counter++ actually be counter += 3,
right?

81
00:03:29.717 --> 00:03:32.050
And then that's gonna
actually update this.

82
00:03:32.050 --> 00:03:34.530
So I can really interact
with it any way I want.

83
00:03:34.530 --> 00:03:38.010
I just gotta write my function,
the internal function,

84
00:03:38.010 --> 00:03:41.960
before I pass it out, I need to write
it in a way that makes it interactive.

85
00:03:41.960 --> 00:03:42.820
Makes sense?

86
00:03:42.820 --> 00:03:43.450
Great question Katie.

87
00:03:43.450 --> 00:03:44.490
Go ahead, Griffin.

88
00:03:44.490 --> 00:03:46.890
&gt;&gt; Griffin: Could counter be
like an array or an object?

89
00:03:46.890 --> 00:03:48.030
&gt;&gt; Will: It could be anything you want.

90
00:03:48.030 --> 00:03:48.906
And we're gonna see,

91
00:03:48.906 --> 00:03:51.680
that's what allows us to do some of
the most powerful things with this.

92
00:03:51.680 --> 00:03:52.690
Spot on, Griffin.

93
00:03:52.690 --> 00:03:54.970
There was still another clarification,
yeah Andrew?

94
00:03:54.970 --> 00:04:00.210
&gt;&gt; Andrew: So does it take
everything declared before function.

95
00:04:00.210 --> 00:04:01.280
Everything?

96
00:04:01.280 --> 00:04:05.570
&gt;&gt; Will: No the bond made
at the function definition,

97
00:04:05.570 --> 00:04:07.550
properly square bracket squared, is so

98
00:04:07.550 --> 00:04:13.470
the whole local memory which is not
an object, but is a single entity.

99
00:04:13.470 --> 00:04:19.916
So the bond is not to the stuff that came
above, it's to the whole set of stuff.

100
00:04:19.916 --> 00:04:24.110
So any set of live data,
the whole variable environment as a whole,

101
00:04:24.110 --> 00:04:24.700
the whole thing.

102
00:04:24.700 --> 00:04:27.460
So, if you were to define something after,
no problem.

103
00:04:27.460 --> 00:04:30.160
That's all still gonna be
bonded in there as long as

104
00:04:30.160 --> 00:04:31.730
when you return that increment counter,

105
00:04:31.730 --> 00:04:36.670
that that increment counter functionality
makes reference to all that stuff.

106
00:04:36.670 --> 00:04:39.145
If it doesn't, Jarvis is really smart and

107
00:04:39.145 --> 00:04:42.370
won't return the stuff that never gets
referenced again in the backpack.

