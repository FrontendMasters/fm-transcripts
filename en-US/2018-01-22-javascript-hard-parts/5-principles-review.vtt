WEBVTT

1
00:00:00.000 --> 00:00:03.489
&gt;&gt; Will Sentance: Unfortunately
my slides are less, man.

2
00:00:03.489 --> 00:00:05.297
That thing there it says
functional programming.

3
00:00:05.297 --> 00:00:09.121
That's meant to be like a grand
bold statement on a new slide but

4
00:00:09.121 --> 00:00:12.091
instead it's like a little
thing on the bottom.

5
00:00:12.091 --> 00:00:16.044
So let's imagine we're just looking
at this functional programming.

6
00:00:16.044 --> 00:00:17.012
Here we go.

7
00:00:17.012 --> 00:00:23.167
We now have core Platform of
JavaScript from which to learn from.

8
00:00:23.167 --> 00:00:24.988
We have our core platform.

9
00:00:24.988 --> 00:00:25.767
There it is.

10
00:00:25.767 --> 00:00:28.280
Our memory, where stuff gets stored.

11
00:00:28.280 --> 00:00:31.400
Our thread,
where stuff gets run line by line.

12
00:00:31.400 --> 00:00:35.468
When we start running a function,
remind me again, Shelby,

13
00:00:35.468 --> 00:00:37.750
how do I start running a function?

14
00:00:37.750 --> 00:00:41.054
How do I start calling a function?
&gt;&gt; Speaker 2: With parentheses.

15
00:00:41.054 --> 00:00:41.849
&gt;&gt; Will Sentance: Parentheses,

16
00:00:41.849 --> 00:00:42.523
there it is.

17
00:00:42.523 --> 00:00:44.710
What does calling a function
create everyone, together?

18
00:00:44.710 --> 00:00:48.561
It creates a brand new?
&gt;&gt; Speaker 3: [INAUDIBLE]

19
00:00:48.561 --> 00:00:49.440
&gt;&gt; Will Sentance: It creates a brand

20
00:00:49.440 --> 00:00:50.675
new execution context.

21
00:00:50.675 --> 00:00:55.664
This is, believe me, this is everything.

22
00:00:55.664 --> 00:00:57.145
Is so powerful like this.

23
00:00:57.145 --> 00:01:00.557
Whenever I start calling a function,
I get to create a new execution context.

24
00:01:00.557 --> 00:01:02.753
So how do I call a function, Lindsay?
&gt;&gt; Speaker 2: Parentheses.

25
00:01:02.753 --> 00:01:03.407
&gt;&gt; Will Sentance: Parenthesis and

26
00:01:03.407 --> 00:01:07.172
when I call a function I create a new?
&gt;&gt; Speaker 3: Execution context.

27
00:01:07.172 --> 00:01:08.866
&gt;&gt; Will Sentance: Exactly, smart room,

28
00:01:08.866 --> 00:01:13.440
a new execution context where we
just have exactly what we do when

29
00:01:13.440 --> 00:01:14.890
we always run code.

30
00:01:14.890 --> 00:01:19.360
We have our memory, and thread but
now we do it inside the function.

31
00:01:19.360 --> 00:01:22.541
When we start doing the code number
line inside the function and

32
00:01:22.541 --> 00:01:24.233
our memory inside the function.

33
00:01:24.233 --> 00:01:27.924
What we're doing now, multiple execution
context, all at the same time, but

34
00:01:27.924 --> 00:01:28.984
they're all around.

35
00:01:28.984 --> 00:01:32.584
So how do we keep track of them,
cuz we're only ever in one at a time, so

36
00:01:32.584 --> 00:01:35.102
we gotta know which one of you're back to,
etc.

37
00:01:35.102 --> 00:01:36.568
How do we keep track of them?

38
00:01:36.568 --> 00:01:41.204
Don't panic, java script has the cool
stack to track which function core

39
00:01:41.204 --> 00:01:44.980
we're in,
which execution context we're in, okay.

40
00:01:44.980 --> 00:01:48.410
Those are our three
fundamental principles.

41
00:01:48.410 --> 00:01:52.008
All of JavaScript, there's no bonus
features like the prototype of nature,

42
00:01:52.008 --> 00:01:53.404
we'll cover that tomorrow.

43
00:01:53.404 --> 00:01:58.310
They're no bonus features of JavaScript,
but otherwise all of JavaScript can be

44
00:01:58.310 --> 00:02:03.890
captured by these three
underlying principles.

45
00:02:03.890 --> 00:02:07.980
Now, we're gonna come tomorrow
also to asychronus JavaScript.

46
00:02:07.980 --> 00:02:10.595
That introduces a couple of bonus,

47
00:02:10.595 --> 00:02:15.749
very significant pieces that cannot
be explained by this world view.

48
00:02:15.749 --> 00:02:20.680
Tomorrow we're gonna see some code and
try and evaluate it from this world view,

49
00:02:20.680 --> 00:02:25.540
this paradigm, and we're gonna go no,
no, no, this doesn't capture,

50
00:02:25.540 --> 00:02:28.677
this doesn't capture what
I'm trying to do here.

51
00:02:28.677 --> 00:02:30.240
There must be something else going on.

52
00:02:30.240 --> 00:02:31.710
We'll see that tomorrow morning.

53
00:02:31.710 --> 00:02:34.150
But for synchronous JavaScript,
this is it.

54
00:02:34.150 --> 00:02:37.186
What's that, Mark?
&gt;&gt; Speaker 3: I wanted to ask you about,

55
00:02:37.186 --> 00:02:41.811
so you're saying JavaScript goes line
by line but they're must be some

56
00:02:41.811 --> 00:02:45.758
other process to create the context and
stuff ahead of time.

57
00:02:45.758 --> 00:02:50.159
So they're asking if there's
a compilation phase or

58
00:02:50.159 --> 00:02:54.254
does JavaScript just go line by line?
&gt;&gt; Will Sentance: We maybe mentioned it

59
00:02:54.254 --> 00:02:57.920
before people came on, but we talked about
there being an interpretation style.

60
00:02:57.920 --> 00:03:03.570
JavaScript nowadays actually uses
what's called just-in-time compilation.

61
00:03:03.570 --> 00:03:06.800
The V8 engine from Chrome uses
just-in-time compilation,

62
00:03:06.800 --> 00:03:10.690
which does all sorts of very
smart optimizations around

63
00:03:10.690 --> 00:03:13.210
which bit of this gets
assigned to memory first.

64
00:03:13.210 --> 00:03:17.810
But for our purposes, again that comes
back to that question, going deep,

65
00:03:17.810 --> 00:03:21.840
going under the hood of the language,
is not for theoretical purposes.

66
00:03:21.840 --> 00:03:25.220
It's not for our intellectual curiosity,

67
00:03:25.220 --> 00:03:29.967
we do it because it makes debugging,
writing clean code, and

68
00:03:29.967 --> 00:03:35.281
communicating what we're really
doing much, much more possible.

69
00:03:35.281 --> 00:03:38.455
But that also means we have to
hit a level we go, hold on,

70
00:03:38.455 --> 00:03:41.711
do I need to understand how
this is turned into bi-code.

71
00:03:41.711 --> 00:03:46.631
Well, no I don't because it doesn't have
any implications for how I write my code,

72
00:03:46.631 --> 00:03:50.047
it doesn't help me write cleaner or
more efficient code.

73
00:03:50.047 --> 00:03:54.533
So the question from the online audience
about, how does the compilation step work

74
00:03:54.533 --> 00:03:58.073
here, how does the just-in-time
compilation actually work?

75
00:03:58.073 --> 00:03:59.812
We don't need to worry about here.

76
00:03:59.812 --> 00:04:04.163
These are our three already
quite under the hood

77
00:04:04.163 --> 00:04:07.542
aspects of the JavaScript run time.

78
00:04:07.542 --> 00:04:11.602
These are the three we need
to know to effectively write,

79
00:04:11.602 --> 00:04:13.980
debug and communicate our code.

