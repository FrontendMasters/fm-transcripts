WEBVTT

1
00:00:00.000 --> 00:00:03.442
&gt;&gt; Will Sentance: Folk we're gonna walk
through this line by line this is our

2
00:00:03.442 --> 00:00:06.332
final function for
our higher order functions.

3
00:00:06.332 --> 00:00:10.801
So we're gonna walk through
this line by line and

4
00:00:10.801 --> 00:00:15.929
to kick us off Mohammed line
one no this was a mistake.

5
00:00:15.929 --> 00:00:18.093
Mohammed line one,
what are we doing Mohammed?

6
00:00:18.093 --> 00:00:21.889
Talk me through line one of this
function of this set of code.

7
00:00:21.889 --> 00:00:27.560
&gt;&gt; Mohammed: Declaring a function
called copyArray, and manipulating it.

8
00:00:27.560 --> 00:00:28.818
&gt;&gt; Will Sentance: Perfect thank you, man.

9
00:00:28.818 --> 00:00:33.476
CopyArrayManipulate, and of course, we're
at the global level right, aren't we?

10
00:00:33.476 --> 00:00:36.051
We're not inside a function, so
where's that being stored, Mohammed?

11
00:00:36.051 --> 00:00:37.428
&gt;&gt; Mohammed: In the global memory.

12
00:00:37.428 --> 00:00:38.279
&gt;&gt; Will Sentance: In the global memory.

13
00:00:38.279 --> 00:00:38.956
There it is.

14
00:00:38.956 --> 00:00:41.415
I'm gonna draw it as
a little function box,

15
00:00:41.415 --> 00:00:43.817
a little function, a whole description.

16
00:00:43.817 --> 00:00:45.475
Okay, next line is what, Shelby?

17
00:00:45.475 --> 00:00:49.366
&gt;&gt; Shelby: Declaring
the function multiplyBy2.

18
00:00:49.366 --> 00:00:52.299
&gt;&gt; Will Sentance: There it is,
multiplyBy2.

19
00:00:52.299 --> 00:00:57.418
As a little baby function that
only takes in a single what?

20
00:00:57.418 --> 00:01:00.629
&gt;&gt; multiple: [LAUGH]
&gt;&gt; Will Sentance: Little baby function, so

21
00:01:00.629 --> 00:01:06.129
it takes in a single element,
and then multiplies it by 2.

22
00:01:06.129 --> 00:01:07.220
Little baby function, there it is.

23
00:01:07.220 --> 00:01:11.687
And let's just highlight it slightly so
we know which function it is.

24
00:01:11.687 --> 00:01:17.766
And if I were, Shelby, in the line after
that definition, declaration multiplyBy2.

25
00:01:17.766 --> 00:01:19.509
If I were to console.log.

26
00:01:19.509 --> 00:01:20.275
Let's write it up.

27
00:01:20.275 --> 00:01:25.132
If I were to do this, console.log

28
00:01:25.132 --> 00:01:29.489
multiplyBy2, no parenths.

29
00:01:29.489 --> 00:01:31.874
What would this display
on my console Shelby.

30
00:01:31.874 --> 00:01:35.888
Just to make sure we're really clear,
what would this display on my console?

31
00:01:35.888 --> 00:01:37.410
&gt;&gt; Shelby: Undefined.
&gt;&gt; Will Sentance: Undefined,

32
00:01:37.410 --> 00:01:40.498
What have we stored in multiplyBy2?

33
00:01:40.498 --> 00:01:42.847
JavaScript goes and
looks in global memory, sees multiplyBy2.

34
00:01:42.847 --> 00:01:43.452
What's it see?

35
00:01:45.571 --> 00:01:46.097
&gt;&gt; multiple: The whole function.

36
00:01:46.097 --> 00:01:47.154
&gt;&gt; Will Sentance: The whole
function definition.

37
00:01:47.154 --> 00:01:49.418
So if I were console log
the word multiplyBy2,

38
00:01:49.418 --> 00:01:51.410
what would I see in my console, Mohamed?

39
00:01:51.410 --> 00:01:53.041
&gt;&gt; Mohammed: Just the whole function.

40
00:01:53.041 --> 00:01:56.272
&gt;&gt; Will Sentance: The whole function
definition, multiplyBy2 is label for

41
00:01:56.272 --> 00:01:58.087
my whole function description.

42
00:01:58.087 --> 00:02:05.249
Okay, okay,
it is the whole function definition.

43
00:02:05.249 --> 00:02:10.076
Meaning, if I then pass
multiplyBy2 in to instructions,

44
00:02:10.076 --> 00:02:12.691
I'm not passing undefined in.

45
00:02:12.691 --> 00:02:17.113
I'm not running copyArrayandManipulate
with multiplyBy2 as actually undefined.

46
00:02:17.113 --> 00:02:20.909
No, it's gonna literally be
the whole function definition,

47
00:02:20.909 --> 00:02:24.932
being passed in to replace
the placeholder word, instructions.

48
00:02:24.932 --> 00:02:28.963
All right, so now, we've declared
copyArrayandManipulate declared

49
00:02:28.963 --> 00:02:31.879
multiplyBy2, what's the next
line tell us to do?

50
00:02:31.879 --> 00:02:35.363
Matthew, what's the final line
on the left hand side say?

51
00:02:35.363 --> 00:02:36.767
&gt;&gt; Matthew: Leb results.

52
00:02:36.767 --> 00:02:40.223
&gt;&gt; Will Sentance: Which is saying
give JavaScript label results, right?

53
00:02:40.223 --> 00:02:42.539
&gt;&gt; Matthew: Right.
&gt;&gt; Will Sentance: Good, and Matthew,

54
00:02:42.539 --> 00:02:47.520
do we know what's gonna be
stored Matthew in result yet?

55
00:02:47.520 --> 00:02:48.428
&gt;&gt; Matthew: No.

56
00:02:48.428 --> 00:02:50.779
&gt;&gt; Will Sentance: No,
cuz we've got to go run that function.

57
00:02:50.779 --> 00:02:54.488
Matthew, how do I know I've gotta
go run that function what symbols?

58
00:02:54.488 --> 00:02:55.221
&gt;&gt; Matthew: Paranthesis.

59
00:02:55.221 --> 00:02:56.824
&gt;&gt; Will Sentance: Good job
Matthew very nice yeah correct.

60
00:02:56.824 --> 00:02:58.315
I'm gonna go run that function.

61
00:02:58.315 --> 00:02:59.667
It's undefined for now.

62
00:02:59.667 --> 00:03:01.507
I'm gonna go run that function.

63
00:03:01.507 --> 00:03:05.302
And I'm gonna do it

64
00:03:05.302 --> 00:03:13.137
copyArrayManipulate code with what?

65
00:03:13.137 --> 00:03:17.124
What's our first argument, Griffin?

66
00:03:17.124 --> 00:03:19.821
&gt;&gt; Griffin: Is the array 1, 2, 3.

67
00:03:19.821 --> 00:03:21.725
&gt;&gt; Will Sentance: Good,
there it is, array 1, 2, 3.

68
00:03:21.725 --> 00:03:23.286
And our second value, Griffin?

69
00:03:23.286 --> 00:03:25.826
&gt;&gt; Griffin: Is the function multiplyBy2.

70
00:03:25.826 --> 00:03:28.166
&gt;&gt; Will Sentance: Spot on, multiplyBy2 and

71
00:03:28.166 --> 00:03:32.854
it's the whole function definition,
right Shelby?

72
00:03:32.854 --> 00:03:36.963
It's a whole function definition that
wasn't a passive aggressive statement,

73
00:03:36.963 --> 00:03:38.279
it sort of was but no, no.

74
00:03:38.279 --> 00:03:40.547
It was not intentionally there.

75
00:03:40.547 --> 00:03:41.578
The whole function definition, right?

76
00:03:41.578 --> 00:03:43.871
The who node description,
if I would say, yeah.

77
00:03:43.871 --> 00:03:45.645
I know,
it's the whole function definition.

78
00:03:45.645 --> 00:03:47.652
Good job, there it is.

79
00:03:47.652 --> 00:03:52.625
And the output, we're saying already that
we know that whatever gets returned out

80
00:03:52.625 --> 00:03:56.675
of this function, whatever comes
out the bottom of this function,

81
00:03:56.675 --> 00:03:58.822
is gonna be stored where, Shelby?

82
00:03:58.822 --> 00:04:02.524
The output of running this function
is gonna be stored where Shelby?

83
00:04:02.524 --> 00:04:03.942
&gt;&gt; Shelby: Global.
&gt;&gt; Will Sentance: In what label?

84
00:04:03.942 --> 00:04:06.133
What's it say?

85
00:04:06.133 --> 00:04:06.926
&gt;&gt; Shelby: In result.

86
00:04:06.926 --> 00:04:08.423
&gt;&gt; Will Sentance: In result, exactly.

87
00:04:08.423 --> 00:04:09.907
In result.

88
00:04:09.907 --> 00:04:13.959
But we've got a whole set of
instructions copyArrayandManipulate,

89
00:04:13.959 --> 00:04:16.507
that we've gotta run through line by line.

90
00:04:16.507 --> 00:04:18.477
That's the thread of execution.

91
00:04:18.477 --> 00:04:21.628
And we got a whole bunch of data
we gotta store, output array,

92
00:04:21.628 --> 00:04:24.493
that's the variable environment,
the local memory.

93
00:04:24.493 --> 00:04:26.790
What do we call those two things together?

94
00:04:26.790 --> 00:04:28.309
Everyone together, a?

95
00:04:28.309 --> 00:04:30.054
&gt;&gt; multiple: Execution context.

96
00:04:30.054 --> 00:04:31.332
&gt;&gt; Will Sentance: Perfect, there it is.

97
00:04:31.332 --> 00:04:35.603
We're gonna create it, there it is,

98
00:04:35.603 --> 00:04:40.146
execution context with a local memory.

99
00:04:40.146 --> 00:04:44.380
Local memory,
in which anything we declare,

100
00:04:44.380 --> 00:04:48.611
define, create inside of
the code of a running

101
00:04:48.611 --> 00:04:53.835
copyArrayandManipulate stored
in there not in global.

102
00:04:53.835 --> 00:05:00.797
So, at this point,
&gt;&gt; Will Sentance: Bob,

103
00:05:00.797 --> 00:05:05.806
what's the first thing we do inside
copyArrayandManipulate before we even

104
00:05:05.806 --> 00:05:11.296
get inside copyArrayandManipulate what's
the first thing we're gonna handle?

105
00:05:11.296 --> 00:05:12.964
&gt;&gt; Bob: The placeholder passing array in.

106
00:05:12.964 --> 00:05:14.561
&gt;&gt; Will Sentance: Yeah,
nice, so what do we say,

107
00:05:14.561 --> 00:05:18.311
what's the posh way of saying
that we're gonna yeah here we go.

108
00:05:18.311 --> 00:05:22.092
&gt;&gt; Bob: Sorry, the [LAUGH] placeholder.

109
00:05:22.092 --> 00:05:23.295
&gt;&gt; Will Sentance: So what's the first
placeholder we've gotta handle?

110
00:05:23.295 --> 00:05:26.629
&gt;&gt; Bob: The 1, 2, 3.

111
00:05:26.629 --> 00:05:28.482
&gt;&gt; Will Sentance: Which is gonna
fill in what sort of a placeholder?

112
00:05:28.482 --> 00:05:30.966
That's the actual value, the argument-
&gt;&gt; Bob: The array param.

113
00:05:30.966 --> 00:05:33.335
&gt;&gt; Will Sentance: Array parameter,
exactly.

114
00:05:33.335 --> 00:05:36.988
And what will array now be,
because of what you just said,

115
00:05:36.988 --> 00:05:39.682
everywhere inside this function called?

116
00:05:39.682 --> 00:05:42.105
1,2,3, spot on.

117
00:05:42.105 --> 00:05:48.756
And now, Clara, Clara when someone's
on their phone, they get called upon.

118
00:05:48.756 --> 00:05:54.141
Clara, we filled an array as 1,2,3,

119
00:05:54.141 --> 00:06:00.132
we now have another parameter,
which is what?

120
00:06:00.132 --> 00:06:01.313
&gt;&gt; Clara: Instructions.

121
00:06:01.313 --> 00:06:04.179
&gt;&gt; Will Sentance: And
what is instructions, Clara,

122
00:06:04.179 --> 00:06:06.383
going to be replaced with?

123
00:06:06.383 --> 00:06:07.407
It's just a placeholder.

124
00:06:07.407 --> 00:06:08.691
What's it gonna point to?

125
00:06:08.691 --> 00:06:12.798
What's its value gonna be throughout
the life of this function call?

126
00:06:12.798 --> 00:06:15.959
&gt;&gt; Clara: It's a function
the multiplyBy2 function.

127
00:06:15.959 --> 00:06:19.831
&gt;&gt; Will Sentance: Spot on,
the entire multiplyBy2 functionality.

128
00:06:19.831 --> 00:06:24.440
We no longer, are gonna refer
to it as multiplyBy2 inside.

129
00:06:24.440 --> 00:06:25.803
We're gonna refer to these instructions.

130
00:06:25.803 --> 00:06:30.895
But it is that entire function definition
that we gave birth to out here,

131
00:06:30.895 --> 00:06:34.068
in global, we defined here and
then pass in,

132
00:06:34.068 --> 00:06:39.764
to be available inside copyArrayManipulate
under its new label instructions.

133
00:06:39.764 --> 00:06:43.300
So Clara, if I wanted to,
inside copyArrayManipulate,

134
00:06:43.300 --> 00:06:47.342
run that multiplyBy2 functionality
in here under its new label,

135
00:06:47.342 --> 00:06:50.244
what's the exact wording
I would use to run it?

136
00:06:50.244 --> 00:06:51.398
&gt;&gt; Clara: You'd say instructions.

137
00:06:51.398 --> 00:06:53.269
&gt;&gt; Will Sentance: Instructions,
I'm sorry, say that again.

138
00:06:53.269 --> 00:06:54.829
&gt;&gt; Clara: Instructions, parentheses.

139
00:06:54.829 --> 00:06:58.021
&gt;&gt; Will Sentance: Parentheses, I probably
wanna parse something because right if you

140
00:06:58.021 --> 00:07:01.718
look at the definition and multiplyBy2
it's got a placeholder so I pass in 3.

141
00:07:01.718 --> 00:07:09.120
Because instructions literally evaluate
to, that becomes the multiplyBy2 function.

142
00:07:09.120 --> 00:07:12.677
Just like Array if we were
to go array position 1,

143
00:07:12.677 --> 00:07:16.162
inside of here,
we are gonna look at this array.

144
00:07:16.162 --> 00:07:18.720
Instructions, we are gonna
look at what it is.

145
00:07:18.720 --> 00:07:20.877
It is the multiplyBy2 functionality.

146
00:07:20.877 --> 00:07:23.792
It has literally replaced the placeholder,

147
00:07:23.792 --> 00:07:27.099
that was previously
a placeholder instructions.

148
00:07:27.099 --> 00:07:31.996
All right, let's walk through
it as precisely as we can, okay.

149
00:07:31.996 --> 00:07:33.670
So we've done our parameters.

150
00:07:33.670 --> 00:07:35.959
Art, we've done our parameters.

151
00:07:35.959 --> 00:07:37.689
What's our next line in our local memory?

152
00:07:37.689 --> 00:07:38.700
We've done our parameters, our arguments.

153
00:07:38.700 --> 00:07:40.124
What's the next bit in our local memory?

154
00:07:40.124 --> 00:07:42.304
&gt;&gt; Art: We're sending
our output to our array.

155
00:07:42.304 --> 00:07:47.749
&gt;&gt; Will Sentance: Spot on, I'm gonna put
again our sort of working area over here.

156
00:07:47.749 --> 00:07:50.112
So sort of not,
I have no idea but there we go.

157
00:07:50.112 --> 00:07:52.686
Output exactly is an empty array.

158
00:07:52.686 --> 00:07:57.156
There we go output, just so
we can work with this slightly easier.

159
00:07:57.156 --> 00:08:02.175
Okay, big moment, Andrea,
we're gonna hit the body of that for

160
00:08:02.175 --> 00:08:08.670
loop, we've done outputs and MD array,
we're gonna hit the body of that for loop.

161
00:08:08.670 --> 00:08:12.270
First time we do,
what's the first, I guess,

162
00:08:12.270 --> 00:08:15.871
variable of whose value
we're interested in?

163
00:08:15.871 --> 00:08:17.490
JavaScript kind of works inwards,
outwards.

164
00:08:17.490 --> 00:08:18.727
So what's the first one
we're interested in?

165
00:08:18.727 --> 00:08:20.395
&gt;&gt; Andrea: I guess the i to zero.

166
00:08:20.395 --> 00:08:21.777
&gt;&gt; Will Sentance: I is zero, spot on.

167
00:08:21.777 --> 00:08:29.418
So i is zero, so
array index zero is what, Andrea?

168
00:08:29.418 --> 00:08:30.924
&gt;&gt; Andrea: Sub zero one.

169
00:08:30.924 --> 00:08:33.771
&gt;&gt; Will Sentance: It's spot on Andrea,
really nice.

170
00:08:33.771 --> 00:08:35.193
So array sub zero is?

171
00:08:35.193 --> 00:08:35.902
&gt;&gt; Andrea: 1.

172
00:08:35.902 --> 00:08:36.488
&gt;&gt; Will Sentance: The value 1.

173
00:08:36.488 --> 00:08:37.399
&gt;&gt; Andrea: Yes.

174
00:08:37.399 --> 00:08:39.367
&gt;&gt; Will Sentance: My goodness, exactly.

175
00:08:39.367 --> 00:08:41.020
There it is, the value 1.

176
00:08:41.020 --> 00:08:46.805
And now that 1,
that means this little portion here, zero,

177
00:08:46.805 --> 00:08:54.723
one, what's this instruction's placeholder
now being filled in with, Andrea?

178
00:08:54.723 --> 00:08:56.019
&gt;&gt; Andrea: MultiplyBy2.

179
00:08:56.019 --> 00:08:58.668
&gt;&gt; Will Sentance: The function,
multiplyBy2.

180
00:08:58.668 --> 00:09:04.453
So actually,
what has this little portion here become,

181
00:09:04.453 --> 00:09:07.234
but multiplyBy2 (1).

182
00:09:07.234 --> 00:09:11.201
That's saying go run
the multiplyBy2 function.

183
00:09:11.201 --> 00:09:13.902
And when we start running a function,
Andrea, what do we do?

184
00:09:13.902 --> 00:09:15.026
We declare a brand new?

185
00:09:15.026 --> 00:09:16.600
Everyone together.

186
00:09:16.600 --> 00:09:18.351
Execution context.

187
00:09:18.351 --> 00:09:20.843
We forgot to add this one
in the first place, well.

188
00:09:20.843 --> 00:09:22.328
So copyArrayandManipulate.

189
00:09:22.328 --> 00:09:25.191
When we started running it, we added it
to the call stack so it's already inside,

190
00:09:25.191 --> 00:09:26.196
copyArrayandManipulate.

191
00:09:26.196 --> 00:09:28.832
So you see JavaScript
needs to know these stuff.

192
00:09:28.832 --> 00:09:33.761
There we are that's all that calls
that and yes we now exactly as

193
00:09:33.761 --> 00:09:38.505
Andrea said start calling,
instructions which is really

194
00:09:38.505 --> 00:09:43.529
just multiplyBy2, but
let's refer to as instructions here,

195
00:09:43.529 --> 00:09:47.739
instructions, which is really just what,
Andrea?

196
00:09:47.739 --> 00:09:49.841
&gt;&gt; Andrea: Parameter?

197
00:09:49.841 --> 00:09:51.843
&gt;&gt; Will Sentance: What is
instructions really just?

198
00:09:51.843 --> 00:09:53.337
&gt;&gt; Andrea: MultiplyBy2.

199
00:09:53.337 --> 00:09:55.784
&gt;&gt; Will Sentance: MultiplyBy2,
and we pass in the what value?

200
00:09:55.784 --> 00:09:57.715
&gt;&gt; Andrea: First value in the array.

201
00:09:57.715 --> 00:09:58.729
&gt;&gt; Will Sentance: Which is?
&gt;&gt; Andrea: 1.

202
00:09:58.729 --> 00:09:59.575
&gt;&gt; Will Sentance: 1, exactly.

203
00:09:59.575 --> 00:10:04.907
And if we're calling it,
we're creating new execution context.

204
00:10:04.907 --> 00:10:10.152
There it is,
with a local memory of it's own and

205
00:10:10.152 --> 00:10:14.492
Andrea what happens to our call stack?

206
00:10:14.492 --> 00:10:16.622
&gt;&gt; Andrea: It gets added
to the call stack.

207
00:10:16.622 --> 00:10:18.492
&gt;&gt; Will Sentance: The call
to instructions,

208
00:10:18.492 --> 00:10:23.467
multiplied by two there the same thing,
get's added to the call stack.

209
00:10:23.467 --> 00:10:24.102
There it is.

210
00:10:24.102 --> 00:10:27.423
Now we know when we finish running it,
where we gonna go back to, Andrea?

211
00:10:27.423 --> 00:10:29.983
&gt;&gt; Andrea: It's gonna go back down-
&gt;&gt; Will Sentance: CopyArray exactly,

212
00:10:29.983 --> 00:10:33.287
that's what stack is such a good way
of tracking this, you add something,

213
00:10:33.287 --> 00:10:34.135
start running it.

214
00:10:34.135 --> 00:10:36.672
When you finish running,
you wanna go out one step,

215
00:10:36.672 --> 00:10:40.548
or you go down then you take it off and
your back out to copyArrayandManipulate.

216
00:10:40.548 --> 00:10:43.815
And so as we go,
this is a tough bit Clara?

217
00:10:43.815 --> 00:10:48.739
I'm inside the call to instructions, I've
passed which is really multiplyBy2 I've

218
00:10:48.739 --> 00:10:53.395
passed in one, what's my first pairing of
label and data inside the local memory,

219
00:10:53.395 --> 00:10:55.807
given this is really multiplyBy2 Clara?

220
00:10:55.807 --> 00:10:56.658
&gt;&gt; Clara: So inputs.

221
00:10:56.658 --> 00:10:58.565
&gt;&gt; Will Sentance: Input, exactly.

222
00:10:58.565 --> 00:11:00.019
And it's assigned what?

223
00:11:00.019 --> 00:11:04.500
&gt;&gt; Clara: You equate it with 1, right?

224
00:11:04.500 --> 00:11:05.174
&gt;&gt; Will Sentance: The 1, exactly.

225
00:11:05.174 --> 00:11:06.268
Exactly, and then we,

226
00:11:06.268 --> 00:11:09.844
cuz we're now really running
the functionality of multiplyBy2 everyone.

227
00:11:09.844 --> 00:11:12.579
So this portion here 0, 1, and

228
00:11:12.579 --> 00:11:18.555
that one got thrown into instructions,
which is really multiplyBy2.

229
00:11:18.555 --> 00:11:20.063
So that one got thrown in.

230
00:11:20.063 --> 00:11:26.616
As input, and there it is,
shit, there it is, input 1.

231
00:11:26.616 --> 00:11:34.077
And so we do 1 which is input by 2 and
return that 2 out.

232
00:11:34.077 --> 00:11:39.488
Which means now multiplyBy2 with
the input of 1 this whole statement.

233
00:11:39.488 --> 00:11:44.894
multiplyBy2 has evaluated,
has become that output value 2.

234
00:11:44.894 --> 00:11:47.323
And what do we do with that 2, Andrea?

235
00:11:47.323 --> 00:11:49.353
&gt;&gt; Andrea: We times it.

236
00:11:49.353 --> 00:11:52.825
&gt;&gt; Will Sentance: What do we do with
that evaluated result, Lindsey?

237
00:11:52.825 --> 00:11:54.275
&gt;&gt; Lindsey: We push it into the output.

238
00:11:54.275 --> 00:11:57.464
&gt;&gt; Will Sentance: We push it into output,
spot on, there it is.

239
00:11:57.464 --> 00:11:59.183
And what happens to our execution context,
Lindsey?

240
00:11:59.183 --> 00:12:02.668
&gt;&gt; Lindsey: It goes away.

241
00:12:02.668 --> 00:12:03.249
&gt;&gt; Will Sentance: It goes away.

242
00:12:03.249 --> 00:12:05.236
We poshly say it gets popped off.

243
00:12:05.236 --> 00:12:06.041
&gt;&gt; Lindsey: It gets popped off.

244
00:12:06.041 --> 00:12:08.380
&gt;&gt; Will Sentance: Yeah,
it goes away, but it's a for loop.

245
00:12:08.380 --> 00:12:12.280
It's a for loop so what happens.

246
00:12:12.280 --> 00:12:17.266
Even though we throw away our
execution context, it's all gone for

247
00:12:17.266 --> 00:12:20.688
the running of instructions
that first time.

248
00:12:20.688 --> 00:12:21.758
Well, what do you know?

249
00:12:21.758 --> 00:12:26.003
It's a for loop, so
we're gonna hit the body of the for

250
00:12:26.003 --> 00:12:29.058
loop again, and this time, Griffin.

251
00:12:29.058 --> 00:12:31.816
This time Griffin, what is the value of i?

252
00:12:31.816 --> 00:12:33.374
&gt;&gt; Griffin: 1.

253
00:12:33.374 --> 00:12:35.607
&gt;&gt; Will Sentance: 1 and
therefore we get array sub one which is?

254
00:12:35.607 --> 00:12:36.166
&gt;&gt; Griffin: 2.

255
00:12:36.166 --> 00:12:38.675
&gt;&gt; Will Sentance: And
we take that 2, and do what with it?

256
00:12:38.675 --> 00:12:40.618
&gt;&gt; Griffin: Pass it into instruction.

257
00:12:40.618 --> 00:12:41.304
&gt;&gt; Will Sentance: Which is really just?

258
00:12:41.304 --> 00:12:42.100
&gt;&gt; Griffin: MultiplyBy2.

259
00:12:42.100 --> 00:12:43.965
&gt;&gt; Will Sentance: Very good,
exactly, instructions.

260
00:12:43.965 --> 00:12:50.673
And we call that instructions, there is
the 2 gets parsed into the local memory.

261
00:12:50.673 --> 00:12:52.198
Call stack, what happens?

262
00:12:52.198 --> 00:12:54.467
&gt;&gt; Griffin: It gets push out of there.

263
00:12:54.467 --> 00:12:55.270
&gt;&gt; Will Sentance: Gets pushed on again.

264
00:12:55.270 --> 00:12:58.667
A new execution context.

265
00:12:58.667 --> 00:13:01.623
Inside, what's the first data pairing?

266
00:13:01.623 --> 00:13:03.107
&gt;&gt; Griffin: Input and 2.

267
00:13:03.107 --> 00:13:08.333
&gt;&gt; Will Sentance: Yeah, input and 2,
and we to 2 by 2, which becomes 4.

268
00:13:08.333 --> 00:13:12.589
Out it returns, return out 4.

269
00:13:12.589 --> 00:13:15.558
That means this little portion here,
multiplyBy2,

270
00:13:15.558 --> 00:13:19.117
the input of 2 is evaluated to 4,
and that 4 gets pushed where?

271
00:13:19.117 --> 00:13:20.906
&gt;&gt; Griffin: To outputs?

272
00:13:20.906 --> 00:13:27.099
&gt;&gt; Will Sentance: Perfect, there it is,
and then it gets created again we get 6.

273
00:13:27.099 --> 00:13:34.070
Our output is now 2,4,6 and
we hit the key line, Mohamed which is?

274
00:13:34.070 --> 00:13:36.029
What's the final line of the function?

275
00:13:36.029 --> 00:13:38.631
&gt;&gt; Griffin: Return output.

276
00:13:38.631 --> 00:13:41.502
&gt;&gt; Will Sentance: Return, see I have
an amazing habit of always calling on

277
00:13:41.502 --> 00:13:43.342
the same people for the same thing.

278
00:13:43.342 --> 00:13:46.289
So what will it actually return out,
Mohamed?

279
00:13:46.289 --> 00:13:46.988
&gt;&gt; Mohammed: 2, 4, 6.

280
00:13:46.988 --> 00:13:49.221
&gt;&gt; Will Sentance: Yeah,
the value associated with output, right?

281
00:13:49.221 --> 00:13:51.818
JavaScript never sees a word and
leaves it.

282
00:13:51.818 --> 00:13:54.639
It evaluates everything down
to its lowest possible part.

283
00:13:54.639 --> 00:13:58.785
So it sees the word output,
it goes hold on, what is that?

284
00:13:58.785 --> 00:14:01.157
It's 2, 4, 6, returns that.

285
00:14:01.157 --> 00:14:08.280
Output out, 2,4,6, and where do we
say Mohamed we're gonna assign it?

286
00:14:08.280 --> 00:14:09.757
&gt;&gt; Mohammed: To the label result.

287
00:14:09.757 --> 00:14:15.110
&gt;&gt; Will Sentance: To the label result,
and there it is.

288
00:14:15.110 --> 00:14:20.379
So this is hard, this is supposedly
profound areas of JavaScript.

289
00:14:20.379 --> 00:14:25.233
We'll see in a moment we have already
encountered all the material of high

290
00:14:25.233 --> 00:14:27.829
order functions list with cool backs.

291
00:14:27.829 --> 00:14:31.545
But I wanna have thumps in
a moment on what we saw here.

292
00:14:31.545 --> 00:14:36.211
But look we achieved with generalized
copyArrayandManipulate, and

293
00:14:36.211 --> 00:14:40.165
then a specific little baby
function that we passed in, for

294
00:14:40.165 --> 00:14:43.975
the specifics,
of what we're gonna do to each element.

295
00:14:43.975 --> 00:14:47.359
We achieved exactly the same as we
did with copyArrayAndMultiplyBy2.

296
00:14:47.359 --> 00:14:50.789
Where we took in 1, 2, and 3,
and came out with 2, 4, and 6.

297
00:14:50.789 --> 00:14:55.384
Look at this, went in 1, 2,
3, but we add no specificity

298
00:14:55.384 --> 00:14:59.905
of multiplyBy2 in there,
instead we left a placeholder.

299
00:14:59.905 --> 00:15:05.417
Which we then determined what it would be
when we called copyArrayAndManipulate and

300
00:15:05.417 --> 00:15:06.902
what do we end up with?

301
00:15:06.902 --> 00:15:10.719
But 2, 4, 6, the very same result.

302
00:15:10.719 --> 00:15:15.612
We could have parsed in not
multiplyBy2 but add 3 or divide by 2.

303
00:15:15.612 --> 00:15:18.477
We ended up with the same results.

304
00:15:18.477 --> 00:15:23.595
We parametrized,
we generalized our function.

