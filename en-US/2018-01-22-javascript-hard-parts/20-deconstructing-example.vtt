WEBVTT

1
00:00:00.240 --> 00:00:00.780
&gt;&gt; Will Sentance: We just saw

2
00:00:00.780 --> 00:00:02.770
the function's gonna be returned
from the functions in jobs.

3
00:00:02.770 --> 00:00:03.950
We want a hint of that.

4
00:00:03.950 --> 00:00:07.840
We say from high order functions, we know
we can return a function from a function,

5
00:00:07.840 --> 00:00:11.730
and then store it in a new label
globally and run it by that new label.

6
00:00:11.730 --> 00:00:15.380
Let's do this very precisely line by line.

7
00:00:15.380 --> 00:00:18.950
Again, this is gonna feel like,
why are we doing this?

8
00:00:18.950 --> 00:00:24.280
If we get our head around this,
closure follows so naturally, so

9
00:00:24.280 --> 00:00:29.810
line 1, Katy, what are we doing Katy?

10
00:00:29.810 --> 00:00:33.820
&gt;&gt; Katy: We're declaring
the function instruction generated.

11
00:00:33.820 --> 00:00:36.858
&gt;&gt; Will Sentance: Excellent Katy,
getting the hang of it, very nice.

12
00:00:36.858 --> 00:00:43.010
Instruction,
&gt;&gt; Will Sentance: Generator.

13
00:00:43.010 --> 00:00:50.370
Instruction generator is a whole
function definition sort of memory.

14
00:00:50.370 --> 00:00:51.420
Excellent.

15
00:00:51.420 --> 00:00:59.970
Next line of code,
who's gonna be the lucky person?

16
00:00:59.970 --> 00:01:02.418
It is Kara.

17
00:01:04.066 --> 00:01:05.000
&gt;&gt; Will Sentance: Next line of code, Kara.

18
00:01:05.000 --> 00:01:07.190
&gt;&gt; Kara: Let generated function.

19
00:01:07.190 --> 00:01:11.346
&gt;&gt; Will Sentance: So that's just saying
create a label, generate a func.

20
00:01:11.346 --> 00:01:15.930
And folks, this is clearly, right,
as anything on the left hand side

21
00:01:15.930 --> 00:01:21.140
of a function call is a placeholder,
right?

22
00:01:21.140 --> 00:01:23.062
We don't yet
know what's gonna be stored there.

23
00:01:23.062 --> 00:01:25.770
So what's temporarily, Andrea,
gonna be stored there?

24
00:01:25.770 --> 00:01:26.510
&gt;&gt; Andrea: Undefined?

25
00:01:26.510 --> 00:01:27.160
&gt;&gt; Will Sentance: Undefined, right.

26
00:01:27.160 --> 00:01:28.328
So we've gotta go and do what?

27
00:01:30.383 --> 00:01:32.840
&gt;&gt; Andrea: Execute instruction generator.

28
00:01:32.840 --> 00:01:33.980
&gt;&gt; Will Sentance: Execute
instruction generator.

29
00:01:33.980 --> 00:01:36.700
That's what you're spot on, Andrea.

30
00:01:36.700 --> 00:01:38.310
Okay, generated func.

31
00:01:39.700 --> 00:01:46.560
Generated func is going to be
the result of running exactly as

32
00:01:46.560 --> 00:01:52.320
Andrea rightly said of running
instruction generator.

33
00:01:52.320 --> 00:01:55.574
Andrea, remind sorry of how I'm
running instruction generator here?

34
00:01:55.574 --> 00:01:56.460
&gt;&gt; Andrea: Parens.
&gt;&gt; Will Sentance: Parens,

35
00:01:56.460 --> 00:01:58.680
right, there's no input.

36
00:01:58.680 --> 00:02:02.120
All parens do is say go look for
this function description and do its code.

37
00:02:02.120 --> 00:02:04.320
And if there's input, great.

38
00:02:04.320 --> 00:02:04.890
Fill those in.

39
00:02:04.890 --> 00:02:08.030
But if there's none,
this just says go run me.

40
00:02:08.030 --> 00:02:09.010
So go run me.

41
00:02:09.010 --> 00:02:11.870
Create everybody a brand new-
&gt;&gt; class: Execution counters.

42
00:02:12.960 --> 00:02:14.290
&gt;&gt; Will Sentance: I'm gonna try again man,

43
00:02:14.290 --> 00:02:16.890
I'm not even joking,
everyone we create a brand new?

44
00:02:16.890 --> 00:02:18.600
&gt;&gt; class: Execution counters.

45
00:02:18.600 --> 00:02:22.540
&gt;&gt; Will Sentance: Beautiful
&gt;&gt; Will Sentance: It's so important.

46
00:02:22.540 --> 00:02:29.171
Create new execution context, here it is,
&gt;&gt; Will Sentance: In which we are,

47
00:02:29.171 --> 00:02:31.850
that's a bit big, actually.

48
00:02:31.850 --> 00:02:34.230
In which we are going to do.

49
00:02:34.230 --> 00:02:37.130
Firstly, if we're creating this
new execution context, Griffin,

50
00:02:37.130 --> 00:02:39.000
what are we doing in our call stack?

51
00:02:39.000 --> 00:02:41.000
&gt;&gt; Griffin: We push it off.

52
00:02:41.000 --> 00:02:42.510
&gt;&gt; Will Sentance: Push, push what?

53
00:02:42.510 --> 00:02:43.550
The call to.

54
00:02:43.550 --> 00:02:48.780
&gt;&gt; Griffin: The instruction generator.

55
00:02:48.780 --> 00:02:50.780
&gt;&gt; Will Sentance: Right, how do I know
it's the call to instruction generator?

56
00:02:50.780 --> 00:02:52.960
What's those key symbols on
the end of instruction generator?

57
00:02:52.960 --> 00:02:53.890
&gt;&gt; Griffin: The parantheses.

58
00:02:53.890 --> 00:02:54.590
&gt;&gt; Will Sentance: Good, exactly.

59
00:02:54.590 --> 00:02:56.480
It knows to be confused by that.

60
00:02:56.480 --> 00:03:01.090
And into instruction generators
execution context we go.

61
00:03:02.340 --> 00:03:07.470
And it has a local memory and a thread.

62
00:03:07.470 --> 00:03:09.390
So the thread is no
longer running globally.

63
00:03:09.390 --> 00:03:10.160
It's now in here.

64
00:03:10.160 --> 00:03:15.310
I'm gonna give this its other name,
which is its variable environment.

65
00:03:15.310 --> 00:03:18.230
That's the variable environment for
the call to instruction generator.

66
00:03:18.230 --> 00:03:20.140
That's the posh name for it.

67
00:03:20.140 --> 00:03:22.210
You got a?
&gt;&gt; Katy: Yeah, I have a question about.

68
00:03:22.210 --> 00:03:23.940
When you're in the-
&gt;&gt; Will Sentance: Local

69
00:03:23.940 --> 00:03:24.660
executition context.

70
00:03:24.660 --> 00:03:27.680
&gt;&gt; Katy: Yep, the local executition
context do you have access to

71
00:03:27.680 --> 00:03:28.600
global memory?

72
00:03:28.600 --> 00:03:29.730
&gt;&gt; Will Sentance: We're
gonna see that in a second.

73
00:03:29.730 --> 00:03:32.650
Absolutely, absolutely you do.

74
00:03:32.650 --> 00:03:35.710
We're gonna see that process,
actually in just a second.

75
00:03:35.710 --> 00:03:41.004
So let's see local memory, everything that
get's saved here goes to local memory.

76
00:03:41.004 --> 00:03:42.332
I was giving a preview.

77
00:03:42.332 --> 00:03:45.740
Anything that gets referred to
looks in local memory first.

78
00:03:45.740 --> 00:03:49.150
It doesn't find it there,
it looks down its call stack,

79
00:03:49.150 --> 00:03:50.200
looks out to global memory.

80
00:03:50.200 --> 00:03:52.740
You're gonna see in a moment
where that actually plays out.

81
00:03:52.740 --> 00:03:58.570
Actually Katie's here about to get
to the heart of this whole section.

82
00:03:58.570 --> 00:04:00.040
This is the heart of this whole section.

83
00:04:00.040 --> 00:04:02.590
Katie has almost posed the question that

84
00:04:02.590 --> 00:04:04.961
we're gonna find the answer
to in this session.

85
00:04:06.770 --> 00:04:07.778
Cool, right Katie?

86
00:04:07.778 --> 00:04:09.350
&gt;&gt; Katy: [LAUGH]
&gt;&gt; Will Sentance: Exactly, cool.

87
00:04:09.350 --> 00:04:16.250
Okay so we said, announce generated funct,
left hand side as a placeholder.

88
00:04:16.250 --> 00:04:18.066
We do not know what's
gonna be stored in it.

89
00:04:18.066 --> 00:04:18.980
It could be anything.

90
00:04:18.980 --> 00:04:23.520
It could be, you know,
a number, it could be a string.

91
00:04:23.520 --> 00:04:24.610
Could be a function.

92
00:04:26.380 --> 00:04:27.420
Makes sense, right?

93
00:04:27.420 --> 00:04:29.460
Could be anything.

94
00:04:29.460 --> 00:04:32.480
Whatever comes out the bottom
of instruction generator

95
00:04:32.480 --> 00:04:33.930
is what's gonna be stored there.

96
00:04:33.930 --> 00:04:35.500
So we gotta go run instruction generator.

97
00:04:36.870 --> 00:04:38.350
Let's have Clara.

98
00:04:38.350 --> 00:04:41.050
Clara, we jump inside
the instruction generator.

99
00:04:41.050 --> 00:04:43.010
There's no parameters to handle this time.

100
00:04:43.010 --> 00:04:44.370
What do we do, Clara?

101
00:04:44.370 --> 00:04:48.920
&gt;&gt; Kara: So you're creating the name
multiplied by two because it's a function?

102
00:04:48.920 --> 00:04:50.660
&gt;&gt; Will Sentance: It's a function,
there it is.

103
00:04:50.660 --> 00:04:56.320
A whole function definition and
there it is.

104
00:04:56.320 --> 00:05:00.649
Okay, I'm gonna highlight it so
we really know which function this is.

105
00:05:02.570 --> 00:05:03.070
There it is.
So

106
00:05:03.070 --> 00:05:06.220
I've already called console log call
immediately after that definition.

107
00:05:06.220 --> 00:05:07.060
I've called console log,

108
00:05:07.060 --> 00:05:10.880
not my console, immediately after that
function definition multiplied by 2.

109
00:05:10.880 --> 00:05:13.080
Inside instruction generator,
what would I see?

110
00:05:13.080 --> 00:05:14.580
&gt;&gt; Kara: You'd see the function.

111
00:05:14.580 --> 00:05:17.040
&gt;&gt; Will Sentance: Yeah, because folks,
when I declare a function,

112
00:05:17.040 --> 00:05:21.960
I'm not saying like, I'm not saying
JavaScript He is a function vaguely.

113
00:05:21.960 --> 00:05:23.180
I'm saying Java Script.

114
00:05:23.180 --> 00:05:27.820
Free up some position in memory to put
the description of that functionality in.

115
00:05:27.820 --> 00:05:30.500
And that label is gonna
point to that description.

116
00:05:30.500 --> 00:05:33.515
This is not like, when JavaScript sees
that line in function mode what it'll do

117
00:05:33.515 --> 00:05:35.670
is it'll start saying okay now there's a.

118
00:05:35.670 --> 00:05:36.820
I'm saying that literally.

119
00:05:36.820 --> 00:05:38.920
Go and free some space up in memory.

120
00:05:38.920 --> 00:05:42.140
Use that label to refer to
the functionality that we just defined.

121
00:05:42.140 --> 00:05:46.560
And there's a little bit of memory now
with the functionality counter plus plus.

122
00:05:46.560 --> 00:05:49.810
And the inputs or whatever's,
I'm sorry number by two.

123
00:05:49.810 --> 00:05:52.350
Whatever's in that,
not counter plus plus obviously.

124
00:05:52.350 --> 00:05:53.270
Whatever's in that definition.

125
00:05:53.270 --> 00:05:57.370
It's a little bit of memory this bit here,
with that label, for that definition.

126
00:05:57.370 --> 00:06:00.376
Okay, next line of code, Lindsey.

127
00:06:00.376 --> 00:06:04.770
We've declared multiply by two, we've
stored it the actual function in memory.

128
00:06:04.770 --> 00:06:08.515
Now do we now execute multiply by 2,
Lindsay, do we call it?

129
00:06:08.515 --> 00:06:10.360
&gt;&gt; [BLANK AUDIO]
&gt;&gt; Will Sentance: No.

130
00:06:10.360 --> 00:06:13.180
That was my the answer's no voice,
question voice.

131
00:06:13.180 --> 00:06:15.030
Do we now call it?

132
00:06:15.030 --> 00:06:15.670
We do not right?

133
00:06:15.670 --> 00:06:19.780
What would it take to be called here?

134
00:06:19.780 --> 00:06:21.350
&gt;&gt; Katy: Multply by 2 with parenthesis?

135
00:06:21.350 --> 00:06:23.000
&gt;&gt; Will Sentance: Yeah exactly.
Everyone getting that yet?

136
00:06:23.000 --> 00:06:25.090
Now we're gonna see why it is so
important.

137
00:06:25.090 --> 00:06:28.600
This throws seasoned developers
all the time, this bit here.

138
00:06:28.600 --> 00:06:31.790
What am I actually doing in my next line?

139
00:06:31.790 --> 00:06:32.945
This one's on you, Lindsay.

140
00:06:32.945 --> 00:06:37.320
&gt;&gt; [SOUND]
&gt;&gt; Lindsey: Returning the actual function?

141
00:06:38.390 --> 00:06:39.620
&gt;&gt; Will Sentance: Fantastic.

142
00:06:39.620 --> 00:06:42.440
Spot on, I'm returning the whole.

143
00:06:42.440 --> 00:06:45.140
And by the way, know its label, the value.

144
00:06:45.140 --> 00:06:47.730
The function is a value.

145
00:06:47.730 --> 00:06:49.860
It is that description that you see.

146
00:06:49.860 --> 00:06:51.280
I'm returning it out.

147
00:06:52.400 --> 00:06:55.790
And I'm gonna store it, whatever gets
returned out of instruction generator was

148
00:06:55.790 --> 00:06:56.899
gonna be stored where, Lindsey?

149
00:06:59.670 --> 00:07:02.530
Whatever gets returned out in instruction
generator is gonna be stored where?

150
00:07:02.530 --> 00:07:04.120
&gt;&gt; Lindsey: In the local.

151
00:07:04.120 --> 00:07:05.000
&gt;&gt; Will Sentance: Whatever gets returned,

152
00:07:05.000 --> 00:07:06.700
whatever the output of
instruction generator.

153
00:07:06.700 --> 00:07:07.330
&gt;&gt; Lindsey: In the generated func.

154
00:07:07.330 --> 00:07:08.040
&gt;&gt; Will Sentance: In generated func,

155
00:07:08.040 --> 00:07:09.940
that's where you're gonna store it,
wasn't it?

156
00:07:09.940 --> 00:07:12.220
There it is, generated func.

157
00:07:12.220 --> 00:07:15.400
And what's ended up being
returned out then, Lindsay?

158
00:07:15.400 --> 00:07:18.390
&gt;&gt; Lindsey: The actual function
of multiply by 2, the value.

159
00:07:18.390 --> 00:07:20.430
&gt;&gt; Will Sentance: Very good job,
Lindsay, I like this.

160
00:07:20.430 --> 00:07:21.540
There it is.

161
00:07:21.540 --> 00:07:25.440
The whole function,
there it is the whole function.

162
00:07:25.440 --> 00:07:27.580
I try, and representing like this.

163
00:07:27.580 --> 00:07:29.620
Is this whole function definition.

164
00:07:29.620 --> 00:07:32.537
I'm actually going to write
out exactly what we see.

165
00:07:32.537 --> 00:07:39.458
Yeah, I'm gonna write the whole
function definition is returned out,

166
00:07:39.458 --> 00:07:43.656
function Num, it doesn't have a name yet,

167
00:07:43.656 --> 00:07:48.987
it's just the definition of it,
cuz it's not got a name

168
00:07:48.987 --> 00:07:53.780
if we return that as a value,
num return num by 2.

169
00:07:53.780 --> 00:07:59.720
That's what got returned out and
is stored in generated func.

170
00:07:59.720 --> 00:08:00.490
This whole.

171
00:08:02.400 --> 00:08:04.490
This whole function definition.

172
00:08:04.490 --> 00:08:08.000
Out it got returned and
we stored it in generated func.

173
00:08:09.280 --> 00:08:15.500
My friends, this is the thing that
throws seasoned developers all the time.

174
00:08:15.500 --> 00:08:16.890
This particular thing.

175
00:08:16.890 --> 00:08:18.880
And I'll ask you a question.

176
00:08:18.880 --> 00:08:20.030
And I'll ask Lindsay it.

177
00:08:20.030 --> 00:08:25.790
How can I now- Let's just finish
up with our execution context.

178
00:08:25.790 --> 00:08:27.140
Just to make sure we're really clear.

179
00:08:28.480 --> 00:08:33.280
We've returned our multiplier by two,
stored it under what label Andrea?

180
00:08:36.310 --> 00:08:39.940
We've returned our multiplier by two
from running instruction generator,

181
00:08:39.940 --> 00:08:41.450
it's the output stored in what label?

182
00:08:41.450 --> 00:08:42.320
The internal function?

183
00:08:44.450 --> 00:08:47.460
We've returned out multiplied by two,
stored it where Mohammed.

184
00:08:49.030 --> 00:08:50.500
&gt;&gt; Muhammed: In the generated func.

185
00:08:50.500 --> 00:08:52.150
&gt;&gt; Will Sentance: In generated func,

186
00:08:52.150 --> 00:08:54.590
what's happened to the call to
instruction generator Lindsay.

187
00:08:56.490 --> 00:08:58.530
&gt;&gt; Lindsey: Wait, ask that again please.

188
00:08:58.530 --> 00:09:02.880
&gt;&gt; Will Sentance: It's done.
It's done It's finished.

189
00:09:02.880 --> 00:09:06.310
So Griffin, call stack expert.

190
00:09:06.310 --> 00:09:07.450
What happens to our call stack?

191
00:09:07.450 --> 00:09:08.730
&gt;&gt; Griffin: It gets popped off.

192
00:09:08.730 --> 00:09:10.810
&gt;&gt; Will Sentance: It gets popped off.

193
00:09:10.810 --> 00:09:16.240
So that means that yes,
fine we returned out the whole definition,

194
00:09:17.850 --> 00:09:21.580
which is multiplied by two's definitions.

195
00:09:21.580 --> 00:09:23.410
But all of this.

196
00:09:24.590 --> 00:09:26.040
All of this local memory.

197
00:09:27.110 --> 00:09:29.680
All these, all gone.

198
00:09:31.000 --> 00:09:33.450
I still don't know how
to say to show visually

199
00:09:33.450 --> 00:09:36.270
without it becoming a complete mess,
which obviously it did.

200
00:09:36.270 --> 00:09:37.150
There you go.

201
00:09:37.150 --> 00:09:38.000
All gone.

202
00:09:38.000 --> 00:09:39.680
Except this function
that got returned out and

203
00:09:39.680 --> 00:09:43.630
stored in the new label generated That's
the only thing that got hold onto.

204
00:09:43.630 --> 00:09:47.270
So now which execution
context are we into Griffin?

205
00:09:47.270 --> 00:09:48.070
&gt;&gt; Griffin: The global.

206
00:09:48.070 --> 00:09:49.050
&gt;&gt; Will Sentance: Global.

207
00:09:49.050 --> 00:09:51.740
In global is there a function
named multiply by 2 Griffin?

208
00:09:51.740 --> 00:09:52.312
&gt;&gt; Griffin: No.
&gt;&gt; Will Sentance: So

209
00:09:52.312 --> 00:09:56.630
how can I run/call invoke
execute multiply by 2 in global?

210
00:09:56.630 --> 00:09:57.750
&gt;&gt; Griffin: On parentheses.

211
00:09:59.170 --> 00:10:00.230
&gt;&gt; Will Sentance: Is he right?

212
00:10:00.230 --> 00:10:01.760
He's so right.

213
00:10:01.760 --> 00:10:02.650
Very nice round.

214
00:10:02.650 --> 00:10:03.490
Exactly.

215
00:10:03.490 --> 00:10:11.210
If I run now generated func, it is
that functionality multiplied by two.

216
00:10:11.210 --> 00:10:14.230
I just stick parenthesis on the end
of it because this is generated func

217
00:10:14.230 --> 00:10:16.140
is this functionality.

218
00:10:16.140 --> 00:10:18.660
Multiply by two that we
return that as wholesale,

219
00:10:18.660 --> 00:10:21.440
the whole description of the function and
gave it a new label.

220
00:10:21.440 --> 00:10:24.190
We said whatever comes out of the ball
instruction generator it's this whole

221
00:10:24.190 --> 00:10:27.320
functionality where it said return

222
00:10:27.320 --> 00:10:31.440
multiply by two pulls
the whole function out.

223
00:10:31.440 --> 00:10:33.940
It's the output of running
instruction generator,

224
00:10:33.940 --> 00:10:38.230
that whole functionality
gets stored in funct.

225
00:10:38.230 --> 00:10:41.900
So now if you wanna run that previously,
the function previously known,

226
00:10:41.900 --> 00:10:44.430
general function previously
known is multiplied by two,

227
00:10:44.430 --> 00:10:49.710
a new label, we just put prints on the end
obviously parse in a parameter because

228
00:10:49.710 --> 00:10:54.980
this function has a place holder, num,
waiting for parameter, there it is.

229
00:10:56.210 --> 00:11:00.450
Same code but we've now at the bottom
we're now calling, invoking,

230
00:11:00.450 --> 00:11:05.500
running the function
value formerly known as

231
00:11:05.500 --> 00:11:11.390
multiply by 2 by its new label, generated
func, and we're passing it the input 3.

232
00:11:11.390 --> 00:11:15.720
Well, if I'm calling a function,
Katie what do I do?

233
00:11:15.720 --> 00:11:17.420
Create a new?

234
00:11:17.420 --> 00:11:18.490
&gt;&gt; Label?

235
00:11:18.490 --> 00:11:19.170
Wait.

236
00:11:19.170 --> 00:11:20.676
&gt;&gt; Will Sentance: Everyone together!

237
00:11:20.676 --> 00:11:22.090
&gt;&gt; Katy: Execution code!.

238
00:11:22.090 --> 00:11:22.610
&gt;&gt; Will Sentance: Good job, Katie!

239
00:11:22.610 --> 00:11:23.390
&gt;&gt; class: [LAUGH]
&gt;&gt; Will Sentance: [LAUGH]

240
00:11:23.390 --> 00:11:24.560
I'm calling a function.

241
00:11:24.560 --> 00:11:26.050
But I forgot the left hand side actually.

242
00:11:26.050 --> 00:11:27.560
So I'm calling Jenny to with input three.

243
00:11:27.560 --> 00:11:30.450
What's the left hand
side said to do Katie?

244
00:11:30.450 --> 00:11:32.090
&gt;&gt; Katy: Assign it to result.

245
00:11:32.090 --> 00:11:33.660
&gt;&gt; Will Sentance: Right, so
we're gonna have result.

246
00:11:33.660 --> 00:11:34.720
Do we know what result's gonna be yet?

247
00:11:34.720 --> 00:11:35.570
We do not.

248
00:11:35.570 --> 00:11:38.690
We do not, just like any function
call being assigned to a variable,

249
00:11:38.690 --> 00:11:39.875
we don't know yet.

250
00:11:39.875 --> 00:11:46.638
The call generated func, and we know that
whatever is going to get returned out or

251
00:11:46.638 --> 00:11:51.711
generated func will be assigned
to the placeholder result,

252
00:11:51.711 --> 00:11:57.891
because result is set to be the evaluated
output of running the function.

253
00:11:57.891 --> 00:11:59.989
And whenever you see
a statement like this,

254
00:11:59.989 --> 00:12:02.482
it means go create an execution context,
friends,

255
00:12:02.482 --> 00:12:05.841
and whatever is the return statement
inside that execution context.

256
00:12:05.841 --> 00:12:09.840
Whatever's after the return statement
is what's going to be assigned to

257
00:12:09.840 --> 00:12:12.800
whatever's on the left
hand side of equals.

258
00:12:12.800 --> 00:12:14.406
All right, so in we go.

259
00:12:14.406 --> 00:12:19.530
Katie, generated func at this point
is really the functionality known as,

260
00:12:20.670 --> 00:12:23.620
is that's what's we're [INAUDIBLE]
is really what the functionality

261
00:12:23.620 --> 00:12:27.770
we used to call when we created that
function inside an instruction generator.

262
00:12:27.770 --> 00:12:29.370
What was this functionality called?

263
00:12:29.370 --> 00:12:30.120
&gt;&gt; Katy: Multiply by two.

264
00:12:30.120 --> 00:12:33.130
&gt;&gt; Will Sentance: Multiply by two,
exactly.

265
00:12:33.130 --> 00:12:35.090
But we said inside
an instruction generator and

266
00:12:35.090 --> 00:12:37.380
we called it, we created multiply by two.

267
00:12:37.380 --> 00:12:38.310
How do we create multiply by two?

268
00:12:38.310 --> 00:12:41.370
What key words says
create multiply by two?

269
00:12:41.370 --> 00:12:42.290
&gt;&gt; Katy: F, function.

270
00:12:42.290 --> 00:12:43.680
&gt;&gt; Will Sentance: Keyword function,
correct.

271
00:12:43.680 --> 00:12:44.390
That created it,

272
00:12:44.390 --> 00:12:49.360
said stall the description in memory
under the label multiply by two.

273
00:12:49.360 --> 00:12:53.900
But we then said return multiplied by two,
and

274
00:12:53.900 --> 00:12:57.600
JavaScript went to look for
multiplied by two, saw what it was.

275
00:12:57.600 --> 00:13:00.770
It's this function description as a value.

276
00:13:00.770 --> 00:13:06.430
Return out that description, this
description, and that's now the output

277
00:13:06.430 --> 00:13:11.110
of running instruction generator which
we've said store in generated func.

278
00:13:11.110 --> 00:13:14.340
So generated func is now that
functionality multiplied by 2.

279
00:13:14.340 --> 00:13:20.200
And so if that's the case,
this functionality, what's

280
00:13:20.200 --> 00:13:25.020
the first thing we we have to handle in
the core degenerator's function ,Katie?

281
00:13:25.020 --> 00:13:26.960
&gt;&gt; Katy: We set num to be three.

282
00:13:26.960 --> 00:13:28.330
&gt;&gt; Will Sentance: Yep, spot on.

283
00:13:28.330 --> 00:13:31.024
Then we do three by two, six, and

284
00:13:31.024 --> 00:13:35.953
that's our return now value,
which is assigned to result.

285
00:13:37.357 --> 00:13:43.652
&gt;&gt; Will Sentance: [EXHALES] My good, and
we forgot to add generator's func Jesus,

286
00:13:43.652 --> 00:13:48.730
we've got add to generated func,
let's add it, generated func.

287
00:13:48.730 --> 00:13:52.530
When we were calling generated func
we were inside pool vaccuum stack.

288
00:13:54.730 --> 00:13:57.430
Next thing that happens when we
continue running generated func Katie?

289
00:13:57.430 --> 00:13:58.880
&gt;&gt; Katy: It gets popped off.

290
00:13:58.880 --> 00:13:59.640
&gt;&gt; Will Sentance: Popped off, perfect.

291
00:13:59.640 --> 00:14:01.370
&gt;&gt; Katy: And then everything is done.

292
00:14:01.370 --> 00:14:03.660
&gt;&gt; Will Sentance: And yeah, then we're
back to global and then the code's done.

293
00:14:03.660 --> 00:14:04.550
Very good job, Katie.

294
00:14:05.740 --> 00:14:09.420
Okay, so,
we're gonna have funcs in a second, on.

295
00:14:09.420 --> 00:14:12.090
I create a function instruction generator,

296
00:14:12.090 --> 00:14:14.230
I then create a placeholder
generated func,

297
00:14:14.230 --> 00:14:20.170
that's gonna have in it whatever value
gets returned from instriction generator.

298
00:14:20.170 --> 00:14:23.080
Even if that value is just
a function description.

299
00:14:23.080 --> 00:14:26.330
What do you know I called in instruction
generator that means I start running

300
00:14:26.330 --> 00:14:28.380
through the code inside
the instruction generators.

301
00:14:28.380 --> 00:14:30.070
What’s it say to do?

302
00:14:30.070 --> 00:14:32.653
It says JavaScript go create
a space in memory for

303
00:14:32.653 --> 00:14:36.370
this function description, return
num by two with the input of num and

304
00:14:36.370 --> 00:14:39.330
sort it under the label multiplied by two.

305
00:14:39.330 --> 00:14:42.000
Don’t then run it,
don’t ever invoke it, don’t call it,

306
00:14:42.000 --> 00:14:47.610
just return that whole description out,
and it's now the output of running

307
00:14:47.610 --> 00:14:52.900
instruction generator and store that
whole description in generator func.

308
00:14:52.900 --> 00:14:53.880
So now globally,

309
00:14:53.880 --> 00:14:57.890
we have access even though we've
finished instruction generator.

310
00:14:57.890 --> 00:15:00.930
We still have access to that formerly

311
00:15:00.930 --> 00:15:04.570
known as multiplied by 2
functionality under a new label.

312
00:15:04.570 --> 00:15:06.030
Generated func.

313
00:15:06.030 --> 00:15:08.340
And then we say, okay, well,
I wanna run that functionality.

314
00:15:08.340 --> 00:15:08.930
How do I do it?

315
00:15:10.030 --> 00:15:10.630
Use a new label.

316
00:15:10.630 --> 00:15:11.600
Generated func.

317
00:15:11.600 --> 00:15:12.880
Pass in three.

318
00:15:12.880 --> 00:15:15.050
And I'm really running
the multiplier by two functionality.

319
00:15:15.050 --> 00:15:18.560
By the way, I ain't going back in
here to look for multiplier by two.

320
00:15:18.560 --> 00:15:19.980
This was done.

321
00:15:19.980 --> 00:15:23.090
It's only because I
returned that function out.

322
00:15:23.090 --> 00:15:25.240
To give it a new label globally.

323
00:15:25.240 --> 00:15:29.680
This whole names, all gone,
because it's returned that.

324
00:15:29.680 --> 00:15:32.840
By the way, we returned that function and
stored it in generatedfunc.

325
00:15:33.920 --> 00:15:38.850
We lost this label and then we run
generatedfunc really multiplied by 2,

326
00:15:38.850 --> 00:15:40.210
but a 3, fine.

327
00:15:40.210 --> 00:15:41.230
Num is 3, 3 by 2, 6.

328
00:15:41.230 --> 00:15:44.310
Return that out and store it in results.

