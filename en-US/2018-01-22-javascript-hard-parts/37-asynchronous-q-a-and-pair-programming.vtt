WEBVTT

1
00:00:00.000 --> 00:00:01.710
&gt;&gt; Will Sentance: Let's
see any clarifications.

2
00:00:01.710 --> 00:00:03.700
Griffin has one or two is good.

3
00:00:03.700 --> 00:00:06.530
Griffin, it would take going
into a online clarification.

4
00:00:06.530 --> 00:00:07.390
Griffin, you wanna go?

5
00:00:07.390 --> 00:00:09.880
&gt;&gt; Griffin: Is there a way
to bypass the event loop?

6
00:00:09.880 --> 00:00:14.460
Like manually coding,
come back in at this time.

7
00:00:14.460 --> 00:00:16.230
No?
&gt;&gt; Will Sentance: This is a very strict,

8
00:00:16.230 --> 00:00:19.260
because if you could,
how unpredictable would that code be?

9
00:00:19.260 --> 00:00:22.390
We could randomly say
[SOUND] come second up.

10
00:00:22.390 --> 00:00:25.500
Now there is ways of setting ordering.

11
00:00:25.500 --> 00:00:28.420
So what you people often do is,
you don't print hello,

12
00:00:28.420 --> 00:00:30.512
you don't console hello
inside this function.

13
00:00:30.512 --> 00:00:31.123
You know what you do?

14
00:00:31.123 --> 00:00:36.587
You speak off to another inside of another
one, so you can order things by in

15
00:00:36.587 --> 00:00:42.399
the call back you past, in there making
another reference to a web browser API,

16
00:00:42.399 --> 00:00:48.640
cuz you therefore know this one must
complete before that next one is made.

17
00:00:48.640 --> 00:00:51.740
Because it's being made
inside the call back and

18
00:00:51.740 --> 00:00:55.620
that is what creates,
who knows what that creates?

19
00:00:55.620 --> 00:00:57.580
That the famous call back hell.

20
00:00:57.580 --> 00:00:59.370
That's the notion of,
when you hear of call back hell,

21
00:00:59.370 --> 00:01:03.700
what it is is saying, I need to delay
my next call back until I know I've

22
00:01:03.700 --> 00:01:07.070
successfully completed
the previous API interaction.

23
00:01:07.070 --> 00:01:08.110
In this case, timer.

24
00:01:08.110 --> 00:01:12.340
But it could be for data from an API,
from an outside API.

25
00:01:12.340 --> 00:01:15.720
I need to complete that one and
get that function running.

26
00:01:15.720 --> 00:01:18.450
And then inside that function
make the next request.

27
00:01:19.990 --> 00:01:23.220
Because we've gotta wait on that first
data before we can make the next one

28
00:01:23.220 --> 00:01:25.000
to store into a database, for example.

29
00:01:25.000 --> 00:01:28.270
So you make call back, and then
another request inside that call back,

30
00:01:28.270 --> 00:01:30.620
another request inside that call back.

31
00:01:30.620 --> 00:01:36.470
All using the fact that when you
insert your additional request,

32
00:01:36.470 --> 00:01:41.430
your next API interaction inside the
function that got passed to the first one,

33
00:01:41.430 --> 00:01:46.000
first API interaction, you know
that first API will have done, for

34
00:01:46.000 --> 00:01:49.290
Print Hello to be running
it must have completed.

35
00:01:49.290 --> 00:01:52.580
And therefore you can write your
next request inside here and

36
00:01:52.580 --> 00:01:54.470
you know it will be coming after.

37
00:01:54.470 --> 00:01:55.610
So it's a way of ordering stuff.

38
00:01:55.610 --> 00:01:59.310
So that sort of answers the question in
the sense that that's what people do.

39
00:01:59.310 --> 00:02:04.970
But you're certainly not able to just go,
now let me de-queue and just go.

40
00:02:04.970 --> 00:02:08.360
I can't, timing is a weird
thing in any environment.

41
00:02:09.480 --> 00:02:14.500
It's hard to, this the way we
handle timing in JavaScript, and

42
00:02:14.500 --> 00:02:18.290
it's by setting constraints
on ourselves like this,

43
00:02:18.290 --> 00:02:22.970
otherwise the unpredictability of
when our functions will be calling,

44
00:02:22.970 --> 00:02:25.040
where our functions
would be evaluating to.

45
00:02:25.040 --> 00:02:29.850
Suppose we through Print Hello on while
block for one second is on top, that means

46
00:02:29.850 --> 00:02:35.010
Print Hello is gonna evaluate into
block for one second when it completes.

47
00:02:35.010 --> 00:02:37.732
&gt;&gt; Will Sentance: You get all sorts
of interesting rates, conditions,

48
00:02:37.732 --> 00:02:41.000
that means I'm waiting for
some data that's not been ready yet.

49
00:02:41.000 --> 00:02:46.050
All this stuff is protected for
us by a very strict set of rules.

50
00:02:46.050 --> 00:02:48.860
For now,
we're gonna do another block of pairing.

51
00:02:48.860 --> 00:02:54.608
After this we're gonna look at one final
version, for now, of pur web browser API.

52
00:02:54.608 --> 00:02:57.617
If you've seen timer, but
there is a whole bunch of other ones,

53
00:02:57.617 --> 00:02:59.810
including the ones that
do the ATTP requests.

54
00:02:59.810 --> 00:03:04.765
You’re going to start to see those
in the challenges in a moment, and

55
00:03:04.765 --> 00:03:08.920
we’re gonna look through
those after the challenges.

56
00:03:08.920 --> 00:03:13.210
All right folks, back to your pairing,
and we’ll go and look at the challenges

