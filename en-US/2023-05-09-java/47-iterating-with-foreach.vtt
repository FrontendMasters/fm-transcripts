WEBVTT

1
00:00:00.271 --> 00:00:04.916
So using the forEach method,
is an even more straight

2
00:00:04.916 --> 00:00:09.667
forward approach to iterating
over collections, and

3
00:00:09.667 --> 00:00:14.433
this is available on every collection and
even on Mac.

4
00:00:14.433 --> 00:00:19.292
We are going to use forEach
to print the elements of

5
00:00:19.292 --> 00:00:24.164
the fruit list, so
back to our CollectionsDemo.

6
00:00:24.164 --> 00:00:28.396
I'm gonna uncomment out the listDemo.

7
00:00:28.396 --> 00:00:34.240
And then here,
I'm gonna comment out the enhanced for

8
00:00:34.240 --> 00:00:37.807
loop and I wanna use another one.

9
00:00:37.807 --> 00:00:43.061
All right, so this is so
dead simple, you're gonna love it.

10
00:00:43.061 --> 00:00:46.417
We just say fruits.forEach.

11
00:00:49.402 --> 00:00:52.645
The end, that is my loop.

12
00:00:52.645 --> 00:00:54.997
And then I'm basically saying for

13
00:00:54.997 --> 00:00:59.793
every element that is in this collection,
I want you to do something.

14
00:00:59.793 --> 00:01:04.400
Inside of these parentheses
is where we are going to

15
00:01:04.400 --> 00:01:08.159
provide the action that we want to occur.

16
00:01:08.159 --> 00:01:11.354
All right, so for, what do we wanna do?

17
00:01:11.354 --> 00:01:13.264
We basically wanna print something.

18
00:01:13.264 --> 00:01:14.207
Print each element, right?

19
00:01:14.207 --> 00:01:16.142
That's all we were doing.

20
00:01:16.142 --> 00:01:20.492
So we're gonna use a lambda expression.

21
00:01:20.492 --> 00:01:27.423
Okay, this is part of Java's like
functional programming capabilities.

22
00:01:27.423 --> 00:01:32.470
So now you're kind of dabbling in
the functional programming side.

23
00:01:32.470 --> 00:01:36.926
So you got a little objectory, you got
a little functional look at you, right?

24
00:01:36.926 --> 00:01:41.927
All right, in order to write
a lambda expression, what you're

25
00:01:41.927 --> 00:01:47.959
gonna do is you're gonna provide
a variable name for every element, right?

26
00:01:47.959 --> 00:01:52.087
Just like we kind of did right
here where we said string fruit

27
00:01:52.087 --> 00:01:55.474
over fruits except with
the lambda expression,

28
00:01:55.474 --> 00:02:00.776
it's really common to just use a single
letter versus a full variable name.

29
00:02:00.776 --> 00:02:05.366
Now you're more than welcome to
use a full variable name but,

30
00:02:05.366 --> 00:02:10.233
it's really short term, and
you just kind of do like f whatever.

31
00:02:10.233 --> 00:02:11.925
F for fruit.

32
00:02:11.925 --> 00:02:15.954
All right,
you look really cool with a single letter.

33
00:02:15.954 --> 00:02:17.956
Okay, I know what I'm doing.

34
00:02:17.956 --> 00:02:23.026
[LAUGH] All right, and
then we'll say okay,

35
00:02:23.026 --> 00:02:29.755
for every f, I wanna print,
I wanna print something out.

36
00:02:29.755 --> 00:02:33.919
And then what am I wanna print,

37
00:02:33.919 --> 00:02:38.893
I wanna print f itself dn, one line.

38
00:02:38.893 --> 00:02:40.751
In a queue,
&gt;&gt; That's nice.

39
00:02:40.751 --> 00:02:43.813
&gt;&gt; That's nice.

40
00:02:43.813 --> 00:02:50.112
All right, so let's just run it,
make sure everything is working.

41
00:02:50.112 --> 00:02:55.715
Boom, so I did the exact same thing
that we did with the enhanced for

42
00:02:55.715 --> 00:02:59.632
loop or
that we did with like the big iterator.

43
00:02:59.632 --> 00:03:03.232
So I'll be honest with you,
the iterator is played out.

44
00:03:03.232 --> 00:03:08.020
I just taught it to you because if
you have to read any legacy code,

45
00:03:08.020 --> 00:03:09.949
you might see it in there.

46
00:03:09.949 --> 00:03:11.704
I want you to know what it is.

47
00:03:11.704 --> 00:03:17.914
But if you have to write brand new code,
don't pull the iterator out.

48
00:03:17.914 --> 00:03:22.827
Unless you're using like an older version
of Java that doesn't have these features

49
00:03:22.827 --> 00:03:26.573
or, that's just like the way that
it's done in that code base.

50
00:03:26.573 --> 00:03:32.308
Sometimes people don't want you showing
off with your new fancy tricks and

51
00:03:32.308 --> 00:03:37.967
stuff, but if it's a greenfield project,
do not pull the iterator out.

52
00:03:37.967 --> 00:03:39.815
So this really slipped, right?

53
00:03:39.815 --> 00:03:44.573
Now in this case, this is equivalent
to this loop where I only had one line

54
00:03:44.573 --> 00:03:49.338
that I was executing, but what if you
wanted to do multiple lines there?

55
00:03:49.338 --> 00:03:51.825
You could still use this approach.

56
00:03:51.825 --> 00:03:57.633
You simply would, let me make another
one so that you have couple of examples.

57
00:03:59.443 --> 00:04:05.766
So what you would do is put
a curly brace right there.

58
00:04:05.766 --> 00:04:12.045
So after the arrow, a curly brace, and
then you could put whatever sentences,

59
00:04:12.045 --> 00:04:17.855
I mean whatever statements you want it so
let's say we wanna say f equals,

60
00:04:17.855 --> 00:04:24.070
I don't know, we wanna append the string
with the word fruit for example +f.

61
00:04:24.070 --> 00:04:26.554
And then I wanna print out f or whatever.

62
00:04:26.554 --> 00:04:32.104
So that short lambda expression,
just to give you a little bit more context

63
00:04:32.104 --> 00:04:37.581
on that, it is a block of code that
works basically like a method, right?

64
00:04:37.581 --> 00:04:41.863
It accepts parameters, it returns a value.

65
00:04:41.863 --> 00:04:45.664
They differ from methods in
that they don't have names.

66
00:04:45.664 --> 00:04:50.350
And they're executed inline versus
being called by other methods.

67
00:04:50.350 --> 00:04:52.878
So if you're from the JavaScript world,

68
00:04:52.878 --> 00:04:55.993
this is like equivalent
to an anonymous function.

69
00:04:55.993 --> 00:04:59.545
All right,
let's look at forEach for a map,

70
00:04:59.545 --> 00:05:03.015
cuz map always has to
be a little different.

71
00:05:09.943 --> 00:05:14.461
All right, so if I go to the map,
I'm gonna comment out this one.

72
00:05:18.370 --> 00:05:23.074
All right, so
we'll say fruitCalories.still forEach.

73
00:05:23.074 --> 00:05:26.106
I don't have to get an entry set or
anything like that.

74
00:05:26.106 --> 00:05:29.470
So still much simpler.

75
00:05:29.470 --> 00:05:34.936
Okay, it gets a little different but it's
still much better than everything else.

76
00:05:34.936 --> 00:05:40.758
So as opposed to just saying, like,
the one variable, because it's a map,

77
00:05:40.758 --> 00:05:45.072
you're dealing with two things,
the key and the value.

78
00:05:45.072 --> 00:05:51.041
So in parentheses, you would specify
two different variables versus one.

79
00:05:51.041 --> 00:05:56.006
We use K for key, V for value,
and then the rest is the same.

80
00:05:56.006 --> 00:05:58.088
You do your arrow function.

81
00:05:58.088 --> 00:05:59.276
And then, whatever.

82
00:05:59.276 --> 00:06:06.935
So you can say like system.out.println.

83
00:06:06.935 --> 00:06:11.323
And maybe I wanna print both the key and
the value,

84
00:06:11.323 --> 00:06:16.036
that's how you reference them with the K,
and the V.

85
00:06:17.631 --> 00:06:19.685
Plus V and that's it.

86
00:06:19.685 --> 00:06:21.420
That's really simple too, right?

87
00:06:25.197 --> 00:06:29.703
Much better than,
where's that iterator one?

88
00:06:29.703 --> 00:06:30.877
Did I write it in here?

89
00:06:30.877 --> 00:06:31.702
I might have not.

90
00:06:31.702 --> 00:06:32.972
I only showed slides, right?

91
00:06:32.972 --> 00:06:37.152
It was too horrible to put you through,
like writing it, right?

92
00:06:37.152 --> 00:06:43.476
But the iterator for map was like, so
you don't have to live like that anymore.

93
00:06:43.476 --> 00:06:47.419
And then even the forEach
which was much better,

94
00:06:47.419 --> 00:06:51.939
it still is a little bit
lengthy compared to just using,

95
00:06:51.939 --> 00:06:57.149
I mean the enhanced for
loop compared to like just the four each.

96
00:06:59.781 --> 00:07:01.111
Questions?

97
00:07:01.111 --> 00:07:03.348
You like it?

98
00:07:03.348 --> 00:07:07.013
Okay, there's another little
thing I wanna show you.

99
00:07:07.013 --> 00:07:11.228
If we go back to the listDemo.

100
00:07:11.228 --> 00:07:16.680
All right, so here, We said,

101
00:07:16.680 --> 00:07:20.758
okay, I have F,
I wanna just print out something.

102
00:07:20.758 --> 00:07:26.439
There's another little like shortcut
syntactically that you can use and

103
00:07:26.439 --> 00:07:29.379
these are called method references.

104
00:07:29.379 --> 00:07:37.347
I could just say The class name,

105
00:07:37.347 --> 00:07:44.178
so remember I said that the lambda
expressions are anonymous functions,

106
00:07:44.178 --> 00:07:48.594
they take input,
they return output, right?

107
00:07:48.594 --> 00:07:54.403
So what we were doing with the f in
the arrow and then we were saying print F,

108
00:07:54.403 --> 00:07:58.648
basically, we're using f
as the input yada, yada.

109
00:07:58.648 --> 00:08:04.260
This is a shorthand since it's only
a single method that's being used,

110
00:08:04.260 --> 00:08:09.047
I can just say the class name in our case,
it's system.out.

111
00:08:09.047 --> 00:08:11.555
But if it was another class
that just had a method,

112
00:08:11.555 --> 00:08:13.363
you would just say that class name.

113
00:08:13.363 --> 00:08:18.074
And then you would say colon,
colon, and the method name.

114
00:08:18.074 --> 00:08:20.641
So this is called a method reference.

115
00:08:20.641 --> 00:08:22.482
That way it knows, okay,

116
00:08:22.482 --> 00:08:27.345
the input that you were gonna use is
whatever is like the next object.

117
00:08:27.345 --> 00:08:32.318
I'll pass that to this method and
then we're good to go, right?

118
00:08:32.318 --> 00:08:36.814
And you don't have to specify
that with the long form.

119
00:08:36.814 --> 00:08:41.436
Now, you can, I'll put the other
way just so you have it here.

120
00:08:41.436 --> 00:08:45.707
It's definitely fine to do it that way,
but you don't have to.

121
00:08:45.707 --> 00:08:47.628
This is a shortcut.

122
00:08:47.628 --> 00:08:51.514
And that only works when it's
just a single method that you're

123
00:08:51.514 --> 00:08:54.740
trying to execute if you had
like the curly braces and

124
00:08:54.740 --> 00:08:58.353
you were trying to do multiple
methods this does not work.

125
00:09:01.013 --> 00:09:05.446
&gt;&gt; If whatever method that
you're calling with this way of

126
00:09:05.446 --> 00:09:10.255
doing it has a little like,
private helper method it uses you

127
00:09:10.255 --> 00:09:14.714
accomplish that task cuz I
couldn't change anything.

128
00:09:14.714 --> 00:09:16.483
&gt;&gt; No it's still gonna call that method.

129
00:09:16.483 --> 00:09:18.170
&gt;&gt; All right, so just gonna run as normal.

130
00:09:18.170 --> 00:09:22.734
&gt;&gt; It's gonna run as normal, it's just
basically a shortcut way to write it to,

131
00:09:22.734 --> 00:09:27.037
in your code, but under the covers,
it's gonna do the exact same thing.

132
00:09:27.037 --> 00:09:30.439
&gt;&gt; Does it have to be as guessing
crinoline is a static method does it have

133
00:09:30.439 --> 00:09:32.583
to be static or can you use-
&gt;&gt; It doesn't,

134
00:09:32.583 --> 00:09:36.715
that's a great question because we're
referencing this almost like we do

135
00:09:36.715 --> 00:09:39.611
static things where we say class.method,
right?

136
00:09:39.611 --> 00:09:44.638
If this was not a static method,
we could still do the class

137
00:09:44.638 --> 00:09:51.221
with the colon-colon in the non-static
method and that would be fine too.

138
00:09:51.221 --> 00:09:52.088
Yeah.

139
00:09:56.562 --> 00:09:58.431
Any other questions?

140
00:09:58.431 --> 00:10:00.495
&gt;&gt; Does it work for maps?

141
00:10:00.495 --> 00:10:02.447
&gt;&gt; Yes, it does.

142
00:10:02.447 --> 00:10:07.218
&gt;&gt; See you could read a
&gt;&gt; So with well, I don't know, cuz method

143
00:10:07.218 --> 00:10:10.542
takes two, I mean maps takes two
&gt;&gt; Yes if you

144
00:10:10.542 --> 00:10:14.024
had a custom method that took
&gt;&gt; A bike

145
00:10:14.024 --> 00:10:17.163
&gt;&gt; Let's try it out, I don't know,

146
00:10:17.163 --> 00:10:19.333
let's just try it out.

147
00:10:19.333 --> 00:10:23.542
&gt;&gt; I'll tell you you
folks are adventurous.

148
00:10:24.777 --> 00:10:27.662
Okay, and let's say that.

149
00:10:30.965 --> 00:10:33.361
Okay, I don't like that.

150
00:10:33.361 --> 00:10:35.432
Ambiguous.

151
00:10:35.432 --> 00:10:38.846
Man both println.

152
00:10:38.846 --> 00:10:43.184
You get yourself in trouble, right?

153
00:10:43.184 --> 00:10:47.894
Because you're no longer explicitly
like when I did this println,

154
00:10:47.894 --> 00:10:53.514
I'm explicitly saying which one of those
and apparently there's an overloaded

155
00:10:53.514 --> 00:10:58.653
method that takes a boolean and now it
just doesn't know what to do [LAUGH].

156
00:10:58.653 --> 00:11:01.597
So it did when it was
a single argument but

157
00:11:01.597 --> 00:11:07.323
with the two I don't know it just gets
it gets confused, so short answer is no.

158
00:11:07.323 --> 00:11:08.588
&gt;&gt; What do you call that again?

159
00:11:08.588 --> 00:11:09.710
&gt;&gt; Method reference.

160
00:11:12.911 --> 00:11:15.345
So it's just a little syntactic sugar.

161
00:11:15.345 --> 00:11:19.091
Same thing as the lambda expression,
just kind of shorthand.

