WEBVTT

1
00:00:00.220 --> 00:00:01.158
Hybrid apps.

2
00:00:01.158 --> 00:00:05.658
So, we're JavaScript developers,
a lot of people are.

3
00:00:05.658 --> 00:00:09.533
You can create apps for
native mobile with web technologies, so

4
00:00:09.533 --> 00:00:11.119
that's happening a lot.

5
00:00:11.119 --> 00:00:15.180
And I get questions a lot about
what do we need to think about for

6
00:00:15.180 --> 00:00:17.770
hybrid mobile apps as web developers.

7
00:00:17.770 --> 00:00:22.382
Pure native apps or
kind of outside of the scope of this?

8
00:00:22.382 --> 00:00:26.551
But if you're doing things
with React Native or Ionic,

9
00:00:26.551 --> 00:00:32.532
you're starting with a web code base and
packaging it out for app stores.

10
00:00:32.532 --> 00:00:35.135
There's also progressive web apps,
those are cool too.

11
00:00:35.135 --> 00:00:39.842
But what I'm really focused on is,
you start with a web code base, and then

12
00:00:39.842 --> 00:00:45.044
what the users are looking at is primarily
a native mobile wrapper around it.

13
00:00:45.044 --> 00:00:49.343
There might be some web views in there,
but it's like, what is the interface that

14
00:00:49.343 --> 00:00:52.353
the user is seeing when they're
looking at a mobile app?

15
00:00:52.353 --> 00:00:56.514
There's gonna be slightly different
outputs, slightly different requirements.

16
00:00:56.514 --> 00:01:00.971
So there could be some issues around that
translation of going from web to native

17
00:01:00.971 --> 00:01:02.041
mobile.

18
00:01:02.041 --> 00:01:05.640
And so we can test all the web views,
I mean, you think about Storybook,

19
00:01:05.640 --> 00:01:07.711
you could fire those up on their own.

20
00:01:07.711 --> 00:01:12.554
They're not in the native mobile wrapper,
squash any bugs you find there, but

21
00:01:12.554 --> 00:01:15.311
test it when it's
integrated in the app too.

22
00:01:16.321 --> 00:01:21.054
And so, some potential issues
could just mostly be things that

23
00:01:21.054 --> 00:01:24.462
get lost in translation
with the framework.

24
00:01:24.462 --> 00:01:28.351
I know Electron, people have had
some issues there, where it's like,

25
00:01:28.351 --> 00:01:30.599
you don't even know where to go to fix it.

26
00:01:30.599 --> 00:01:35.133
So go check their repos, go see if you
can find any places where people have

27
00:01:35.133 --> 00:01:38.224
asked for help, and
then what guidelines apply.

28
00:01:38.224 --> 00:01:43.239
WCAG does apply to native mobile,
so that's the standard.

29
00:01:43.239 --> 00:01:47.599
Some of it's kind of confusing at best and
irrelevant at worst.

30
00:01:48.669 --> 00:01:52.181
There are a few new success
criteria in WCAG 2.1 and

31
00:01:52.181 --> 00:01:56.329
2.2 that are more geared towards mobile,
so that's cool.

32
00:01:57.689 --> 00:02:00.498
But focus mostly on creating
a good user experience, so

33
00:02:00.498 --> 00:02:02.752
people use keyboards with mobile devices.

34
00:02:02.752 --> 00:02:05.432
Can you navigate with Bluetooth keyboard?

35
00:02:05.432 --> 00:02:06.712
Can you use a screen reader?

36
00:02:08.202 --> 00:02:12.282
You could consider using some of
the testing tools I have here.

37
00:02:12.282 --> 00:02:18.950
There's some from Apple, Google for
Android, DQ has some native mobile stuff.

38
00:02:18.950 --> 00:02:24.294
And then Evinced, the startup,
they have a flow analyzer for mobile.

39
00:02:24.294 --> 00:02:28.665
So any kind of native mobile tooling is
what you would use to test the packaged

40
00:02:28.665 --> 00:02:31.482
thing, and
there's different ways to do that.

41
00:02:31.482 --> 00:02:34.381
But you could test your web
views separately too and

42
00:02:34.381 --> 00:02:37.226
just make sure those
are accessible to start out.

