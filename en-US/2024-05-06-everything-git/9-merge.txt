[00:00:00]
>> With the previous section, you should have this setup. Hopefully everyone has this setup. So now we're gonna need to do the exact same thing to trunk, except for we want to have D and E. This time, I do want you to edit the README file. So the README file will contain three changes now, A, D, and E.

[00:00:17]
Then we'll have a second file called second.md that's only on foo. So, to be able to make these changes, you first have to check out trunk. Now you need to make these changes one at a time onto trunk. So I'll use the identical process here. I'll do D and this is gonna go to ReadMe.

[00:00:33]
I will add it. I'll commit it with the message D, very important Important to do that. I will now add the next commit which is gonna be E, add it to ReadMe, stage it, and then commit it with the same message. So now if I were to do a git log, I'll do one line this time, you'll see trunk points to E, which has D and A in the past.

[00:00:59]
Did you know you can use git log with the branch name? So I can do foo, and you'll see foo CBA, perfect. So we have these two setups now. I can see trunk is correct. I can see foo is correct. And I have this setup right here. So now it's time to merge these two together.

[00:01:17]
There's actually two different ways you can do it. There's Merge and there's Rebase. We'll go over Rebase at some point, but we're gonna start first with Merge. Now remember, a commit is just a set of changes in the entire code base at a specific point in time. And if you have work on one branch and you need to get it over to another branch, we're gonna use merge.

[00:01:37]
Now, the thing about merge that's a little bit confusing is that when you use merge, you can have kind of two different outcomes. You can have one that has a merge commit and one that doesn't have a merge commit. And you've probably experienced this where sometimes you merge and you have to input a message, and then sometimes you merge and you don't have to input a message.

[00:01:53]
And there's a very specific reason why, because it depends on your history. We'll go over that in just a little bit. We'll create the two situations which exit. So what is a merge? A merge is just attempting to combine two histories that may or may not have diverged.

[00:02:07]
Diverging means how we set it up. A is in the past and we both share A, but there could be zero or more commits in both branches that cause us to diverge. Now, whatever you are merging, git uses something called the best common ancestor, which is gonna be the first in common commit.

[00:02:27]
So for us, we have ABC and we have ADE. A is the best common ancestor. In the docs, you'll often see it's called the merge base. And so really it's just the first thing that's in common. So if you were to walk up the tree, if you were to think about it, you having to write this algorithm, you literally start at each commit and you just keep on walking the parents with the hash map.

[00:02:46]
By the way, you'd wanna use a hash map here unironically. You'd use a hash map to contain, or really a set, to contain all the things you've seen up to this point, all the commits you've seen up to this point. And the first time you have something that is in common, you know you've just found the best common ancestor.

[00:03:02]
Funny enough, it's always a hash map. I don't know why, but it just always is. Anyways, git then takes these two commits that you have, checks out the merge base or the best common ancestor, then plays those commits on top of it. Creates a new commit called a merge commit, and that will actually have two parents.

[00:03:20]
You'll have one parent from one branch and one parent from another branch, and that is a merge commit. And so this happens, that's what you'll get a message because you have two different diverging branches. So we'll go over that, here we go, all right? So how to merge very, very easy.

[00:03:35]
You have a target branch, which is the branch you are on. And you have a source branch, the one you wish to merge with. And the source branch is gonna be the one that you provide the name. This is how I think about it at least, I think this is probably the easiest way to think of it.

[00:03:50]
And so you'll do git merge, the branch you wish to bring onto the one you're currently on. So, let's do it now. Let's merge foo onto trunk. But remember we don't want to ruin our current trunk state. So I want you to check out a branch called trunk-merge-foo.

[00:04:08]
So I'm gonna go git check out, trunk-merge- foo have my new branch. Remember, -b just creates a new branch if it doesn't exist. Awesome, so now I'm gonna go git-merge-foo. There we go, well presented this menu saying, hey, we need you to merge this together. We want you to add a commit message.

[00:04:32]
It's been auto merged for you, but we still need a commit message. Because remember, a commit is a series of changes that represents the entire state of the repo, plus an author, plus a message and time as well. You probably see something like this merge made by Ort strategy, that's relatively new.

[00:04:51]
I think at one point it was, it used to say like a three way commit strategy, and now it's changed into the ORT strategy. I don't know when that change happened. I don't know what Ort stands for. I should have probably read that, but I just didn't. I know I read it up and what was like different about it but well, here we are, the old ORT strategy, the one we're all familiar with.

[00:05:10]
It's practically like a HashMap. All right, so when we're done I want you to use git.log, so everyone that has just merged, use git.log and see what happens. And I also want you to use the term parents when you do git.log. When you do git.log, I want you to add- - parents.

[00:05:27]
So let's show the parents commits along with everything. So I'm gonna go git.log > one line > graph > parents. So you can see right here, the merge commit has two parents. If you look at this ID, the sha, you'll realize this is trunk, where trunk is currently pointing to.

[00:05:54]
When you look at this one, this is where foo is currently pointing to. This is C. So this is E. And then now with the graph, it's able to draw this nice graph because it has all that information. It's able to walk back the graph and be able to display for you, so you can actually see in line what is happening.

[00:06:14]
So there you go. That's pretty neat, right? By the way, log totally underrated, super cool. Super cool utility to kinda know some of the things to use, all right? So, now I want you to create the following git set up. I want you to check out trunk, then I want you to check out a new branch called bar, and I want you to add two commits X and Y.

[00:06:33]
And X and Y, please put the changes into a bar.md file, or just some other file. That's not readme. I used bar.nb. I'll do it with you, git checkout trunk, git checkout-b bar. I'm gonna echo in X into bar.md. And I'm gonna add it. I'm gonna commit it.

[00:07:02]
And I'm going to do it again with Y. All right, anyway, so we've now created this right here. It's pretty straightforward. All you have to do is just check out bar, add the two commits. This is almost identical to what I just got done doing on the screen.

[00:07:19]
Pretty easy. So we should now have the exact same thing. We should be able to use git log to see that we've done this correctly. So I'll do it right now. And we'll use the exact same git log that we're always using with one line. And we can erase parents who don't really need to know parents.

[00:07:31]
But you can see here, bar is that Y? Trunk, is that E? Can you say anything that's unique about the situation that wasn't unique in foo, or that was different in foo, shall I say? What's different between this setup versus what was done with foo and trunk? Foo and trunk both diverged.

[00:07:53]
In this situation, bar is the only one that has diverged. Its best common ancestor is the tip of trunk. It's a very important thing to remember or to observe, shall we say. So now let's merge bar onto trunk. So do the exact same thing. And this time we do not create a separate branch, just check out trunk and merge bar onto it.

[00:08:18]
So I'm gonna go get check out trunk, git > merge > bar. And you'll notice this time, there's no commit message. Why is there no commit message? Again, the best common ancestor was the tip of the branch you were merging onto, which means that it can just take the commits and just update the pointer.

[00:08:43]
That's all, it doesn't have to do any sort of merging, it already works. You've already resolved any conflict, it can just simply fast forward the merge. So you'll often see in the documentation where says ff- merge, it literally means you have a linear history with no divergence. And you can just simply take the commits and update the pointer.

