WEBVTT

1
00:00:00.000 --> 00:00:04.340
[MUSIC]

2
00:00:04.340 --> 00:00:08.290
&gt;&gt; Douglas Crockford: So that's the brain
we use to write computer programs.

3
00:00:08.290 --> 00:00:13.380
And computer programs are the most
complicated things that humans make.

4
00:00:13.380 --> 00:00:16.730
Computer programs are composed
of more elements,

5
00:00:16.730 --> 00:00:22.910
which are more Intricately connected
than anything else we've ever done.

6
00:00:22.910 --> 00:00:24.800
Maybe anything else we'll ever do.

7
00:00:24.800 --> 00:00:29.687
Programs are really complicated and early
on it was recognized that programming is

8
00:00:29.687 --> 00:00:32.616
hard and
wouldn't it be nice if we could figure out

9
00:00:32.616 --> 00:00:35.849
a way to get the computers to
write the programs for us.

10
00:00:35.849 --> 00:00:40.560
Because while we can do it,
It's really slow and error-prone.

11
00:00:40.560 --> 00:00:42.180
Maybe the machines could do a better job.

12
00:00:43.280 --> 00:00:46.642
So, that kicked off the experimentation
in artificial intelligence.

13
00:00:46.642 --> 00:00:51.260
One of the goals of AI was to be able to
build a program that could write programs.

14
00:00:51.260 --> 00:00:54.360
Now, AI has achieved a lot of things.

15
00:00:54.360 --> 00:00:56.670
It can play brilliant chess now.

16
00:00:56.670 --> 00:01:01.090
Pretty good game of jeopardy, but
you cannot give a set of requirements and

17
00:01:01.090 --> 00:01:05.820
some customer interviews to a program and
say write that program.

18
00:01:05.820 --> 00:01:06.650
You can't do that.

19
00:01:07.740 --> 00:01:11.620
So instead,
we're still writing programs by hand,

20
00:01:11.620 --> 00:01:14.020
that's the best we've been
able to figure out to do.

21
00:01:14.020 --> 00:01:16.350
Programs can't do that for us.

22
00:01:16.350 --> 00:01:21.175
What programs can do,
is translate one formal language

23
00:01:21.175 --> 00:01:25.360
into another formal language, that's
something computers are really good at.

24
00:01:25.360 --> 00:01:30.180
And so our programming languages continue
to improve over the years, slowly,

25
00:01:30.180 --> 00:01:31.460
but they do improve,

26
00:01:33.400 --> 00:01:38.450
constantly raising the level of
abstraction to where we get more leverage.

27
00:01:38.450 --> 00:01:42.640
But it turns out, the number of lines of
code we can write a day is pretty much

28
00:01:42.640 --> 00:01:47.540
fixed so that the higher level that we can
program, the more effective we can be.

29
00:01:47.540 --> 00:01:52.240
And so programming languages are still
our best tool for managing programs.

30
00:01:54.020 --> 00:01:57.830
One of the things that makes programming
so hard is the need for perfection.

31
00:01:57.830 --> 00:02:03.430
A program has to be perfect in every
aspect for all possible inputs.

32
00:02:03.430 --> 00:02:07.790
And even inputs that were not anticipated
at the time that the program was designed.

33
00:02:09.250 --> 00:02:13.210
The contract we have with the computer
is that if the program is not

34
00:02:13.210 --> 00:02:17.680
perfect in every detail, for
all states, for all possibilities,

35
00:02:17.680 --> 00:02:22.500
the computer has license to do the worst
possible thing at the worst possible time.

36
00:02:23.500 --> 00:02:25.680
And it's not the computer's fault.

37
00:02:25.680 --> 00:02:27.390
Who's fault is it?

38
00:02:27.390 --> 00:02:28.930
It's your fault, right?

39
00:02:28.930 --> 00:02:32.445
You're the ones who get the call why
did you put out this piece of software

40
00:02:32.445 --> 00:02:33.432
that has a bug in it?

41
00:02:33.432 --> 00:02:35.186
That doesn't make sense,
why do you do that?

42
00:02:35.186 --> 00:02:39.917
So given that, you would think that
we would never release a piece of

43
00:02:39.917 --> 00:02:43.110
software until we knew it was perfect.

44
00:02:43.110 --> 00:02:45.180
And we don't do that.

45
00:02:46.390 --> 00:02:48.940
Because if we did we would
never release anything.

46
00:02:48.940 --> 00:02:52.050
And so
that certainly would be counterproductive.

47
00:02:52.050 --> 00:02:55.900
In fact we would not recognize
perfection if it ever occurred.

48
00:02:55.900 --> 00:02:57.300
It's unlikely it'll ever occur.

49
00:02:57.300 --> 00:02:59.710
But if it did, we wouldn't know it.

50
00:02:59.710 --> 00:03:00.850
There's no test for it.

51
00:03:00.850 --> 00:03:02.450
How would we know if something is perfect?

52
00:03:02.450 --> 00:03:05.850
We can know something
passed all of its tests but

53
00:03:05.850 --> 00:03:09.440
only a fool would think that passing all
the tests means it's perfect, right?

54
00:03:09.440 --> 00:03:13.390
Tests cannot cover everything,
so we just don't know.

55
00:03:13.390 --> 00:03:17.050
So given that what we do instead
is we release software early

56
00:03:17.050 --> 00:03:19.010
knowing that it's full of bugs.

57
00:03:19.010 --> 00:03:22.260
Hoping that we'll discover them
before they cause any damage or

58
00:03:22.260 --> 00:03:23.910
before anybody else finds them.

59
00:03:23.910 --> 00:03:28.090
Which is crazy, but it's the best we've
been able to figure out how to do.

60
00:03:28.090 --> 00:03:29.310
That's the state of the art.

61
00:03:31.180 --> 00:03:35.010
So we're doing this with the brains
of hunters and gatherers.

62
00:03:35.010 --> 00:03:36.540
We are hunters and gatherers.

63
00:03:36.540 --> 00:03:40.700
There's been no human evolution
since at least the last ice age, and

64
00:03:40.700 --> 00:03:46.090
there is nothing in that experience to
have prepared us for doing programming.

65
00:03:47.930 --> 00:03:50.390
Somehow we can do it anyway,
which is sort of miraculous.

66
00:03:52.479 --> 00:03:56.157
&gt;&gt; Douglas Crockford: So evolution likes
to make use of dual use technologies and

67
00:03:56.157 --> 00:03:59.150
I have to figure this happened here too.

68
00:03:59.150 --> 00:04:00.600
Since there was no preparation for

69
00:04:00.600 --> 00:04:05.890
programming, we're making use of
facilities that we had for other purposes.

70
00:04:05.890 --> 00:04:09.160
So, programming obviously makes
use of system two, right?

71
00:04:09.160 --> 00:04:13.840
Because that, it's analytical
where algorithms work, all that.

72
00:04:13.840 --> 00:04:16.850
But I have to figure system
one has an effect here too.

73
00:04:16.850 --> 00:04:22.155
Sometimes a negative one but
I think there's a positive effect,

74
00:04:22.155 --> 00:04:25.736
that we cannot describe
how we do programs.

75
00:04:25.736 --> 00:04:28.053
You cannot write down a algorithm for

76
00:04:28.053 --> 00:04:33.800
programming something which will take the
problem statement and turn it into code.

77
00:04:33.800 --> 00:04:35.606
We don't know how to do that.

78
00:04:35.606 --> 00:04:40.560
We all have this process that we do where
we'll take something and we'll analyze it.

79
00:04:40.560 --> 00:04:45.408
And we'll look at it top down and we'll
look at it bottom up, and inside out and

80
00:04:45.408 --> 00:04:47.548
outside in, and micro and macro.

81
00:04:47.548 --> 00:04:51.801
We're constantly changing our point of
view the thing until suddenly [SOUND]

82
00:04:51.801 --> 00:04:52.941
a program happens.

83
00:04:52.941 --> 00:04:54.794
And we do not know how we do that,

84
00:04:54.794 --> 00:04:59.160
you cannot write down the steps
by which that's accomplished.

85
00:04:59.160 --> 00:05:01.380
Somehow all of us have figured that out.

86
00:05:02.650 --> 00:05:06.577
But not to the extent that we could
tell a program how we did it.

87
00:05:06.577 --> 00:05:13.400
It's magical and I have to figure system
one has something to do with that.

88
00:05:13.400 --> 00:05:18.750
It somehow is kind of intuitively, you
know intuition is in system one, right.

89
00:05:18.750 --> 00:05:21.890
Intuitively pushing us around,
helping us to solve problems for

90
00:05:21.890 --> 00:05:24.865
which we don't have enough information,
system one is great at that.

91
00:05:27.260 --> 00:05:30.210
Allowing us to find those flashes
of insight that make the whole

92
00:05:30.210 --> 00:05:30.860
thing possible.

93
00:05:32.110 --> 00:05:36.540
So I think programming would be
impossible if it were not for system one.

94
00:05:37.760 --> 00:05:42.400
Now I have no evidence to
support that statement, but

95
00:05:42.400 --> 00:05:44.335
system one tells me it's true so
I believe it.

96
00:05:44.335 --> 00:05:47.520
&gt;&gt; Speaker 2: [LAUGH]
&gt;&gt; Douglas Crockford: No,

97
00:05:47.520 --> 00:05:50.350
programming is all about
making trade-offs.

98
00:05:50.350 --> 00:05:55.480
Cuz there are always multiple
ways of doing something, and

99
00:05:55.480 --> 00:05:57.190
each of those has a cost.

100
00:05:57.190 --> 00:06:01.780
And often, those costs are not known or
recognized at the time that

101
00:06:01.780 --> 00:06:04.900
we're writing the program, so we're
guessing as we're making the trade-offs.

102
00:06:04.900 --> 00:06:06.400
And some of the trade-offs
we make are good,

103
00:06:06.400 --> 00:06:10.990
and some are bad, but that's the process,
that's what we're doing.

104
00:06:10.990 --> 00:06:14.061
And it turns out system one
is terrible at trade-offs,

105
00:06:14.061 --> 00:06:16.650
because it evaluates things wrong.

106
00:06:16.650 --> 00:06:18.030
And we'll show you some examples of that.

107
00:06:19.400 --> 00:06:23.680
So I'm gonna be showing you examples
of programming style in JavaScript.

108
00:06:23.680 --> 00:06:29.720
But this analysis could be applied, should
be applied to every programming language.

109
00:06:29.720 --> 00:06:31.470
Every language has good parts and

110
00:06:31.470 --> 00:06:34.340
every language has bad parts,
it's just inevitable.

111
00:06:35.830 --> 00:06:39.690
Every designer intends to create
a language composed of only good parts,

112
00:06:39.690 --> 00:06:42.299
but things always go wrong unexpectedly.

113
00:06:43.680 --> 00:06:46.850
Now JavaScript is unique in that
it's good parts are some of

114
00:06:46.850 --> 00:06:49.470
the best good parts ever put
into a programming language.

115
00:06:49.470 --> 00:06:51.940
And later we'll talk about what those are.

116
00:06:51.940 --> 00:06:54.460
And it's bad parts of some of
the worst parts ever put into

117
00:06:54.460 --> 00:06:56.160
a programming language.

118
00:06:56.160 --> 00:06:58.450
It's much more extreme in the goodness and

119
00:06:58.450 --> 00:07:03.210
badness than other languages, but
all languages have that in common.

120
00:07:03.210 --> 00:07:07.420
So because JavaScript has so many bad
parts in it, and because they are so

121
00:07:07.420 --> 00:07:11.446
treacherous, and because I'm trying to
achieve perfection, and there is so much

122
00:07:11.446 --> 00:07:15.980
in the language which is working against
me, I wrote a program called JSLint.

