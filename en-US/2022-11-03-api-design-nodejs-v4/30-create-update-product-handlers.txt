[00:00:00]
>> So I get one product, let's keep moving, and then eventually you will stop and add these to the routes and try them out. But let's just add some more, that way you have some more examples. So we're gonna get one product, we're gonna get many products. Let's do create a product.

[00:00:15]
So createProduct Same thing request response And this one's pretty simple. So we can say product equals await prisma.product.creates. Instead of having a where fields cuz we're not searching for anything, we have to tell prisma what data we're giving it to create something. So it's called data instead of where.

[00:00:52]
And the data that we want to create. If we go back and look at our routes for creating a product, it's only gonna be a body, that's it. Or I'm sorry, a name on the body like that's it, there's nothing else here. But a product also needs a belongs to.

[00:01:10]
We just don't get that from the user, that's gonna be on req.user. So we'll say data, name is req.body.name. And that's the brilliance of those inputs. It's that like now we know 100% sure that req.body.name is there because if it wasn't, this handler would never run. Because our input validation middleware would have saw that and sent back an error message before we got here.

[00:01:41]
So it just makes, having that middleware allows your handlers to just flow very easily and you can just safely assume that all the things are there, which is great. So you see, I'm still getting this cuz it's like, hey you have a name or whatever, but like now,you might need something else.

[00:02:00]
So we got name. Now we need belongs to. So there's a couple of ways you can do this. So you can say belongs to, and then you can just put the ID yourself. So you can say req.user.id and that works. When it comes to relationships, the other way you can do it is, I'm sorry, that would be belongs to ID, there we go.

[00:02:25]
The other way you can do it is if you wanted to do belongs to instead of belongs to ID and you had the actual user, which we don't, but if we did, you could say belongsTo. And then I believe you can do something like associates or match, there's a keyword here.

[00:02:48]
Maybe it's not worth it. Yeah, just do belongs to ID, that's the preferred way. But there's another way to do it, just almost never had to. So there we go, we got that we got the ID, we got the name should get a product back. We're just gonna be na√Øve here and res.json.data with the product.

[00:03:08]
Okay, keep it moving. We got the create, we got the gets. Let's do the update and delete and then we'll try them out and see what's up. So create product, let's just say update a product. Like so, async req, res. So to update, there's so many ways you can do it in Prisma, but we can try this way.

[00:03:37]
So I'll say, Await prisma.product., and if didn't say dot on that, you can see all the different methods they have like for instances fine first to throw. This is really good, you find a unique throw. I really like this because most of the time, if you do a query to look for something and it doesn't exist, the database won't throw an error, it'll just send you back at nd result NDRA undefined.

[00:04:12]
But maybe sometimes you want it to break, like I'm looking for a user who's signing in, if that user doesn't exist, I wanna throw an error. Otherwise you'd have to do an if statement on the next line yourself anyway. So this kinda saves you that, which I think is really cool.

[00:04:24]
But anyway, here we go, so we have update, we have updataMany, we have upCert. I'm not sure if you heard an upCert before. UpCert just means like I'm gonna give you some information. First, try to find something that matches this, if it doesn't, then use this to create a new one.

[00:04:40]
So just create or update. We're gonna use update, okay? So this one is just for updating one product and you can see even Prisma wrote the documentation for it literally says it right there update one product. Pretty brilliant, we didn't write that. Okay, so update You go and then because update is like also a find and all a write at the same time, we have to use the where and the data.

[00:05:13]
So first, we have to say where, so it knows what to find, right? And then outside of the where we have to tell it when you find it this is the data you need to update it with. So we got these both. So for where, we will say where id is gonna be req.params.id.

[00:05:41]
And then the data, if we go look at our validator for the product update. It's just the name, you can only update the name. So we'll just say name is req.body.name. And then we get that. And then usually on update, it's kind of you as an API person to send back the thing that you updated with the updates on it.

[00:06:13]
Otherwise the client is probably gonna make another request back to the server to get the updated thing. So just be nice and send back the updated thing, save them some time. So that's what we're gonna do. And I'm pretty sure that returns the product. Yeah, now, if you do update many, you will not get back an array of all the things you updated.

[00:06:40]
You'll get back an object describing all the operations you did. And you have to make a query to get them all, but if you updat one, you'll get back the thing you updated, okay? And then last one is gonna be delete, the simplest one. So delete a product, Or the req, res, Async, And const deleted = await prisma.product.delete.

[00:07:19]
Delete kind of works the same way as like update where you'll get back the thing you deleted. But if you do delete many, you'll just get back information of how many things deleted. So we're gonna delete where, Id is req.params.id. I just remembered something, we just fell into security flaw in the last one.

[00:07:44]
[LAUGH] Because we are just trusting that this is the ID that you wanted. Okay, well, I found your product ID, now I'm about to delete it, right? How do I stop that, right? So you also have to do the combination of belongsToId of req.user.id. BelongsToId is not assignable to type where belongs, ToId.

[00:08:21]
Yeah, it's definitely there. I don't know why TypeScript doesn't like me doing that, but I'm gonna leave it anyway cuz I'm pretty sure it's there. So req.user.id, because yeah, without this, what's gonna happen is, hey, you can auto delete whatever ID you put here and it'll be gone.

[00:08:43]
So you definitely don't want that, there we go. I don't know why that thing doesn't like me having anything here. Maybe wants me to manually find it myself and then delete it. But I'm not doing that product were unique, yeah, it's going back to the index point. Delete is basically a find unique.

[00:09:08]
And we don't have an index for this combination. So it's like you can't do that. So this is why you would have to index this. So we'd have to go back and index this run another migration, regenerate the client and/or to find ourselves first and then delete it.

[00:09:26]
But just leave it like this, yeah, your app's gonna be a wild, wild west, people just screwing with each other. So we can go back and add the index. So I'm just gonna leave this here for now and then we'll add the index for it. Okay, so then we have to delete it.

[00:09:45]
I'm just gonna say, res.json{(data: deleted)}. And the same thing is true for the update, we would have to add the belongsTo here as well. Otherwise you could update anybody and we're gonna get the same issue because this is not unique. We gotta update that index. Okay, so I'm just gonna go do that right quick for the index.

[00:10:20]
I think instead of doing that I can say unique like that. So now that's unique. Id, and a belongsToId. But we have to tell the database about it. So in order to do that, I gotta go back into the terminal. And I have to run a migration so I'd say mpx prisma migrate dev.

[00:11:00]
And I'm not even gonna give it a name, so we'll just run it. It'll just come up with a name by itself. So this happens a lot faster locally but we have a host dv, so this will take a minute. Yeah, every time you make a change, especially like indexes or anything unique or anything like that, you have to run a migration.

[00:11:21]
Some changes, and you can see right here is saying a unique constraint, covering the columns ID belongs to the table product will be added. If there are existing duplicate values, this will fail. So this just tells you the database just assumed because I didn't put a unique index on it that I could possibly have duplicate values.

[00:11:38]
Even though we wouldn't, because all IDs are unique and stuff. So that wouldn't have happened. But I'm gonna say yes, it's asking for a name, enter, I want write one. Once this is successful, it'll regenerate the clients. And then a client should not scream at us with TypeScript anymore because those things should be unique.

[00:12:01]
So let's see. And we close it and come back maybe. Yeah, it's still screaming at us, let's see. You have to write it in this special index anyway. So this is a compound index or joint index. So it's basically saying we have a index between the id and belongsToId, it's a joint index.

[00:12:37]
Yeah, and in fact, I think if you have that, you don't even need the ID field, you can just say Id belongs to and, I don't know if it's an array, let's see. I think it'd be like req.params.id and then req. User.id. Now, it's not an array. Do you have to like add them together?

[00:13:05]
Let's look that up.

