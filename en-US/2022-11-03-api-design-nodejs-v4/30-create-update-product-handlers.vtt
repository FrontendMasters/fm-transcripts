WEBVTT

1
00:00:00.067 --> 00:00:04.306
So I get one product, let's keep moving,
and then eventually you will stop and

2
00:00:04.306 --> 00:00:06.465
add these to the routes and try them out.

3
00:00:06.465 --> 00:00:09.790
But let's just add some more,
that way you have some more examples.

4
00:00:09.790 --> 00:00:12.791
So we're gonna get one product,
we're gonna get many products.

5
00:00:12.791 --> 00:00:15.341
Let's do create a product.

6
00:00:15.341 --> 00:00:20.459
So createProduct

7
00:00:22.292 --> 00:00:26.064
Same thing request response

8
00:00:27.990 --> 00:00:31.734
And this one's pretty simple.

9
00:00:31.734 --> 00:00:36.646
So we can say product equals await

10
00:00:36.646 --> 00:00:41.214
prisma.product.creates.

11
00:00:41.214 --> 00:00:45.041
Instead of having a where fields cuz
we're not searching for anything,

12
00:00:45.041 --> 00:00:48.754
we have to tell prisma what data
we're giving it to create something.

13
00:00:48.754 --> 00:00:52.325
So it's called data instead of where.

14
00:00:52.325 --> 00:00:54.618
And the data that we want to create.

15
00:00:54.618 --> 00:00:59.497
If we go back and look at our routes for
creating a product,

16
00:00:59.497 --> 00:01:02.893
it's only gonna be a body, that's it.

17
00:01:02.893 --> 00:01:06.424
Or I'm sorry, a name on the body like
that's it, there's nothing else here.

18
00:01:06.424 --> 00:01:10.538
But a product also needs a belongs to.

19
00:01:10.538 --> 00:01:14.463
We just don't get that from the user,
that's gonna be on req.user.

20
00:01:14.463 --> 00:01:21.176
So we'll say data, name is req.body.name.

21
00:01:21.176 --> 00:01:23.888
And that's the brilliance of those inputs.

22
00:01:23.888 --> 00:01:28.810
It's that like now we know 100%
sure that req.body.name is

23
00:01:28.810 --> 00:01:33.382
there because if it wasn't,
this handler would never run.

24
00:01:33.382 --> 00:01:37.925
Because our input validation
middleware would have saw that and

25
00:01:37.925 --> 00:01:41.216
sent back an error message
before we got here.

26
00:01:41.216 --> 00:01:46.381
So it just makes, having that middleware
allows your handlers to just flow very

27
00:01:46.381 --> 00:01:51.871
easily and you can just safely assume that
all the things are there, which is great.

28
00:01:51.871 --> 00:01:56.534
So you see, I'm still getting this
cuz it's like, hey you have a name or

29
00:01:56.534 --> 00:02:00.296
whatever, but
like now,you might need something else.

30
00:02:00.296 --> 00:02:01.818
So we got name.

31
00:02:01.818 --> 00:02:05.176
Now we need belongs to.

32
00:02:05.176 --> 00:02:06.678
So there's a couple of
ways you can do this.

33
00:02:06.678 --> 00:02:10.017
So you can say belongs to, and
then you can just put the ID yourself.

34
00:02:10.017 --> 00:02:15.070
So you can say req.user.id and that works.

35
00:02:15.070 --> 00:02:20.619
When it comes to relationships,
the other way you can do it is,

36
00:02:20.619 --> 00:02:25.452
I'm sorry, that would be belongs to ID,
there we go.

37
00:02:25.452 --> 00:02:29.684
The other way you can do it is
if you wanted to do belongs

38
00:02:29.684 --> 00:02:34.011
to instead of belongs to ID and
you had the actual user,

39
00:02:34.011 --> 00:02:38.637
which we don't, but if we did,
you could say belongsTo.

40
00:02:38.637 --> 00:02:44.789
And then I believe you can do
something like associates or

41
00:02:44.789 --> 00:02:48.515
match, there's a keyword here.

42
00:02:48.515 --> 00:02:50.299
Maybe it's not worth it.

43
00:02:50.299 --> 00:02:54.315
Yeah, just do belongs to ID,
that's the preferred way.

44
00:02:54.315 --> 00:02:59.090
But there's another way to do it,
just almost never had to.

45
00:02:59.090 --> 00:03:03.586
So there we go, we got that we got the ID,
we got the name should get a product back.

46
00:03:03.586 --> 00:03:08.917
We're just gonna be naÃ¯ve here and
res.json.data with the product.

47
00:03:08.917 --> 00:03:12.672
Okay, keep it moving.

48
00:03:12.672 --> 00:03:15.334
We got the create, we got the gets.

49
00:03:15.334 --> 00:03:18.999
Let's do the update and delete and
then we'll try them out and see what's up.

50
00:03:18.999 --> 00:03:23.663
So create product,
let's just say update a product.

51
00:03:23.663 --> 00:03:30.453
Like so, async req, res.

52
00:03:30.453 --> 00:03:37.442
So to update, there's so many ways you can
do it in Prisma, but we can try this way.

53
00:03:37.442 --> 00:03:44.589
So I'll say, Await prisma.product.,

54
00:03:44.589 --> 00:03:49.610
and if didn't say dot on that,
you can see all the different

55
00:03:49.610 --> 00:03:54.547
methods they have like for
instances fine first to throw.

56
00:03:54.547 --> 00:03:57.223
This is really good,
you find a unique throw.

57
00:03:57.223 --> 00:04:02.692
I really like this because most of
the time, if you do a query to look for

58
00:04:02.692 --> 00:04:08.258
something and it doesn't exist,
the database won't throw an error,

59
00:04:08.258 --> 00:04:12.548
it'll just send you back at
nd result NDRA undefined.

60
00:04:12.548 --> 00:04:15.435
But maybe sometimes you want it to break,
like I'm looking for

61
00:04:15.435 --> 00:04:19.098
a user who's signing in, if that user
doesn't exist, I wanna throw an error.

62
00:04:19.098 --> 00:04:21.903
Otherwise you'd have to do an if statement
on the next line yourself anyway.

63
00:04:21.903 --> 00:04:24.793
So this kinda saves you that,
which I think is really cool.

64
00:04:24.793 --> 00:04:30.261
But anyway, here we go, so we have update,
we have updataMany, we have upCert.

65
00:04:30.261 --> 00:04:32.188
I'm not sure if you
heard an upCert before.

66
00:04:32.188 --> 00:04:36.335
UpCert just means like I'm gonna
give you some information.

67
00:04:36.335 --> 00:04:39.419
First, try to find something that
matches this, if it doesn't,

68
00:04:39.419 --> 00:04:40.972
then use this to create a new one.

69
00:04:40.972 --> 00:04:44.389
So just create or update.

70
00:04:44.389 --> 00:04:47.371
We're gonna use update, okay?

71
00:04:47.371 --> 00:04:51.800
So this one is just for updating one
product and you can see even Prisma wrote

72
00:04:51.800 --> 00:04:56.312
the documentation for it literally says
it right there update one product.

73
00:04:56.312 --> 00:04:58.768
Pretty brilliant, we didn't write that.

74
00:04:58.768 --> 00:05:04.725
Okay, so update You go and

75
00:05:04.725 --> 00:05:07.980
then because update is
like also a find and

76
00:05:07.980 --> 00:05:13.105
all a write at the same time,
we have to use the where and the data.

77
00:05:13.105 --> 00:05:19.644
So first, we have to say where,
so it knows what to find, right?

78
00:05:19.644 --> 00:05:23.996
And then outside of the where we have to
tell it when you find it this is the data

79
00:05:23.996 --> 00:05:25.562
you need to update it with.

80
00:05:25.562 --> 00:05:26.942
So we got these both.

81
00:05:26.942 --> 00:05:30.117
So for where,

82
00:05:30.117 --> 00:05:36.202
we will say where id is gonna

83
00:05:36.202 --> 00:05:41.237
be req.params.id.

84
00:05:41.237 --> 00:05:48.875
And then the data, if we go look at
our validator for the product update.

85
00:05:51.490 --> 00:05:54.286
It's just the name,
you can only update the name.

86
00:05:54.286 --> 00:06:01.052
So we'll just say name is req.body.name.

87
00:06:04.149 --> 00:06:04.958
And then we get that.

88
00:06:04.958 --> 00:06:09.866
And then usually on update, it's kind
of you as an API person to send back

89
00:06:09.866 --> 00:06:13.253
the thing that you updated
with the updates on it.

90
00:06:13.253 --> 00:06:17.759
Otherwise the client is probably gonna
make another request back to the server to

91
00:06:17.759 --> 00:06:19.093
get the updated thing.

92
00:06:19.093 --> 00:06:23.433
So just be nice and send back
the updated thing, save them some time.

93
00:06:23.433 --> 00:06:24.550
So that's what we're gonna do.

94
00:06:31.893 --> 00:06:34.354
And I'm pretty sure that
returns the product.

95
00:06:34.354 --> 00:06:36.757
Yeah, now, if you do update many,

96
00:06:36.757 --> 00:06:40.779
you will not get back an array
of all the things you updated.

97
00:06:40.779 --> 00:06:45.186
You'll get back an object describing
all the operations you did.

98
00:06:45.186 --> 00:06:49.032
And you have to make a query to get
them all, but if you updat one,

99
00:06:49.032 --> 00:06:51.896
you'll get back the thing you updated,
okay?

100
00:06:51.896 --> 00:06:55.672
And then last one is gonna be delete,
the simplest one.

101
00:06:55.672 --> 00:06:59.253
So delete a product,

102
00:07:02.267 --> 00:07:06.876
Or the req, res, Async,

103
00:07:08.270 --> 00:07:13.413
And const deleted = await

104
00:07:13.413 --> 00:07:19.265
prisma.product.delete.

105
00:07:19.265 --> 00:07:23.791
Delete kind of works the same way as like
update where you'll get back the thing you

106
00:07:23.791 --> 00:07:24.388
deleted.

107
00:07:24.388 --> 00:07:25.775
But if you do delete many,

108
00:07:25.775 --> 00:07:29.126
you'll just get back information
of how many things deleted.

109
00:07:29.126 --> 00:07:32.344
So we're gonna delete where,

110
00:07:35.678 --> 00:07:40.253
Id is req.params.id.

111
00:07:40.253 --> 00:07:44.377
I just remembered something, we just
fell into security flaw in the last one.

112
00:07:44.377 --> 00:07:50.584
[LAUGH] Because we are just trusting
that this is the ID that you wanted.

113
00:07:50.584 --> 00:07:56.376
Okay, well, I found your product ID,
now I'm about to delete it, right?

114
00:07:56.376 --> 00:07:57.400
How do I stop that, right?

115
00:07:57.400 --> 00:08:05.854
So you also have to do the combination
of belongsToId of req.user.id.

116
00:08:08.346 --> 00:08:15.186
BelongsToId is not assignable to type

117
00:08:15.186 --> 00:08:21.041
where belongs, ToId.

118
00:08:21.041 --> 00:08:22.715
Yeah, it's definitely there.

119
00:08:26.689 --> 00:08:29.055
I don't know why TypeScript
doesn't like me doing that, but

120
00:08:29.055 --> 00:08:31.388
I'm gonna leave it anyway cuz
I'm pretty sure it's there.

121
00:08:31.388 --> 00:08:37.708
So req.user.id, because yeah,
without this, what's gonna happen is,

122
00:08:37.708 --> 00:08:43.363
hey, you can auto delete whatever
ID you put here and it'll be gone.

123
00:08:43.363 --> 00:08:47.430
So you definitely don't want that,
there we go.

124
00:08:47.430 --> 00:08:50.675
I don't know why that thing doesn't
like me having anything here.

125
00:08:52.253 --> 00:08:54.892
Maybe wants me to manually find
it myself and then delete it.

126
00:08:54.892 --> 00:09:00.082
But I'm not doing that
product were unique,

127
00:09:00.082 --> 00:09:04.901
yeah, it's going back to the index point.

128
00:09:04.901 --> 00:09:08.999
Delete is basically a find unique.

129
00:09:08.999 --> 00:09:11.003
And we don't have an index for
this combination.

130
00:09:11.003 --> 00:09:12.807
So it's like you can't do that.

131
00:09:12.807 --> 00:09:15.003
So this is why you would
have to index this.

132
00:09:15.003 --> 00:09:20.269
So we'd have to go back and
index this run another migration,

133
00:09:20.269 --> 00:09:26.664
regenerate the client and/or to find
ourselves first and then delete it.

134
00:09:26.664 --> 00:09:31.525
But just leave it like this,
yeah, your app's gonna be a wild,

135
00:09:31.525 --> 00:09:35.412
wild west,
people just screwing with each other.

136
00:09:35.412 --> 00:09:38.562
So we can go back and add the index.

137
00:09:38.562 --> 00:09:41.419
So I'm just gonna leave this here for
now and then we'll add the index for it.

138
00:09:44.028 --> 00:09:45.397
Okay, so then we have to delete it.

139
00:09:45.397 --> 00:09:52.230
I'm just gonna say,
res.json{(data: deleted)}.

140
00:09:57.932 --> 00:10:00.853
And the same thing is true for the update,

141
00:10:00.853 --> 00:10:04.203
we would have to add
the belongsTo here as well.

142
00:10:04.203 --> 00:10:06.493
Otherwise you could update anybody and

143
00:10:06.493 --> 00:10:09.968
we're gonna get the same issue
because this is not unique.

144
00:10:09.968 --> 00:10:11.047
We gotta update that index.

145
00:10:18.196 --> 00:10:20.840
Okay, so I'm just gonna go do
that right quick for the index.

146
00:10:20.840 --> 00:10:27.216
I think instead of doing that
I can say unique like that.

147
00:10:30.479 --> 00:10:32.595
So now that's unique.

148
00:10:32.595 --> 00:10:36.126
Id, and a belongsToId.

149
00:10:40.343 --> 00:10:42.459
But we have to tell the database about it.

150
00:10:42.459 --> 00:10:47.621
So in order to do that,
I gotta go back into the terminal.

151
00:10:47.621 --> 00:10:53.563
And I have to run a migration so

152
00:10:53.563 --> 00:11:00.231
I'd say mpx prisma migrate dev.

153
00:11:00.231 --> 00:11:04.785
And I'm not even gonna give it a name,
so we'll just run it.

154
00:11:04.785 --> 00:11:06.380
It'll just come up with a name by itself.

155
00:11:09.377 --> 00:11:12.801
So this happens a lot faster locally but
we have a host dv, so

156
00:11:12.801 --> 00:11:14.251
this will take a minute.

157
00:11:14.251 --> 00:11:17.506
Yeah, every time you make a change,
especially like indexes or

158
00:11:17.506 --> 00:11:21.017
anything unique or anything like that,
you have to run a migration.

159
00:11:21.017 --> 00:11:24.571
Some changes, and you can see right
here is saying a unique constraint,

160
00:11:24.571 --> 00:11:27.902
covering the columns ID belongs to
the table product will be added.

161
00:11:27.902 --> 00:11:30.984
If there are existing duplicate values,
this will fail.

162
00:11:30.984 --> 00:11:35.475
So this just tells you the database just
assumed because I didn't put a unique

163
00:11:35.475 --> 00:11:38.807
index on it that I could
possibly have duplicate values.

164
00:11:38.807 --> 00:11:43.339
Even though we wouldn't,
because all IDs are unique and stuff.

165
00:11:43.339 --> 00:11:44.999
So that wouldn't have happened.

166
00:11:44.999 --> 00:11:49.004
But I'm gonna say yes, it's asking for
a name, enter, I want write one.

167
00:11:50.871 --> 00:11:53.314
Once this is successful,
it'll regenerate the clients.

168
00:11:53.314 --> 00:11:58.089
And then a client should not scream
at us with TypeScript anymore because

169
00:11:58.089 --> 00:12:00.212
those things should be unique.

170
00:12:01.861 --> 00:12:03.159
So let's see.

171
00:12:08.197 --> 00:12:13.378
And we close it and come back maybe.

172
00:12:13.378 --> 00:12:16.192
Yeah, it's still screaming at us,
let's see.

173
00:12:17.269 --> 00:12:21.953
You have to write it in
this special index anyway.

174
00:12:21.953 --> 00:12:25.418
So this is a compound index or
joint index.

175
00:12:25.418 --> 00:12:33.078
So it's basically saying we
have a index between the id and

176
00:12:33.078 --> 00:12:37.934
belongsToId, it's a joint index.

177
00:12:37.934 --> 00:12:42.774
Yeah, and in fact, I think if you have
that, you don't even need the ID field,

178
00:12:42.774 --> 00:12:47.638
you can just say Id belongs to and,
I don't know if it's an array, let's see.

179
00:12:47.638 --> 00:12:55.489
I think it'd be like req.params.id and
then req.

180
00:12:59.338 --> 00:13:01.068
User.id.

181
00:13:01.068 --> 00:13:01.966
Now, it's not an array.

182
00:13:01.966 --> 00:13:05.665
Do you have to like add them together?

183
00:13:05.665 --> 00:13:07.168
Let's look that up.

