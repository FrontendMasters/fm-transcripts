WEBVTT

1
00:00:00.000 --> 00:00:04.111
[MUSIC]

2
00:00:04.111 --> 00:00:06.320
&gt;&gt; Mike North: Without further ado,
let's jump in.

3
00:00:06.320 --> 00:00:09.380
So, Ember's designed for ambitious apps.

4
00:00:09.380 --> 00:00:11.684
If you go to their website,
you'll see this is their tagline.

5
00:00:12.760 --> 00:00:15.900
And I wanna elaborate on what that means.

6
00:00:15.900 --> 00:00:19.250
And part of understanding that is
understanding where Ember came from.

7
00:00:19.250 --> 00:00:22.770
So one of the first two
commits to the framework

8
00:00:23.980 --> 00:00:26.290
was the source code of another framework.

9
00:00:26.290 --> 00:00:27.520
And that is SproutCore 2.0.

10
00:00:28.590 --> 00:00:34.640
SproutCore was built at Apple, and
later spun off into another company.

11
00:00:34.640 --> 00:00:38.510
But it's what Apple used for
MobileMe and iCloud.

12
00:00:38.510 --> 00:00:42.779
And, in fact, if you go to icloud.com
today, and look at the source code,

13
00:00:42.779 --> 00:00:45.271
you will see it is still SproutCore 2.0.

14
00:00:45.271 --> 00:00:49.377
And one thing that's notable about
these applications if you look at them,

15
00:00:49.377 --> 00:00:53.818
it's a very, very rich experience, and
there's a lot of functionality there.

16
00:00:53.818 --> 00:00:56.671
It's a lot of complexity to manage.

17
00:00:56.671 --> 00:01:03.204
And it's important to understand that
these are Ember's roots, and as a result,

18
00:01:03.204 --> 00:01:09.570
you're not gonna find that your app is
becoming too complex for Ember to handle.

19
00:01:09.570 --> 00:01:13.050
It's designed to make
managing complexity easy.

20
00:01:13.050 --> 00:01:17.971
The abstractions that you deal with in the
Hello World app, the patterns you follow,

21
00:01:17.971 --> 00:01:21.950
will scale up as your app gets bigger,
as you add more to it,

22
00:01:21.950 --> 00:01:25.562
as more users start coming in,
as you have to customize it more.

23
00:01:25.562 --> 00:01:31.790
Everything holds up because it was
designed for the complicated case,

24
00:01:31.790 --> 00:01:35.600
and then we make sure that the simple
case is not too difficult.

25
00:01:35.600 --> 00:01:40.770
And when picking a framework, at least
from my point of view, I care about that.

26
00:01:40.770 --> 00:01:43.950
I would rather build something
that is optimized for

27
00:01:43.950 --> 00:01:48.790
where I'm going than optimized for how
I'm starting out in the very beginning,

28
00:01:48.790 --> 00:01:51.320
because ultimately that's where
you are going to hit problems.

29
00:01:51.320 --> 00:01:52.840
That's where snags are going
to start biting you.

30
00:01:54.600 --> 00:01:57.460
So Ember's also focused on productivity.

31
00:01:59.300 --> 00:02:01.370
All of these framework communities in it.

32
00:02:01.370 --> 00:02:05.590
Anyone who's building a library or
a piece of software of any kind,

33
00:02:05.590 --> 00:02:08.770
you have to pick what your
most important goals are.

34
00:02:10.140 --> 00:02:13.849
And in the case of Ember,
it's not something like performance or

35
00:02:13.849 --> 00:02:16.450
making it as light weight as possible.

36
00:02:16.450 --> 00:02:21.200
The focus is on making sure that
developers can get off the ground and

37
00:02:21.200 --> 00:02:26.100
move fast and
leverage other people's code effectively.

38
00:02:26.100 --> 00:02:28.670
If you want to think about other

39
00:02:28.670 --> 00:02:33.320
web technologies that have
a similar alignment, Rails.

40
00:02:33.320 --> 00:02:35.180
Very similar alignment.

41
00:02:35.180 --> 00:02:39.330
And the idea is developers are expensive.

42
00:02:39.330 --> 00:02:43.660
Leverage their time more effectively and
you're gonna have a good experience.

43
00:02:46.360 --> 00:02:51.125
Another aspect of Ember's
focus on productivity is

44
00:02:51.125 --> 00:02:54.770
its convention over configuration nature.

45
00:02:54.770 --> 00:02:59.510
And what this means is if you've worked
on one Ember app you can shift and

46
00:02:59.510 --> 00:03:02.580
take a look at someone
else's code in their app.

47
00:03:02.580 --> 00:03:04.380
And within a couple minutes,

48
00:03:04.380 --> 00:03:08.690
you're gonna know where everything is,
how to diagnose a problem.

49
00:03:08.690 --> 00:03:11.440
The structure's very much the same,
the idioms are the same.

50
00:03:12.740 --> 00:03:19.437
As opposed to if you use a stitched
together jQuery and Flatiron Director,

51
00:03:19.437 --> 00:03:24.870
and picking micro libraries and
assembling them together.

52
00:03:24.870 --> 00:03:25.680
Everything is custom.

53
00:03:26.790 --> 00:03:29.730
You may be used to Grunt and
they're using Gulp and you may not know

54
00:03:29.730 --> 00:03:33.970
how their deployment process works and
it takes a while to get spun up.

55
00:03:33.970 --> 00:03:37.510
The idea here is everyone
should be on the same page.

56
00:03:37.510 --> 00:03:42.930
Let's not make those individual
little decisions on a per app basis.

57
00:03:42.930 --> 00:03:45.480
Let's reduce the number of decisions and

58
00:03:45.480 --> 00:03:51.290
make the task of building an app
simple without sacrificing capability.

59
00:03:51.290 --> 00:03:56.120
And so you sort of have patterns and you
have a happy path that you can go down.

60
00:03:56.120 --> 00:04:00.718
And if you can stay aligned with the happy
path, you have to write way less code and

61
00:04:00.718 --> 00:04:02.799
things kind of just work out of the box.

62
00:04:05.570 --> 00:04:08.200
So Ember's also aligned
with web standards.

63
00:04:12.280 --> 00:04:13.982
Why is this important?

64
00:04:13.982 --> 00:04:16.787
So we're writing rich applications for

65
00:04:16.787 --> 00:04:20.230
what essentially is
still a document viewer.

66
00:04:20.230 --> 00:04:21.390
That's what the browser is.

67
00:04:21.390 --> 00:04:23.320
That's our programming environment.

68
00:04:23.320 --> 00:04:28.730
And if you compare that to writing
an app for iOS or Android as a platform,

69
00:04:28.730 --> 00:04:34.430
the primitives we have to work with
are divs and functions and objects.

70
00:04:34.430 --> 00:04:38.680
They're not map widget and
navbar and icon.

71
00:04:39.810 --> 00:04:42.520
We use frameworks to bridge that gap

72
00:04:42.520 --> 00:04:46.200
to give ourselves a reasonable
platform to build on top of.

73
00:04:46.200 --> 00:04:49.150
And at the same time,
the browser's getting better.

74
00:04:49.150 --> 00:04:53.040
New JavaScript language
features were officially

75
00:04:54.180 --> 00:04:56.770
adopted as the new language
standard this year.

76
00:04:56.770 --> 00:04:58.300
The browser's getting better.

77
00:04:58.300 --> 00:04:59.470
The language is getting better.

78
00:04:59.470 --> 00:05:03.960
And the hope is that if we look
at these frameworks as shims,

79
00:05:03.960 --> 00:05:06.730
you wanna have alignment
with these web standards.

80
00:05:06.730 --> 00:05:12.730
So eventually, as native promises
become way more performant than native

81
00:05:12.730 --> 00:05:19.290
JavaScript promise libraries, you want to
take out that part of the shim, and then

82
00:05:19.290 --> 00:05:23.260
rest neatly on the native functionality,
and everything should just work.

83
00:05:23.260 --> 00:05:25.870
You don't want to have
to rethink everything.

84
00:05:25.870 --> 00:05:27.690
So that's why it's important to me.

85
00:05:27.690 --> 00:05:33.020
In addition, it helps interoperability
between different apps.

86
00:05:33.020 --> 00:05:37.792
So if we're all on board with,
this is the way a promise works,

87
00:05:37.792 --> 00:05:42.565
that a library that has to use
promises can be used in Angular and

88
00:05:42.565 --> 00:05:47.338
Ember and React and
wherever you need to use it, because we've

89
00:05:47.338 --> 00:05:52.322
adopted this singular idea of how
this problem should be solved.

90
00:05:52.322 --> 00:05:55.908
Ember aims to be a complete solution, and

91
00:05:55.908 --> 00:05:59.810
I will compare Ember to
a library like React.

92
00:05:59.810 --> 00:06:06.930
So React is a great view layer, it's
great for keeping data and DOM in sync.

93
00:06:06.930 --> 00:06:11.800
But if you look at ten
different React apps at random,

94
00:06:11.800 --> 00:06:13.380
they are all very different.

95
00:06:13.380 --> 00:06:16.340
They all may have
different build pipelines,

96
00:06:16.340 --> 00:06:18.490
they may have their code
structured differently.

97
00:06:19.840 --> 00:06:23.796
And as a result, you have to have a lot of
knowledge of how everything fits together.

98
00:06:23.796 --> 00:06:27.190
It's the developer's job to make sure they

99
00:06:27.190 --> 00:06:30.890
take this island of excellence
that Facebook has created, and

100
00:06:32.490 --> 00:06:37.750
get a complete cohesive single
page app setup working.

101
00:06:37.750 --> 00:06:43.190
And the idea with Ember is that we focus
on not only the framework itself, not only

102
00:06:43.190 --> 00:06:48.740
the library that you use to persist data
to an API and to read data from the API.

103
00:06:48.740 --> 00:06:53.880
But the build tools, even the process
of deploying, we wanna have a good

104
00:06:53.880 --> 00:07:00.560
story around that, so that this happy
path is a comprehensive happy path.

105
00:07:00.560 --> 00:07:05.762
From how you write your code to
which transpiler you're using,

106
00:07:05.762 --> 00:07:11.560
to how things are minified, and
even now, deployment and animation.

107
00:07:11.560 --> 00:07:14.626
These all have an advised approach, and

108
00:07:14.626 --> 00:07:21.100
as a result you can rely on things working
together very nicely out of the box.

109
00:07:21.100 --> 00:07:24.510
And this is a big problem to solve,
this is a huge problem.

110
00:07:24.510 --> 00:07:29.770
And you're gonna see today that even
as we start touching on these areas and

111
00:07:29.770 --> 00:07:34.000
going deep, there's so much to know,
and there are things we're gonna not

112
00:07:34.000 --> 00:07:38.390
cover them, because you can't do it in
two days, or four days, or six days.

113
00:07:38.390 --> 00:07:45.730
But it's a big problem to solve, and
the framework is a moving target.

114
00:07:45.730 --> 00:07:49.540
It keeps growing, it keeps improving,
every six weeks there's a new release.

115
00:07:49.540 --> 00:07:53.150
And usually they're a significant
performance improvement, or

116
00:07:53.150 --> 00:07:54.339
new features coming out.

117
00:07:55.720 --> 00:07:59.950
The list of things we want
to do to the framework is

118
00:07:59.950 --> 00:08:03.510
steadily outpacing
the ability to get them done.

119
00:08:03.510 --> 00:08:04.390
And this is a good thing.

120
00:08:04.390 --> 00:08:05.840
This means that there is adoption, and

121
00:08:05.840 --> 00:08:11.350
that there are new use cases
being brought to our attention.

122
00:08:11.350 --> 00:08:13.530
And so it's constantly growing and

123
00:08:13.530 --> 00:08:17.080
improving, and you just need to be aware
of that because I don't think Ember's

124
00:08:17.080 --> 00:08:21.290
going to be done at any
point in the near future.

125
00:08:22.630 --> 00:08:25.670
It's gonna keep trying to
solve the problem better and

126
00:08:25.670 --> 00:08:29.495
evolving to meet today's needs and
tomorrow's.

