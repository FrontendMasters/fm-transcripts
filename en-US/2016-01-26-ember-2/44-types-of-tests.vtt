WEBVTT

1
00:00:00.000 --> 00:00:03.833
[MUSIC]

2
00:00:03.833 --> 00:00:07.863
&gt;&gt; Mike North: Unit tests just like all
tests are automatically generated by

3
00:00:07.863 --> 00:00:09.770
ember-cli in a very basic way.

4
00:00:10.870 --> 00:00:15.300
They test in isolation and that is
important because a lot of the things that

5
00:00:15.300 --> 00:00:20.590
we've talked about that are globally
available like components I've said.

6
00:00:20.590 --> 00:00:22.610
If it's in the components folder,

7
00:00:22.610 --> 00:00:26.180
you can use it in any template,
not true in the unit test.

8
00:00:26.180 --> 00:00:32.770
Unit test is you start with sort
of an empty context only seated

9
00:00:32.770 --> 00:00:38.060
with the object that you are aiming
to test and then anything else,

10
00:00:38.060 --> 00:00:42.000
there is a needs option when
you're setting up the test module.

11
00:00:42.000 --> 00:00:45.150
Where you can bring in additional
objects that are necessary.

12
00:00:46.830 --> 00:00:50.660
For example if you're unit testing
a model and it relates to another model.

13
00:00:50.660 --> 00:00:53.140
There's like a has many relationship.

14
00:00:53.140 --> 00:00:56.520
You'll need to bring in that other
model so that you can kind of have

15
00:00:56.520 --> 00:01:01.460
a complete meaningful scenario, and

16
00:01:01.460 --> 00:01:05.790
this will also make it clear how
coupled together things start to get.

17
00:01:05.790 --> 00:01:10.590
Because if you have a unit test and
you're needing you know 15 other

18
00:01:10.590 --> 00:01:14.500
things you're not really
writing a unit test any more.

19
00:01:14.500 --> 00:01:19.590
And it may be time to reconsider
shifting towards something else.

20
00:01:19.590 --> 00:01:21.820
These run really, really quickly and

21
00:01:21.820 --> 00:01:27.020
that's why when you find unit
testable chunks of code go for this.

22
00:01:27.020 --> 00:01:30.290
Get a lot of confidence where it
makes sense from unit tests and

23
00:01:31.400 --> 00:01:32.820
leave the acceptance tests and

24
00:01:32.820 --> 00:01:35.730
everything else for the things that
are more difficult like routes.

25
00:01:38.860 --> 00:01:42.850
So component integration tests.

26
00:01:42.850 --> 00:01:49.283
The important thing to realize here is
what you are using to set up a scenario.

27
00:01:49.283 --> 00:01:53.317
And I can actually show you
what one looks like what

28
00:01:53.317 --> 00:01:56.309
are the other generated test cases.

29
00:01:56.309 --> 00:02:01.150
GithubOrg test.

30
00:02:01.150 --> 00:02:04.340
And this was a major major improvement.

31
00:02:04.340 --> 00:02:10.283
It used to be very difficult to set up,
like some you know handle bars snip it and

32
00:02:10.283 --> 00:02:16.070
to build a test case around that now,
you're actually just render in line.

33
00:02:17.540 --> 00:02:22.668
As long as you put hbs before it,
it'll get treated

34
00:02:22.668 --> 00:02:27.798
as a handlebars template and
not just as a string and

35
00:02:27.798 --> 00:02:32.730
you render something and
then, you can test it.

36
00:02:32.730 --> 00:02:35.370
And you can get and set and
that's the equivalent of getting and

37
00:02:35.370 --> 00:02:36.690
setting on the component itself.

38
00:02:36.690 --> 00:02:37.470
So, you can really.

39
00:02:38.660 --> 00:02:43.090
You know set the component the JavaScript
piece of the component up directly.

40
00:02:43.090 --> 00:02:46.610
You can set up a scenario in terms
of I'm going to pass at name.

41
00:02:46.610 --> 00:02:48.130
I'm going to pass at this.

42
00:02:50.200 --> 00:02:56.610
So its a very powerful tool in
terms of being able to you know

43
00:02:56.610 --> 00:03:01.910
get a variety of scenarios validated and
you can see up

44
00:03:01.910 --> 00:03:07.190
here even they're giving you instructions
on you know how do you setup an action?

45
00:03:07.190 --> 00:03:10.290
You just do this.on myAction so
if we were, for

46
00:03:10.290 --> 00:03:14.950
example, and this is a preview of
what we're gonna work on in a second.

47
00:03:16.010 --> 00:03:20.030
We have an action that comes out of our
component whenever favoriting is tiled.

48
00:03:20.030 --> 00:03:21.570
And this will let us validate that.

49
00:03:21.570 --> 00:03:24.740
In fact, when you click it,
the action is fired.

50
00:03:26.280 --> 00:03:31.340
But this is a very easy way of doing
that and It's come a tremendously long

51
00:03:31.340 --> 00:03:37.310
way compared to the hoops you
used to have to jump through.

52
00:03:37.310 --> 00:03:40.770
So finally, Acceptance Tests,
you're testing the app as a whole.

53
00:03:40.770 --> 00:03:41.690
It's slower.

54
00:03:42.750 --> 00:03:44.644
It will attempt to make API requests,

55
00:03:44.644 --> 00:03:47.496
because it's just programmatically
driving your app.

56
00:03:47.496 --> 00:03:52.178
So, if you are not Interested in actually
making API requests potentially,

57
00:03:52.178 --> 00:03:54.482
if you have an app that changes data and

58
00:03:54.482 --> 00:03:59.180
you're gonna end up creating a bunch
of test records and polluting your API.

59
00:03:59.180 --> 00:04:07.460
And polluting your data base basically
you may want to use something like

60
00:04:07.460 --> 00:04:12.650
Pretender or Ember CLI Mirage,
both of which are used to mock API.

61
00:04:14.450 --> 00:04:18.240
And in addition to that,
you cannot use those.

62
00:04:19.630 --> 00:04:24.170
But, just be aware that that is sort of a
conceptually a different kind of testing,

63
00:04:24.170 --> 00:04:28.350
where you're you're really making
sure the contract between the API and

64
00:04:28.350 --> 00:04:30.520
the URL are intact.

65
00:04:30.520 --> 00:04:34.170
You're really hitting
an API getting real data.

66
00:04:34.170 --> 00:04:36.340
And in that case you're gonna
write your test differently and

67
00:04:36.340 --> 00:04:41.920
you're probably not going to be deleting
things and creating things quite so much.

68
00:04:45.020 --> 00:04:49.500
So in acceptance tests and this is where a
lot of complexity exist because in theory,

69
00:04:49.500 --> 00:04:53.840
if you have a product owner and they say,
your thing needs to be able to do this and

70
00:04:53.840 --> 00:04:54.950
this, and this, and this.

71
00:04:56.330 --> 00:05:02.489
You may be building an acceptance test
to represent those product requirements.

72
00:05:03.990 --> 00:05:08.800
So these are the tests that get big and
a little bit complicated.

73
00:05:08.800 --> 00:05:15.430
So a lot of helper functions to ease
that pain, we've got some synchronous

74
00:05:15.430 --> 00:05:20.410
helpers that are really about reading
the current situation reading state.

75
00:05:20.410 --> 00:05:22.520
As I said before when we're running tests,

76
00:05:22.520 --> 00:05:28.200
especially when we're running in
the browser your app is running.

77
00:05:28.200 --> 00:05:31.710
It's just rendering the whole
Ember app into a div.

78
00:05:31.710 --> 00:05:35.740
Be aware of this if you use
the global jQuery selector.

79
00:05:35.740 --> 00:05:39.600
You may pick up parts of the test
runner if you're not careful, so

80
00:05:39.600 --> 00:05:42.824
that's what this find
synchronous helper is for.

81
00:05:42.824 --> 00:05:47.210
And make sure that you're looking
up elements only within your ember

82
00:05:47.210 --> 00:05:52.160
application and you're not gonna grab
the check boxes that turn on and

83
00:05:52.160 --> 00:05:56.270
off different test modules and
things like that.

84
00:05:56.270 --> 00:05:58.270
Asynchronous test helpers
are really interesting.

85
00:05:58.270 --> 00:06:02.650
So, these are for
things that may trigger a transition or

86
00:06:02.650 --> 00:06:06.330
other sorts of asynchronous behavior.

87
00:06:06.330 --> 00:06:10.560
What's happening under the hood here
is that each of these is essentially

88
00:06:10.560 --> 00:06:14.940
returning a promise and accumulating
promises in an array behind the scene.

89
00:06:15.960 --> 00:06:20.700
And basically you're
chaining promises together

90
00:06:21.950 --> 00:06:25.160
to run things asynchronously.

91
00:06:25.160 --> 00:06:29.030
So you can write synchronous
looking code but

92
00:06:29.030 --> 00:06:33.990
really you can deal with asynchrony
within the pieces of this code.

93
00:06:33.990 --> 00:06:38.750
So, if we look at this, visit,

94
00:06:38.750 --> 00:06:43.110
andThen, and
click are all asynchronous test helpers.

95
00:06:43.110 --> 00:06:48.220
So, we start by visiting a URL, and
we know that the router's gonna deal with

96
00:06:48.220 --> 00:06:53.200
the transition there, and potentially
you're making a real API request.

97
00:06:53.200 --> 00:06:55.460
And we have this promise aware hooks.

98
00:06:55.460 --> 00:06:57.540
We have to wait until that resolves.

99
00:06:57.540 --> 00:07:00.660
So, this is going to add
a promise to the array.

100
00:07:00.660 --> 00:07:02.700
When you define visit.

101
00:07:02.700 --> 00:07:03.710
Right?

102
00:07:03.710 --> 00:07:06.900
And then we're immediately going
to proceed to the next step.

103
00:07:06.900 --> 00:07:08.950
And we're going to define the next step,
and

104
00:07:08.950 --> 00:07:11.570
then we're going to define the next step,
and we're going to define the next step.

105
00:07:11.570 --> 00:07:16.520
And so now we have this chain of promises,
so this code will actually evaluate

106
00:07:16.520 --> 00:07:21.200
really quickly, because you're
just sort of scheduling work.

107
00:07:21.200 --> 00:07:26.131
And then when visit is complete
the callback to end then will be run and

108
00:07:26.131 --> 00:07:31.030
when that's complete the click will be run
and when that's complete, you know you

109
00:07:31.030 --> 00:07:37.790
sort of just go down the line so that
everything happens in the proper order.

110
00:07:37.790 --> 00:07:42.140
And you can actually write your
own asynchronous test helpers.

111
00:07:42.140 --> 00:07:47.700
For example, Liquid Fire which is
a popular way to animate transitions and

112
00:07:47.700 --> 00:07:48.920
other things in ember.

113
00:07:49.920 --> 00:07:51.650
The animations take time.

114
00:07:51.650 --> 00:07:55.390
They actually add time to
the transitioning between two states in

115
00:07:55.390 --> 00:07:57.030
an application potentially.

116
00:07:57.030 --> 00:08:02.730
If your API call comes back right away but
you still say I want a 0.5

117
00:08:02.730 --> 00:08:08.130
second transition, you know that's a new
time that has to be taken into account.

118
00:08:08.130 --> 00:08:15.850
And so it communicates with the testing
tooling and says here's a new promise and

119
00:08:15.850 --> 00:08:20.860
wait until that's done before we say
good to go, proceed to the next step.

120
00:08:23.300 --> 00:08:24.540
Everybody clear on this stuff?

121
00:08:25.670 --> 00:08:30.750
Now, one thing you have to be careful of,
so as I mentioned, this is basically,

122
00:08:30.750 --> 00:08:35.260
this code here is like creating
four promises in a row.

123
00:08:35.260 --> 00:08:39.340
If we had some synchronous code in
between a couple of these things,

124
00:08:39.340 --> 00:08:43.040
we have to remember that that will
be evaluated immediately, and so

125
00:08:43.040 --> 00:08:45.730
if we had like asynchronous click.

126
00:08:45.730 --> 00:08:51.900
If we just did dollar sign, dot selector
dot click using the jQuery click function.

127
00:08:54.060 --> 00:08:56.370
That will be evaluated right away.

128
00:08:56.370 --> 00:08:59.800
So you don't want to mix
a sync code with sync code.

129
00:08:59.800 --> 00:09:06.790
What you wanna do is use this andThen
helper which gives you a place to put

130
00:09:06.790 --> 00:09:12.670
sent code in the correct spot so
that it's part of this promise chain.

131
00:09:12.670 --> 00:09:16.679
But everything at the top level of
an acceptance test should really be one of

132
00:09:16.679 --> 00:09:18.150
these async test helpers.

133
00:09:22.650 --> 00:09:24.690
&gt;&gt; Mike North: So Mocking API Responses,

134
00:09:24.690 --> 00:09:28.510
pretender is sort of
a lower level library.

135
00:09:28.510 --> 00:09:32.685
Though the way it works and it's by
the way completely independent of ember,

136
00:09:32.685 --> 00:09:39.930
used heavily in ember but
it is very generic.

137
00:09:39.930 --> 00:09:44.815
What it does essentially is it
hijacks XML HTTP request and

138
00:09:44.815 --> 00:09:49.900
puts something else in its place
to intercept attempted XHR.

139
00:09:50.900 --> 00:09:56.700
And you set up a mock server before
your tests start running and

140
00:09:56.700 --> 00:10:01.610
you say these are the URLs that I expect

141
00:10:01.610 --> 00:10:06.760
request to be sent out to you and
here is the way to handle those requests.

142
00:10:06.760 --> 00:10:09.620
And then when you start running
it knows what to do and

143
00:10:09.620 --> 00:10:13.570
it will in fact raise errors
if it sees traffic go out,

144
00:10:13.570 --> 00:10:18.460
if it sees attempts to make
requests that are not on the list.

145
00:10:18.460 --> 00:10:23.920
You can define pass throughs which let
you allow certain things to go through.

146
00:10:23.920 --> 00:10:27.530
But a very useful tool for mocking XHR.

147
00:10:27.530 --> 00:10:32.770
Mirage actually builds on top of Pretender
and gives you just some additional sugar,

148
00:10:32.770 --> 00:10:38.780
the ability to have sort of an in memory
database of records that you can return.

149
00:10:38.780 --> 00:10:42.640
And particularly if you're
operating at a high level and

150
00:10:42.640 --> 00:10:48.060
you're just making standard
JSON RESTful API requests.

151
00:10:48.060 --> 00:10:50.691
Mirage is probably a good option as well.

