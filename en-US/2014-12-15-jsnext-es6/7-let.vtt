WEBVTT

1
00:00:00.000 --> 00:00:03.851
[MUSIC]

2
00:00:03.851 --> 00:00:06.248
&gt;&gt; Aaron Frost: So we've got LET
definitions, we've got LET with looping,

3
00:00:06.248 --> 00:00:08.410
those are the two pieces
we're gonna cover.

4
00:00:08.410 --> 00:00:12.630
There used to be three pieces of LET, or
sorry four, but they cut two of them out.

5
00:00:12.630 --> 00:00:16.130
So there used to be LET definitions and

6
00:00:16.130 --> 00:00:20.350
they cut out LET expressions and
LET statements, okay?

7
00:00:20.350 --> 00:00:22.870
And if you guys wanna come talk to me
on the break about what those were,

8
00:00:22.870 --> 00:00:27.560
those were invented by Mozilla,
I think, and with block functions,

9
00:00:27.560 --> 00:00:28.450
we don't need them anymore.

10
00:00:28.450 --> 00:00:31.690
Okay, so let's talk about LET definitions,
and then LET with looping.

11
00:00:31.690 --> 00:00:36.360
So, LET definitions,
this is LET in its most

12
00:00:36.360 --> 00:00:40.460
basic form, just like that, okay.

13
00:00:41.590 --> 00:00:47.469
So, instead of var you can use LET, so
you literally use it just like you do LET.

14
00:00:47.469 --> 00:00:48.820
There's not a lot of differences.

15
00:00:48.820 --> 00:00:51.880
You can reassign it just like you can var.

16
00:00:51.880 --> 00:00:56.400
So, I can declare foo set it to 2 and
I can say foo = 3, we're good to go.

17
00:00:56.400 --> 00:00:58.740
So, it's not constant.

18
00:00:58.740 --> 00:01:04.490
It's just like you use var,
it's just a different word, okay.

19
00:01:06.630 --> 00:01:10.720
And this is also let in
its most basic form.

20
00:01:10.720 --> 00:01:14.390
We've already seen this code, though, the
only thing that changed is the word LET.

21
00:01:15.880 --> 00:01:20.270
Now who thinks they know what's
going to to happen, any ganders?

22
00:01:20.270 --> 00:01:22.116
Error, 2, 3, or undefined, anyone?

23
00:01:22.116 --> 00:01:23.895
No one's willing,

24
00:01:23.895 --> 00:01:28.560
I burnt you all on the first one?
&gt;&gt; Speaker 2: Wouldn't

25
00:01:28.560 --> 00:01:31.360
it actually be NaN?
&gt;&gt; Aaron Frost: NaN?

26
00:01:31.360 --> 00:01:36.110
Undefined plus, it could be NaN, yeah,
it's gonna throw an error, though.

27
00:01:36.110 --> 00:01:42.130
It's gonna say bar not defined cuz,
inside the lexical scope on the if,

28
00:01:42.130 --> 00:01:46.200
it actually blocked your LET inside,
your bar inside there.

29
00:01:46.200 --> 00:01:49.550
So, the bar variable is now trapped
inside your if statement, and

30
00:01:49.550 --> 00:01:52.880
you can't access it outside of that scope.

31
00:01:52.880 --> 00:01:55.310
This is what we thought it was gonna do,
right?

32
00:01:55.310 --> 00:02:00.090
We did this with var and it didn't do what
we thought it was gonna do, remember?

33
00:02:00.090 --> 00:02:04.520
But now now it is going to do what we
think it's going to do so it's nice.

34
00:02:04.520 --> 00:02:07.350
So we have block scoping again.

35
00:02:08.970 --> 00:02:16.096
If you run this code, does anyone know
what they think's going to happen?

36
00:02:16.096 --> 00:02:19.260
Let a=0, a=2, what's this going to log and
what's this going to log?

37
00:02:21.380 --> 00:02:24.489
Anyone know?
Yeah, they're gonna log what you thought

38
00:02:24.489 --> 00:02:29.990
they were gonna log, it's not a tricky
anymore, I'm past the tricky stuff.

39
00:02:29.990 --> 00:02:31.870
That was the very wise thing.

40
00:02:31.870 --> 00:02:36.200
It runs like you think
it's going to run now.

41
00:02:36.200 --> 00:02:40.500
So you're like yeah,
this is this what I always wanted right.

42
00:02:40.500 --> 00:02:43.847
He didn't know you needed it to today but
yeah this is what you always wanted.

43
00:02:43.847 --> 00:02:47.670
This is what you thought you had all
along, so you don't really miss it.

44
00:02:47.670 --> 00:02:50.110
So this is actually gonna
throw an error though.

45
00:02:50.110 --> 00:02:51.966
So if you say let a = 0 and

46
00:02:51.966 --> 00:02:57.560
then you you make another a with with
a let declaration, he's gonna die.

47
00:02:57.560 --> 00:03:01.616
You're gonna get an error.
&gt;&gt; Speaker 3: [INAUDIBLE] The same is true

48
00:03:01.616 --> 00:03:03.693
for var if you use string.

49
00:03:03.693 --> 00:03:05.742
[INAUDIBLE]
&gt;&gt; Aaron Frost: Yes, yeah,

50
00:03:05.742 --> 00:03:09.710
you can't redefine, you can't double
declare those, you can only use it once.

51
00:03:09.710 --> 00:03:14.870
Did someone say something.

52
00:03:14.870 --> 00:03:20.090
So yeah, so without you strict you
can do this with our so you know you

53
00:03:20.090 --> 00:03:23.893
don't ever do that, but you could do that,
like it wouldn't it wouldn't totally die.

54
00:03:23.893 --> 00:03:28.128
But with let you're going
to get a SyntaxError, and

55
00:03:28.128 --> 00:03:32.362
even if you declare of var
then you do a new let with c,

56
00:03:32.362 --> 00:03:37.410
you can get the same thing,
say Variable c already exists.

57
00:03:37.410 --> 00:03:42.710
So, yeah and
these scopes exist across the board.

58
00:03:42.710 --> 00:03:47.090
So b is going to be trapped inside here.

59
00:03:47.090 --> 00:03:49.640
This let c is going to be trapped
inside this switch statement.

60
00:03:50.640 --> 00:03:52.880
Let d is going to be trapped
inside that while loop.

61
00:03:52.880 --> 00:03:55.771
So your curly braces are your new scope,

62
00:03:55.771 --> 00:04:00.470
cool.
&gt;&gt; Aaron Frost: Any question about that?

63
00:04:00.470 --> 00:04:02.630
&gt;&gt; Speaker 4: Question, on the chats.

64
00:04:02.630 --> 00:04:07.010
So what if you double declare a let
in the var, if you do var twice,

65
00:04:07.010 --> 00:04:08.770
it just uses the same variable.

66
00:04:08.770 --> 00:04:12.910
What happens with,
either two let's, or a var and

67
00:04:12.910 --> 00:04:14.310
let at the same?
&gt;&gt; [INAUDIBLE]

68
00:04:14.310 --> 00:04:16.810
&gt;&gt; Aaron Frost: I already answered that.

69
00:04:16.810 --> 00:04:19.820
Do you want me to, I'll do it again.
&gt;&gt; Speaker 4: Just show me the slide that-

70
00:04:19.820 --> 00:04:20.810
&gt;&gt; Aaron Frost: This is what happens.

71
00:04:20.810 --> 00:04:21.750
&gt;&gt; Speaker 4: Yeah at the bottom there

72
00:04:21.750 --> 00:04:23.570
it's a-
&gt;&gt; Aaron Frost: If you double LET,

73
00:04:23.570 --> 00:04:24.550
it freaks.

74
00:04:24.550 --> 00:04:27.580
If you declare a var and
then LET, it freaks.

75
00:04:27.580 --> 00:04:31.390
I'm not sure what would happen
if you did LET and then var.

76
00:04:31.390 --> 00:04:33.240
Who cares,

77
00:04:33.240 --> 00:04:36.960
right, you shouldn't do that anyway, so.
&gt;&gt; Speaker 2: Okay,

78
00:04:36.960 --> 00:04:39.980
sorry about that.
&gt;&gt; Speaker 4: There was another,

79
00:04:39.980 --> 00:04:42.700
I don't know if this was a comment or
kind of a question, but

80
00:04:42.700 --> 00:04:45.651
select works everywhere, var works,

81
00:04:45.651 --> 00:04:49.620
and var works everywhere it has worked.

82
00:04:49.620 --> 00:04:51.500
&gt;&gt; Aaron Frost: Yes.
&gt;&gt; Speaker 4: Okay.

83
00:04:51.500 --> 00:04:52.490
&gt;&gt; Aaron Frost: And in all the same ways

84
00:04:52.490 --> 00:04:55.080
that it always has worked.

85
00:04:55.080 --> 00:04:56.059
Yeah, good way to put it.

86
00:04:57.340 --> 00:05:00.520
Okay so we have this thing
called the Temporal Dead Zone.

87
00:05:00.520 --> 00:05:04.580
And you guys know it's some Dungeon and

88
00:05:04.580 --> 00:05:07.690
Dragon Master forgive me
that term up right like

89
00:05:08.740 --> 00:05:13.640
it was not like a normal folk
call them the Temporal Dead Zone.

90
00:05:15.720 --> 00:05:18.540
So, we have this thing called
the Temporal Dead Zone and

91
00:05:18.540 --> 00:05:20.130
I'm going to try my best to explain it.

92
00:05:21.170 --> 00:05:22.653
So, look at this code,

93
00:05:22.653 --> 00:05:27.520
I'm using let a =1 I'm trying to log
it before the let statement happens.

94
00:05:27.520 --> 00:05:29.028
What do you guys think is going to happen?

95
00:05:29.028 --> 00:05:32.396
Error?
&gt;&gt; Speaker 3: Error.

96
00:05:32.396 --> 00:05:34.080
&gt;&gt; Aaron Frost: Error.

97
00:05:34.080 --> 00:05:40.660
Anyone think it's going to log on to find?
&gt;&gt; Speaker 5: [INAUDIBLE],

98
00:05:40.660 --> 00:05:42.286
right?

99
00:05:42.286 --> 00:05:44.566
&gt;&gt; Aaron Frost: So Firefox implementation

100
00:05:44.566 --> 00:05:47.220
currently has got a bug.

101
00:05:47.220 --> 00:05:49.460
This is the reason I'm pointing it out
cuz you guys might get in there and

102
00:05:49.460 --> 00:05:52.650
play around with it and it's gonna work
differently than the way I'm saying.

103
00:05:52.650 --> 00:05:54.140
So I wanted to point this out.

104
00:05:54.140 --> 00:06:00.280
So Firefox is gonna log a zero or
an and undefined here, okay.

105
00:06:01.500 --> 00:06:08.280
But, with the concept of the temporal dead
zone, it should throw an error, okay.

106
00:06:08.280 --> 00:06:13.850
You cannot use it until it's
been declared, officially.

107
00:06:15.230 --> 00:06:18.410
So under the covers though, the reason
that they came up with this crazy concept

108
00:06:18.410 --> 00:06:22.320
called the temporal dead zone is because
they still are going to evaluate it.

109
00:06:22.320 --> 00:06:26.260
When it evaluates this function, when it
evaluates to do something, it's gonna go,

110
00:06:26.260 --> 00:06:28.060
I mean it's gonna evaluate this.

111
00:06:28.060 --> 00:06:30.120
I see what I left there on line two,

112
00:06:31.570 --> 00:06:35.630
I'm actually gonna reserve a spot in
memory for that, but you can't access it.

113
00:06:37.010 --> 00:06:38.230
That's called a temporal dead zone.

114
00:06:38.230 --> 00:06:42.008
You can't access it so you declare it.

115
00:06:42.008 --> 00:06:44.674
Does that makes sense of
what the temporal dead zone

116
00:06:44.674 --> 00:06:45.247
is?
&gt;&gt; Speaker 3: But

117
00:06:45.247 --> 00:06:47.831
what if there was a global a,

118
00:06:47.831 --> 00:06:53.440
what if there's an a in the global scope?
&gt;&gt; Aaron Frost: It should log that a but

119
00:06:53.440 --> 00:06:55.556
there's bugs like in all
the implementations right now.

120
00:06:55.556 --> 00:06:59.720
That is solid question.

121
00:06:59.720 --> 00:07:03.824
And I found that when Alex, so
if you have like an a up at the top and

122
00:07:03.824 --> 00:07:06.333
then you had a function
with an a in it and

123
00:07:06.333 --> 00:07:10.689
you tried to use it before you tried
to log it before it was declared.

124
00:07:10.689 --> 00:07:15.195
It should go up at the top one but all the
implementations right now, just log this

125
00:07:15.195 --> 00:07:19.671
undefined one that you're coming up on.
&gt;&gt; [INAUDIBLE]

126
00:07:19.671 --> 00:07:22.104
&gt;&gt; Aaron Frost: Yes, yeah, well,

127
00:07:22.104 --> 00:07:28.136
they don't respect
the temporal dead zone yeah.

128
00:07:28.136 --> 00:07:33.670
So, yeah, okay so it does kind of hoist
it to reserve space in memory but

129
00:07:33.670 --> 00:07:35.290
you can't access until it's there.

130
00:07:35.290 --> 00:07:38.930
So it would actually,
it should throw a reference error.

131
00:07:38.930 --> 00:07:41.090
If you do this in Firefox it won't,
but it should.

132
00:07:43.050 --> 00:07:44.540
Any questions on LET before I move on?

133
00:07:44.540 --> 00:07:46.960
We're gonna get into looping,
it's similar, but yeah.

134
00:07:46.960 --> 00:07:48.520
Go ahead.
&gt;&gt; Speaker 4: We have a few of them here.

135
00:07:48.520 --> 00:07:50.570
Do you think we should only use LET, or

136
00:07:50.570 --> 00:07:55.540
is var still useful?
&gt;&gt; Aaron Frost: I mean, if you're starting

137
00:07:55.540 --> 00:08:00.340
a new project, I would only, okay, so

138
00:08:00.340 --> 00:08:04.360
if you don't have to support legacy
browsers, a gear that you're

139
00:08:04.360 --> 00:08:09.150
the Sasquatch, the mythical thing that
doesn't have to support legacy, right.

140
00:08:11.080 --> 00:08:13.020
So if you don't have to,
then yeah, use LET.

141
00:08:13.020 --> 00:08:16.180
Or you're a node developer then yeah,
use LET.

142
00:08:16.180 --> 00:08:20.690
I would, because it makes your code
way more predictable, I think.

143
00:08:20.690 --> 00:08:24.700
Like it runs, going back to that
statement, your code has a lot

144
00:08:24.700 --> 00:08:28.570
less to do with the way it looks than
the way it executes when you're using var.

145
00:08:28.570 --> 00:08:32.786
So I would definitely use LET, if you can.
&gt;&gt; Speaker 4: Then, the next two

146
00:08:32.786 --> 00:08:36.570
questions, can you use LET in a for loop?
&gt;&gt; Aaron Frost: That's the next

147
00:08:36.570 --> 00:08:37.412
section.
&gt;&gt; Speaker 4: Okay and

148
00:08:37.412 --> 00:08:40.814
then when can I use this again,
I'm guessing they're asking when is it

149
00:08:40.814 --> 00:08:43.346
available?
&gt;&gt; Aaron Frost: When's it available.

150
00:08:43.346 --> 00:08:46.300
We'll talk about that when
we get to that too, okay?

151
00:08:46.300 --> 00:08:50.210
Okay so
LET with looping it's pretty simple.

152
00:08:50.210 --> 00:08:54.492
So look at this code,
one's gonna log a ten,

153
00:08:54.492 --> 00:08:58.000
one's gonna log a ReferenceError.

154
00:08:58.000 --> 00:08:59.830
So specifically you're looking
at these lines of code.

155
00:09:01.180 --> 00:09:05.847
So, in the first for
loop, I use var, right.

156
00:09:05.847 --> 00:09:11.830
Okay so, that means you say here it
incremented i until i was equal to ten and

157
00:09:12.880 --> 00:09:17.060
when i was equal to ten, it didn't
run this anymore it stopped, right.

158
00:09:18.142 --> 00:09:23.040
So, here it logged 0 through 9 and
then once it was equal to 10, it stopped.

159
00:09:23.040 --> 00:09:26.480
Down here your j, it went,
did the exact same thing,

160
00:09:26.480 --> 00:09:30.740
once j was 10, I'm out,
so, it logged 0 through 9.

161
00:09:30.740 --> 00:09:36.610
But when you get down here, i was still
a thing because the i from the for

162
00:09:36.610 --> 00:09:39.830
loop had been hoisted out, so
you could still reference i.

163
00:09:39.830 --> 00:09:44.576
But over here you're getting
a ReferenceError because using

164
00:09:44.576 --> 00:09:48.872
a let instead of a for
loop is going to scope out here for.

165
00:09:48.872 --> 00:09:50.560
That make sense?

166
00:09:50.560 --> 00:09:54.510
So, it seems that
everything you ever wanted.

167
00:09:54.510 --> 00:09:58.470
So you could have two you could
use i twice, who feels good now?

168
00:10:00.060 --> 00:10:02.970
You can do it, go home, tell your family.

169
00:10:04.480 --> 00:10:07.070
Okay, Steve W is so happy about that, wow.

170
00:10:09.090 --> 00:10:14.610
So yeah,
anyone else want to ask a question before,

171
00:10:14.610 --> 00:10:17.270
because I think I'm pretty much done?

172
00:10:18.870 --> 00:10:22.750
Yeah, also anything inside of the for

173
00:10:22.750 --> 00:10:26.540
loop I think this one without saying is
also locked inside of the loop body, so.

174
00:10:27.680 --> 00:10:31.180
So anyway constant,
anyone ready to move on the constant, and

175
00:10:31.180 --> 00:10:32.470
does anyone has questions.

176
00:10:32.470 --> 00:10:33.850
Yeah.
&gt;&gt; Speaker 4: Two questions here.

177
00:10:33.850 --> 00:10:37.480
I don't know if you did cover one of these
but does LET still behave the same in

178
00:10:37.480 --> 00:10:41.619
respect to closure?
&gt;&gt; Aaron Frost: So if I put it inside but

179
00:10:41.619 --> 00:10:46.307
IAF or something,
like inside an anonymous function?

180
00:10:46.307 --> 00:10:48.580
Yeah yeah totally does.

181
00:10:48.580 --> 00:10:52.868
An anonymous function or an IAF either,
they're just a function, so

182
00:10:52.868 --> 00:10:55.423
it totally functions the exact same way.

183
00:10:55.423 --> 00:10:58.012
And then what's the other question?
&gt;&gt; Speaker 4: The next one is

184
00:10:58.012 --> 00:11:01.174
are variables declared
with let hoisted within

185
00:11:01.174 --> 00:11:01.925
the box?
&gt;&gt; Aaron Frost: So

186
00:11:01.925 --> 00:11:04.650
I talk about that when I talked
about temporal dead zone.

187
00:11:06.720 --> 00:11:14.070
As far as us the developers are concerned,
no, but behind the scenes it is.

188
00:11:14.070 --> 00:11:17.090
Which is why you have
the current funkiness.

189
00:11:17.090 --> 00:11:18.640
Behind the scenes it actually is going,

190
00:11:18.640 --> 00:11:22.240
you have a leg to reserve
a spot in memory for it.

191
00:11:22.240 --> 00:11:22.920
And then but

192
00:11:22.920 --> 00:11:26.940
you can't use it you can't access until
it actually is declared on whatever line.

193
00:11:26.940 --> 00:11:28.690
So it's not if it's declared on line 10,

194
00:11:28.690 --> 00:11:33.260
you can't refer to it until line 10,
otherwise you're gonna get an error.

195
00:11:33.260 --> 00:11:36.720
Today, you can refer to it before you
get to line 10 which is a bug but

196
00:11:36.720 --> 00:11:37.880
you shouldn't be able to do so.

197
00:11:38.900 --> 00:11:41.396
So you're good.
&gt;&gt; Speaker 4: What version,

198
00:11:41.396 --> 00:11:45.367
of nodes supports LET?
&gt;&gt; Aaron Frost: So, if you run node,

199
00:11:45.367 --> 00:11:48.497
I think node-
&gt;&gt; Speaker 3: 0.11.

200
00:11:48.497 --> 00:11:50.870
&gt;&gt; Aaron Frost: 0.11 okay, cool.

201
00:11:50.870 --> 00:11:51.968
&gt;&gt; Speaker 3: But with a harmony flag.

202
00:11:51.968 --> 00:11:53.024
&gt;&gt; Aaron Frost: Thank you, yeah,

203
00:11:53.024 --> 00:11:56.456
they're hidden behind the harmony
flag all these features.

204
00:11:56.456 --> 00:12:00.160
So once they're in V8,
it's just, it's just there.

205
00:12:00.160 --> 00:12:05.319
So if you wanted to use maps which
we'll talk about in a bit, it gets

206
00:12:05.319 --> 00:12:11.328
there you could you could probably use
a map in node to get the latest version.

207
00:12:11.328 --> 00:12:14.419
But if you wanted to use
LET it's not in yet so,

208
00:12:14.419 --> 00:12:17.051
you have proper tail calls same thing.

209
00:12:17.051 --> 00:12:22.197
Good question, question?
&gt;&gt; Speaker 4: One thing, can you use

210
00:12:22.197 --> 00:12:25.004
LET to assign a function to a variable?
&gt;&gt; Aaron Frost: So

211
00:12:25.004 --> 00:12:26.586
let A equal a function?
&gt;&gt; Speaker 4: Yeah.

212
00:12:26.586 --> 00:12:27.842
&gt;&gt; Aaron Frost: Totally, yeah,

213
00:12:27.842 --> 00:12:31.441
like when we said you can
use LET the places use VAR,

214
00:12:31.441 --> 00:12:33.470
we were serious about that.

215
00:12:33.470 --> 00:12:34.580
You can totally do that.

