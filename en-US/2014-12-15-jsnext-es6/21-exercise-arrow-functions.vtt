WEBVTT

1
00:00:00.000 --> 00:00:03.972
[MUSIC]

2
00:00:03.972 --> 00:00:07.400
&gt;&gt; Aaron: So let's have everyone
try some Noni functions out.

3
00:00:07.400 --> 00:00:09.220
So these actually work in Firefox.

4
00:00:10.380 --> 00:00:13.940
So yes, you go ahead and try them out
straight in your Firefox console.

5
00:00:13.940 --> 00:00:17.860
They also work in the Traceur Repl
like you saw me using them.

6
00:00:19.500 --> 00:00:21.936
But go ahead and try them out inside
an object, try with some event handlers.

7
00:00:21.936 --> 00:00:26.584
And then try passing some error

8
00:00:26.584 --> 00:00:30.695
functions to an array map or

9
00:00:30.695 --> 00:00:36.240
array for each or an array reverse.

10
00:00:36.240 --> 00:00:38.830
See if you can not reverse.

11
00:00:38.830 --> 00:00:44.370
See if you can figure how to do
[INAUDIBLE] with that stuff.

12
00:00:44.370 --> 00:00:49.250
So, good?
&gt;&gt; Speaker 2: Couple of questions

13
00:00:49.250 --> 00:00:50.139
here.
&gt;&gt; Aaron: Yeah, yeah ,yeah.

14
00:00:50.139 --> 00:00:50.830
&gt;&gt; Speaker 2: Is it a good spot?

15
00:00:50.830 --> 00:00:51.514
&gt;&gt; Aaron: Yeah, yeah,

16
00:00:51.514 --> 00:00:54.020
it is a great spot for questions.
&gt;&gt; Speaker 2: So

17
00:00:54.020 --> 00:00:57.040
an arrow function in ES6 is
different than the one used in

18
00:00:57.040 --> 00:00:59.150
CoffeeScript?
&gt;&gt; Aaron: So

19
00:00:59.150 --> 00:01:01.640
CoffeeScript has two arrow functions.

20
00:01:01.640 --> 00:01:05.930
And they have a skinny arrow,
which is instead of the equals sign,

21
00:01:05.930 --> 00:01:09.410
it's just the hyphen and
then the greater than.

22
00:01:10.510 --> 00:01:13.653
And let me show you here, so

23
00:01:13.653 --> 00:01:18.450
in CoffeeScript, they have no, voice.

24
00:01:21.850 --> 00:01:23.604
So they have this kind
of an arrow function.

25
00:01:28.115 --> 00:01:31.630
&gt;&gt; Aaron: And then they have, so

26
00:01:31.630 --> 00:01:37.560
they have those two arrow functions.

27
00:01:38.816 --> 00:01:40.960
In a CoffeeScript, they built them for

28
00:01:40.960 --> 00:01:45.450
this purpose, this is why they have two of
them for exactly what we're talking about.

29
00:01:45.450 --> 00:01:49.820
And use your skinny arrow functions where
wherever you would use an anonymous,

30
00:01:49.820 --> 00:01:51.190
just a regular function.

31
00:01:51.190 --> 00:01:55.462
You don't care whether this is you
just need the codec skew when you do.

32
00:01:55.462 --> 00:01:59.639
And then they're like well, we have this
time where we need to bind stuff like

33
00:01:59.639 --> 00:02:01.850
can easily be scoped lexically to this.

34
00:02:01.850 --> 00:02:03.310
And so they're like well,

35
00:02:03.310 --> 00:02:07.640
in that case, we'll create this second
arrow function which is a fat arrow.

36
00:02:07.640 --> 00:02:09.800
And so,
in CoffeeScript you have to learn and

37
00:02:09.800 --> 00:02:12.720
and you have to read
in parts of your eyes.

38
00:02:12.720 --> 00:02:17.030
That is skinny function, that's a fat
function, which one of the two is it.

39
00:02:17.030 --> 00:02:21.640
And so this actually does work just
like CoffeeScript's fat arrow functions.

40
00:02:21.640 --> 00:02:23.856
It does not work like CoffeeScript's
skinny arrow functions,

41
00:02:23.856 --> 00:02:27.780
so yeah?
&gt;&gt; Speaker 3: But

42
00:02:27.780 --> 00:02:30.250
is the parsing different?

43
00:02:30.250 --> 00:02:35.080
Cuz with your last example where
you changed the emit function to

44
00:02:35.080 --> 00:02:37.590
be a fat arrow function instead.

45
00:02:37.590 --> 00:02:39.950
And then this ended up bound to window.

46
00:02:41.936 --> 00:02:44.640
I thought CoffeeScript
parses that differently, so

47
00:02:44.640 --> 00:02:48.750
it would have worked the way you expect.
&gt;&gt; Aaron: I don't know, man,

48
00:02:48.750 --> 00:02:50.340
I'm not a CoffeeScript guy.

49
00:02:50.340 --> 00:02:51.650
So maybe someone who's used it.

50
00:02:51.650 --> 00:02:54.100
Maybe on the livestream can tell.

51
00:02:54.100 --> 00:02:55.780
But I don't know what
CoffeeScript would do.

52
00:02:55.780 --> 00:03:02.650
I would imagine that if fat arrow did what
I've been told it does, it would break.

53
00:03:02.650 --> 00:03:06.430
But it may work, I don't know.
&gt;&gt; Speaker 2: Another question was,

54
00:03:06.430 --> 00:03:09.660
are there any performance
improvements with the arrow function?

55
00:03:09.660 --> 00:03:10.694
&gt;&gt; Aaron: That's a good question,

56
00:03:10.694 --> 00:03:11.916
why didn't I talk about that.

57
00:03:11.916 --> 00:03:12.553
Well, [INAUDIBLE],

58
00:03:12.553 --> 00:03:13.695
you gotta stop [CROSSTALK]
&gt;&gt; Speaker 2: I just got here and

59
00:03:13.695 --> 00:03:15.609
we started questions.
&gt;&gt; Aaron: Okay, so

60
00:03:15.609 --> 00:03:21.730
it's not like strictly sugar, right?

61
00:03:21.730 --> 00:03:23.640
It is sugar because it's
going to bind this for

62
00:03:23.640 --> 00:03:27.220
you which is nice and
it takes the word function out and

63
00:03:27.220 --> 00:03:30.840
it gets rid of the return statement
if you only have one line.

64
00:03:30.840 --> 00:03:32.612
So there's a little bit of sugar.

65
00:03:32.612 --> 00:03:37.072
I'm gonna say mostly

66
00:03:37.072 --> 00:03:42.560
sugar, but combined.

67
00:03:42.560 --> 00:03:46.230
So remember how we said you can't
new this up, you can't new this guy?

68
00:03:47.970 --> 00:03:51.311
Combined with classes,

69
00:03:51.311 --> 00:03:56.880
there's a potential long-term benefit

70
00:03:56.880 --> 00:04:01.710
of having these kind of functions.

71
00:04:01.710 --> 00:04:07.079
And that is, so right now we have
functions and every function has this

72
00:04:07.079 --> 00:04:12.363
constructor thing on it, so
that you can construct it if you need to.

73
00:04:12.363 --> 00:04:17.139
And I'm not 100% into how much weight that

74
00:04:17.139 --> 00:04:22.290
takes up in memory, but
I mean it's not nothing.

75
00:04:23.290 --> 00:04:25.320
And so if every function,

76
00:04:25.320 --> 00:04:28.775
if you can get rid of these
constructors on every single function.

77
00:04:28.775 --> 00:04:32.570
Cuz most functions, I mean that almost
all functions aren't constructors,

78
00:04:32.570 --> 00:04:36.100
they're just methods, right?

79
00:04:37.270 --> 00:04:42.530
I'm not ever gonna new up my click
handler, it's just a function.

80
00:04:42.530 --> 00:04:45.540
And if there was a time where all

81
00:04:45.540 --> 00:04:48.890
constructors were only
used to the class syntax.

82
00:04:48.890 --> 00:04:53.800
And functions were only used as
functions but not as constructors.

83
00:04:53.800 --> 00:04:57.810
You could conceivably remove
the constructor binding

84
00:04:58.980 --> 00:05:02.180
from a function which might make
it lighter weight in memory.

85
00:05:02.180 --> 00:05:07.190
Which could potentially have
a benefit over runtime in that it

86
00:05:07.190 --> 00:05:12.650
wouldn't take up such
a big memory footprints.

87
00:05:12.650 --> 00:05:17.260
But again, I'm talking about
something I read one time,

88
00:05:17.260 --> 00:05:22.080
not that I write JavaScript engines,
right?

89
00:05:22.080 --> 00:05:27.970
Because I don't.
&gt;&gt; Speaker 2: One other

90
00:05:27.970 --> 00:05:33.925
kind of question here, so object functions
can be bind by skinny arrow functions,

91
00:05:33.925 --> 00:05:38.179
but I think skinny arrow
functions are only CoffeeScript,

92
00:05:38.179 --> 00:05:39.660
right?
&gt;&gt; Aaron: Totally,

93
00:05:39.660 --> 00:05:41.519
yeah, I think that's what they're saying.

94
00:05:42.620 --> 00:05:44.340
Yes, skinnier, like the word fat and

95
00:05:44.340 --> 00:05:48.370
skinny, that's not an [INAUDIBLE]
script thing, that's purely Java.

96
00:05:48.370 --> 00:05:49.820
I keep saying it.

97
00:05:49.820 --> 00:05:51.740
I said it so
now you guys are gonna go say it and

98
00:05:51.740 --> 00:05:54.640
I felt bad,
because I didn't mean to teach that habit.

99
00:05:54.640 --> 00:05:56.350
They're just arrow functions.

100
00:05:56.350 --> 00:05:58.560
And then someone on the livestream
is obsessed with it and so

101
00:05:58.560 --> 00:06:00.810
we've said it ten more times.

102
00:06:00.810 --> 00:06:05.250
But again, it's not called fat arrows,
they're just called arrow functions.

103
00:06:06.330 --> 00:06:08.420
Okay, let's code up

104
00:06:09.850 --> 00:06:18.550
a destructuring inside of an array
function, should we do that?

105
00:06:20.820 --> 00:06:23.300
With default parameters?
&gt;&gt; Speaker 3: Mm-hm, I can do that.

106
00:06:23.300 --> 00:06:24.401
&gt;&gt; Aaron: Okay, let's try it.

107
00:06:24.401 --> 00:06:29.240
[COUGH] Let's try it.

108
00:06:29.240 --> 00:06:33.590
So let me hide the runtime or
the generated code, okay.

109
00:06:33.590 --> 00:06:36.693
So I'm gonna make an array, for
now it's just gonna be of numbers.

110
00:06:53.750 --> 00:06:56.221
&gt;&gt; Aaron: Right, so we got numbers.

111
00:06:56.221 --> 00:06:59.311
Does everyone agree?
&gt;&gt; Speaker 2: [LAUGH]

112
00:06:59.311 --> 00:07:00.171
&gt;&gt; Aaron: Okay?

113
00:07:00.171 --> 00:07:07.230
And then we're gonna say,
nums.forEach or excuse me, map.

114
00:07:07.230 --> 00:07:08.110
Let's do a forEach, it doesn't matter.

115
00:07:10.610 --> 00:07:12.970
Okay, so
we're gonna do a forEach on these guys.

116
00:07:12.970 --> 00:07:16.411
So here we're gonna have this parameter.

117
00:07:16.411 --> 00:07:22.408
We're gonna do our arrow.
&gt;&gt; Speaker 4: Can

118
00:07:22.408 --> 00:07:26.963
you bump up the farm maybe one or two?
&gt;&gt; Aaron: Is that good?

119
00:07:26.963 --> 00:07:32.150
Okay, [COUGH] so in here,

120
00:07:32.150 --> 00:07:39.314
we're gonna say this is the num and

121
00:07:39.314 --> 00:07:46.490
we will default it to 1,000.

122
00:07:46.490 --> 00:07:49.070
In the forEach it passes

123
00:07:49.070 --> 00:07:52.830
the second parameter which is the index.
&gt;&gt; Speaker 4: ForEach?

124
00:07:54.000 --> 00:07:55.100
Yeah.
&gt;&gt; Aaron: It does,

125
00:07:55.100 --> 00:07:55.725
right?
&gt;&gt; Speaker 4: Yep.

126
00:07:55.725 --> 00:07:56.957
&gt;&gt; Aaron: Okay.

127
00:07:56.957 --> 00:07:59.256
&gt;&gt; [INAUDIBLE].

128
00:07:59.256 --> 00:08:03.347
&gt;&gt; Aaron: [COUGH]
&gt;&gt; Aaron: So,

129
00:08:03.347 --> 00:08:08.028
I don't think I can do index minus one.

130
00:08:12.658 --> 00:08:17.966
&gt;&gt; Aaron: Probably not.
&gt;&gt; Aaron: Let's try it though

131
00:08:26.142 --> 00:08:28.015
&gt;&gt; Aaron: Num are the index+1.

132
00:08:38.233 --> 00:08:39.935
&gt;&gt; Speaker 4: Your experimental's

133
00:08:39.935 --> 00:08:41.850
turned off, is it?
&gt;&gt; Aaron: Was it?

134
00:08:43.710 --> 00:08:47.295
Do I need a num?
&gt;&gt; Speaker 4: Create the default,

135
00:08:47.295 --> 00:08:53.436
wouldn't you?
&gt;&gt; Aaron: I don't think so.

136
00:08:53.436 --> 00:08:56.360
&gt;&gt; Speaker 5: Mine is working fine with

137
00:08:56.360 --> 00:09:01.202
it.
&gt;&gt; Aaron: Horn.

