WEBVTT

1
00:00:00.000 --> 00:00:01.681
So my name is Lucas Ruebbelke.

2
00:00:01.681 --> 00:00:07.821
I've been a principal engineer for
many years and done a lot of work for

3
00:00:07.821 --> 00:00:12.622
anywhere from startups to
Fortune 100 companies.

4
00:00:12.622 --> 00:00:17.923
And the goal of Enterprise Angular is

5
00:00:17.923 --> 00:00:23.908
that when you start to
program in a context

6
00:00:23.908 --> 00:00:29.728
where there's scale, things change.

7
00:00:29.728 --> 00:00:34.934
What I'm hoping to target
is developers that not only

8
00:00:34.934 --> 00:00:40.494
wanna learn how to write
high-quality code in Angular.

9
00:00:40.494 --> 00:00:46.202
But also to start to be exposed and
understand the principles that

10
00:00:46.202 --> 00:00:51.912
really factor into just building
large-scale applications and

11
00:00:51.912 --> 00:00:55.769
what that looks like and the architecture.

12
00:00:55.769 --> 00:01:01.592
Now, doing enterprise development
without an enterprise

13
00:01:01.592 --> 00:01:07.540
is a little bit tricky as well
as it can be very overwhelming.

14
00:01:07.540 --> 00:01:13.148
And so this is where you'll
notice on the companion site and

15
00:01:13.148 --> 00:01:16.861
the repository, it's enterprisey.

16
00:01:16.861 --> 00:01:22.107
And so what I'm hoping to do is, for
those who are curious to learn how

17
00:01:22.107 --> 00:01:27.627
to build enterprise products and
applications that were writing code,

18
00:01:27.627 --> 00:01:32.349
but we're just being a little
bit more enterprisey about it.

19
00:01:32.349 --> 00:01:37.596
We're going to start at a high
level of abstraction and work down.

20
00:01:37.596 --> 00:01:42.294
And with that said, the first thing
that we're going to start with,

21
00:01:42.294 --> 00:01:44.726
and this is incredibly important,

22
00:01:44.726 --> 00:01:49.440
is we're going to talk about
the domain and domain-driven design.

23
00:01:49.440 --> 00:01:54.829
From there,
we're going to talk about monorepos

24
00:01:54.829 --> 00:01:59.756
in tooling, and then micro-frontends.

25
00:01:59.756 --> 00:02:04.037
And moving on to reactive architecture,
state management,

26
00:02:04.037 --> 00:02:09.058
standalone components, and then we
are going to get into unit testing,

27
00:02:09.058 --> 00:02:13.777
end-to-end testing, performance and
tuning, and deploying.

28
00:02:13.777 --> 00:02:18.795
One of the things that I've learned in my

29
00:02:18.795 --> 00:02:23.813
years as a programmer is, there's this

30
00:02:23.813 --> 00:02:29.126
arc that you follow in
your career that when

31
00:02:29.126 --> 00:02:34.883
you start as a new programmer,
the tension and

32
00:02:34.883 --> 00:02:41.694
the challenge is trying to
figure out how things work.

33
00:02:41.694 --> 00:02:46.504
And ultimately, your focus shifts

34
00:02:46.504 --> 00:02:51.160
on to how do things work together.

35
00:02:51.160 --> 00:02:56.476
And so this is where somebody who
is like a principal engineer or

36
00:02:56.476 --> 00:03:01.391
an architect that they spend
a lot of time thinking about,

37
00:03:01.391 --> 00:03:05.630
not how things work, but
how they work together.

38
00:03:05.630 --> 00:03:10.286
And I would go as far as to say
that if you were to continue up

39
00:03:10.286 --> 00:03:15.039
the corporate ladder to
becoming executive leadership,

40
00:03:15.039 --> 00:03:18.726
and at the highest ranks
of an organization,

41
00:03:18.726 --> 00:03:24.660
well suddenly your job starts to shift
into how do people work together?

42
00:03:24.660 --> 00:03:27.278
And how do you get
people to work together,

43
00:03:27.278 --> 00:03:30.929
to make the things work together,
to make the things work.

44
00:03:30.929 --> 00:03:35.642
As you do this, the abstraction
layers just keep getting higher and

45
00:03:35.642 --> 00:03:38.570
higher and higher and more conceptual.

46
00:03:38.570 --> 00:03:44.069
When you are starting in
you're building a little app,

47
00:03:44.069 --> 00:03:49.575
your entire focus is just
right there on the app itself.

48
00:03:49.575 --> 00:03:54.136
But then I remember when AngularJS
came out, the top question on

49
00:03:54.136 --> 00:03:59.387
Stack Overflow for years was,
how do two controllers talk to each other.

50
00:03:59.387 --> 00:04:06.415
Is that there was clearly a need to
divide these controllers, but then what?

51
00:04:06.415 --> 00:04:10.117
How do they communicate together?

52
00:04:10.117 --> 00:04:15.044
And so not only are we focusing
on how things work together and

53
00:04:15.044 --> 00:04:20.356
fit together, but how do we divide
them in a way that makes sense,

54
00:04:20.356 --> 00:04:26.250
that we're not creating coupling,
but we're encouraging cohesion,

55
00:04:26.250 --> 00:04:32.554
but we're doing it in a way that promotes
collaboration and communication.

56
00:04:32.554 --> 00:04:37.713
And so
as we get into domain-driven design,

57
00:04:37.713 --> 00:04:45.586
this is a topic that, I think I've
always been passionate about it,

58
00:04:45.586 --> 00:04:51.152
but I didn't quite have
the semantics in place to

59
00:04:51.152 --> 00:04:57.499
really understand kind
of the importance of it.

60
00:04:57.499 --> 00:05:02.034
But, when you talk about
domain driven design,

61
00:05:02.034 --> 00:05:07.456
ultimately it's about how do
you conceptually divide and

62
00:05:07.456 --> 00:05:12.101
organize your business
domain in a way that you can

63
00:05:12.101 --> 00:05:16.209
then write your code
to pattern the domain.

64
00:05:16.209 --> 00:05:21.514
And I've seen a lot of really bad
things happen or costly things or

65
00:05:21.514 --> 00:05:26.916
cumbersome things, just a lot of
problems when you have a code base

66
00:05:26.916 --> 00:05:33.909
that is not reflective of the business
domain that it's actually operating in.

67
00:05:33.909 --> 00:05:40.479
Because you might have a portion of
the business domain that needs to change,

68
00:05:40.479 --> 00:05:45.229
but because the code doesn't
represent that, to go and

69
00:05:45.229 --> 00:05:49.692
make that code change is
exponentially expensive.

70
00:05:49.692 --> 00:05:54.025
And one of the companies
that I've worked for,

71
00:05:54.025 --> 00:06:01.513
they're spending a ton of money breaking
up their monolith into microservices.

72
00:06:01.513 --> 00:06:03.565
And why are they doing that?

73
00:06:03.565 --> 00:06:09.584
Because it's simply too hard
to make a change in one piece.

74
00:06:09.584 --> 00:06:15.283
It's like Jenga, the game where
you've got the little blocks,

75
00:06:15.283 --> 00:06:20.166
and if you just do one wrong,
the whole thing tips over.

76
00:06:20.166 --> 00:06:23.224
Everything is bundled together and
it's very hard to make changes.

77
00:06:23.224 --> 00:06:26.514
It's very hard to move and to innovate.

78
00:06:26.514 --> 00:06:33.813
And it's because coupling is bad, as a
result, it makes communication cumbersome.

79
00:06:33.813 --> 00:06:39.565
And I believe that when you get
your business stakeholders,

80
00:06:39.565 --> 00:06:44.303
the people that understand
the business domain,

81
00:06:44.303 --> 00:06:47.346
and the engineers in a room, and

82
00:06:47.346 --> 00:06:53.099
they are clear that they have
a conceptual understanding and

83
00:06:53.099 --> 00:06:59.457
an agreement on what the domain is,
and what it's supposed to do.

84
00:06:59.457 --> 00:07:04.459
That sets the stage for
establishing what we call a ubiquitous

85
00:07:04.459 --> 00:07:09.951
language where everybody's using
words that mean the same thing.

86
00:07:09.951 --> 00:07:12.992
That we understand when we say case, or

87
00:07:12.992 --> 00:07:17.969
flight, or these different words
within the business domain,

88
00:07:17.969 --> 00:07:22.682
specifically what it means and
in the context that it means.

89
00:07:22.682 --> 00:07:27.915
And these conversations, I think for

90
00:07:27.915 --> 00:07:33.481
cowboys who wants to just run in code is,

91
00:07:37.542 --> 00:07:41.379
I understand that on the surface,
maybe it's not super exciting.

92
00:07:41.379 --> 00:07:46.456
There's nothing quite as exciting as,
my gosh, it's a green field and

93
00:07:46.456 --> 00:07:51.210
I'm gonna run into the green field and
I'm just gonna write code, but

94
00:07:51.210 --> 00:07:56.473
oftentimes the best code that we write
is the code that we don't write at all.

95
00:07:56.473 --> 00:08:02.598
And the greatest thing that
we can have is, as engineers,

96
00:08:02.598 --> 00:08:08.848
is a clear understanding of
the business domain that we're

97
00:08:08.848 --> 00:08:13.980
operating in,
where the lines of division are.

98
00:08:13.980 --> 00:08:19.996
And I would say, if you want to level up
and really kinda go to the next level,

99
00:08:19.996 --> 00:08:25.932
understand how they fit together to
serve the business and to drive value.

100
00:08:25.932 --> 00:08:31.851
Is that when you have an engineer that can
actually talk about business outcomes,

101
00:08:31.851 --> 00:08:34.168
that is incredibly valuable and

102
00:08:34.168 --> 00:08:37.880
non-technical people
respond very well to that.

103
00:08:37.880 --> 00:08:44.497
So this is where we're starting very high.

104
00:08:44.497 --> 00:08:49.053
And we're going to talk about domains for
just a moment.

105
00:08:49.053 --> 00:08:52.600
And my goal is to write
as much code as possible.

106
00:08:52.600 --> 00:08:54.656
But before we do that,

107
00:08:54.656 --> 00:09:00.511
we have to have a clear understanding
of what we're working in.

