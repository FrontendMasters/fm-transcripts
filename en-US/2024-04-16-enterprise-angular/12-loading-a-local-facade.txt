[00:00:00]
>> What we're doing, our behavior subject, we're exposing the observable portion of it. So this right here completely matches, This right here, loaded allChallenges, selectChallenges. I think this is important, right? Within these methods, I'm just manipulating this data structure, and then updating the subject to emit the new value back out to the interested party.

[00:00:46]
Now, I think this is right, I haven't tested it, but the concept stands, is that this has the same exact API as the Facade that I would use to interface with NgRx. Now, the difference is that in the local Facade it's all in memory, I don't have any dependencies outside of that other than, obviously, the behavior sub hit.

[00:01:21]
So, now the question is, what to do if I wanted to load this into Challenges. I believe that I would come up into, This remote entry here, and this is the beauty of dependency injection, is that I'm able to say here is the challenges Facade. But instead of using the real growing-up version, I want you to use this logo version.

[00:02:07]
This is how testing works in Angular. This is the whole point. I think React is a great framework, but the one thing that I wish it had was inversion of control or dependency injection mechanism. Because, and you may be able to do this in React, so if somebody knows, hit me up, this is the one thing that I struggle with.

[00:02:32]
Is that, the ability to wire up things like this is, I think, so clever and so powerful. So now, just wanna make sure I don't have anything running. I really hope this works. So, what I'm doing here is, I'm loading the entire Challenges feature, which is, it's a JSON server and it's the frontend app.

[00:03:19]
So, in the JSON server, and I hope we talk about it, if we have time, is I just have a JSON structure with five challenges in it, right? So this is what I should be loading, but this is not what we're saying. Why is this happening? Well, what I'm going to do is I'm gonna just take this off screen, I'm gonna make a change, and then I'm gonna put it right back on screen, and we will observe this.

[00:04:13]
Do you see that? What did I do? I think, maybe because I don't do this a lot, but this is, in my opinion, probably one of the cooler things that we've seen today, because all I'm doing is I'm just turning, This on and off. So, I'm basically overriding the injector with a local injector.

[00:04:59]
So once I inject it, what I'm able to do He's essentially approximate, the entire State Management layer with a single Local Facade. That because it's all observables and I haven't tested the functions yet, but I have every reason, like, it'd be easy to fix, is that, imagine now you wanna do end-to-end testing.

[00:05:30]
And you don't actually wanna hit a server. Well, there's ways to override that. This is how the proxy works, is that we can, if we agree on a contract, we can hydrate our component layer without ever touching an API. And your component layer has no idea, and this is why I think Facades are so powerful, Is because it decouples your component layer from everything else.

[00:06:08]
And your component layer has no idea, other than that there's a Facade, that it's using a store, anything. Does anybody have any questions about the blasphemy that I've just unleashed onto this workshop?
>> So, here are you, is the point of the local Facade essentially that you're agreeing on a contract, but you have not built out the NgRx, like, if we are in a world that we hadn't built out the NgRx facade, essentially?

[00:06:44]
You have both right now, so that's where I was trying to understand what's the point of the local one.
>> So, I'm just showing that you can flip them, that they are functionally equivalent, other than the level in which that state change is propagating. One of the other reasons why I like the facade is because it creates a nice division of labor within a development team, which nobody talks about.

[00:07:18]
I have worked a lot with junior developers, that they, from a skill-standpoint, are effective building out components. But they are not quite ready to handle more complicated things like State Management. So, not only does the Facade allow me to decouple the frontend from the backend, it allows me to decouple the component layer so my junior developers can work on it.

[00:07:54]
While my senior developers can go and work on the hard stuff, which is, really it's asynchronous business logic. I think it's the hardest thing technically to get right. It's the division of the conceptual model, but also the division of labor to achieve the outcome as a result.

