[00:00:00]
>> I wanna talk about one more module and then we are going to call it a day. We're actually running out of film in the back. They only bought so many tapes, maybe I should not talk so much, or maybe talk really fast. All right, so I wanna take a moment and I wanna talk about unit testing.

[00:00:23]
And I wanna talk about conceptually how we should think about unit testing, and then just show a few patterns that when I write test, I just see it over and over and over. As well as, I believe the standalone API also makes this a lot easier. So in Angular, my experience is that I spend, probably 90% of my time just getting the unit under test to initialize.

[00:01:05]
Because, essentially, every dependency that exists, you have to account for that. And in some cases, when you have very large components with components, sometimes I just end up just doing process of elimination, cuz you don't need to inject everything, just enough to satisfy the dependency. So literally, I'm looking at 20 dependencies.

[00:01:36]
I'm just adding them in one by one, until it renders. So one thing I would say is that keep your components, your services, everything, fine grain, single purpose. And if you find that you're having to import, Four or five, six modules, ask yourself why that's necessary. And you probably have a component that is too coarse-grained.

[00:02:12]
Or you're doing something that's too coarse-grained. A really, really great book, probably one of my favorite programming books is Clean Code by Robert C Martin. And I've read it probably three or four times, and I actually am fortunate enough to have a signed copy. And if my house ever caught on fire and my kids were safe, I would run in, grab that copy of that book and my Fender Rhodes keyboard, and I'd be out of there, and my golf clubs, and my shoes, and my skateboard.

[00:02:56]
Just kidding, I've grabbed three skateboards. All right, so one of the things that, when you read Clean Code, what's interesting to me is that in hindsight, it's so obvious. What uncle Bob is talking about is common sense. I think it's really about portion control. If I could describe Clean Code in the simplest possible terms, it's about portion control.

[00:03:37]
Is that, do not do too much, do just enough. And if you're doing too much, you need to break it up. You need to refactor. And I've talked about this before in other workshops, but what's interesting to me even in an enterprise products workshop context, to this day 85%, if not more of the code that I see, comes down to three basic errors.

[00:04:14]
Every single time, show me a code base and there's three things that are happening. One, hidden state, nested logic, and SRP violations, single responsibility principle violations. And every single one of those are, I think one of the easiest things to fix in code and it creates so much pain and suffering and misery, and it just ushers in the apocalypse in your organization.

[00:04:55]
And it's like the end of time, and it seems so innocent at first, but what happens is things start to get coupled in a way that you can't uncouple it. And then you leave with your boss to go to some other company because you wanna create a better and cooler culture over there, and I don't think he's taken the bait.

[00:05:24]

>> [LAUGH]
>> [LAUGH] Michaela Maroney is not amused. But it's a slippery slope and it creates entropy and rot in the code, and it's super simple. Is, when I describe in the state nested logic SRP violations, it's things that are tightly coupled in the wrong way, is that you have hidden state coupled into a function, nested logic, SRP violations.

[00:05:58]
And when something is word, it should be the opposite is the solution in that extract, promote, move it out. So if you have, for instance, hidden state in a function where you're mutating state within a function, and so you have the state mutation inside of a function, well, how do you test that function?

[00:06:26]
You can't, because you have no way of knowing what the end result of that function is gonna be without knowing things that are happening outside of the function. Super easy to solve, you take the hidden state, you pass it in as a parameter. Extract the parameter, that's the logic, extract a function.

[00:06:49]
So if you have an if else statement or a switch statement and you got these complicated, there's business logic in there, how do you test that? How do you test that and step over the other things? Suddenly, you got this complicated setup to just get into that one thing.

[00:07:07]
Well, you just extract it to a method. It's that simple. If you have a function that's doing two things or more, what do you do? Extract a method, and so the, I think one of the first principles or core principles of programming is to commit. If you want to write good tests, write good code.

[00:07:44]
And its always funny to me when somebody comes to me and says, hey, we wanna hire you to come and fix the test. And you're like, fix the test? [LAUGH] I can't fix the test without fixing your code, which means that I probably have to fix your culture.

[00:08:03]
Which means then we probably have to fix your organization. That's the canary in the coal mine. So with that said, I want to just show a few patterns in the sample app. All right, git push. I'm guessing here. This feels like the right thing. And P, [LAUGH] nice try, Louis.

[00:09:11]
All right, that's it, we did it. Everybody, go home, have a good weekend, awesome. That, for a second, I almost believed it. Let's just step through the components and kinda work through just a few things. The biggest thing, as I said, that when you are writing tests for Angular, I think the majority of your time is going to revolve around satisfying the dependencies.

[00:09:53]
This is why when you have fine-grained code with minimal dependencies, it's so much easier to set up the context for that unit under test to operate. So the question is then, if you have a dependency, what can you do to solve that dependency? If you have a dependency, what do you do?

[00:10:29]
Well, there's a few things, so, One is you can, and if I look up, Here, [SOUND] you can use mocks or stubs. And so when I say mock or stub, and if anybody wants to offer the version of what they think is that when I think of a mock and a stub, a stub is the bare minimum to satisfy the API, and a mock actually has some basic functionality kind of baked into it.

[00:11:15]
So a mock actually can exhibit some behavior. Stub is just a stubby little object. When you are writing your test, that's the first thing that you have to ask yourself. And I'm looking to see if I'm trying to find a good example of, I would wager either in one of these state ones, or, Perfect, awesome, so dependency injection for the win, we are setting up the challengesFacade.

[00:12:12]
And so what we're able to do is provide the action subject and use this mock action subject in its place. So this is really, really nice when it's like, you have this dependency, I can give it to you, we can call it that, but it's really something else.

[00:12:36]
And the action subject here, Is, we're actually using, I think, the full one if I'm not mistaken. So what you have as well, speaking of mocks, is that NGRX provides some of this for you. I will say this, if you want, I think some of the best API documentation for a library is in the test.

[00:13:12]
If you're confused at how something works, go look at the test. And it's very, very precise, highly concentrated examples of how do you interact with this thing. Well, because it's a unit under test, and you can see it. So now, when we are creating this, we're testing the challengesFacade, we have, A few dependencies, and what's interesting is that we're using the inject or to pull in the store.

[00:13:54]
So this is coming off the core. And so typically, I look for hard dependencies. And then I create a reference to the unit in our test. So we're testing the challengesFacade. So I create a placeholder for an instance of that, and then a placeholder for the things that we're directly injecting in.

[00:14:17]
And then in the testing module, then we use providers, crying out loud. This VS code is all over the place, to override and wire this up. So here, provide mock store. So it's like the store, but it's not action subject, mock action subject. And then we're able to inject these instances, these units under test, into the test module or the testbed, so the testbed actually wraps the module.

[00:15:06]
So that's the first piece, is understanding how to satisfy dependency injection. If you can figure that out, or better yet, if you can figure out how to avoid creating dependencies, high five. Then satisfying them is pretty easy using the provide, use value, use class, use object syntax.

