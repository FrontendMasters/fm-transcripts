[00:00:00]
>> Lukas: When somebody is learning Redux.
>> Lukas: The first phase is you got to get them comfortable with state flows down, event flows up.
>> Lukas: One of two questions is going to happen next.
>> Lukas: The first one, or it can happen in any order, but one of them is what happens if you have a relational data structure?

[00:00:32]
How do you put those back together?
>> Lukas: The second question is what happens if I need to do something at the server before I save it to the store? So, how do you compose relational data? So you have two slices, like let's say we had users and challenges or whatever, and like how do I actually combine that, because they're separated because you don't want it in two places.

[00:01:05]
And so, we'll go with the asynchronous one first, because we've already touched on the compositional one.
>> Speaker 2: Sorry, excuse me, if I may ask, I'm looking at this now, and then going back to the visualstudio.net, the way we used to structure is this, the data set or data source where you have all the data pulled into a particular place, and then finish working, and then you take everything back to.

[00:01:40]

>> Lukas: Yes, so this is basically a port of Redux which is heavily into to React, and the idea is that all state gets composed into a single state tree, and all your application state is in one place. Why this is important, and the other thing is any operation you do to application state is immutable.

[00:02:16]
The reason being is that,
>> Lukas: How does garbage collection know if something has changed?
>> Lukas: Well, a very obvious way is that the memory pointer changes, and so when you have a variable pointing to a specific heap of memory, and historically, we would just mutate it. It's like, I've got an array of 20 things, and I'm gonna go change the 9th one, well, how do you know it changed?

[00:03:02]
How do you know it changed? Versus, I'm going to replace the entire array with a new one, well, that's a pretty good indication that something's changed and you no longer have to go and waste the cycle is trying to figure out like, well, what changed? What do I update?

[00:03:22]
What happened? And it's actually trying to go figure out like what actually was mutated, versus I'm just gonna swap it and just respond by refreshing or re-rendering the things. And so this is why there's a lot of other things I could say about immutable operations, but this is one of them.

[00:03:49]
Is that all your state goes into one place, when you change state, it essentially swaps that object out with a new one, which you can store and create a memento. You can do a lot of really interesting things, I've done it where I've actually, when you throw an error, I capture the previous state and the command, and I send it to LogRocket, and then you can actually replay that entire state.

[00:04:14]
You can pull the state tree back down, replay that, and you can recreate with total precision the application before it went into an air state, it's pretty interesting. So, this is, yes, to answer your question in a very roundabout way, it's this is exactly what's happened. This was heavily inspired by Redux, and I'll actually show you something kind of interesting in a moment.

[00:04:45]
So, the asynchronous part.
>> Lukas: This, I believe, is the hardest part about learning NgRX, and this is where I think people, really get stuck. And I feel like maybe I've said this already, I feel like I just made went back in time Groundhog day style. The reason why people struggle with effects, is because you're dealing with asynchronous business logic.

[00:05:29]

>> Lukas: And that's hard because most people do not appropriately understand observable streams.
>> Lukas: And if you don't understand observable streams, the asynchronous nature of an observable stream is going to be mysterious and confusing and unpredictable. I think I talked about it in one of the courses here, so I'm not gonna get too much into it, it's just asynchronous logic is tough in any domain, any technology, any platform.

[00:06:13]

>> Lukas: And, I can say that most certainly.
>> Lukas: Effects are no exception. What we have here is, we're creating an effect that is looking for a trigger event. So in this case,
>> Lukas: We are listening for, if I can get this mouse to stop being stupid, what's the action that we're looking for here?

[00:06:50]
Can you guys see this? Load workshops, right, this is the trigger event. Then you either have a success or failure completion event. And so, effects are basically middleware for your front end app were just like the reducer, they're listening for actions and responding if it matches up. Now, it is possible to have a reducer and an effect listening for the same event, I would recommend avoiding that.

[00:07:39]

>> Lukas: Where I think maybe I would permit it and I think it's actually in this example is that if I needed to set loading to false and so I need to just like it's loaded, it's not loaded but then all of the logic, and even then I'm not in love with it.

[00:07:55]
But you have a trigger event or action. Those go into effects, then the effects dispatch the completion event. And so I think of it as, you're assembling a train. Cuz you can actually have an effect that listens for a trigger event, that dispatches an event, that gets picked up by another effect, that triggers another event, that gets picked up by another event.

[00:08:35]
You can string effects together and do some really interesting asynchronous, like logic composition and workflow composition. If anybody is familiar with step functions in AWS Lambda, it's all event-based distributed workflow stuff. Well, in a microcosm, this is what effects are, trigger, completion, trigger, completion. So most of the time, the trigger event is, do some asynchronous thing it to the server, the completion event is this is the result of it, save it to the store.

[00:09:16]
And we have some basic stuff. I would say that this is a matter of just kinda looking at the operators and doing a little bit of homework on them. The other piece, or the other question that I posed is, what happens when you have relational data?
>> Lukas: That, let's say we have users and lessons, and I want to stitch those back together to display them, what do I do?

[00:09:52]
Well, this is where you use a selector to essentially create two subselectors, combine them together cuz they're just streams, compose them together, and then return a new stream with a combined data source. State flows down, events flow up. If event flows up, if there's an asynchronous action, it hits an effect.

[00:10:20]
That effect completes and it pushes it into the store. If state flows down, and you need to perform some sort of composition, it goes into a selector or selectors, that then performs that operation, and then returns it as unified stream into the really the facade, which then gets passed on to the component layer.

[00:10:46]
Does that make sense so far? All right, we have just a few more things to wire up here, just wanna make sure I'm giving this the proper attention.
>> Lukas: Oops, the one thing that I haven't done yet is because we're no longer pushing this into an entry module, because of the standalone API, that you have to achieve that somewhere else.

[00:11:30]
And so in this case, what I've done, and what I do is,
>> Lukas: Well, apparently, I'm totally discombobulated right now, hold on.
>> Lukas: user-state, workshop-state, there we go.
>> Lukas: I just create a state.ts file, go in here
>> Lukas: Now, the one thing that needs to happen, if anybody wants to submit a pull request, is my template wizard does not do a good job with all caps.

[00:12:24]
So I would accept a pull request on that.
>> Lukas: So I have to go through and,
>> Lukas: So this I believe, for the most part, is all the stuff. I feel like I might have,
>> Lukas: What am I missing here? I'm on a spec, okay, that's fine.
>> Lukas: Admittedly, there are a lot of moving pieces.

[00:13:21]
So the other thing is kinda the barrel roll or kind of the index file that serves as kinda the public API is this. So, eloquently, point out here, [SOUND]
>> Lukas: All right, so I think the library, or the state library is pretty much good to go. Now the question is, how do we actually get this hooked in?

[00:14:01]
And this is where, when I was wrapping my mind rather new standalone API. Poor Brian Love, just called him on the phone, just sobbing my eyes out.
>> Lukas: All right, so, I believe there's only two places that you see NgRx kind of emerge into the consuming layer. And fortunately it happens in the, maybe not totally constrained with the way that we're doing it now.

[00:14:52]
[COUGH] It's pretty much isolated into the remote entry point, which I'm pretty happy about. So one is, when you're setting up your app config. So when you're Bootstrapping your application that instead of having just this big, long, or this huge thing where you're calling Bootstrap application, you got this big config object that they've started to move this out into appConfig.

[00:15:32]

>> Lukas: I'm just gonna copy this.
>> Lukas: I keep forgetting that workshops is all the way down here.
>> Lukas: What's interesting this is actually a host application that, notice, it doesn't have a remote entry point. And the last thing that we have is, we need to just wire in the facade into the component.

[00:16:33]
So typically,
>> Lukas: In this case, it would go into,
>> Lukas: The container component in the,
>> Lukas: Application, but I don't have all of this in, so I am gonna just put this in here. I think really what I would need to do in this case, if I was gonna be thorough, is actually generate a workshops component, Master Detail View to put in there.

[00:17:24]
So what I'm going to do instead is,
>> Lukas: I'm just going to copy the facade.
>> Lukas: And,
>> Lukas: What file am I in? Wrong, that's not it, all right?
>> Lukas: I'm excited thinking about a break.
>> Lukas: All right, now I'm in the right place. So private workshopsFacade.
>> Lukas: I was really hoping this would just pick up.

[00:19:07]

>> Speaker 3: Line 15 needs an A in facade
>> Lukas: I might have actually sabotaged.
>> Lukas: I thought I did this already.
>> Lukas: Come on, notes, notes, notes, notes.
>> Lukas: Actually, I think I did this, almost done.
>> Lukas: Go in your hole you stupid ball. All right, that's done
>> Speaker 4: I think you're importing it from the data not the state.

[00:20:16]

>> Lukas: Am I doing that cuz that would make a lot of sense.
>> Speaker 4: Yeah, you definitely didn't have an export for the facade on the data lib
>> Lukas: So that's where we have unintended consequences where like, I'm just gonna leave this here it's totally fine. And if I wasn't in front of everybody just desperate for your approval, I probably would have went and fixed that.

[00:20:40]
So, all right,

