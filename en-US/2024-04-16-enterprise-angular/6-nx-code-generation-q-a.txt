[00:00:00]
>> I believe the gentleman in the corner had a question.
>> Yeah, so you had us create like a state and a data library. Would you essentially, and if you're in a large enterprise, create a state and a data library for each domain you have? So whether or not you would create like a state and a data library for every single domain, I think it's really contextual to the environment.

[00:00:29]
Again, if I was doing a fairly small application, I would have just a core state and a core data. But, especially with the CLI, it's very, very easy to refactor through promotion is that you're just one command away from cutting a new library and dropping that in. Especially with the template wizard, it's pretty easy and one of the things that we'll just see this theme throughout the day is that, engineers and I think there's a part when you come to a coding workshop it's like show me how the code works and there is that but I think more importantly is that at this level, it's examining how we think about code.

[00:01:33]
And so that is that's a great question, do we have a separate data in state library for every kind of entity in the domain or every domain, and in this case we have a domain with kind of a single entity in it, and for the sake of this exercise, yes.

[00:01:53]

>> Do the nouns need plural? Or do the nouns need to be plural, like users-data or workshop-data where they list multiple things?
>> So typically I make them plural because I believe that encapsulates a collection of the thing and so there's some weird ones. Like obviously I wouldn't do logins data.

[00:02:22]
So there's somewhere semantically it doesn't make sense again, you want your code to be really self-documenting and reflective of your reality. But i would say if you were dealing with a single user then i think you could have like a user state in a user data. But typically, if I'm dealing with more than one of the thing, then I make it plural.

[00:02:48]
And that's just how we talk, so
>> And then the question from earlier, he clarified, if I have different repos for the UI, the UI is Angular. And then the API, which is Node.Js, would I use Nx for the Angular app?
>> I would say that if everything is working, fine, and it's not getting in the way of your business initiatives.

[00:03:20]
Then you may not need to do anything. On the other hand, I would say that Nx would be a great candidate to put everything in there. And I oftentimes will run like Angular and Node or Angular Node React. And so answer is, if it's business as usual and it's not impeding your ability to deliver value to your customers, you could probably stay the course.

[00:03:51]
But if it is slowing you down or creating friction and you need to go faster, absolutely moving those into a single mono repo is going to speed that up.
>> If I need to make changes across every data service, like supporting feature flags and the URL for version one versus version two, how would you handle that, would you use something like inheritance?

[00:04:23]

>> I love that question so much. So if you need to make a cross cutting change, a across multiple services, how would you handle that? Well, ideally, I would handle that with an interceptor or some aspect oriented mechanism. So without understanding what the actual use case is, that if you have something that impacts a large number of things, try to extract that out.

[00:05:07]
So you can change that independently of the thing. And so it's almost the opposite of inheritance and that you're leaning towards extraction. And so you want to converge on the things that are the same and then the things that are different. Those are the things that you wanna program towards.

[00:05:27]
So if you had to make a change to like all the services, I would ask myself, what do I need to change? Let's say it's the remote endpoint. Well, I would try to capture that with an interceptor or in this case, possibly even just an environment variable or some of runtime configuration.

[00:05:51]
So that the core body of the service itself stays the same and the context in the execution details are handled outside of it. One of the things that really bothered me about Angular JS and even Angular pre-Redux is that You had services that were not only responsible for communicating with a remote endpoint, but they were also responsible for managing state.

[00:06:31]
So I'm gonna go call the service and when I get it back, I'm gonna transform it into something and then I'm gonna save it. But then if you wanna make a change, you wanna get something, you're going to talk to me and I'm gonna also manage the state for this thing.

[00:06:44]
And that really, really bothered me because that's not a clear separation of concerns. Anytime you ask yourself, what is this do? And you're like, well, does this end, the men who say end, stop, that's a flag. You're doing probably more than one thing. And so, if we look at, For instance, the note service, Other than, It has this console log in here.

[00:07:19]
I don't know where that came from. But what do we notice about this? How many lines are each of my functions? The body is just doing one thing. And what this allows me to do is because now it's separated out from the state portion. Let's say I wanted to have a GraphQL endpoint, so it can totally different transportation mechanism.

[00:07:54]
Well, I could create notes, GraphQL data library, encapsulate the GraphQL stuff, and then the state layer doesn't have to know anything about it. They just know that I call this thing, and this is what I get back, and they are communicating on a contract and everything is encapsulated.

[00:08:27]
It took me a long time to figure that out but at scale it's very painful to not figure it out.

