WEBVTT

1
00:00:00.090 --> 00:00:06.170
There was a question previously
about how comparable or

2
00:00:06.170 --> 00:00:11.471
comparable is NgRx to
Redux inside of React, and

3
00:00:11.471 --> 00:00:16.980
the answer is they're heavily influenced.

4
00:00:16.980 --> 00:00:22.468
In fact, I believe,
to the best of my knowledge,

5
00:00:22.468 --> 00:00:27.757
that NgRx is basically Redux compliant.

6
00:00:27.757 --> 00:00:31.450
That the APIs that Redux has,

7
00:00:31.450 --> 00:00:36.387
that they map for the most part to NgRx.

8
00:00:36.387 --> 00:00:41.265
I think the difference is that Redux,
if I'm not mistaken,

9
00:00:41.265 --> 00:00:47.839
uses a venting under the hood,
whereas NgRx uses observable streams.

10
00:00:47.839 --> 00:00:52.040
But what's interesting

11
00:00:52.040 --> 00:00:57.040
about that is I am just going to

12
00:00:57.040 --> 00:01:01.648
pull up the notes feature.

13
00:01:05.927 --> 00:01:10.277
And what we have here is
a basic master detail view,

14
00:01:10.277 --> 00:01:13.931
the atomic building block of everything.

15
00:01:15.271 --> 00:01:20.847
And what I wanted to
point out that I think

16
00:01:20.847 --> 00:01:26.261
is absolutely incredible is that if you

17
00:01:26.261 --> 00:01:31.673
install the Redux DevTools in Chrome,

18
00:01:31.673 --> 00:01:37.087
you can instrument NgRx to essentially

19
00:01:37.087 --> 00:01:42.664
interface with the Redux DevTools, and

20
00:01:42.664 --> 00:01:48.094
you get a ton of valuable information.

21
00:01:48.094 --> 00:01:53.154
So I'm just gonna click over here,
and what you can see

22
00:01:53.154 --> 00:02:00.239
is it's capturing all of the actions
as it's going through the pipeline.

23
00:02:00.239 --> 00:02:03.209
This is really important.

24
00:02:03.209 --> 00:02:07.521
So I'm just gonna refresh this again,
because this is all local,

25
00:02:07.521 --> 00:02:09.439
it's very, very quick.

26
00:02:09.439 --> 00:02:14.334
But what I want you to notice
is that we're doing some

27
00:02:14.334 --> 00:02:19.349
initialization and
then we're calling Load Notes.

28
00:02:21.330 --> 00:02:26.736
And we're also resetting
the selected note,

29
00:02:26.736 --> 00:02:29.509
and more importantly,

30
00:02:29.509 --> 00:02:34.510
that we're getting a Load Notes Success.

31
00:02:35.810 --> 00:02:40.830
And, what this does is,

32
00:02:44.246 --> 00:02:46.835
You can actually see
the raw object coming in.

33
00:02:48.395 --> 00:02:53.425
And then you can see it as
it's being transformed into,

34
00:02:53.425 --> 00:02:58.562
essentially its IDs and and
entities, and I can probably

35
00:02:58.562 --> 00:03:03.713
zoom out just a little bit,
but I think you get the point.

36
00:03:03.713 --> 00:03:06.263
It's just taking it, dumping it out.

37
00:03:07.373 --> 00:03:14.189
But when you are trying to trace or
debug an application,

38
00:03:14.189 --> 00:03:19.475
being able to step forward and backwards.

39
00:03:19.475 --> 00:03:25.582
And I don't know if you can see
this on the left-hand side,

40
00:03:25.582 --> 00:03:33.175
but you can essentially go back to
a certain point and replay the actions.

41
00:03:34.965 --> 00:03:39.135
Again, from a observability

42
00:03:39.135 --> 00:03:44.153
standpoint, this is incredible.

43
00:03:44.153 --> 00:03:46.215
You can observe the action.

44
00:03:47.945 --> 00:03:51.305
The state,
you can actually observe the state diff.

45
00:03:52.565 --> 00:03:57.495
There's tons and tons and
tons of stuff that,

46
00:03:57.495 --> 00:04:02.183
You can do,
this as actually pretty fascinating.

47
00:04:02.183 --> 00:04:07.326
It looks like it's writing
some test stuff for you.

48
00:04:07.326 --> 00:04:11.608
Pretty cool.

49
00:04:11.608 --> 00:04:16.756
And, yeah,
just this alone is a huge, huge,

50
00:04:16.756 --> 00:04:24.940
huge I'd say force multiplier into
at least my development experience,

51
00:04:24.940 --> 00:04:30.616
because it's really handy
when you can see the data

52
00:04:30.616 --> 00:04:36.569
via an action stream flow
through your application.

53
00:04:36.569 --> 00:04:41.542
You can like, this is where I went wrong,
and you can actually step back

54
00:04:41.542 --> 00:04:46.355
in your application state and
replay that again, and see what happens.

55
00:04:46.355 --> 00:04:50.135
It's really, really neat.

56
00:04:50.135 --> 00:04:54.823
And I think when we're talking
about enterprise development,

57
00:04:54.823 --> 00:05:00.565
we also have to consider enterprise
problems and enterprise debugging, so.

58
00:05:02.659 --> 00:05:05.649
There we have that.

59
00:05:05.649 --> 00:05:07.734
So before I move on, any questions?

60
00:05:07.734 --> 00:05:08.889
Yes.

61
00:05:08.889 --> 00:05:13.395
&gt;&gt; Is this what you're dumping
into like LogRocket you said?

62
00:05:13.395 --> 00:05:18.091
&gt;&gt; Yes.
&gt;&gt; Are you pulling that out somehow to

63
00:05:18.091 --> 00:05:19.114
run it?

64
00:05:19.114 --> 00:05:27.651
&gt;&gt; What you can do is you can attach
a meta reducer to your main reducer.

65
00:05:28.921 --> 00:05:36.911
And essentially as they come in,
they go through the meta reducer first.

66
00:05:36.911 --> 00:05:39.581
So it's almost like an HTTP interceptor.

67
00:05:39.581 --> 00:05:45.466
And so what I was basically doing
is when there was an error,

68
00:05:45.466 --> 00:05:51.589
it would capture that error event,
but it was keeping track,

69
00:05:51.589 --> 00:05:55.907
essentially a stack of previous actions.

70
00:05:55.907 --> 00:06:00.443
And so here, the same thing's
happening is that you have a stack of

71
00:06:00.443 --> 00:06:03.121
actions that is essentially momento.

72
00:06:03.121 --> 00:06:08.663
So you're just stacking it in,
and so if there was an error,

73
00:06:08.663 --> 00:06:13.664
what I would capture is the last
previous good state and

74
00:06:13.664 --> 00:06:17.451
the action that fired the error.

75
00:06:17.451 --> 00:06:22.002
Then what I would do is go into LogRocket,

76
00:06:22.002 --> 00:06:26.943
pull that down,
sideload the good state in,

77
00:06:26.943 --> 00:06:31.000
and then play that action back.

78
00:06:31.000 --> 00:06:36.139
And I was able to essentially recreate

79
00:06:36.139 --> 00:06:40.320
the crime scene and replay it.

80
00:06:40.320 --> 00:06:45.273
I mean, there's a lot of things

81
00:06:45.273 --> 00:06:50.226
that we can do by moving state and

82
00:06:50.226 --> 00:06:56.280
business logic away from the component

83
00:06:56.280 --> 00:07:01.423
layer and into even an API layer.

84
00:07:01.423 --> 00:07:06.033
Which there's another talk
I gave where it was talking

85
00:07:06.033 --> 00:07:09.537
about how Angular is the thin client.

86
00:07:09.537 --> 00:07:13.809
And I was talking about how you can
actually take a series of actions and

87
00:07:13.809 --> 00:07:18.817
just replay them, and mimic complex human
interactions within an application.

88
00:07:20.197 --> 00:07:26.247
At the end of the talk,
the big reveal was that the reducer and

89
00:07:26.247 --> 00:07:29.805
the store was actually on node, and

90
00:07:29.805 --> 00:07:35.736
I was using web sockets to
communicate with the front end and

91
00:07:35.736 --> 00:07:42.093
then I pulled two browsers out,
and there's no local state.

92
00:07:42.093 --> 00:07:45.679
It's actually in this
remote server instance.

93
00:07:45.679 --> 00:07:51.726
And when I would do it here, it would
play the action and mirror it over here.

94
00:07:51.726 --> 00:07:53.050
Think about it.

95
00:07:55.396 --> 00:08:02.859
So, I think if you look on YouTube,

96
00:08:02.859 --> 00:08:06.975
components are the new thin client or

97
00:08:06.975 --> 00:08:10.710
something that I unpacked that.

98
00:08:10.710 --> 00:08:15.724
That was certainly part of
the paradigm shift of what does

99
00:08:15.724 --> 00:08:20.847
it mean when you pull state
away from the component layer?

100
00:08:20.847 --> 00:08:26.019
Well, suddenly you can manipulate time and
space in really novel ways.

