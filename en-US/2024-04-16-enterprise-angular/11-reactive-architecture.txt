[00:00:00]
>> Lukas Ruebbelke: So, how many people know what the Facade pattern is? I would wager you could probably infer a reasonable guess based on the fact that it's a Facade. Like, what it gotta be. It's like, tell me what the Phantom of the Opera pattern does. It's like, well, super creepy and likes to sing, and so, a Facade pattern is essentially a thin layer that
>> Lukas Ruebbelke: Interfaces between, I would say, two kind of distinct systems.

[00:00:52]
And
>> Lukas Ruebbelke: So for me, I quite like the facade pattern, because what it does is it allows me to abstract away the state management details of an application from the component layer. I, on principle, do not the believe that your components should know or care how your state management is being handled.

[00:01:32]
We certainly, and I'm trying to avoid going into this deep philosophical conversation, but if I suggested that we start shipping angular material with NgRx store baked into it, people would be like, absolutely not. We're not doing it. So, why would you not let angular material ship with NgRx store, but you'd have no problem putting it into your component layer?

[00:02:11]
I think that ultimately the difference is scale. And I think it's totally fine to say, we understand that we are coupling our component layer to NgRx, and that's a tradeoff we're willing to make. What I have a hard time with is that when somebody has heard from somebody that heard from somebody that the Facade pattern is bad, and then they're like, well, it's bad.

[00:02:42]
And you're like, but why? And it's clear that, at least in the conversations I've been, is that these individuals have not thought about the second and third orders of complexity of coupling their component layer to the NgRx store. And the one criticism that I will agree with is that a Facade, it's a delegation layer, period.

[00:03:12]
What I have seen is that developers have used it as like a junk drawer. Of like, well, I don't know where to put this logic, so I'm gonna throw it in the Facade, and that's bad. That approach is bad, that doesn't make Facades bad. Somebody drives the Tesla off a cliff, are they a bad driver?

[00:03:39]
Was it a bad thing that happened? Or is Tesla bad? So again, separating the mechanism, the institution from the execution. So, with that said, before we get into stage management, let's talk about just some very specific reactive example that I kinda wanna get out, and I think it is a pretty valuable tool in the toolbox.

[00:04:14]
So,
>> Lukas Ruebbelke: Before we get into, like I said, state management, we are going to approximate it with the Facade. So ideally, and it's a little bit, it's not quite as clean as I would have liked, but using the new standalone component API, but it's still pretty close. So, what I'm gonna do is I am going to generate a new library.

[00:04:54]
And I'm gonna call this challenges logo data, I'm going to put it in the appropriate folder, lives, challenges, local data. Standalone is false, and the project name and root format is as provided. Let me just,
>> Lukas Ruebbelke: Put my seatbelt on.
>> Lukas Ruebbelke: All right.
>> Lukas Ruebbelke: So, does anybody wanna take a guess at what this library is gonna do?

[00:05:45]

>> Lukas Ruebbelke: Local data, so, we are going to use this to essentially stub out and mock out what would appear to be a service, but we're only dealing with [COUGH] the data structure within the Facade itself. All right, so now what I'm gonna do, I'm gonna copy a bunch of stuff in here, I'm gonna paste it, and then we're gonna unpack it.

[00:06:27]

>> Lukas Ruebbelke: That's a little better. I must have zoomed that out. [COUGH]
>> Lukas Ruebbelke: Libs, local data.
>> Lukas Ruebbelke: I forgot something.
>> Lukas Ruebbelke: I need to generate a service real quick.
>> Lukas Ruebbelke: Data, data, data, all right, here we go.
>> Lukas Ruebbelke: Let's paste this in.
>> Lukas Ruebbelke: What do I call this thing?

[00:07:35]

>> Lukas Ruebbelke: Actually, it doesn't matter quite what I'm calling it, because I'm gonna change this in a second.
>> Lukas Ruebbelke: All right, so I'm doing this, I'm creating a service that It looks like a
>> Lukas Ruebbelke: [INAUDIBLE] I should have done this and called it local state.
>> Lukas Ruebbelke: So let me actually just change that real quick.

[00:08:27]

>> Lukas Ruebbelke: Service, service, service.
>> Lukas Ruebbelke: There we go.
>> Lukas Ruebbelke: Well, what the heck?
>> Lukas Ruebbelke: All right, that's fine, I can make this work.
>> Lukas Ruebbelke: All right, so, within the services here, and what I'm actually gonna do, just cuz this is gonna bother me.
>> Lukas Ruebbelke: Well, we'll just leave it for now.

[00:09:41]
All right,
>> Lukas Ruebbelke: So I'm going to just rename this, because what we're actually doing is
>> Lukas Ruebbelke: creating a Facade
>> Lukas Ruebbelke: And normally, I'd have put this in the state limb, but.
>> Speaker 2: I think you have one in the state limb.
>> Lukas Ruebbelke: Do I?
>> Speaker 2: Yeah, that's where I was.

[00:10:12]

>> Lukas Ruebbelke: Yes, I do.
>> Speaker 2: Yeah, and it's all there.
>> Lukas Ruebbelke: I don't mind, I wanna play my hand.
>> Lukas Ruebbelke: Let's do
>> Lukas Ruebbelke: All right, let's do this. Let's operate under this one, and I'm gonna just
>> Lukas Ruebbelke: I'm gonna just pretend that I just generated this.
>> Lukas Ruebbelke: Good call out.

[00:10:46]
It's the lesson I did before I left the hotel this morning. All right, so, what I've done previously, generated changes, local, Facade, and this is in the state folder. So, I apologize that was a little abrupt, but thanks to the power of pair programming, we got that fixed.

[00:11:09]
So, what I wanna do is, I want to create a file that is essentially serving as an interface to NgRx, or that's typically what I use it for. So in the feature Facade, which we'll talk about in the next module. But the point is that we have state management, how the component communicates with the rest of the application is through the Facade, which then gets delegated out to the store.

[00:11:48]
So you can see here, we are injecting a lot of NgRx stuff into the Facade, and the Facade is dispatching all the actions and all the different things. So, in the local Facade, is we want to achieve that same or simulate that same interaction without NgRx. So it has the same interface, remember we talked about contracts and programming to contracts as interfaces?

[00:12:19]
And so here, what I can also say is if you go and you look at challenges state, I have a Facade that you can compare against, right here. So I basically have to create a version of this without NgRx. Thus it's a Facade, it's a fake version of it.

[00:12:45]
So, I've generated some mock data, mock challenge, and I have a challenge, local Facade. Now what I'm doing is, I'm using a behavior subject to essentially manage the state and memory. So, a subject is a mechanism that will emit data as it becomes available, a behavior subject is a subject that remembers state or behavior.

[00:13:27]
And so, it basically was funny cuz when Redux- Isn't there other ways to do that though, with the state management, like little things, like input output in listeners for sharing values across states, like different pages or components?
>> Speaker 2: I don't like using input or output or listeners, I rely on behavior subject all the time, almost too much.

[00:13:57]
Can you be using it too much?
>> Lukas Ruebbelke: Yes.
>> Speaker 3: [LAUGH]
>> Lukas Ruebbelke: Yes, sir. I mean, you kind of encoded the answer in the question. So, just a quick save and get this done in 30 seconds, is that
>> Lukas Ruebbelke: Observables handle state in a, essentially, a microtransaction level. Here's this data, and I wanna move from here to here, I wanna manage state within the observable stream, and I want it to come out the other side, and I want it to be in some shape.

[00:14:38]
So, I think of it at a micro level, this is where an observable comes in. I mean, literally, in the stream, it's called an observable stream as you're protecting that data and transporting it from one place to another, and then transforming it if you need to.
>> Lukas Ruebbelke: At a medium level, I think, is this is where you have, inputs and outputs from a parent component to a child component, is that state is flowing down into the child component.

[00:15:14]
When something happens in the child component, it fires an event and it bubbles up to the parent component to be delegated and taken care of. And so it's like my nine-year-old coming to me and saying, the 13-year-old hit me, go punish him. It's kind of that equivalent of, this thing happened, go take care of it.

[00:15:37]
At a macro level, this is where the NgRx store comes in. An observable is not appropriate to manage application state, it's very good for managing a transaction state. Inputs and outputs Are good for measuring presentation state. This is where signals come in. Signals are just very, very lightweight observables.

[00:16:13]
If I just need to signal efficiently, something happened, you need to know about it. This is where signals come in, that it's just, I think of signals, and I've talked to a lot of the Angular folks about this. Conceptually, I believe that signals are for presentation state, NgRx is for application state.

[00:16:40]
You do not need NgRx to manage what buttons are visible on a page. This is where signals come in. So if you're using it to manage temporal presentation state, signals are great, as well as inputs and outputs, it's a part of that. So for me, I think of when you have the kind of container presenter model or Spark DOM, and you don't tell, it was canceled, is that I think of, this kinda goes back to the domain model in the future slides, is that it all kind of just lines up.

[00:17:21]
Is I try to have large container modules that interfaces with the facade that's hooked to NgRx. From the container module to the presenter module, it's inputs and outputs.
>> Lukas Ruebbelke: Within any of the components, so I said module, but container-presenter component, is that any transaction that happens, this is where, depending on the level of the transaction, it's RxJS or it's a signal.

[00:18:07]

>> Lukas Ruebbelke: Does that make sense?
>> Speaker 2: Yeah, the only part of that I'm a little foggy is that whole listener kind of scenario where you need some sort of event to make this show up over here in a different component like a trigger, or a host listener, or whatever.

[00:18:28]
Event emitter, that's the one.
>> Lukas Ruebbelke: Right, so that's an output, I mean.
>> Speaker 2: Technically, yeah.
>> Lukas Ruebbelke: And so again, following, I said it previously, but this is a good opportunity to reiterate it. Is that if you have two adjacent mechanisms that have a shared interest in something, what you need to do is you need to promote that shared thing to the next available abstraction layer that the two adjacent siblings have access to.

[00:19:09]
So a good example, and I think we'll get to it, is I'm a huge fan of master-detail view layouts. And so if you've ever seen any of my workshops, I mean, everything at the end of the day is a master-detail view. When you look at your email, Facebook, Twitter, whatever, is that you have a list of a collection of items.

[00:19:35]
And then you select one, and then in the Detail View, you're able to see those details and then you can either update it, modify it, etc. And so what that looks like,
>> Lukas Ruebbelke: I'll Just veer over here real quick, and then we will get back on track, I promise.

[00:19:59]

>> Lukas Ruebbelke: So here is good example, that when I select an item in the List View, the Detail View has an interest in what that is, but they don't know about each other. All the List View knows is that I'm sending you a list of challenges to render. And if any of your challenges are selected or deleted, let me know.

[00:20:33]
But aside from saying it's deleted, it just say, let me know if these buttons are clicked. So when you hit Select, in this case, I'm whipping around to the store and back down, is this is just saying, I've got a challenge, render it. And so this is how this is being selected.

[00:20:55]
And so they don't know about each other, because one's delegating,
>> Lukas Ruebbelke: To the layer just above it. Things are happening. I mean, these two components have no idea what's actually happening that they went up, up, up, up, up into the NgRx store and back down. This works, because Angular is built to be reactive, that instead of us pulling information, we're able to push it to interested parties so that they can respond.

[00:21:33]
So its observables typically going into the container component, which then is being then passed down via binding, which binding under the hood is nothing more than an event mechanism. So if you actually went and looked, it's just a venting that they've just hid really, really well. So now, back to this.

[00:21:57]
And the reason why I like this is inputs and outputs essentially are separating command and query. So in a facade, what you have is you have your queries. This is what I want from the store. This is what I need to hydrate my template. Instead of using the store, we are essentially using the BehaviorSubject as a micro store.

[00:22:25]
If you go look and dig through the API, under the hood, it is some form of a BehaviorSubject. So what's really funny to me is that people that don't like NgRx because they think it's too heavy, and instead want to get religious about using a service with a subject, I think it's funny to me that it's like, I'm a huge fan of a service with a subject.

[00:22:59]
It's called the NgRx Store. The difference is, I'm happy with one, and for some reason, you hate them so much, you need 20 of them. And again, I'm totally fine with it. It's just I think sometimes people are a little bit disingenuine about where they're coming from or they haven't thought about it.

[00:23:18]
So anyways, sorry, I'm not trying to be offensive. It's, I've just had some very emotional arguments that was completely and logically inconsistent.

