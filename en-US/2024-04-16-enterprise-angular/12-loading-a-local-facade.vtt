WEBVTT

1
00:00:00.142 --> 00:00:03.464
What we're doing, our behavior subject,

2
00:00:03.464 --> 00:00:07.071
we're exposing the observable
portion of it.

3
00:00:07.071 --> 00:00:13.142
So this right here completely matches,

4
00:00:17.202 --> 00:00:21.768
This right here, loaded allChallenges,
selectChallenges.

5
00:00:21.768 --> 00:00:24.021
I think this is important, right?

6
00:00:24.021 --> 00:00:28.775
Within these methods, I'm just

7
00:00:28.775 --> 00:00:34.038
manipulating this data structure,

8
00:00:34.038 --> 00:00:40.318
and then updating
the subject to emit the new

9
00:00:40.318 --> 00:00:46.103
value back out to the interested party.

10
00:00:46.103 --> 00:00:49.325
Now, I think this is right,

11
00:00:49.325 --> 00:00:54.697
I haven't tested it,
but the concept stands,

12
00:00:54.697 --> 00:00:59.934
is that this has the same
exact API as the Facade

13
00:00:59.934 --> 00:01:04.520
that I would use to interface with NgRx.

14
00:01:04.520 --> 00:01:11.726
Now, the difference is that in
the local Facade it's all in memory,

15
00:01:11.726 --> 00:01:17.939
I don't have any dependencies
outside of that other than,

16
00:01:17.939 --> 00:01:21.686
obviously, the behavior sub hit.

17
00:01:21.686 --> 00:01:26.680
So, now the question is,

18
00:01:26.680 --> 00:01:31.901
what to do if I wanted to load

19
00:01:31.901 --> 00:01:36.443
this into Challenges.

20
00:01:36.443 --> 00:01:41.748
I believe that I would come up into,

21
00:01:44.707 --> 00:01:47.891
This remote entry here, and

22
00:01:47.891 --> 00:01:52.932
this is the beauty of
dependency injection,

23
00:01:52.932 --> 00:01:59.046
is that I'm able to say here
is the challenges Facade.

24
00:01:59.046 --> 00:02:04.304
But instead of using
the real growing-up version,

25
00:02:04.304 --> 00:02:07.896
I want you to use this logo version.

26
00:02:07.896 --> 00:02:09.429
This is how testing works in Angular.

27
00:02:09.429 --> 00:02:12.713
This is the whole point.

28
00:02:12.713 --> 00:02:16.277
I think React is a great framework, but

29
00:02:16.277 --> 00:02:21.461
the one thing that I wish it
had was inversion of control or

30
00:02:21.461 --> 00:02:24.704
dependency injection mechanism.

31
00:02:24.704 --> 00:02:27.851
Because, and
you may be able to do this in React, so

32
00:02:27.851 --> 00:02:32.406
if somebody knows, hit me up, this is
the one thing that I struggle with.

33
00:02:32.406 --> 00:02:38.200
Is that, the ability to wire
up things like this is,

34
00:02:38.200 --> 00:02:42.294
I think, so clever and so powerful.

35
00:02:44.810 --> 00:02:49.047
So now, just wanna make sure I
don't have anything running.

36
00:02:52.872 --> 00:02:54.239
I really hope this works.

37
00:03:02.210 --> 00:03:07.735
So, what I'm doing here is, I'm loading

38
00:03:07.735 --> 00:03:13.413
the entire Challenges feature, which is,

39
00:03:13.413 --> 00:03:19.557
it's a JSON server and
it's the frontend app.

40
00:03:19.557 --> 00:03:24.488
So, in the JSON server, and

41
00:03:24.488 --> 00:03:31.474
I hope we talk about it, if we have time,

42
00:03:31.474 --> 00:03:37.432
is I just have a JSON structure with

43
00:03:37.432 --> 00:03:42.990
five challenges in it, right?

44
00:03:42.990 --> 00:03:47.544
So this is what I should be loading, but

45
00:03:47.544 --> 00:03:51.274
this is not what we're saying.

46
00:03:51.274 --> 00:03:52.711
Why is this happening?

47
00:03:52.711 --> 00:03:57.835
Well, what I'm going to do is I'm gonna

48
00:03:57.835 --> 00:04:04.618
just take this off screen,
I'm gonna make a change,

49
00:04:04.618 --> 00:04:10.647
and then I'm gonna put
it right back on screen,

50
00:04:10.647 --> 00:04:13.982
and we will observe this.

51
00:04:13.982 --> 00:04:15.449
Do you see that?

52
00:04:15.449 --> 00:04:16.381
What did I do?

53
00:04:23.376 --> 00:04:29.014
I think,
maybe because I don't do this a lot,

54
00:04:29.014 --> 00:04:34.075
but this is, in my opinion, probably one

55
00:04:34.075 --> 00:04:39.570
of the cooler things
that we've seen today,

56
00:04:39.570 --> 00:04:43.763
because all I'm doing is I'm just

57
00:04:43.763 --> 00:04:49.029
turning, This on and off.

58
00:04:49.029 --> 00:04:53.632
So, I'm basically overriding
the injector with a local injector.

59
00:04:59.347 --> 00:05:06.137
So once I inject it, what I'm able
to do He's essentially approximate,

60
00:05:06.137 --> 00:05:11.954
the entire State Management layer
with a single Local Facade.

61
00:05:11.954 --> 00:05:15.809
That because it's all observables and

62
00:05:15.809 --> 00:05:19.896
I haven't tested the functions yet, but

63
00:05:19.896 --> 00:05:24.797
I have every reason, like,
it'd be easy to fix,

64
00:05:24.797 --> 00:05:30.556
is that, imagine now you
wanna do end-to-end testing.

65
00:05:30.556 --> 00:05:34.409
And you don't actually wanna hit a server.

66
00:05:34.409 --> 00:05:36.309
Well, there's ways to override that.

67
00:05:36.309 --> 00:05:41.896
This is how the proxy works,
is that we can,

68
00:05:41.896 --> 00:05:47.483
if we agree on a contract,
we can hydrate our

69
00:05:47.483 --> 00:05:53.535
component layer without
ever touching an API.

70
00:05:53.535 --> 00:05:57.585
And your component layer has no idea, and

71
00:05:57.585 --> 00:06:01.867
this is why I think Facades are so
powerful,

72
00:06:01.867 --> 00:06:08.600
Is because it decouples your
component layer from everything else.

73
00:06:08.600 --> 00:06:14.212
And your component layer has no idea,
other than that there's a Facade,

74
00:06:14.212 --> 00:06:17.120
that it's using a store, anything.

75
00:06:17.120 --> 00:06:22.227
Does anybody have any
questions about the blasphemy

76
00:06:22.227 --> 00:06:26.880
that I've just unleashed
onto this workshop?

77
00:06:26.880 --> 00:06:32.027
&gt;&gt; So, here are you, is the point
of the local Facade essentially

78
00:06:32.027 --> 00:06:38.050
that you're agreeing on a contract,
but you have not built out the NgRx,

79
00:06:38.050 --> 00:06:44.873
like, if we are in a world that we hadn't
built out the NgRx facade, essentially?

80
00:06:44.873 --> 00:06:46.148
You have both right now, so

81
00:06:46.148 --> 00:06:49.706
that's where I was trying to understand
what's the point of the local one.

82
00:06:49.706 --> 00:06:54.795
&gt;&gt; So,
I'm just showing that you can flip them,

83
00:06:54.795 --> 00:06:59.364
that they are functionally equivalent,

84
00:06:59.364 --> 00:07:06.425
other than the level in which
that state change is propagating.

85
00:07:06.425 --> 00:07:12.440
One of the other reasons why I like
the facade is because it creates a nice

86
00:07:12.440 --> 00:07:18.669
division of labor within a development
team, which nobody talks about.

87
00:07:18.669 --> 00:07:23.467
I have worked a lot
with junior developers,

88
00:07:23.467 --> 00:07:27.878
that they, from a skill-standpoint,

89
00:07:27.878 --> 00:07:32.431
are effective building out components.

90
00:07:32.431 --> 00:07:36.852
But they are not quite
ready to handle more

91
00:07:36.852 --> 00:07:41.665
complicated things like State Management.

92
00:07:41.665 --> 00:07:46.636
So, not only does the Facade
allow me to decouple the frontend

93
00:07:46.636 --> 00:07:51.894
from the backend, it allows me to
decouple the component layer so

94
00:07:51.894 --> 00:07:54.873
my junior developers can work on it.

95
00:07:54.873 --> 00:08:00.177
While my senior developers can go and
work on the hard stuff,

96
00:08:00.177 --> 00:08:05.068
which is,
really it's asynchronous business logic.

97
00:08:05.068 --> 00:08:08.939
I think it's the hardest thing
technically to get right.

98
00:08:08.939 --> 00:08:12.934
It's the division of the conceptual model,
but

99
00:08:12.934 --> 00:08:18.007
also the division of labor to
achieve the outcome as a result.

