[00:00:01]
>> Homestretch. I wanna talk about two things, and it'll probably be a ratio of one to two-ish or three-ish. The first thing I wanna talk about is, Standalone components and the standalone API. Admittedly, when I first started playing around with it, I'm like, what's this about? I don't feel like we've actually solved problems, that I think sometimes it's like a kid who doesn't want to eat their vegetables for dinner, and what they do is they just kinda push it around.

[00:01:02]
And I think sometimes as engineers, that's what we do, is we're just like, I don't wanna deal with this and let's push it onto the server. Let's push it onto Q&A or whatever. And with that said, I think the standalone API, which is moving Angular in the right direction from the sense of it allows us to do a lot more dynamic composition, because we're shifting the focus onto components and routes, specifically on routes.

[00:01:46]
And the ability to inject providers into the routes as you load them and compose the context in which a component is being rendered at runtime is, I think, very powerful. And I think we're just starting to see some of the interesting things that we can do with this.

[00:02:21]
So for me, I'm warming up to the standalone API. I believe that the advantage of it is that it allows us to do more things at runtime. I think that what we are seeing is a module was, I think, a good mechanism for creating kind of boundaries. And so one of the things with, even JavaScript or TypeScript moving into a kind of more of an OOP, object-oriented programming, kind of a paradigm.

[00:03:11]
That I was originally concerned about it because I personally, I think that stylistically I leaned towards more functional programming. And so I'm like, great, we're turning JavaScript into Java, which is funny, because Java, they're trying to be dynamic and closure. And it's kinda funny, it's like we're going in these circles.

[00:03:39]
But the way that I was able to resolve that cognitive dissonance is that objects represent reality, we live in a world of objects. And as an organizational mechanism, objects and modules are a great sense-making device. And I think where we deviate from reality is when we start doing things like inheritance because that just doesn't happen in the real world the way that happens in code.

[00:04:22]
And you just have to be really careful about that. And I realized that just because you can do something doesn't mean that you're going to, and so, yes, I acknowledge that I can do inheritance in JavaScript. And I can write JavaScript like Java, but I don't have to.

[00:04:51]
So I think as an organizational mechanism it was fine. The problem is that it is by nature a static stationary construct within the app, and the standalone API just gives us some more options at runtime, which I like. And one of the things that I like as well, and I'll flesh this out, is that you can write very, very portable pipes, directives, interceptors that you're no longer having to go and register those with the module.

[00:05:42]
And I think this is where people at the disconnect was, is that I wanna put it into this thing here, why do I gotta go register it and come back down? It sounded like you show up in a town and you gotta drive across town to check in with the magistrate, it doesn't make sense.

[00:05:58]
So that was just a little bit of a thought on that. I think that anybody new to Angular who's maybe hasn't done it for a while and they're coming back or they're just starting, it's definitely a paradigm shift. I also have it on good authority that we haven't fully seen everything that's possible.

[00:06:26]
And so I have the benefit of being able to interface with the Angular core team and the different ones. And there's some really, really cool stuff coming down the pipeline, and they've done a good job of looking forward and really seeing where the technological landscape is and kind of what's on the horizon and making good choices for that.

[00:06:50]

>> As far as standalone components, they can be intermixed with regular components?
>> Yep, the interop is seamless, that you can put static modules into standalone components and standalone components into static modules.
>> So maybe you created some kinda utility component that was standalone, just has a specific job or something.

[00:07:21]
You sent directives or whatnot or pipes or something, no longer do you have to go into the app module and make a reference there?
>> Yep, in some cases, well, the other thing is, And we saw this with observable operators, is that it's funny to me that most of the time when we talk about RSJS, there's a lot of people that are like, ooh, that's tough.

[00:07:56]
But really, what I think they're getting hung up on is, are they talking about the observable stream or the 323 operators that exist, and it's not actually, I think it's like 120 something. And, [COUGH] when Angular first started using observables, you would just pull everything in, you just import it.

[00:08:24]
And I think that created a lot of problems, it was very heavy. And I am a fan of if you're going to use an operator or use something, be explicit about it, be intentional about it. And so with the standalone API, there are things that you have to pull in to your component that before just came in with a common module.

[00:08:48]
But the upside is you're able to pull just that thing in and not all the other things, and so I would give it a, I think it's something that's interesting. I'm not over the moon in love with it, not like observables, but I do think there are some good reasons, and it doesn't offend me to the point I'm like, I'm not using this, this is crazy.

[00:09:17]
It's pretty painless, and they've done a pretty decent job of creating some migration paths for that as well.
>> One tiny more question, one more question. Is there a default when you create a new component of standalone or not standalone?
>> Standalone is now the default.
>> So don't you find that strange if, I do anyway, that standalone would kinda be a one-off, why it would be the default, or am I not thinking right mind?

[00:09:49]

>> Well, I think, especially if it's a one-off, you wouldn't want to anchor it unnecessarily to the rest of the application context. So if I had a details component, I wouldn't need to go and register that up at the module, I can just register it at the consuming.

[00:10:14]

>> Okay, yeah, yeah, I get it.
>> So it's a little bit more wiring up, but it's for a reason, and what ultimately it does is it allows for a better signaling of intention. And more importantly, that you're not doing these, so for instance, if I just imported all of RSJS, you don't know what my intentions are.

[00:10:43]
I've just imported like 120 operators, versus if I do from and of, or whatever, you'd have a pretty good idea of what I'm up to, so a minimum, I think it's good signaling

