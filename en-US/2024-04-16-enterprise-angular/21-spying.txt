[00:00:00]
>> One of the important things about testing is that you only test what the function does. Nothing else, if you're testing a service that calls HTTP client, you're not testing HTTP clients ability to do its job, there's test for that. So if I were looking at, Let me see here.

[00:00:40]
What does this method right here, what does it do? Just read it out loud and you'll probably get a pretty good hint.
>> Returns-
>> Return the action.
>> Challenges.
>> Yeah, so, it's loading challenges, right? What is it actually doing in the function?
>> Calling the API.

[00:01:13]

>> Yeah, it's calling dispatch. And so, if we are going to test just what this function does, What do we verify?
>> That we got a 200.
>> No, not even that. It's when I call load challenges, I need to just verify that the load challenges action was dispatched.

[00:01:40]
And actually not even that, I need to verify that this function load challenges called dispatch with this object, that's what I verify. Cuz that's all it's doing, is you're just testing has it delegated correctly. And when you have functions that appear and you are avoiding any kind of transformation logic in it, they're very easy to test.

[00:02:12]
And I believe that, I wanna say probably 70 to 80% of your code, if you do it correctly, you're just testing the delegation mechanism because-
>> Just the call.
>> Just the call.
>> Yeah, but does the test runner have a quick pass, fail, yes, no, yes, no, yes, no?

[00:02:34]

>> I mean, so okay, back to the spec. What we're doing here is we're spying on dispatch. We are creating a fake action, so arrange a cert test, and we are saying that when we call selectChallenge that it should have been called with this action. Loadchallenges on load.

[00:03:15]
So this is exactly right here. So what are we spying on, dispatch. And we're saying when we call loadChallenges that we expect that, The spy was called with this action. That's it.
>> [COUGH] So you're coding is pretty minimal of the unit test harness. You have to get good at expect statements and things like that.

[00:03:44]
It's a one liner, right?
>> I try very hard to make my code as small and precise as possible because this is very, very easy to test. Arrange. Act, and even I have some arrange happening underneath of it, so it's not written in stone. But it's just arrange, act, assert.

[00:04:12]
But ideally, you're looking to test typically one statement within the function. So we talked about mocks, spies. That's the provide mechanism with use value, use class, use object. The next piece, if your functions are small enough, all you're doing is spying on the function that's being called inside the function.

[00:04:47]
Really, really, really simple and I can say for somebody who has been victimized and traumatized from bad tests that I'm learning, and I'm just healing in my heart to learn to love tests like this, cuz it's really quite simple.
>> And you use the built-in spec file with the Just command then.

[00:05:23]

>> Yeah, so we're using Just as the test runner and which I believe is built with whatever assertion they have. So let's look at, Maybe just a few more, because I think that just that piece right there, if we can just converge on that. How do you satisfy dependencies?

[00:05:54]
How do you spy on functions? You are light years ahead and a lot of times the reason why people have a really, really hard time writing test is because they're trying to test something that's not really testable so, What do you think we're testing here? This will be the last one.

[00:06:27]
And then I will leave you to, Go explore this application and the website and-
>> See if it's in the endpoints.
>> Not that it's hitting it.
>> That is calling it.
>> That's calling it, as if you have a function that's calling another function. You just have to validate that the delegation has happened.

[00:06:54]
And that is conceptually a lot easier than when you have a method that's doing 22 things. It's impossible. I wouldn't even try. The Angular team has actually even done a good job of providing a testing module, a testing controller, and This is a little interesting because it is asynchronous, that there's this flush method that you make a call.

[00:07:39]
And what we're doing is, in this case. We're kind of doing two things here. And I'm going to permit it because this is, I think, what has been prescribed. But we're calling it and this right here I think we could do without, but it's here so I'm not gonna rip it out.

[00:08:03]
But what I really care about is, well, I think what's happening is that we're calling service.all, and so we have to call the method, so we may as well validate the result in some way. That's fine, I think we probably don't need to do that but it kind of in a way contradicts a little bit what I'm saying.

[00:08:31]
But I would not throw a chair through a window if somebody did it. It's just, I would say, do you really need to do this right here? I think, if anything, we just need to call it. Well, the one thing I, actually, let me back up. So because subscribe or observables are lazily instantiated, is that you have to call.

[00:08:59]
And so you're getting a result anyways. So I think at this point, it's like, well, let validate it. But here, we called it and we're saying, hey, we expected one call to this URL. So we're saying this is the expectation, this is what we expected the request to be, and then we're calling flush, which essentially, it basically simulates an HTTP call.

[00:09:34]
And from there, we're validating it.

