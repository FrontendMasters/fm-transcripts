[00:00:00]
>> Could you elaborate a bit on the host remote generations Nevets?
>> This is a guide within the NX documentation. And I think they do a pretty good job of explaining a lot of these concepts. But I would say any gaps that I leave, by all means, I'd go check out this particular article, and do this actually say who wrote this?

[00:00:38]
Neither here nor there. So let's just take a quick tour of this. Conceptually it's a little bit much and I will be the first to admit that it took me a couple days of kinda staring at it, and thinking about it for it to become kinda natural, and I'm still warming up to it.

[00:01:00]
So, how this works is that, let's start with the remote. So, we have a remote that is sessions, and within this, We have a ModuleFederationConfig. So this is pretty important. The ModuleFederationConfig essentially says, I want to attach a name just like a route, to, like this name exposes this, let me see if they actually, Exposes a record that says at this name, at this place, we are going to load this routing table, or this remote entry point.

[00:02:07]
Then from there, if we go into the entry routes here, This is saying we have a route that's just going to load the RemoteEntryComponent. So by convention, remote applications have this remote kind of entry point where you have your remote entry routes and your RemoteEntryComponent. Now, this allows you to, on the routes and on the component, Load any kind of dependencies that you need for the rest of that component and everything underneath of it, in a very distinct way, because you can actually have more than one entry point into a component.

[00:03:11]
So you could, in theory, load this ns-welcome component directly into the app. And this happens is what if you wanna load this into another app, but maybe you wanna load a portion of it into the app that it lives is that the remote entry point allows you to set context specifically to the federated module mechanism.

[00:03:44]
So this is how this works on the remote side, is that we have this ModuleFederationConfig that's just saying, hey, this is what you need to look for. But for sessions and we're exposing this via webpack, and it's pointing to these routes. Now, if we go to, just close this down, our host, this is a little bit different in that, initially, what we had was in our FederatedConfig, we had a name and we were statically defining our remotes.

[00:04:37]
But ultimately, unless you're doing a very simple app, I think you want this to be dynamic. In the assets folder, which is around here somewhere we created a manifest, and you can have n number of records in this. So instead of pointing to a routing table that points to a module you are pointing to an n point that you expose in the main.ts in the host.

[00:05:18]
So in the host, you are going and loading the manifest. You're parsing it and then you're saying, take these records, and create remote definitions. And so this is an asynchronous thing, that happens before you get down to line 6, which is, then you bootstrap the application. The last little piece to this is in your host application instead of doing loadChildren, because this is now a remotely defined n point, you need to wrap the insides of this function with loadRemoteModule.

[00:06:16]
So, there is just a handful of moving pieces, pretty small, a lot of it is actually generated by the CLI. I think with this, what's a little bit confusing is you are only changing five lines of code, it seems like. You're just doing it in five different files.

