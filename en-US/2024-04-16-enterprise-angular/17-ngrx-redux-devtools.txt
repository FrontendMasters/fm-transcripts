[00:00:00]
>> There was a question previously about how comparable or comparable is NgRx to Redux inside of React, and the answer is they're heavily influenced. In fact, I believe, to the best of my knowledge, that NgRx is basically Redux compliant. That the APIs that Redux has, that they map for the most part to NgRx.

[00:00:36]
I think the difference is that Redux, if I'm not mistaken, uses a venting under the hood, whereas NgRx uses observable streams. But what's interesting about that is I am just going to pull up the notes feature. And what we have here is a basic master detail view, the atomic building block of everything.

[00:01:15]
And what I wanted to point out that I think is absolutely incredible is that if you install the Redux DevTools in Chrome, you can instrument NgRx to essentially interface with the Redux DevTools, and you get a ton of valuable information. So I'm just gonna click over here, and what you can see is it's capturing all of the actions as it's going through the pipeline.

[00:02:00]
This is really important. So I'm just gonna refresh this again, because this is all local, it's very, very quick. But what I want you to notice is that we're doing some initialization and then we're calling Load Notes. And we're also resetting the selected note, and more importantly, that we're getting a Load Notes Success.

[00:02:35]
And, what this does is, You can actually see the raw object coming in. And then you can see it as it's being transformed into, essentially its IDs and and entities, and I can probably zoom out just a little bit, but I think you get the point. It's just taking it, dumping it out.

[00:03:07]
But when you are trying to trace or debug an application, being able to step forward and backwards. And I don't know if you can see this on the left-hand side, but you can essentially go back to a certain point and replay the actions. Again, from a observability standpoint, this is incredible.

[00:03:44]
You can observe the action. The state, you can actually observe the state diff. There's tons and tons and tons of stuff that, You can do, this as actually pretty fascinating. It looks like it's writing some test stuff for you. Pretty cool. And, yeah, just this alone is a huge, huge, huge I'd say force multiplier into at least my development experience, because it's really handy when you can see the data via an action stream flow through your application.

[00:04:36]
You can like, this is where I went wrong, and you can actually step back in your application state and replay that again, and see what happens. It's really, really neat. And I think when we're talking about enterprise development, we also have to consider enterprise problems and enterprise debugging, so.

[00:05:02]
There we have that. So before I move on, any questions? Yes.
>> Is this what you're dumping into like LogRocket you said?
>> Yes.
>> Are you pulling that out somehow to run it?
>> What you can do is you can attach a meta reducer to your main reducer.

[00:05:28]
And essentially as they come in, they go through the meta reducer first. So it's almost like an HTTP interceptor. And so what I was basically doing is when there was an error, it would capture that error event, but it was keeping track, essentially a stack of previous actions.

[00:05:55]
And so here, the same thing's happening is that you have a stack of actions that is essentially momento. So you're just stacking it in, and so if there was an error, what I would capture is the last previous good state and the action that fired the error. Then what I would do is go into LogRocket, pull that down, sideload the good state in, and then play that action back.

[00:06:31]
And I was able to essentially recreate the crime scene and replay it. I mean, there's a lot of things that we can do by moving state and business logic away from the component layer and into even an API layer. Which there's another talk I gave where it was talking about how Angular is the thin client.

[00:07:09]
And I was talking about how you can actually take a series of actions and just replay them, and mimic complex human interactions within an application. At the end of the talk, the big reveal was that the reducer and the store was actually on node, and I was using web sockets to communicate with the front end and then I pulled two browsers out, and there's no local state.

[00:07:42]
It's actually in this remote server instance. And when I would do it here, it would play the action and mirror it over here. Think about it. So, I think if you look on YouTube, components are the new thin client or something that I unpacked that. That was certainly part of the paradigm shift of what does it mean when you pull state away from the component layer?

[00:08:20]
Well, suddenly you can manipulate time and space in really novel ways.

