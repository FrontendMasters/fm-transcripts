[00:00:00]
>> In our application, there's really kinda four distinct domains. A lot of times, these will manifest in the form of features. So it's very common that features kind of wrap around specific kind of domain boundaries. And so for us, we have a user domain which has a conceptually distinct set of tasks and things they do.

[00:00:33]
We have challenges, flashcards, and notes. And the idea is that when you're building an application, you wanna properly segment your domains in a way that they're not dependent on each other. At the same time, they can still communicate in a meaningful way. And one of the things I've been doing, quite a bit of microservices over the last two years and the concept of every microservice has its own data source.

[00:01:11]
The first time I heard that, I'm like, what are you talking about? That's madness. But then I realized that when you have a single database with a bunch of data models in there and somebody needs to make a change in one place, you can have a just an incredibly disruptive effect across the entire database.

[00:01:32]
Now, a separate database per endpoint is there's a cost that comes with it. There's a really good microservices book, there's a honeycomb and a beat or something on it. And I think it's Sam Newman, whoever, he spends a lot of time talking about, there are trade-offs to do this.

[00:01:53]
Enterprise is that there's a certain scale where that's when it makes sense to go on that direction. But even though maybe we're not in the enterprise, we can still be enterprising. And so with that, we have our kind of four domains. And the idea is that within the domains that we are going to build an app or apps that capture specific parts of the domain, but we're going to try to do it in a way where each app in each feature slice is uncoupled from the other feature.

[00:02:40]
And this is really important that you're gonna have a user's team that's working on the user's feature and they wanna deploy the app or they wanna deploy their endpoint. Well, they can do that and they don't have to go ask the challenges team if it's okay to do that.

[00:02:59]
And so I think the big takeaway here is I want to just, Encourage everybody to think about their domain and then start to think about, in a very disciplined way, what it would take to keep those separated. And this is my goal by the end of the day is if we understood how to spin up a feature alongside other features without blowing the whole thing up or it's completely independent decoupled but you can still operate in a meaningful way, that would be a big win for me.

[00:03:43]
So the goal today is that we understand how to build a feature within a larger application. One thing that we have to talk about, and this is incredibly important. You have to have a data contract. So first and foremost, it comes to having an understanding of the domain.

[00:04:07]
And then you must agree on a data contract or a data model in which everybody is going to adhere to. Because what happens, and I don't know if anybody has experienced this, but you have the frontend team that they're working at a certain cadence, and then you have the backend team and they're working at a much different cadence.

[00:04:35]
Usually, what I've seen is you have one frontend team working on a feature and you have a backend team working on a dozen API's. And it's very, very common that you have one side or the other sitting around and saying, well, we can't build this because we're waiting for the API, or we can't do this because of this.

[00:05:00]
When you have a data contract, you decouple the frontend from the backend, because everybody is in agreement about what is coming across the wire. And so one of the things we're gonna see today is once you're in agreement on the data contract, then the frontend team could mock out data to that contract.

[00:05:29]
The backend team, they know what their target is. And I've been in situations where we had a contract, we built it out, the frontend. And when API was ready because it was to the contract, you just flip the switch, point it to the live endpoint and it just works because you're programming to a contract.

[00:05:54]
Usually what I do, and I'm not gonna go get the whiteboard and pull it out here and we're not gonna do that. But you'll sit on the whiteboard and you'll endeavor to understand the business domain and how things communicate and what are the events that cause things to happen within the domain.

[00:06:14]
And for me, I usually will then translate that Into, because Typescript or Javascript is my native language, I use Typescript interfaces. But I've also seen it done in a graphQL schema. The point being you need to be able to define your domain. And so within this page, we have interfaces for all of the features that before I started building anything I sat down and pretended I was 20 people, and I said, if I was 20 people, what would I want this to be?

[00:07:01]
And so we have an interface that services a contract for every single kinda feature in here. So what I would like us to do just on the outset of this, I would like for us to think of some entity that we can add to the domain, and I'm gonna do workshop.

[00:07:43]
I don't know why. It just seems relevant, I guess. So I'm gonna do workshop, and I'm not gonna put too much thought into it. But I would like for us to come up with a domain and then within the API interface inside of our mono repo, and we'll get into some of that more.

[00:08:12]
So we're kinda easing into this. I would for everybody to create an interface for the entity that they chose and it could be anything you want. You are the entire company that you represent your entire organization, at least for this workshop. But what I would like everybody to do is if you go into Visual Studio Code, in the libs, the very first folder that you see is API interfaces and we are going to just come up with an additional entity.

[00:08:56]
So I decided to go with workshop, and I haven't actually thought through this until just now. But one of the nice things about programming is that [COUGH] we are, in fact, modeling reality in the real world. I think the further we just drift away from that reality, the more problems that we run into.

[00:09:21]
And it's always amusing to me when somebody's programming is hard. And it's like, well, that's because life is hard. Reality is hard. And you're trying to model something that it's complex and complicated. And so I would just say is a little boop bonus. Is that if you are modeling your domain and you're like, we're drifting away from reality, stop and check yourself and be like, if we keep going down this way path, are we gonna end up creating code?

[00:10:00]
That's going to be impossible to maintain, because it's not going to be able to move and adapt with the business. So with that said, I am going to create a new interface, and we're gonna call it Workshop, and I'm gonna be pretty simplistic about it. And the reason why if you see the BaseEntity, I just do it so that I can just put on the ID at a top level.

[00:10:42]
Typically, I'm not a huge fan of inheritance, but this is one case where I think it's just a lot easier when you're not having to see that ID explicitly like, okay, it's there, we get it. So for a workshop, I'm gonna say title, And, Description, And what else?

[00:11:15]
When we think of workshop, let's just-
>> Date.
>> Date, yeah, so date, which I think is a type of date, I think. Topic, yeah, that's good.
>> Instructor.
>> Instructor. And let's actually do instructor ID, that way, you can have a table of users or whatever, and then you just drop the ID in.

[00:11:55]
And so one of the things we'll talk about a little bit more that in Redux, that it's really, really important to normalize your data so that you are working with essentially key value pairs or entities. Because it's 0, 0, like the log 0, whatever that is. Look up when you have a dictionary and you have the key, you just can go straight to not having to diverse the collection.

[00:12:23]
And so I was already on board with that, then you start getting into microservices and you realize that everything is normalized and then split out and you're just sharing ideas around. So I think this is probably pretty good. And-
>> Excuse me.
>> Yes.
>> Instructor ID, is it okay to be number instead of string in data type?

[00:12:49]

>> So it's actually like a UU ID, which-
>> A combination of-
>> Yeah, so you really want it to be alphanumeric. And unless you're doing something really simplistic, strict numbers are pretty limited. So I learned that the hard way.
>> So how about were you wanted to tie the instructor ID to a user entity?

[00:13:17]
At this point, are you worried about OG? Is there an ID field and user all because of BaseEntity?
>> That was a good question. Do we have something we can actually kind of pin onto? And because we're extending BaseEntity, we have that ID. So this is why I'm not a fan of inheritance.

[00:13:41]
Is because there's something happening that's not obvious, is that it creates a certain level of indirection. And inheritance is, I think, a rather egregious form of coupling. The idea is that we want to favor composition over inheritance. This is, I think, one concession that I make just because it's there.

[00:14:03]

>> It's actually a real common pattern, so yeah.
>> Very good question. So all right, I think this is pretty good. Fortunately, we're not doing heart surgery. And we're not even building pacemakers. Or if we get this wrong, then you know what happens at this point? We tear it down and we start over.

[00:14:30]
So has anybody heard of the concept of immutable infrastructure? That if you have a A Kubernetes cluster out in the cloud and you need to make an update, well, you're not gonna SSH into that cluster and fix it, you're just going to tear that cluster down and redeploy a new one.

[00:14:54]
And I think that as engineers, when we adopt that same mindset of, let's do something, let's get feedback, and then let's tear it down and keep iterating. This is why I love CLIs, this is why I love generators, is because it gives us the opportunity to iterate very, very quickly.

