WEBVTT

1
00:00:00.000 --> 00:00:04.968
Does anybody have any questions
that they would like to ask me?

2
00:00:04.968 --> 00:00:08.542
&gt;&gt; So, what are the requirements for
a micro frontend, or

3
00:00:08.542 --> 00:00:13.649
the trade offs of using micro frontends,
and when do they become problematic?

4
00:00:13.649 --> 00:00:18.279
&gt;&gt; So, as I said, nothing is for free.

5
00:00:18.279 --> 00:00:22.232
Is that, there is overhead for

6
00:00:22.232 --> 00:00:28.320
implementing a micro
frontend architecture.

7
00:00:28.320 --> 00:00:33.391
Obviously, I've kind of been
chuckling about this all day,

8
00:00:33.391 --> 00:00:38.462
is that breaking everything up
towards like I've got a single

9
00:00:38.462 --> 00:00:43.255
library with a single service
that's serving one thing.

10
00:00:43.255 --> 00:00:47.279
Locally that looks kind of silly, but

11
00:00:47.279 --> 00:00:52.687
there's two main things to consider,
I believe,

12
00:00:52.687 --> 00:00:58.494
when evaluating,
do we need to start making a change?

13
00:00:58.494 --> 00:01:02.761
And they're entirely contextual in that,

14
00:01:02.761 --> 00:01:07.834
are you trying to release
a specific feature slice at

15
00:01:07.834 --> 00:01:13.959
a cadence that's faster than
everybody else can keep up with?

16
00:01:13.959 --> 00:01:14.842
So that's one.

17
00:01:14.842 --> 00:01:21.610
Like, are you moving in a different
cadence than the rest of the team.

18
00:01:21.610 --> 00:01:25.832
Kind of conversely to that is not so

19
00:01:25.832 --> 00:01:31.072
much on a cadence side,
but is the overhead

20
00:01:31.072 --> 00:01:37.042
of having to just factor
in the other features and

21
00:01:37.042 --> 00:01:43.320
the other facets of
the platform holding you back.

22
00:01:43.320 --> 00:01:48.120
And so for me,
I believe that micro frontends,

23
00:01:48.120 --> 00:01:55.210
the real value is really in the things
that are kind of hard to measure.

24
00:01:55.210 --> 00:01:58.644
So, yes, you can deploy faster, yes,

25
00:01:58.644 --> 00:02:03.092
there's better,
more deployable, more stable.

26
00:02:03.092 --> 00:02:08.457
But if you've ever been in
a war room where you're

27
00:02:08.457 --> 00:02:12.929
faced with doing a critical upgrade, but

28
00:02:12.929 --> 00:02:19.187
if you don't get it right, and
if the platform goes down,

29
00:02:19.187 --> 00:02:27.153
then your company is literally losing
millions of dollars every minute.

30
00:02:27.153 --> 00:02:32.982
That is, I think you almost have to use
your imagination a little bit in terms of,

31
00:02:32.982 --> 00:02:34.372
what is that like?

32
00:02:34.372 --> 00:02:36.787
What I can say, it's not fun.

33
00:02:36.787 --> 00:02:41.628
It's not fun when you are sitting
here saying, I want or

34
00:02:41.628 --> 00:02:47.912
I need to deploy this critical bug fix,
or this patch, or this feature.

35
00:02:47.912 --> 00:02:52.883
And bad things are gonna happen
if I cannot coordinate this

36
00:02:52.883 --> 00:02:57.352
other thing over here that
has nothing to do with me.

37
00:02:57.352 --> 00:03:03.829
And so, this is where I believe that
none of this is all or nothing,

38
00:03:03.829 --> 00:03:11.597
is that you have things like the strangler
fig pattern of, it's incremental.

39
00:03:11.597 --> 00:03:18.542
And I think, where you should
start evaluating it seriously,

40
00:03:18.542 --> 00:03:24.177
is the burden of the rest
of the platform preventing

41
00:03:24.177 --> 00:03:29.172
you from releasing fast and
releasing safe?

42
00:03:29.172 --> 00:03:32.527
And from there, I would suggest,

43
00:03:32.527 --> 00:03:36.925
start looking at ways
to incrementally adopt

44
00:03:36.925 --> 00:03:42.492
a micro-frontend strategy
within your organization.

45
00:03:42.492 --> 00:03:48.051
But I would definitely say,
don't be like, we're doing,

46
00:03:48.051 --> 00:03:52.302
micro-frontends, burn the platform down,

47
00:03:52.302 --> 00:03:57.210
is that, you are just tempting
fate when you do that.

48
00:03:57.210 --> 00:04:04.151
Is, I think ultimately, there's ways
to evaluate the feasibility and

49
00:04:04.151 --> 00:04:10.197
viability of a technology or
an approach without going all in.

50
00:04:10.197 --> 00:04:13.515
It's like, hey, I wanna be a doctor,

51
00:04:13.515 --> 00:04:18.255
I wanna go to this special
school that is out in Siberia.

52
00:04:18.255 --> 00:04:21.889
And so, I don't know if I
wanna be a doctor really, but

53
00:04:21.889 --> 00:04:26.486
I have to go to Siberia and stick
around for four years or eight years.

54
00:04:26.486 --> 00:04:31.502
Versus, maybe I wanna go
volunteer at the hospital for

55
00:04:31.502 --> 00:04:37.390
a week and see if I can even stand
the smell of a medical facility,

56
00:04:37.390 --> 00:04:41.860
is that, take small,
tiny incremental bets and

57
00:04:41.860 --> 00:04:45.152
measurements and move from there.

58
00:04:45.152 --> 00:04:46.589
Does that make sense?

59
00:04:46.589 --> 00:04:47.128
&gt;&gt; Yeah.

60
00:04:47.128 --> 00:04:47.829
&gt;&gt; Awesome.

61
00:04:47.829 --> 00:04:52.079
&gt;&gt; I have a question regarding
decoupling in a mono repo.

62
00:04:52.079 --> 00:04:56.881
According to you, at which point would
we make an application instead of

63
00:04:56.881 --> 00:04:59.491
a component, for instance Instance?

64
00:04:59.491 --> 00:05:03.848
Before we'd create a car
component in a shared folder, for

65
00:05:03.848 --> 00:05:08.046
instance, now would we create
an application for that?

66
00:05:08.046 --> 00:05:12.297
It would be great to get a,
sort of guideline or

67
00:05:12.297 --> 00:05:17.313
general rule to decide shared
code versus a separate.

68
00:05:17.313 --> 00:05:21.776
&gt;&gt; One of the things that
you have to start with is,

69
00:05:21.776 --> 00:05:27.926
are we describing something that
is conceptually independent.

70
00:05:27.926 --> 00:05:31.475
That it represents a large enough,

71
00:05:31.475 --> 00:05:36.326
indistinct enough unit of
the business domain to

72
00:05:36.326 --> 00:05:41.899
warrant having a user interact
solely with that thing.

73
00:05:41.899 --> 00:05:47.866
That, again, coding to model
the real world, I would say,

74
00:05:47.866 --> 00:05:52.897
if you can justify having
this as a standalone app,

75
00:05:52.897 --> 00:05:56.761
then I think it's worth considering.

76
00:05:56.761 --> 00:06:01.582
I think, with mono repos,
if all your business logic and

77
00:06:01.582 --> 00:06:04.999
your state management is in libraries,

78
00:06:04.999 --> 00:06:10.942
then it's very easy to just build
a wrapper around that and expose it.

79
00:06:10.942 --> 00:06:15.921
So suddenly the idea of
spinning up an application is

80
00:06:15.921 --> 00:06:19.889
not nearly as cumbersome as it used to be.

81
00:06:19.889 --> 00:06:27.089
What I would also say, we were having an
interesting conversation during the break,

82
00:06:27.089 --> 00:06:33.097
is, what do you do in terms of
authentication with micro-frontends?

83
00:06:33.097 --> 00:06:36.517
And my opinion, just right now,

84
00:06:36.517 --> 00:06:41.895
is that I would not have
a standalone authentication

85
00:06:41.895 --> 00:06:47.639
micro-frontend because I
don't think the function,

86
00:06:47.639 --> 00:06:53.525
and it could be, but
the functionality in and of itself.

87
00:06:53.525 --> 00:06:57.916
I don't believe warrants
enough to be an entirely

88
00:06:57.916 --> 00:07:01.373
standalone deployable application.

89
00:07:01.373 --> 00:07:06.296
There could be scenarios where
you would change my mind, but

90
00:07:06.296 --> 00:07:11.703
I think it absolutely would make
sense as a standalone library that

91
00:07:11.703 --> 00:07:18.572
you then pull in to your micro frontends,
and either into your remotes or your host.

92
00:07:18.572 --> 00:07:23.461
So, the idea is that you pull into the
library, so you can independently load it.

93
00:07:23.461 --> 00:07:25.517
It checks for a token.

94
00:07:25.517 --> 00:07:31.617
If it's not there,
then you see the login lib.

95
00:07:31.617 --> 00:07:38.126
If it is there, it just goes away,
and what that allows you to do is,

96
00:07:38.126 --> 00:07:43.154
when you load it into a parent or
a host application,

97
00:07:43.154 --> 00:07:47.988
the host can pass that
token down into the remote.

98
00:07:47.988 --> 00:07:54.581
And say, I've been authenticated and
I don't need to load this library.

99
00:07:54.581 --> 00:07:58.574
But it allows you,
by having that shared component,

100
00:07:58.574 --> 00:08:03.999
to look at remotes independently or
remotes within the context of host.

101
00:08:03.999 --> 00:08:08.187
&gt;&gt; Could you explain the difference
between micro-frontends and

102
00:08:08.187 --> 00:08:11.763
module federation, and
when we would need either or?

103
00:08:11.763 --> 00:08:16.782
&gt;&gt; Micro-frontends is
the concept of having small,

104
00:08:16.782 --> 00:08:22.269
independently deployed frontends or
web applications

105
00:08:22.269 --> 00:08:27.533
that you can then load into
other host applications.

106
00:08:27.533 --> 00:08:33.237
Federated modules are just a way to do
that, and it happens to be very effective.

107
00:08:33.237 --> 00:08:35.490
I think that web pack and

108
00:08:35.490 --> 00:08:41.018
federated modules is probably
the best option right now.

109
00:08:41.018 --> 00:08:47.736
And so, I would say that all federated
modules are probably micro-frontends,

110
00:08:47.736 --> 00:08:52.798
but not all micro-frontends
are using federated modules.

