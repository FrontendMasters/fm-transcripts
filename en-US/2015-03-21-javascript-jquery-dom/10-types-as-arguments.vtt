WEBVTT

1
00:00:00.000 --> 00:00:04.364
[MUSIC]

2
00:00:04.364 --> 00:00:05.069
&gt;&gt; Justin Meyer: Quick question for

3
00:00:05.069 --> 00:00:07.660
the audience if anybody is
brave enough to answer.

4
00:00:07.660 --> 00:00:12.495
What is the value gonna be when all
of this code is run of a, b and c?

5
00:00:12.495 --> 00:00:14.340
And try not to cheat and
just write it out.

6
00:00:14.340 --> 00:00:15.782
And just so you know,

7
00:00:15.782 --> 00:00:20.650
the prefix plus plus operator that
returns the incremented value.

8
00:00:20.650 --> 00:00:26.390
So, if x was going to be let's say 10,
it would increment it to 11 and

9
00:00:26.390 --> 00:00:31.950
return, the result of the parentheses
would essentially be 11.

10
00:00:31.950 --> 00:00:34.500
Any ideas on what a, b,
and c are going to be?

11
00:00:41.101 --> 00:00:41.750
&gt;&gt; Student: They're not gonna change.

12
00:00:43.160 --> 00:00:45.733
&gt;&gt; Justin Meyer: That's
true of one of them.

13
00:00:45.733 --> 00:00:49.455
[LAUGH]
&gt;&gt; Justin Meyer: Any other?

14
00:00:52.564 --> 00:00:56.520
&gt;&gt; Justin Meyer: Sorry, well,
c is not really changed, but yeah,

15
00:00:56.520 --> 00:01:00.939
c will change, I guess,
from undefined to have a value.

16
00:01:00.939 --> 00:01:02.555
&gt;&gt; Student: Val 1, 2, 3?

17
00:01:02.555 --> 00:01:07.710
&gt;&gt; Justin Meyer: Be 1, 3 and then 5.

18
00:01:09.070 --> 00:01:10.944
So, let's see how that works.

19
00:01:10.944 --> 00:01:16.901
So b.val will be 3.

20
00:01:16.901 --> 00:01:21.570
So again, when everything is run,
when all code is run, there's

21
00:01:21.570 --> 00:01:26.350
always this kind of global call object,
this global container for all variables.

22
00:01:26.350 --> 00:01:32.430
And we're gonna treat this code just like
how kind of JavaScript processes it,

23
00:01:32.430 --> 00:01:33.370
think like a computer.

24
00:01:33.370 --> 00:01:38.270
So, the JavaScript processor is going to

25
00:01:38.270 --> 00:01:41.630
come see this first
kind of statement here.

26
00:01:41.630 --> 00:01:43.750
And it's going to do what's
on the right hand side,

27
00:01:43.750 --> 00:01:46.720
the expression on the right
hand side of the equal sign.

28
00:01:46.720 --> 00:01:49.830
And it's going to create
a function in memory first.

29
00:01:51.180 --> 00:01:54.640
We'll be using this a little bit later,
but I want to give a sneak peek to it.

30
00:01:54.640 --> 00:01:56.810
Whenever a function is created in memory,

31
00:01:58.100 --> 00:02:02.570
it has a prototype property that
points to an object in memory.

32
00:02:02.570 --> 00:02:04.949
We'll be using that later,
but just saying,

33
00:02:04.949 --> 00:02:07.511
whenever of you see
a function created in memory,

34
00:02:07.511 --> 00:02:11.913
we create a little function on our kind of
two dimensional representation of memory.

35
00:02:11.913 --> 00:02:16.427
Whenever it's created in code,
we create one in memory with a prototype

36
00:02:16.427 --> 00:02:21.200
property and a circle for its object
that the prototype property points to.

37
00:02:21.200 --> 00:02:24.730
And then we're gonna do the what's on
the left hand side of the equal operator.

38
00:02:24.730 --> 00:02:28.380
We're gonna create a sum
variable in our call object, and

39
00:02:28.380 --> 00:02:32.330
then we're going to set that sum to
point to the function in memory.

40
00:02:33.460 --> 00:02:35.080
That's what JavaScript does.

41
00:02:35.080 --> 00:02:38.100
And JavaScript doesn't know
what's going on inside the func,

42
00:02:38.100 --> 00:02:40.980
you can think of it, it has no idea
what's going inside the function.

43
00:02:40.980 --> 00:02:45.760
It has no idea about x or
y being incremented,

44
00:02:45.760 --> 00:02:49.280
any of that,
it's just kind of blind to at this point.

45
00:02:51.920 --> 00:02:55.830
The next thing it's gonna
do is run these two things.

46
00:02:55.830 --> 00:02:59.362
It's gonna create an a variable,
point it to 1.

47
00:02:59.362 --> 00:03:03.663
And it's gonna create an object
in memory with a val property and

48
00:03:03.663 --> 00:03:05.584
it's gonna point b to that.

49
00:03:08.306 --> 00:03:12.549
&gt;&gt; Justin Meyer: The next thing is
it's going to call the sum function.

50
00:03:14.350 --> 00:03:17.905
And I apologize if the font
is a little small up there,

51
00:03:17.905 --> 00:03:20.520
couldn't really make it much bigger.

52
00:03:20.520 --> 00:03:24.307
The important thing though is,
whenever a function is called,

53
00:03:24.307 --> 00:03:29.620
whenever you see that call operator,
some function followed by parentheses.

54
00:03:29.620 --> 00:03:31.030
There's a bunch of things that happen.

55
00:03:36.220 --> 00:03:40.785
The first thing it does is it creates
a new call object that's going to contain

56
00:03:40.785 --> 00:03:42.625
the arguments and variables.

57
00:03:42.625 --> 00:03:46.514
And also, the reference to this
that when that function is invoked,

58
00:03:46.514 --> 00:03:51.220
it's going to contain its variables,
arguments, and things like that.

59
00:03:51.220 --> 00:03:53.250
So, that's another call object for

60
00:03:53.250 --> 00:03:56.390
the invocation of sum with
the variables a and b.

61
00:03:57.430 --> 00:04:00.786
So, creates this little place in memory to
contain variables and things like that,

62
00:04:00.786 --> 00:04:03.000
and it starts putting things in there.

63
00:04:03.000 --> 00:04:05.910
So, it's called with a and b, but

64
00:04:05.910 --> 00:04:09.850
it's gonna translate that to values
that it contains of x and y.

65
00:04:11.440 --> 00:04:15.410
So, because a is a primitive,
it's passed by a value.

66
00:04:16.920 --> 00:04:25.312
So x is going to point to
essentially a copy of a.

67
00:04:25.312 --> 00:04:29.256
You can think of it is creating new
one in memory, it really doesn't, but

68
00:04:29.256 --> 00:04:30.410
think of it that way.

69
00:04:33.788 --> 00:04:37.376
&gt;&gt; Justin Meyer: And then y is
going to be passed by reference, so

70
00:04:37.376 --> 00:04:41.630
y is going to point exactly
to what b points to.

71
00:04:41.630 --> 00:04:43.370
So, this is what gets set up.

72
00:04:43.370 --> 00:04:46.400
And then the function,
its code is going to be run.

73
00:04:47.720 --> 00:04:53.192
So, it's going to say hey, look,
give me the value of x in memory,

74
00:04:53.192 --> 00:04:59.816
I'm gonna increment that, and give me
y.val, look up that and increment that.

75
00:04:59.816 --> 00:05:05.981
So, it's going to increment x to 2,
and y.val to 3,

76
00:05:05.981 --> 00:05:11.773
and then return the sum of
those two things as c is 5.

77
00:05:11.773 --> 00:05:13.876
Any questions there?

78
00:05:13.876 --> 00:05:16.416
Make sense?

79
00:05:16.416 --> 00:05:23.620
So, two things to remember.

80
00:05:23.620 --> 00:05:29.337
Whenever a function is defined,
a kind of function is created in memory,

81
00:05:29.337 --> 00:05:33.410
it's created in memory
with a prototype property.

82
00:05:33.410 --> 00:05:37.390
And the second thing,
whenever a function is called,

83
00:05:37.390 --> 00:05:42.493
a new call object is created, and
the arguments passed to the function

84
00:05:42.493 --> 00:05:48.487
are kinda translated to what the names of
the arguments the function defines out.

85
00:05:48.487 --> 00:05:49.549
So a and b gets translated to x and y.

86
00:05:52.432 --> 00:05:55.243
&gt;&gt; Justin Meyer: [COUGH] So,
another summary.

87
00:05:55.243 --> 00:05:59.370
[LAUGH] Primitives passed by value, you
get a copy objects passed by reference.

88
00:06:01.240 --> 00:06:04.220
So, another question, what's gonna happen?

89
00:06:05.490 --> 00:06:08.500
What's gonna be alerted
when this code runs?

90
00:06:12.933 --> 00:06:16.020
&gt;&gt; Justin Meyer: And
then bonus points for explaining why.

91
00:06:21.450 --> 00:06:22.350
&gt;&gt; Student: Any?

92
00:06:24.520 --> 00:06:25.870
I can tell you my guess.

93
00:06:25.870 --> 00:06:32.103
I would assume looking at this code,
I would probably think it's gonna be 012.

94
00:06:32.103 --> 00:06:33.552
&gt;&gt; Justin Meyer: You're an idiot.

95
00:06:33.552 --> 00:06:36.310
[LAUGH] No, it won't be that.

96
00:06:36.310 --> 00:06:40.270
It will be, any other guesses?

97
00:06:40.270 --> 00:06:44.613
If it's not gonna be 012,
what else could it be, and maybe why?

98
00:06:44.613 --> 00:06:47.307
And brave souls,
we should start taking names, and

99
00:06:47.307 --> 00:06:50.320
then give rewards, like cookies or
something tomorrow.

100
00:06:51.890 --> 00:06:59.190
Yes and well, maybe yes, maybe bring some
something nice for the those who are.

101
00:06:59.190 --> 00:07:01.680
Do you have a stab in the dark here?

102
00:07:01.680 --> 00:07:02.180
&gt;&gt; Student: Well.

103
00:07:04.562 --> 00:07:07.168
&gt;&gt; Student: I ran across something
like this two or three years ago,

104
00:07:07.168 --> 00:07:09.677
where it ended up being
something like 222, but.

105
00:07:10.870 --> 00:07:14.460
&gt;&gt; Justin Meyer: That's,
you're right on, you're so close.

106
00:07:14.460 --> 00:07:15.046
Yeah.
[LAUGH]

107
00:07:15.046 --> 00:07:16.700
&gt;&gt; Student: But I forget why that was

108
00:07:16.700 --> 00:07:17.285
[LAUGH].

109
00:07:17.285 --> 00:07:19.720
&gt;&gt; Justin Meyer: It's good,
it's going to be 333.

110
00:07:19.720 --> 00:07:25.943
Anybody know why?

111
00:07:25.943 --> 00:07:27.895
Yeah.

112
00:07:27.895 --> 00:07:30.150
&gt;&gt; Student: Cuz i is the reference, and

113
00:07:30.150 --> 00:07:35.260
it's the last reference to
the order once the loop finishes.

114
00:07:35.260 --> 00:07:40.500
And so, as each line then executes
afterwards it's using the same reference.

115
00:07:40.500 --> 00:07:44.223
&gt;&gt; Justin Meyer: Yeah so,
once the i is going to be left at 3,

116
00:07:44.223 --> 00:07:48.670
because the conditional will fail for
the for loop.

117
00:07:48.670 --> 00:07:52.900
So, i will be 0, then 1,
then 2, then 3, this will fail,

118
00:07:52.900 --> 00:07:54.740
and it'll exit the for loop.

119
00:07:54.740 --> 00:08:00.370
But it's because a lot of people think
well, but shouldn't the i be 0, 1, then 2?

120
00:08:00.370 --> 00:08:03.390
It's because JavaScript doesn't
have block level scope.

121
00:08:03.390 --> 00:08:07.240
So, this i is kind of global,
it's in the global call object.

122
00:08:07.240 --> 00:08:12.700
So, it's just gonna output the value
of i as it stands every single time.

123
00:08:12.700 --> 00:08:15.540
So, we'll come back to this and
show how to fix it and

124
00:08:15.540 --> 00:08:17.702
explain the problem a little bit better,
but.

125
00:08:17.702 --> 00:08:18.334
Yep?

126
00:08:18.334 --> 00:08:21.110
&gt;&gt; Student: A couple of question
come up a little bit back here.

127
00:08:21.110 --> 00:08:25.530
He was asking if objects
are all call by reference.

128
00:08:25.530 --> 00:08:33.011
And then also kind of related,
call object is a synonym for scope.

129
00:08:33.011 --> 00:08:36.710
&gt;&gt; Justin Meyer: Call
objects are called by call.

130
00:08:36.710 --> 00:08:44.080
So, call objects, so
you can't really pass a call object

131
00:08:44.080 --> 00:08:48.770
to a function, so you can't really, that
pass by reference, pass by value thing.

132
00:08:51.380 --> 00:08:57.510
I don't know how, maybe the phrasing
of the question I'm missing.

133
00:08:57.510 --> 00:09:00.733
What was the?

134
00:09:00.733 --> 00:09:05.515
&gt;&gt; Student: He's not talking about call,
that was the gentleman

135
00:09:05.515 --> 00:09:09.881
talking about objects
are called by reference?

136
00:09:09.881 --> 00:09:11.596
&gt;&gt; Justin Meyer: Yeah.
&gt;&gt; Student: [CROSSTALK]

137
00:09:11.596 --> 00:09:13.000
&gt;&gt; Justin Meyer: So objects aren't called

138
00:09:13.000 --> 00:09:15.498
by reference,
they are passed by reference.

139
00:09:15.498 --> 00:09:19.770
And then is call object a synonym for
scope?

140
00:09:22.090 --> 00:09:25.310
Call object is a piece of a scope.

141
00:09:25.310 --> 00:09:28.410
You could think of it as if
the whole scope consists of,

142
00:09:28.410 --> 00:09:33.330
if inside this function,
I can reference a, b and c.

143
00:09:33.330 --> 00:09:35.770
But also, inside this function,
I can reference x and y.

144
00:09:37.710 --> 00:09:40.720
If that's what,
a lot times people refer to as the scope.

145
00:09:40.720 --> 00:09:46.873
It's all of the call objects
combined is the scope, right?

146
00:09:46.873 --> 00:09:48.304
It's kind of related.

147
00:09:48.304 --> 00:09:53.231
&gt;&gt; Student: So, you kinda asked
a followup question there why x

148
00:09:53.231 --> 00:09:57.620
isn't called by reference in this example.

149
00:09:57.620 --> 00:10:01.656
&gt;&gt; Justin Meyer: So,
x is not called, it's passed, right?

150
00:10:01.656 --> 00:10:05.824
There's a difference between called, so,

151
00:10:05.824 --> 00:10:11.430
when the sum function is called,
it passes a and b.

152
00:10:11.430 --> 00:10:14.135
So, a is passed by a value,

153
00:10:14.135 --> 00:10:19.090
because it's a primitive type,
it's just a 1.

154
00:10:19.090 --> 00:10:25.260
b is an object, so
it's passed by reference.

155
00:10:25.260 --> 00:10:30.150
Sorry, did I say, x was passed, x is
passed by value, y is passed by reference.

156
00:10:32.600 --> 00:10:39.617
b is passed by reference to sum, so y,
when it kinda translates the arguments,

157
00:10:39.617 --> 00:10:44.353
y is gonna point to b, but
x is gonna get a new copy of a.

158
00:10:44.353 --> 00:10:49.150
So, that makes sense, hopefully.

159
00:10:51.090 --> 00:10:53.180
So, why isn't x called by reference?

160
00:10:54.550 --> 00:10:58.330
Maybe it was also referring
to when I said x isn't,

161
00:10:58.330 --> 00:11:01.460
when I said it's not
actually a new copy is made.

162
00:11:01.460 --> 00:11:03.570
The reason is it can be, and

163
00:11:03.570 --> 00:11:08.680
it could not be, you don't know, because
again, real primitives in JavaScript,

164
00:11:08.680 --> 00:11:14.030
you can never mutate a number, or in
a string, or anything like that in place.

165
00:11:14.030 --> 00:11:20.290
You always get a new copy, whenever you
increment x, that actual value here.

166
00:11:20.290 --> 00:11:26.160
Really, we're showing it as being,
I kind of try to show that it's not so

167
00:11:26.160 --> 00:11:28.790
much the number has changed in place,
instead,

168
00:11:28.790 --> 00:11:35.350
a new number has been instead of x,
is really pointing to a new number.

169
00:11:35.350 --> 00:11:38.340
That's what's really happening
when you increment x,

170
00:11:38.340 --> 00:11:40.909
because you can't actually
change primitives.

171
00:11:42.390 --> 00:11:46.930
So, that's why it's not necessarily,
it could, the engine could optimize and

172
00:11:46.930 --> 00:11:51.540
say okay, well, I see that this function
is constantly changing the number.

173
00:11:51.540 --> 00:11:54.590
So, I'm just gonna copy
the number that was passed and

174
00:11:54.590 --> 00:11:59.020
pass a fresh copy that it
can increment in place, or

175
00:11:59.020 --> 00:12:03.700
it could decide they just want the number,
and they do almost nothing with it.

176
00:12:03.700 --> 00:12:09.391
I'm just going to pass the same number
as if it was passed by reference.

177
00:12:09.391 --> 00:12:14.260
So, I don't know if that's the question
that was being asked, but there's a whole

178
00:12:14.260 --> 00:12:19.269
lot of complexity that can happen, because
primitives are not mutable, that engines

179
00:12:19.269 --> 00:12:23.750
can decide whether to do reference or
value, but think of it as pass by value.

