WEBVTT

1
00:00:00.000 --> 00:00:04.473
[MUSIC]

2
00:00:04.473 --> 00:00:06.500
&gt;&gt; Justin Meyer: Just a quick exercise.

3
00:00:06.500 --> 00:00:09.181
Although it might be a little confusing,

4
00:00:09.181 --> 00:00:14.400
if you've not written a lot of JavaScript,
is we're gonna make a tag a library.

5
00:00:15.420 --> 00:00:19.820
I just wanna make a make object
that has an h1 function that,

6
00:00:19.820 --> 00:00:22.050
when I call it,
will give me an h1 element.

7
00:00:24.260 --> 00:00:28.150
But the secret to this is I want you
guys to try to do it in the least

8
00:00:28.150 --> 00:00:30.070
lines of code possible.

9
00:00:30.070 --> 00:00:34.430
I want you to use the dynamic nature of
JavaScript where it can kind of, if you

10
00:00:34.430 --> 00:00:40.600
remember that jQuery example where I kind
of loop through kind of properties and

11
00:00:40.600 --> 00:00:45.800
values and
dynamically generated a version of jQuery,

12
00:00:45.800 --> 00:00:48.480
I want you to try to do
something like that.

13
00:00:48.480 --> 00:00:52.650
So, essentially,
take maybe like an array of

14
00:00:54.100 --> 00:00:58.150
tag names, generate an h1 function,

15
00:00:58.150 --> 00:01:02.280
that creates an h1 element,
that creates the anchor element.

16
00:01:02.280 --> 00:01:07.214
And you'll have to use kind of similar
techniques that we just used to

17
00:01:07.214 --> 00:01:09.270
fix the for-loop problem.

18
00:01:10.800 --> 00:01:13.522
So are other questions about this?

19
00:01:13.522 --> 00:01:15.020
Yeah.
&gt;&gt; Speaker 2: Just going back on,

20
00:01:15.020 --> 00:01:19.264
can you mention some of the practical
uses of closures in JavaScript?

21
00:01:19.264 --> 00:01:23.609
&gt;&gt; Justin Meyer: So
you use closures constantly in JavaScript.

22
00:01:23.609 --> 00:01:27.434
I need to have a function
inside of another function,

23
00:01:27.434 --> 00:01:32.025
or any time a function is accessing
a variable that it, itself,

24
00:01:32.025 --> 00:01:37.320
did not create, or is not directly
passed to it, you are using closures.

25
00:01:37.320 --> 00:01:43.517
For private variables was also
another one that Alexis talked about.

26
00:01:43.517 --> 00:01:45.993
It's hard for me.

27
00:01:45.993 --> 00:01:48.435
The counter example is, in some ways,

28
00:01:48.435 --> 00:01:52.653
a nice use of it because I created
a function that you can just call and

29
00:01:52.653 --> 00:01:56.700
it increments itself,
almost like using a generator pattern.

30
00:01:56.700 --> 00:02:00.270
Hey, call this outer counter function, and

31
00:02:00.270 --> 00:02:03.140
I'll give you an inner
function that counts.

32
00:02:03.140 --> 00:02:09.910
That kind of stuff you do all the time
when you're building APIs in JavaScript.

33
00:02:09.910 --> 00:02:13.337
So, with this example,

34
00:02:13.337 --> 00:02:17.743
if you open up this tags at HTML,

35
00:02:17.743 --> 00:02:22.166
you can see the functionality.

36
00:02:22.166 --> 00:02:27.649
Here's kind of a little starter code and
that test code right below it.

37
00:02:27.649 --> 00:02:29.993
So you can just take it from there.

38
00:02:29.993 --> 00:02:34.184
And we're here for questions for,
I guess, 15 minutes, and

39
00:02:34.184 --> 00:02:36.289
then we'll give the solution.

40
00:02:36.289 --> 00:02:40.477
But if you're struggling or you even
have questions right now, ask them and

41
00:02:40.477 --> 00:02:43.300
we'll try to help guide
you through this example.

