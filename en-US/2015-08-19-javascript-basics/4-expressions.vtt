WEBVTT

1
00:00:00.290 --> 00:00:05.100
&gt;&gt; Kyle Simpson: Now statements
are comprised of phrases like they

2
00:00:05.100 --> 00:00:07.990
are in English, and these phrases
are what we call expressions.

3
00:00:07.990 --> 00:00:11.110
So going back to this A = B times 2,

4
00:00:11.110 --> 00:00:16.610
there are essentially
several expressions going on.

5
00:00:16.610 --> 00:00:19.717
The first expression
is that literal value,

6
00:00:19.717 --> 00:00:24.226
a literal value expressed is
a literal value expression, okay?

7
00:00:24.226 --> 00:00:27.849
And then there's an identifier expression,
which is the character b.

8
00:00:27.849 --> 00:00:30.302
And then we take b times 2.

9
00:00:30.302 --> 00:00:34.067
We put those things together,
there's an operator in between and

10
00:00:34.067 --> 00:00:35.623
two things on either side.

11
00:00:35.623 --> 00:00:39.403
And that is called
an arithmetic expression.

12
00:00:39.403 --> 00:00:42.129
In this case, a multiplication expression.

13
00:00:42.129 --> 00:00:45.551
So you can see there was an inner
expression, an outer expression, and

14
00:00:45.551 --> 00:00:48.972
I could sort of make that more obvious
if I used the parentheses as sort of

15
00:00:48.972 --> 00:00:49.900
a grouping thing.

16
00:00:49.900 --> 00:00:54.960
So I'm gonna use parentheses to illustrate
this idea of where the expressions are.

17
00:00:54.960 --> 00:00:59.222
So there is an expression here,
the parentheses wrapping around 2.

18
00:00:59.222 --> 00:01:02.430
There is an expression here,
the parentheses wrapping around b.

19
00:01:02.430 --> 00:01:06.780
There's another set of parentheses
that wrap around this expression,

20
00:01:06.780 --> 00:01:11.280
which is a mathematic, an arithmetic
expression, a multiplication expression.

21
00:01:11.280 --> 00:01:15.474
And there's one more expression which
is called an assignment expression.

22
00:01:15.474 --> 00:01:19.119
So all of this stuff, you notice
I did not include the semicolon,

23
00:01:19.119 --> 00:01:23.110
all of that stuff is both
an expression and a statement.

24
00:01:23.110 --> 00:01:29.770
It's an expression from here to here and
then it's the last thing to go out.

25
00:01:29.770 --> 00:01:31.370
There's nothing else outside of it.

26
00:01:31.370 --> 00:01:33.599
So it's also a statement.

27
00:01:33.599 --> 00:01:34.247
Does that make sense?

28
00:01:34.247 --> 00:01:37.171
There's an expression,
an expression, an expression.

29
00:01:37.171 --> 00:01:40.679
And finally, we get to what we
would call an expression statement.

30
00:01:40.679 --> 00:01:42.026
Where they become one and the same.

31
00:01:42.026 --> 00:01:44.790
So this grouping can kind of help you
visualize where those things are.

32
00:01:44.790 --> 00:01:47.280
And that's actually a good practice.

33
00:01:47.280 --> 00:01:49.260
So that's the first thing
that we'll try to do.

34
00:01:49.260 --> 00:01:52.420
I'm going to write a slightly
more complex statement.

35
00:01:52.420 --> 00:01:56.422
And don't let it intimidate you if
you're just starting out programming.

36
00:01:56.422 --> 00:01:59.788
But just from the perspective of trying
to get your feet wet with understanding

37
00:01:59.788 --> 00:02:02.134
the difference between statements and
expressions,

38
00:02:02.134 --> 00:02:04.888
kinda like when your English teacher
had you go up on the board and

39
00:02:04.888 --> 00:02:07.550
underline all the verbs and
circle all the nouns or whatever.

40
00:02:07.550 --> 00:02:08.840
I'm gonna have you do that with this.

41
00:02:08.840 --> 00:02:10.720
I'm gonna write a slightly
more complex statement.

42
00:02:10.720 --> 00:02:14.499
I'm literally just gonna make it up on
the fly, so it might make no sense at all.

43
00:02:14.499 --> 00:02:17.979
But I'm gonna write a statement, and then
I want you to take that same statement and

44
00:02:17.979 --> 00:02:19.719
put in those parentheses like I just did,

45
00:02:19.719 --> 00:02:22.576
identifying all the different
places that there are expressions.

46
00:02:22.576 --> 00:02:25.687
So let me just start out
by saying something like,

47
00:02:30.038 --> 00:02:31.550
&gt;&gt; Kyle Simpson: a = b * 2 +,

48
00:02:31.550 --> 00:02:35.589
then I'm gonna make a function call,

49
00:02:35.589 --> 00:02:40.131
which you haven't seen those before, and

50
00:02:40.131 --> 00:02:44.925
then I'm going to pass
in an argument c * 3,

51
00:02:44.925 --> 00:02:48.230
and there's my statement.

52
00:02:48.230 --> 00:02:49.720
So copy that down first.

53
00:02:49.720 --> 00:02:51.900
You can copy this into
your own code editor.

54
00:02:51.900 --> 00:02:54.910
You can type it into your console or
something like that.

55
00:02:54.910 --> 00:02:58.280
It's a nonsense statement because we
haven't assigned values to foo, b and

56
00:02:58.280 --> 00:03:02.160
c yet, but just from the perspective
of finding those expressions.

57
00:03:02.160 --> 00:03:05.330
Go in and put your parenthesis or
brackets or whatever if you want.

58
00:03:05.330 --> 00:03:08.080
But take just a moment and try to find
all the different places where there

59
00:03:08.080 --> 00:03:11.080
are expressions, and
then we'll come back and solidify that.

60
00:03:12.920 --> 00:03:16.630
All right, so, hopefully you had
a chance to try your hand at that.

61
00:03:16.630 --> 00:03:17.630
Let's see how you did.

62
00:03:17.630 --> 00:03:22.110
So, I'm gonna walk through from the
smallest to the sort of outer and identify

63
00:03:22.110 --> 00:03:25.660
all those different places that are
expressions that make up this statement.

64
00:03:25.660 --> 00:03:29.920
So, because I already have a set of
parentheses in here that means syntax,

65
00:03:29.920 --> 00:03:33.930
I'm actually gonna use brackets instead
of parentheses, the square brackets.

66
00:03:33.930 --> 00:03:36.660
But conceptually, again,
we're not doing anything syntactic.

67
00:03:36.660 --> 00:03:39.300
What we're doing here is
just identifying visually.

68
00:03:39.300 --> 00:03:42.270
So, I'm gonna put square brackets
around all of our expressions.

69
00:03:42.270 --> 00:03:46.810
So here We know that we have an expression
for the literal value three.

70
00:03:46.810 --> 00:03:50.320
I'm not making that an array 3 I'm just
identifying that things as a three.

71
00:03:50.320 --> 00:03:54.270
We also have another expression value
2 and we have another expression for

72
00:03:54.270 --> 00:03:57.770
b and we have another expression for a.

73
00:03:59.090 --> 00:04:03.030
I think in my previous example I forgot to
indicate that the left hand side is also

74
00:04:03.030 --> 00:04:03.880
its own expression.

75
00:04:03.880 --> 00:04:06.310
So the left hand side is an expression.

76
00:04:06.310 --> 00:04:08.270
The c is an expression.

77
00:04:08.270 --> 00:04:11.060
The foo of course is an expression.

78
00:04:11.060 --> 00:04:13.460
So all of those are sort of
our first level expressions.

79
00:04:13.460 --> 00:04:15.850
Now let's start doing
some grouping of stuff.

80
00:04:15.850 --> 00:04:19.810
We know that the c times
3 is an expression.

81
00:04:19.810 --> 00:04:21.230
It's a multiplication expression, so

82
00:04:21.230 --> 00:04:25.530
we should put a bracket around that to
identify that that is an expression.

83
00:04:25.530 --> 00:04:29.040
We know that this thing, we haven't really
talked about what a function call is but

84
00:04:29.040 --> 00:04:32.950
we know that its an inseparable unit
there is, there is this whole thing

85
00:04:32.950 --> 00:04:35.960
like when we put the parenthesis together
with the identifier in front of it,

86
00:04:35.960 --> 00:04:38.270
that's called a call expression.

87
00:04:38.270 --> 00:04:42.040
So there's a set of brackets that need
to go around the call expression,

88
00:04:42.040 --> 00:04:45.110
because that's one coherent
unit of stuff that happens.

89
00:04:45.110 --> 00:04:47.660
So, we've got our bracket around those.

90
00:04:47.660 --> 00:04:51.144
We do a little clean up of my whitespace
here so that's an expression.

91
00:04:51.144 --> 00:04:55.669
Now we've kind of an interesting
question to ask, which is,

92
00:04:55.669 --> 00:05:01.238
would the programming language would
the computer think of these two things

93
00:05:01.238 --> 00:05:07.420
as an expression first or would it think
of these two things as an expression?

94
00:05:07.420 --> 00:05:08.590
Cuz we have two different operators.

95
00:05:08.590 --> 00:05:10.410
They're called binary operators.

96
00:05:10.410 --> 00:05:13.340
It's a fancy way of saying it's
an operator that requires two different

97
00:05:13.340 --> 00:05:13.870
sides.

98
00:05:14.950 --> 00:05:18.290
So it's a binary operator plus that
requires one thing on the left and

99
00:05:18.290 --> 00:05:20.210
one thing on the right and
puts them together.

100
00:05:20.210 --> 00:05:23.000
And then the multiplication
operator's the same way.

101
00:05:23.000 --> 00:05:25.470
So it can't do both of
them at the same time.

102
00:05:25.470 --> 00:05:27.260
It's gotta do one and then the other.

103
00:05:27.260 --> 00:05:32.310
And that leads us into a discussion of
what we'd call operator precedence, okay?

104
00:05:32.310 --> 00:05:37.010
Now this is not necessarily a critical
set of rules that you have to learn, but

105
00:05:37.010 --> 00:05:40.320
awareness that there is such
a thing is the important part.

106
00:05:40.320 --> 00:05:43.230
Not actually knowing each
individual nuanced thing.

107
00:05:43.230 --> 00:05:46.330
There's a set of rules that
tells the programming language

108
00:05:46.330 --> 00:05:48.580
how to know what to do first.

109
00:05:48.580 --> 00:05:51.080
It doesn't always work in
left to right fashion.

110
00:05:52.290 --> 00:05:55.870
Sometimes, it could work from the right
hand side and over it's way backwards.

111
00:05:55.870 --> 00:05:58.670
Now, I accidentally,
literally just made it up and

112
00:05:58.670 --> 00:06:02.600
I accidentally chose this
multiplication to happen first.

113
00:06:02.600 --> 00:06:06.090
Which, happens to matter
because multiplication

114
00:06:06.090 --> 00:06:08.630
is what is said to be more precedent.

115
00:06:08.630 --> 00:06:11.270
Multiplication happens before addition.

116
00:06:11.270 --> 00:06:15.990
If there's a question as to
which one should happen first,

117
00:06:15.990 --> 00:06:19.530
pick multiplication before addition,
and that's what we mean by precedence.

118
00:06:19.530 --> 00:06:26.370
So, we could say that this thing is
an expression because it is the thing

119
00:06:26.370 --> 00:06:30.410
the computer would do first, before
considering what's happening on the plus.

120
00:06:30.410 --> 00:06:33.280
So now, if you're not getting
lost in this sea of brackets,

121
00:06:33.280 --> 00:06:37.010
you can see that I have one expression
here, and I have one expression here.

122
00:06:37.010 --> 00:06:41.440
Those two are the binary operands,
other fancy word,

123
00:06:41.440 --> 00:06:44.110
to say the values that go
into the plus operator.

124
00:06:44.110 --> 00:06:47.200
So now we have one more
wrapping of brackets.

125
00:06:47.200 --> 00:06:50.970
This is getting out of hand of course but
we now have a wrapping around that entire

126
00:06:50.970 --> 00:06:55.800
thing, now this is one big
complicated evaluation to

127
00:06:55.800 --> 00:07:00.841
take b times two and add it to the result
of calling foo with c times 3 pass down.

128
00:07:02.080 --> 00:07:06.180
So we'll put all of that together to be a,
an expression value and

129
00:07:06.180 --> 00:07:09.620
that expression value of course then
gets assigned to the left hand side

130
00:07:09.620 --> 00:07:14.630
to the a variable that's over there and
finally one last set of crazy brackets.

131
00:07:14.630 --> 00:07:17.310
Around the entire assignment expression.

132
00:07:17.310 --> 00:07:20.420
And now we've identified all those
different little pieces that

133
00:07:20.420 --> 00:07:23.340
nest themselves together to
become what we call a statement.

134
00:07:24.800 --> 00:07:27.010
Of course, it looks a lot easier to
read when we don't have all those

135
00:07:27.010 --> 00:07:27.820
brackets in, right?.

136
00:07:27.820 --> 00:07:32.964
So if I go back to the original statement
without all those crazy brackets

137
00:07:32.964 --> 00:07:37.945
in.
&gt;&gt; Kyle Simpson: We

138
00:07:37.945 --> 00:07:40.300
can come back to that same understanding.

139
00:07:40.300 --> 00:07:45.060
We can say hey, I know I need to do c
times 3 cuz that's gotta get passed in.

140
00:07:45.060 --> 00:07:47.740
so find out what c is currently,
whatever value it is, and

141
00:07:47.740 --> 00:07:50.950
multiply it by 3 and
then pass that into the function too.

142
00:07:50.950 --> 00:07:54.000
And again we'll cover call expressions,
what functions are, we'll cover that in

143
00:07:54.000 --> 00:07:59.970
a little bit And then whatever that value
is, add that to the value of b times 2.

144
00:07:59.970 --> 00:08:01.250
So compute b times 2.

145
00:08:01.250 --> 00:08:02.570
Now I have two different things.

146
00:08:02.570 --> 00:08:07.050
Add those together, and whatever that
final result is, assign it into a.

147
00:08:07.050 --> 00:08:07.920
By the way,

148
00:08:07.920 --> 00:08:13.050
the reason why operator precedence
matters is because mathematically.

149
00:08:13.050 --> 00:08:14.470
This could mean two different things.

150
00:08:14.470 --> 00:08:20.120
If I were to simplify it and
say 2 times 3 plus 4,

151
00:08:20.120 --> 00:08:22.680
mathematically it matters
which one you do first.

152
00:08:27.210 --> 00:08:29.775
2 times 3 plus 4 is 10.

153
00:08:29.775 --> 00:08:32.810
2 times 3 plus 4 is 14, so
mathematically, it matters and

154
00:08:32.810 --> 00:08:36.830
that's why this ambiguity has to be
resolved by the programming language.

155
00:08:36.830 --> 00:08:40.420
The way we resolve that in programming
languages is to understand

156
00:08:40.420 --> 00:08:43.680
a basic concept of operator precedence.

157
00:08:43.680 --> 00:08:49.060
Now, what if you were in the scenario
where you wanted to sort of override

158
00:08:49.060 --> 00:08:50.400
that precedence?

159
00:08:50.400 --> 00:08:51.446
Yeah?
&gt;&gt; Speaker 2: You'd wanna

160
00:08:51.446 --> 00:08:52.531
add parentheses.
&gt;&gt; Kyle Simpson: You'd wanna

161
00:08:52.531 --> 00:08:54.422
add parentheses, exactly.
&gt;&gt; Speaker 2: In fact, you'd wanna add

162
00:08:54.422 --> 00:08:58.193
them in your code just so that you could
Accentuate what you're trying to do.

163
00:08:58.193 --> 00:08:59.029
&gt;&gt; Kyle Simpson: That's exactly the point

164
00:08:59.029 --> 00:09:00.660
that I was going to, great segueway.

165
00:09:00.660 --> 00:09:05.717
So, if I wanted to suggest that this
program should do 2 + foo and then

166
00:09:05.717 --> 00:09:11.579
multiply that by b, then I could forcibly
do that by putting in the parentheses.

167
00:09:13.300 --> 00:09:17.190
These here are not made up visual things.

168
00:09:17.190 --> 00:09:19.599
These are actually things
that matter to the program.

169
00:09:19.599 --> 00:09:20.886
The parentheses here says,

170
00:09:20.886 --> 00:09:24.450
do the stuff inside of the parentheses
first before working your way out.

171
00:09:24.450 --> 00:09:29.300
So now, I have forcibly changed that rule,
if you will, of precedence

172
00:09:29.300 --> 00:09:33.600
by forcibly saying that the plus should
happen before the multiplication.

173
00:09:33.600 --> 00:09:36.480
Exactly the same as in
the 2 times 3 plus 4.

174
00:09:36.480 --> 00:09:39.030
I could have done that by saying,

175
00:09:39.030 --> 00:09:43.220
no, what I really want you to do is come
up with 7 first and then multiply it by 2.

176
00:09:43.220 --> 00:09:45.800
So those parentheses in this case,
they matter.

177
00:09:45.800 --> 00:09:48.060
They matter to the end result.

178
00:09:48.060 --> 00:09:53.420
But what if I did want the b times 2 and
I didn't want the 2 plus?

179
00:09:53.420 --> 00:09:56.880
I want it to happen the same
way as operator precedence

180
00:09:56.880 --> 00:09:58.820
to the point that was just brought up.

181
00:09:58.820 --> 00:10:01.630
I can still put in a set
of parentheses here.

182
00:10:03.580 --> 00:10:06.840
They're not necessary to
the functioning of the program.

183
00:10:06.840 --> 00:10:10.220
They don't change
the outcome of the program.

184
00:10:10.220 --> 00:10:13.700
It's still gonna do exactly the same
thing as if I left them out.

185
00:10:13.700 --> 00:10:16.930
But here is that point that we were
talking about earlier where it's this

186
00:10:16.930 --> 00:10:21.690
balance, this goal to try to make sure
that your code is understandable.

187
00:10:22.830 --> 00:10:26.390
If we put something into a program
that the computer doesn't care about,

188
00:10:26.390 --> 00:10:29.960
then the only other reason for it could
be that a developer cares about it.

189
00:10:29.960 --> 00:10:35.340
So developer here not needing to know
the rules of operator precedence

190
00:10:35.340 --> 00:10:41.200
doesn't have to understand whether
times or plus happens first.

191
00:10:41.200 --> 00:10:45.330
If all they understand is the fact that
parenthesis wrap together then they can

192
00:10:45.330 --> 00:10:49.920
process through this program and say
clearly I should do this thing first and

193
00:10:49.920 --> 00:10:51.940
this thing, and then add them together.

194
00:10:51.940 --> 00:10:54.050
So for readability's sake,

195
00:10:54.050 --> 00:10:56.710
you would probably tend to
wanna put the parenthesis in.

196
00:10:57.980 --> 00:11:03.330
Basically the takeaway here is that,
even if you know intricately all the rules

197
00:11:03.330 --> 00:11:08.060
of operator precedence, you don't always
wanna write a program that relies on it.

198
00:11:08.060 --> 00:11:09.920
Sometimes it's helpful but

199
00:11:09.920 --> 00:11:14.910
sometimes it's more appropriate to add
additional things to your program.

200
00:11:14.910 --> 00:11:16.050
Like in this case,

201
00:11:16.050 --> 00:11:19.640
an optional set of parentheses,
to make the code make more sense.

202
00:11:19.640 --> 00:11:21.570
Question.
&gt;&gt; Speaker 2: The question was,

203
00:11:21.570 --> 00:11:24.490
without the parentheses, will it get
the value of the function first or

204
00:11:24.490 --> 00:11:26.950
the variable b?
&gt;&gt; Kyle Simpson: That's a great question.

205
00:11:26.950 --> 00:11:31.600
So, if I didn't put this parentheses here,
what's gonna actually happen?

206
00:11:31.600 --> 00:11:36.620
Well the rules of operator
precedents say which operator,

207
00:11:36.620 --> 00:11:40.160
if two different operators show up in
a line like this without any other kind of

208
00:11:40.160 --> 00:11:42.730
grouping, it's gonna say
which thing happens first?

209
00:11:42.730 --> 00:11:45.250
So from a left to right perspective,

210
00:11:45.250 --> 00:11:49.080
the b times two is gonna happen first
before calling the foo function.

211
00:11:50.650 --> 00:11:54.330
If the foo function had been in the left
position, then the foo function would have

212
00:11:54.330 --> 00:11:57.410
been called, and
then the b times 2 would have happened.

213
00:11:57.410 --> 00:12:00.500
So the programming language
does typically and

214
00:12:00.500 --> 00:12:03.130
generally move in a left to right fashion.

215
00:12:04.410 --> 00:12:06.900
Meaning that something on the left
is typically gonna happen before

216
00:12:06.900 --> 00:12:07.900
something on the right.

217
00:12:07.900 --> 00:12:11.947
Even if we looked only at this expression
right here, the b * 2 expression,

218
00:12:11.947 --> 00:12:16.311
we could say that the programming language
will evaluate the thing on the left first

219
00:12:16.311 --> 00:12:18.608
before evaluating the thing on the right.

220
00:12:18.608 --> 00:12:21.000
So typically it's gonna work
in left to right fashion.

221
00:12:21.000 --> 00:12:25.140
The only time when that is broken is if
there's something like operator precedence

222
00:12:25.140 --> 00:12:27.920
or there's another related concept
called associativity which we don't

223
00:12:27.920 --> 00:12:28.460
need to get into.

224
00:12:28.460 --> 00:12:33.680
But if precedence or associativity
overrides left to right behavior.

225
00:12:33.680 --> 00:12:36.400
And in those cases,
it could force something to happen.

226
00:12:36.400 --> 00:12:42.020
So if I were to simply reverse these two,
and

227
00:12:42.020 --> 00:12:44.760
say b plus 2 times foo.

228
00:12:44.760 --> 00:12:49.510
Now we know that operator precedence
is gonna say, don't, I mean,

229
00:12:49.510 --> 00:12:54.780
we are gonna evaluate the b part first,
and evaluate the two part first,

230
00:12:54.780 --> 00:12:59.730
but here we're going to call this
foo function before we add it to b.

231
00:13:01.460 --> 00:13:04.880
Because we gotta compute
that whole expression first.

232
00:13:04.880 --> 00:13:07.390
So operator precedence can work to

233
00:13:07.390 --> 00:13:11.780
sort of tweak the way this normal
left to right processing happens.

234
00:13:11.780 --> 00:13:14.990
But overall you still see that even inside
of each expression it still works in

235
00:13:14.990 --> 00:13:15.830
a left to right fashion.

236
00:13:17.120 --> 00:13:19.030
So that's a great question.

237
00:13:19.030 --> 00:13:22.890
Yeah I like what's said in the chat room,
be kind to your future, more elderly self.

238
00:13:22.890 --> 00:13:27.850
That's definitely true.
&gt;&gt; Speaker 2: I don't want to

239
00:13:27.850 --> 00:13:32.526
get way ahead of myself but is there any
difference between specifying as 2 and

240
00:13:32.526 --> 00:13:36.130
2.0, does it matter?
&gt;&gt; Kyle Simpson: In some langauges it

241
00:13:36.130 --> 00:13:40.390
matters in Java script it
doesn't in Javascript 2 and

242
00:13:40.390 --> 00:13:44.720
2 point and 2.0 are all the same value
because there is just one number value

