WEBVTT

1
00:00:00.170 --> 00:00:03.080
&gt;&gt; Kyle Simpson: Another interesting
perspective on why functional programming.

2
00:00:04.610 --> 00:00:08.410
And this is more from
the mathematical perspective.

3
00:00:08.410 --> 00:00:12.990
Functional programming though
it looks very programming esque,

4
00:00:12.990 --> 00:00:17.080
it looks like function calls,
it's actually math.

5
00:00:18.420 --> 00:00:20.240
Now, I don't know the math.

6
00:00:21.530 --> 00:00:24.970
And I would guess that at least some
of you don't know the math either.

7
00:00:24.970 --> 00:00:27.730
But you know what, that's okay.

8
00:00:27.730 --> 00:00:31.060
This isn't a math course,
I don't need to teach you the math for

9
00:00:31.060 --> 00:00:32.430
you to benefit from it and here's why.

10
00:00:33.560 --> 00:00:35.850
I'm sure all of you at some time or
another,

11
00:00:35.850 --> 00:00:38.110
probably recently,
have eaten out in a restaurant.

12
00:00:39.230 --> 00:00:43.900
And they brought you the bill and
you had to do some basic arithmetic to

13
00:00:43.900 --> 00:00:48.920
figure what tip to add and how much you're
gonna charge on your credit card, okay?

14
00:00:49.920 --> 00:00:53.610
Now, you probably learned,
most of these at least,

15
00:00:53.610 --> 00:00:58.620
probably learned basic arithmetic back in
1st, 2nd, 3rd grade something like that.

16
00:00:58.620 --> 00:01:01.119
And you've been using those
life skills ever since.

17
00:01:02.580 --> 00:01:07.197
And I'm also willing to bet that
the vast majority if not all of you,

18
00:01:07.197 --> 00:01:12.471
have never actually gone through
the formal proof of why 1 plus 1 equals 2.

19
00:01:12.471 --> 00:01:14.480
You've never gone to that level of math.

20
00:01:14.480 --> 00:01:16.730
Did you know that there's
an actual formal proof for it?

21
00:01:16.730 --> 00:01:21.780
And did you know that it's amazingly
complex to prove that 1 plus 1 equals 2.

22
00:01:21.780 --> 00:01:25.630
I can't even begin to explain the math
you of that, so I'm not even gonna try.

23
00:01:26.800 --> 00:01:30.440
The point is that we're able to take
advantage of a mathematical principle

24
00:01:30.440 --> 00:01:32.170
even if we can't prove it to ourselves.

25
00:01:33.780 --> 00:01:36.396
We can add 1 plus 1 equals 2.

26
00:01:36.396 --> 00:01:40.400
And guess what, we never ever
question 1 plus 1 equals 2, do we?

27
00:01:42.020 --> 00:01:45.900
Is there ever been a time where you were
like, well, I added 10 and 9 together and

28
00:01:45.900 --> 00:01:47.150
I got 19, but is it really 19?

29
00:01:47.150 --> 00:01:49.900
I'm not sure, like, no, you just do it.

30
00:01:51.970 --> 00:01:54.960
So when I tell you that functional
programming is based on mathematical

31
00:01:54.960 --> 00:02:00.510
principles, you can rest on the fact
that if you do 1 plus 1 and

32
00:02:00.510 --> 00:02:04.190
you get 2, that's the end of the story.

33
00:02:04.190 --> 00:02:07.040
The math proves that whether you
can go through the formal proof or

34
00:02:07.040 --> 00:02:08.910
not, is a secondary issue.

35
00:02:10.150 --> 00:02:14.720
Functional programmers, by the way,
seem to get a particular joy in life from

36
00:02:14.720 --> 00:02:19.390
going through the formal proofs and that's
totally okay, but it didn't work for me.

37
00:02:22.290 --> 00:02:25.370
I should say, it has not yet
worked for me.

38
00:02:25.370 --> 00:02:26.665
I'm not at the point of my journey yet,

39
00:02:26.665 --> 00:02:31.160
where to learn a thing means that I need
to go learn some mathematical laws and

40
00:02:31.160 --> 00:02:35.250
apply it, and do some notations and
some conversions of the equations.

41
00:02:35.250 --> 00:02:36.749
That isn't how I learned this stuff.

42
00:02:38.050 --> 00:02:42.957
And yet, I can still take advantage
of the fact that if I know

43
00:02:42.957 --> 00:02:46.982
that this thing done this way,
has this result,

44
00:02:46.982 --> 00:02:51.711
it's the same thing as relying
up on 1 plus 1 equals 2.

45
00:02:51.711 --> 00:02:54.850
If I do it the right way,
I know what the end result's gonna be.

46
00:02:56.390 --> 00:03:00.060
How many of you have ever written
a test in your program before?

47
00:03:00.060 --> 00:03:03.762
Anybody done tests, probably a lot of
you do TDD, I know that's very popular.

48
00:03:03.762 --> 00:03:06.756
TDD, where you write a test and
then you run some code and

49
00:03:06.756 --> 00:03:09.380
you're hoping that it passes the test,
right?

50
00:03:09.380 --> 00:03:12.057
Or maybe you do it the other way around,
you write some code and

51
00:03:12.057 --> 00:03:13.086
then you write a test and

52
00:03:13.086 --> 00:03:16.730
the test fails and now you're questioning,
is my test bad or is my code bad?

53
00:03:16.730 --> 00:03:19.370
Not really sure, for
me, it's usually both.

54
00:03:19.370 --> 00:03:23.590
But we're trying to get the test to run
and we're trying to get it to pass,

55
00:03:23.590 --> 00:03:24.260
we want the green.

56
00:03:26.590 --> 00:03:28.710
Somewhat universal experience for us.

57
00:03:30.240 --> 00:03:32.750
Here's what happens for me and
maybe it happens for you.

58
00:03:34.140 --> 00:03:36.020
I write some code and

59
00:03:36.020 --> 00:03:40.310
then I go to run the test, I'm not really
sure whether it's gonna pass or not.

60
00:03:42.020 --> 00:03:48.980
I think it will, I hope it will,
maybe, let's see.

61
00:03:48.980 --> 00:03:51.420
Nope, it didn't pass, failed.

62
00:03:51.420 --> 00:03:52.430
So, what do I do?

63
00:03:52.430 --> 00:03:56.990
I go back and I wrap some parentheses
around something and I try it again.

64
00:03:56.990 --> 00:03:58.910
No, didn't work,
okay then I add one to it.

65
00:03:58.910 --> 00:04:03.730
Nope didn't work and I just keep fumbling
my way through because if I really

66
00:04:03.730 --> 00:04:08.100
understood it in the first time that I did
it, the test would have passed, right?

67
00:04:08.100 --> 00:04:09.830
So we are clearly into territory,

68
00:04:09.830 --> 00:04:12.990
this gray area where most of
us spend most of our career.

69
00:04:12.990 --> 00:04:16.230
We're in this gray area where we only
partially understand the problem we're

70
00:04:16.230 --> 00:04:19.290
trying to solve, not zero.

71
00:04:19.290 --> 00:04:22.460
You are a smart people,
you understand some of it.

72
00:04:22.460 --> 00:04:23.985
You just don't understand enough of it,

73
00:04:23.985 --> 00:04:28.350
cuz if you did understand all of it,
then it would pass the first time.

74
00:04:28.350 --> 00:04:31.120
Unless you fat finger a typo or something.

75
00:04:31.120 --> 00:04:35.440
But most of the time our bugs are like
logic bugs where we kind of understand

76
00:04:35.440 --> 00:04:38.870
the problem domain, we kind of understand
the algorithm, but not entirely.

77
00:04:38.870 --> 00:04:41.440
So we fumble our way toward it.

78
00:04:41.440 --> 00:04:45.604
This is how I've done almost all of
my programming for 25 plus years, so

79
00:04:45.604 --> 00:04:48.845
I fumble my way towards
something where the test passed.

80
00:04:48.845 --> 00:04:52.418
And then I'm like thank God, and
then I move on to the next thing.

81
00:04:52.418 --> 00:04:54.252
And it's this building and
building and building.

82
00:04:56.652 --> 00:05:01.491
&gt;&gt; Kyle Simpson: Some of you are nodding
your heads like you can relate to that,

83
00:05:01.491 --> 00:05:03.320
what would it be like?

84
00:05:03.320 --> 00:05:09.270
What would it change in your programming,
in your profession,

85
00:05:09.270 --> 00:05:10.070
in your day to day work?

86
00:05:11.670 --> 00:05:14.737
If almost every time that
you went to run a test,

87
00:05:14.737 --> 00:05:17.508
you were 100% certain of the outcome?

88
00:05:20.413 --> 00:05:21.490
&gt;&gt; Kyle Simpson: What would that do for
you?

89
00:05:22.670 --> 00:05:28.574
Would you spend less cycles trying to
fumble your way through figuring it out?

90
00:05:28.574 --> 00:05:30.280
Maybe, hopefully.

91
00:05:32.314 --> 00:05:36.009
&gt;&gt; Kyle Simpson: I'm not suggesting that
you would never run the test, but maybe

92
00:05:36.009 --> 00:05:40.540
you'd run them less often because you
begin to develop a sense of confidence.

93
00:05:40.540 --> 00:05:44.200
I know what I'm doing,
I'm not an imposter anymore.

94
00:05:44.200 --> 00:05:46.640
When I do it, it does the right thing.

95
00:05:46.640 --> 00:05:49.208
Maybe that you would make you
a more effective programmer.

96
00:05:51.848 --> 00:05:55.399
&gt;&gt; Kyle Simpson: One of the reasons why
functional programming is compelling,

97
00:05:55.399 --> 00:06:00.910
at least to me, is it offers the promise
that we can use principles of programming.

98
00:06:00.910 --> 00:06:03.400
Not that somebody just wrote
about in a blog post or

99
00:06:03.400 --> 00:06:08.620
gave a fancy conference talk about,
but it's based on real hard math.

100
00:06:10.490 --> 00:06:13.616
And even if I don't understand the math,
I can trust the mathematicians.

101
00:06:16.400 --> 00:06:18.899
&gt;&gt; Kyle Simpson: I'd like to
have more of my code like that.

102
00:06:18.899 --> 00:06:23.795
I don't know about you, but I'd like to
have more of my code in that category of,

103
00:06:23.795 --> 00:06:28.310
I guarantee you it's gonna do
the right thing every time.

104
00:06:28.310 --> 00:06:31.030
If I use it correctly,
if I legitimately do one and one and

105
00:06:31.030 --> 00:06:33.970
I get two, I don't have to
question that again, that's done.

106
00:06:35.730 --> 00:06:37.740
And that would free up our attention,

107
00:06:37.740 --> 00:06:41.160
I think,
to focus on the more important parts.

108
00:06:41.160 --> 00:06:44.750
Those higher level important things,
those logic and

109
00:06:44.750 --> 00:06:48.222
business domain questions that we
should be spending our time on.

110
00:06:48.222 --> 00:06:51.639
It'd free us up for that and I think
that'd be a good thing if we could free

111
00:06:51.639 --> 00:06:54.398
up our attention and
shift our attention to those things.

112
00:06:56.936 --> 00:06:58.948
&gt;&gt; Kyle Simpson: So that's one of
the compelling reasons why functional

113
00:06:58.948 --> 00:07:00.120
programming.

114
00:07:00.120 --> 00:07:03.665
We know that these techniques
are not just a nicely designed API,

115
00:07:03.665 --> 00:07:06.910
as a matter of fact some of them
are kinda weirdly designed.

116
00:07:06.910 --> 00:07:09.720
They're not just about
a nice design of an API or

117
00:07:09.720 --> 00:07:14.220
a clever name, they're about
using mathematical principles.

118
00:07:14.220 --> 00:07:18.211
In a mathematically sound way that just
happens to look like programming, and

119
00:07:18.211 --> 00:07:20.759
it happens to let us solve
programming problems.

120
00:07:24.027 --> 00:07:26.137
&gt;&gt; Kyle Simpson: Ultimately,
what I'm getting at here,

121
00:07:26.137 --> 00:07:28.197
I think this is the ultimate reason why.

122
00:07:28.197 --> 00:07:32.817
So you have some people say, there's a lot
of different things that people will say

123
00:07:32.817 --> 00:07:34.410
about what is the best code.

124
00:07:36.280 --> 00:07:40.179
I would say that the best code is
the code that didn't have to be read.

125
00:07:40.179 --> 00:07:43.760
And that might sound a little strange
to you, but let me explain it this way.

126
00:07:45.300 --> 00:07:47.097
There's a code base that
has 10,000 lines of code.

127
00:07:48.285 --> 00:07:54.255
What if 9900 lines of that code was based
upon proven mathematical principles and

128
00:07:54.255 --> 00:07:56.935
I didn't ever have to second
guess any of that stuff.

129
00:07:56.935 --> 00:07:59.865
And there were just 100
lines of business logic code

130
00:07:59.865 --> 00:08:01.945
that I spent all day
every day thinking about.

131
00:08:04.145 --> 00:08:06.935
Would that code base be more effective for
me to manage?

132
00:08:06.935 --> 00:08:09.739
Would it be easier for
me to find and fix bugs,

133
00:08:10.910 --> 00:08:14.590
if I reduce the surface area
of what I needed to focus on?

134
00:08:17.100 --> 00:08:21.120
I think that's one of the reasons why
functional programming is compelling.

135
00:08:22.820 --> 00:08:27.579
I hope these ideas are gonna help you when
you have that inevitable conversation with

136
00:08:27.579 --> 00:08:29.669
the other people that you code with.

137
00:08:31.250 --> 00:08:34.410
People you work with on open-source
projects or people that you work with at

138
00:08:34.410 --> 00:08:38.990
your job, people you work with in
your class if you are in school.

139
00:08:40.110 --> 00:08:43.080
You're gonna have to ask them
to come on the journey as well.

140
00:08:43.080 --> 00:08:45.810
You gonna have to convince them to
come on the journey as well and

141
00:08:45.810 --> 00:08:48.650
those are some reasons
why functional program.

