WEBVTT

1
00:00:00.490 --> 00:00:02.000
Let's talk about JavaScript.

2
00:00:02.000 --> 00:00:06.560
And I like to do it with this little game
here, who wants to be a Javascriptaire.

3
00:00:06.560 --> 00:00:10.030
And for this, I'm gonna need a volunteer.

4
00:00:10.030 --> 00:00:14.350
So this is totally different than a game
show called Who Wants to Be a Millionaire?

5
00:00:14.350 --> 00:00:17.410
Because I do not have any
license to use that whatsoever.

6
00:00:17.410 --> 00:00:19.810
And so that is definitely
not read just asking you,

7
00:00:19.810 --> 00:00:22.870
are you ready to play Who Wants
to be a Javascriptaire?

8
00:00:22.870 --> 00:00:23.580
Are you ready?
&gt;&gt; Yes.

9
00:00:23.580 --> 00:00:26.000
&gt;&gt; All right, so
this is gonna work just like it.

10
00:00:26.000 --> 00:00:28.280
I'm gonna ask you
a multiple choice question.

11
00:00:28.280 --> 00:00:29.470
Five of them.

12
00:00:29.470 --> 00:00:34.190
You have one lifeline, one ask
the audience whereby round of applause,

13
00:00:34.190 --> 00:00:37.110
they can tell you what
they think the answer is.

14
00:00:37.110 --> 00:00:39.440
Audience, no cheating.

15
00:00:39.440 --> 00:00:43.990
No opening up your console and
typing in like what is the answer to this.

16
00:00:43.990 --> 00:00:44.660
Honest system.

17
00:00:44.660 --> 00:00:47.000
All right, you ready?

18
00:00:47.000 --> 00:00:47.750
All right.

19
00:00:47.750 --> 00:00:50.160
What does this JavaScript code return?

20
00:00:52.010 --> 00:00:55.862
The string, poop emoji dot length.

21
00:00:55.862 --> 00:00:58.149
Is it A ,undefined.

22
00:00:58.149 --> 00:01:01.760
B 1, C 2, or D, it's an error?

23
00:01:02.890 --> 00:01:07.070
&gt;&gt; I know it's not D,
and B would be too easy.

24
00:01:07.070 --> 00:01:09.120
So, C.

25
00:01:09.120 --> 00:01:10.240
&gt;&gt; C, final answer?

26
00:01:10.240 --> 00:01:12.860
&gt;&gt; Yes.
&gt;&gt; All right, it is C.

27
00:01:13.990 --> 00:01:18.920
In JavaScript, the string length
property returns the number of bytes

28
00:01:18.920 --> 00:01:23.860
actually code points, rather than
the number of characters like we expect.

29
00:01:23.860 --> 00:01:27.710
Unicode characters like all emojis
are actually two bytes to describe.

30
00:01:27.710 --> 00:01:31.390
And so the length of a string will
not always be what you expect it

31
00:01:31.390 --> 00:01:33.290
if it contains Unicode characters.

32
00:01:34.860 --> 00:01:35.930
All right, how about this one?

33
00:01:35.930 --> 00:01:41.503
What will this JavaScript
code return 0.1 + 0.2?

34
00:01:43.823 --> 00:01:46.124
Is it A, 0.3.

35
00:01:46.124 --> 00:01:50.492
B, 0.29999 a bunch of things.

36
00:01:50.492 --> 00:01:55.274
C, 0.300000 a bunch things 4,

37
00:01:55.274 --> 00:01:58.288
or D, the string 0.3?

38
00:02:03.933 --> 00:02:06.410
What's running through your head?

39
00:02:06.410 --> 00:02:08.158
We got to make this good for TV.

40
00:02:08.158 --> 00:02:09.354
&gt;&gt; [LAUGH]
&gt;&gt; Well, yes, sure.

41
00:02:09.354 --> 00:02:12.300
If the answer was A this would
probably not be a question.

42
00:02:12.300 --> 00:02:13.951
&gt;&gt; Good call, good thinking.

43
00:02:13.951 --> 00:02:16.582
&gt;&gt; D,
&gt;&gt; Even though [CROSSTALK] I think we can

44
00:02:16.582 --> 00:02:19.231
agree that A would be
the the expected choice.

45
00:02:19.231 --> 00:02:22.850
&gt;&gt; If a human was doing it
&gt;&gt; [LAUGH]

46
00:02:22.850 --> 00:02:24.820
&gt;&gt; So, neither of those are strings, so

47
00:02:24.820 --> 00:02:27.570
probably not D.

48
00:02:27.570 --> 00:02:28.745
So either B or C.

49
00:02:28.745 --> 00:02:31.380
We're gonna go with B.

50
00:02:31.380 --> 00:02:32.370
&gt;&gt; B, final answer?

51
00:02:34.040 --> 00:02:36.060
I'm sorry it is C.

52
00:02:36.060 --> 00:02:41.080
So Java scripts floating point operations
overflow the rounding precision.

53
00:02:41.080 --> 00:02:45.210
In order to use JavaScript floating point
operations, you need to use the two

54
00:02:45.210 --> 00:02:48.670
precision function to guarantee
that you are getting that correct.

55
00:02:48.670 --> 00:02:51.530
This is actually a problem in
a lot of languages surprisingly.

56
00:02:52.950 --> 00:02:54.620
All right, next question.

57
00:02:54.620 --> 00:02:56.820
This is probably my favorite.

58
00:02:56.820 --> 00:02:59.902
What will the following
JavaScript code return?

59
00:02:59.902 --> 00:03:03.870
A new date, 2016, 5, 31.

60
00:03:03.870 --> 00:03:07.830
Will it be July 1st, 2016, June

61
00:03:09.520 --> 00:03:14.250
31st, 2016, May 31st,
2016, or May 31st, 2017?

62
00:03:14.250 --> 00:03:19.202
&gt;&gt; So the fifth month is May,

63
00:03:19.202 --> 00:03:24.388
which does have 31 days.

64
00:03:26.985 --> 00:03:31.450
But again,
this is probably not the obvious answer.

65
00:03:31.450 --> 00:03:32.140
&gt;&gt; It might not.

66
00:03:32.140 --> 00:03:32.640
Yeah.

67
00:03:34.180 --> 00:03:37.556
It might not prove my point
that JavaScript is weird if

68
00:03:37.556 --> 00:03:38.151
it-
&gt;&gt; Exactly.

69
00:03:38.151 --> 00:03:41.240
&gt;&gt; Does exactly what
you think it would do.

70
00:03:41.240 --> 00:03:45.700
So if we start counting nodes at 0
&gt;&gt; I don't know.

71
00:03:45.700 --> 00:03:50.840
And that would be June 31,
which isn't a thing.

72
00:03:52.820 --> 00:03:54.690
So, A.

73
00:03:55.770 --> 00:03:56.810
&gt;&gt; A, final answer?

74
00:03:56.810 --> 00:03:57.310
&gt;&gt; Yes.

75
00:04:00.200 --> 00:04:02.780
&gt;&gt; All right, very good, it is A.

76
00:04:02.780 --> 00:04:05.310
I think you're the first person
to ever get this one right

77
00:04:07.350 --> 00:04:09.520
&gt;&gt; Months, when constructing dates and

78
00:04:09.520 --> 00:04:12.070
only months are zero based.

79
00:04:12.070 --> 00:04:16.570
So this does indeed specify June 31st,
which doesn't exist and

80
00:04:16.570 --> 00:04:17.990
it overflows into July 1st, 2016.

81
00:04:17.990 --> 00:04:22.670
All right, question four and
you still have a lifeline left.

82
00:04:24.000 --> 00:04:29.074
What will this JavaScript code return,
a new array of 01 and

83
00:04:29.074 --> 00:04:32.405
another array, instantiate with two.

84
00:04:34.264 --> 00:04:36.950
These are too hard for me to speak.

85
00:04:36.950 --> 00:04:40.347
So I'm just going to
say look at the slide.

86
00:04:40.347 --> 00:04:41.320
&gt;&gt; Right.

87
00:04:41.320 --> 00:04:49.484
So I think what we have here would
be an Array within an Array.

88
00:04:49.484 --> 00:04:50.162
So not B.

89
00:04:58.436 --> 00:05:00.720
I'm gonna ask the audience.

90
00:05:00.720 --> 00:05:01.220
&gt;&gt; All right.

91
00:05:01.220 --> 00:05:06.670
Audience, without cheating, what do
you think it is by round of applause?

92
00:05:06.670 --> 00:05:07.410
Who think it's A?

93
00:05:09.780 --> 00:05:10.590
Nobody thinks it's A.

94
00:05:10.590 --> 00:05:11.280
Who thinks it's B?

95
00:05:13.150 --> 00:05:14.080
Nobody thinks it's B.

96
00:05:14.080 --> 00:05:17.765
Who thinks it's C?

97
00:05:17.765 --> 00:05:20.202
&gt;&gt; [APPLAUSE]
&gt;&gt; Okay, who thinks it's D?

98
00:05:20.202 --> 00:05:23.674
&gt;&gt; [APPLAUSE]
&gt;&gt; All right,

99
00:05:23.674 --> 00:05:26.635
somewhere in between C and
D I think [LAUGH].

100
00:05:26.635 --> 00:05:28.600
The audience isn't collectively sure.

101
00:05:32.055 --> 00:05:35.385
&gt;&gt; D.

102
00:05:35.385 --> 00:05:42.840
&gt;&gt; D?
Why do you think it's D?

103
00:05:42.840 --> 00:05:44.415
&gt;&gt; Maybe it's C.

104
00:05:44.415 --> 00:05:52.609
&gt;&gt; [LAUGH]
&gt;&gt; Doo doo.

105
00:05:56.065 --> 00:05:56.810
Which one do you think?

106
00:05:59.280 --> 00:06:00.410
Waffling between C and D?

107
00:06:00.410 --> 00:06:03.860
&gt;&gt; Yep, we'll go with D.

108
00:06:03.860 --> 00:06:04.880
&gt;&gt; D, final answer?

109
00:06:06.760 --> 00:06:07.270
&gt;&gt; No.
&gt;&gt; [LAUGH]

110
00:06:07.270 --> 00:06:09.420
&gt;&gt; C, final answer.

111
00:06:09.420 --> 00:06:10.310
&gt;&gt; C, final answer.

112
00:06:10.310 --> 00:06:13.180
&gt;&gt; Yes.
&gt;&gt; All right, here we go.

113
00:06:15.120 --> 00:06:16.120
I'm sorry it was D.

114
00:06:17.380 --> 00:06:20.560
Instantiating an Array with
multiple arguments creates and

115
00:06:20.560 --> 00:06:22.660
Array with those values in it.

116
00:06:22.660 --> 00:06:26.110
However, if you instantiate
an Array with a single argument,

117
00:06:26.110 --> 00:06:29.040
it creates an empty
Array with that length.

118
00:06:30.280 --> 00:06:37.330
So it could create D with 0, 1 and then an
Array with two undefined positions in it.

119
00:06:37.330 --> 00:06:38.776
Last question.

120
00:06:38.776 --> 00:06:42.700
What will this JavaScript code return?

121
00:06:42.700 --> 00:06:47.292
10, 5, 1 in an Array sorted.

122
00:06:47.292 --> 00:06:47.903
Will it be A, 1, 5 ,10.

123
00:06:47.903 --> 00:06:51.902
B, 10, 5, 1.

124
00:06:51.902 --> 00:06:56.262
C, 1 ,10, 5 or D 5, 10, 1?

125
00:07:00.226 --> 00:07:02.909
What do you think a sorted Array
in JavaScript would look like?

126
00:07:05.050 --> 00:07:07.096
Well, it should look like A, right?

127
00:07:07.096 --> 00:07:14.002
But, Yeah, and

128
00:07:14.002 --> 00:07:21.598
I used my lifeline, so A, final answer.

129
00:07:21.598 --> 00:07:23.030
&gt;&gt; A, final answer.

130
00:07:24.783 --> 00:07:29.340
Sorry, you should have known it
wouldn't have been the expected answer.

131
00:07:29.340 --> 00:07:34.680
The Array prototype sort's
default comparison uses strings.

132
00:07:34.680 --> 00:07:39.520
It casts every number or every thing in
the array to a string and sorts it then.

133
00:07:39.520 --> 00:07:46.170
So the string 1, the string 10, the string
5, is the sorted order, alphabetically.

134
00:07:46.170 --> 00:07:47.660
So JavaScript is weird, right?

135
00:07:48.955 --> 00:07:54.300
here's so many of those, dozens and
dozens and dozens of these

136
00:07:54.300 --> 00:07:59.690
bizarre little things that JavaScript acts
in ways that we don't always expect it to.

137
00:07:59.690 --> 00:08:04.060
And that's just the language, layer on top
of that all of the deployment things that

138
00:08:04.060 --> 00:08:07.879
we have to do to build JavaScript web
apps and no wonder we have lots of bugs.

139
00:08:09.160 --> 00:08:12.340
And JavaScript happens,
JavaScript is everywhere.

140
00:08:12.340 --> 00:08:15.230
Many of our applications
JavaScript is the easiest place to

141
00:08:15.230 --> 00:08:17.250
change something at the last minute.

142
00:08:17.250 --> 00:08:20.730
You need to make one final
tweak to that e-commerce site,

143
00:08:20.730 --> 00:08:23.120
change how a product looks,
where's the easiest place to do it?

144
00:08:23.120 --> 00:08:25.610
Throw a little JavaScript on the page.

145
00:08:25.610 --> 00:08:27.202
You want change how
the checkout flow works?

146
00:08:27.202 --> 00:08:29.060
You throw a little JavaScript on the page.

147
00:08:29.060 --> 00:08:30.190
Before you know it,

148
00:08:30.190 --> 00:08:34.030
an app that wasn't supposed to be all
JavaScript is covered in JavaScript.

149
00:08:36.330 --> 00:08:40.710
And debugging JavaScript is like being
a detective in a crime movie where

150
00:08:40.710 --> 00:08:43.840
you are also the murderer.

151
00:08:43.840 --> 00:08:46.760
Because we did it to ourselves, right?

152
00:08:46.760 --> 00:08:48.750
We wrote that code.

153
00:08:48.750 --> 00:08:54.060
The collective we, it might have
been Nancy the next cube over,

154
00:08:54.060 --> 00:09:00.020
but collectively we wrote it as
developers and so it's our fault.

155
00:09:00.020 --> 00:09:03.660
And so we need to figure out ways to
when we screw up find it faster and

156
00:09:03.660 --> 00:09:05.950
prevent it from happening the next time.

