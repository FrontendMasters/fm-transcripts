WEBVTT

1
00:00:00.290 --> 00:00:02.296
So talking about collections,

2
00:00:02.296 --> 00:00:07.210
I think that this will be straightforward
if you're a JavaScript developer.

3
00:00:07.210 --> 00:00:10.210
There are many collections
within the Dart framework.

4
00:00:10.210 --> 00:00:12.376
We're going to see
the most important ones,

5
00:00:12.376 --> 00:00:15.150
the ones that we will
use later in Flutter.

6
00:00:15.150 --> 00:00:19.010
So we have list that are kind of arrays.

7
00:00:19.010 --> 00:00:22.644
The type,
we declare the type with capital L, List.

8
00:00:22.644 --> 00:00:28.620
And within angle brackets,
what are we expecting inside the list?

9
00:00:28.620 --> 00:00:32.950
So list of a string will only accept
the strings within that array.

10
00:00:32.950 --> 00:00:39.850
And we initialize or we have a literal,
a list with JSON syntax.

11
00:00:39.850 --> 00:00:43.778
So we open square brackets and
we put values inside,

12
00:00:43.778 --> 00:00:47.634
comma separated,
as we are used to in JSON, okay?

13
00:00:47.634 --> 00:00:49.550
So that's pretty straightforward.

14
00:00:49.550 --> 00:00:50.371
We also have sets.

15
00:00:50.371 --> 00:00:52.510
What's a set?

16
00:00:52.510 --> 00:00:56.405
A set, this is new, so
it's different from the others you have.

17
00:00:56.405 --> 00:01:02.865
A set actually use curly braces for
the list instead of square brackets.

18
00:01:02.865 --> 00:01:08.339
The difference,
the set will not accept repetitions and

19
00:01:08.339 --> 00:01:11.537
there is no actual order inside.

20
00:01:11.537 --> 00:01:14.732
That's why here it's giving
me some kind of a warning.

21
00:01:14.732 --> 00:01:15.880
It's not an error.

22
00:01:15.880 --> 00:01:21.530
So you will see that errors will appear in
red, and also the file will now be in red.

23
00:01:22.690 --> 00:01:24.010
Let me click somewhere else.

24
00:01:24.010 --> 00:01:26.390
So you can see that that file is in red,
okay?

25
00:01:26.390 --> 00:01:27.718
That means that's an error.

26
00:01:27.718 --> 00:01:32.449
And when you have warnings, and also you
will see the red, they are in the tab.

27
00:01:32.449 --> 00:01:34.955
When you have warnings,
you won't get that red.

28
00:01:34.955 --> 00:01:40.988
It's just a warning saying, hey, it seems
like something might be wrong here.

29
00:01:40.988 --> 00:01:42.684
In this case, I have c twice.

30
00:01:42.684 --> 00:01:47.984
It's telling me, hey,
that's not gonna work.

31
00:01:47.984 --> 00:01:51.746
I mean, it will compile, but after this,

32
00:01:51.746 --> 00:01:56.239
the length of the strings will be three,
not four,

33
00:01:56.239 --> 00:02:00.748
because a set is not accepting duplicates,
okay?

34
00:02:00.748 --> 00:02:05.725
And then we have, Maps

35
00:02:05.725 --> 00:02:10.020
that is similar to a dictionary or
an object in JSON.

36
00:02:10.020 --> 00:02:14.502
When you use JSON syntax,
that is actually pretty similar.

37
00:02:14.502 --> 00:02:15.859
You have key value.

38
00:02:15.859 --> 00:02:20.859
The difference that we have on the type,
the type is called map of

39
00:02:20.859 --> 00:02:26.430
a string integer is that in Dart,
the keys doesn't need to be strings.

40
00:02:27.580 --> 00:02:31.105
So as a key, you can put a number,
you can put a Boolean,

41
00:02:31.105 --> 00:02:35.000
you can put another object,
wherever you want as a key.

42
00:02:35.000 --> 00:02:37.880
So as a key and as a value,
you can pick the type.

43
00:02:39.040 --> 00:02:45.607
So if you have a JSON, so let's say that
you have a JSON object that has a name,

44
00:02:45.607 --> 00:02:50.240
Jane, and you have age,
and the age is a number.

45
00:02:50.240 --> 00:02:51.330
So what's the type now?

46
00:02:52.870 --> 00:02:56.314
Because for the key, let me increase
the font size a little bit, for

47
00:02:56.314 --> 00:02:58.740
the key, we have strings and
a string, right?

48
00:02:58.740 --> 00:03:00.740
So let me put this like this.

49
00:03:01.960 --> 00:03:04.912
By the way, every time you save,
by default,

50
00:03:04.912 --> 00:03:08.320
the plugin is changing
how you're writing this.

51
00:03:08.320 --> 00:03:09.137
So look at this.

52
00:03:09.137 --> 00:03:13.013
I'm doing this and that, I'm saving,

53
00:03:13.013 --> 00:03:17.470
Cmd+S, Ctrl+S, and it's changing this.

54
00:03:17.470 --> 00:03:19.130
What if I use a trailing comma?

55
00:03:20.220 --> 00:03:23.909
If you use a trailing comma and I save,

56
00:03:23.909 --> 00:03:29.916
it's now designing this or
formatting my code in multiline.

57
00:03:29.916 --> 00:03:33.214
So Dart accepts trailing commas.

58
00:03:33.214 --> 00:03:36.126
When you use trailing commas,

59
00:03:36.126 --> 00:03:41.614
the formatting guideline is
to use several lines, okay?

60
00:03:41.614 --> 00:03:47.320
So you can add a trailing comma anywhere,
and that will actually make that, okay?

61
00:03:47.320 --> 00:03:51.722
So if you add the trailing comma
on the array after Denmark,

62
00:03:51.722 --> 00:03:57.110
I add a trailing comma and I save,
it's changing the format of the code.

63
00:03:57.110 --> 00:04:01.055
Of course, that's an IDE definition and
you can change that if you

64
00:04:01.055 --> 00:04:06.040
don't want that, but the Flutter and the
Dart default guideline looks like this.

65
00:04:06.040 --> 00:04:08.280
So what's the type of the JSON variable?

66
00:04:08.280 --> 00:04:10.180
The type is actually a map.

67
00:04:10.180 --> 00:04:14.080
The key is a string, so you can see,
I have two strings here.

68
00:04:14.080 --> 00:04:15.790
But what about the values?

69
00:04:15.790 --> 00:04:18.160
The values are not of the same kind.

70
00:04:20.110 --> 00:04:26.927
So in that case, the implicit type will
take, if I hover over JSON, object.

71
00:04:29.631 --> 00:04:32.185
Object, it's similar to dynamic, but

72
00:04:32.185 --> 00:04:36.030
dynamic accepts also something
that might not be an object.

73
00:04:36.030 --> 00:04:38.313
You say, what, you mentioned
that everything is an object.

74
00:04:38.313 --> 00:04:40.562
Well, there are a couple of exceptions,
for example, null.

75
00:04:40.562 --> 00:04:43.236
The null value is not an object.

76
00:04:46.055 --> 00:04:48.200
Okay, so there are a couple of exception,
the other idea.

77
00:04:48.200 --> 00:04:51.704
So there are difference between
dynamic and object, but at this point,

78
00:04:51.704 --> 00:04:52.917
I think that it's okay.

79
00:04:52.917 --> 00:04:59.933
I mean, we don't need to get too deep
into the low level parts of Dart.

80
00:04:59.933 --> 00:05:02.775
We wanna write an app at this point, okay?

81
00:05:02.775 --> 00:05:04.070
So that's for collections.

82
00:05:04.070 --> 00:05:06.540
Null safety, you were waiting for this.

83
00:05:06.540 --> 00:05:08.550
So null safety works like this.

84
00:05:08.550 --> 00:05:13.170
First, null safety is
not by default in Dart.

85
00:05:13.170 --> 00:05:15.062
It's by default in Flutter.

86
00:05:15.062 --> 00:05:18.055
Because when you create
the project in Flutter,

87
00:05:18.055 --> 00:05:23.102
it automatically prepopulates the Dart
configuration with null safety, okay?

88
00:05:23.102 --> 00:05:31.310
But null safety was added actually not so
far ago, in 2021 was actually stable.

89
00:05:31.310 --> 00:05:36.094
So the idea is that when you
create the variable like this one,

90
00:05:36.094 --> 00:05:41.155
String myName, if I don't set the value,
it doesn't compile.

91
00:05:41.155 --> 00:05:43.945
Because it says, hey,
you need to initialize this.

92
00:05:43.945 --> 00:05:46.600
And you say, well,
can we initialize with null?

93
00:05:46.600 --> 00:05:48.190
No, you cannot do that.

94
00:05:48.190 --> 00:05:51.930
A value of type null can't be assigned
to a variable of type string.

95
00:05:53.220 --> 00:05:57.808
If you say that your variable
will contain a string,

96
00:05:57.808 --> 00:06:03.348
it must contain a string,
unless you use something like this.

97
00:06:03.348 --> 00:06:05.915
You can apply the late prefix.

98
00:06:05.915 --> 00:06:09.653
Late means I don't have the value now for
the string.

99
00:06:09.653 --> 00:06:12.512
I will set it later, okay?

100
00:06:12.512 --> 00:06:19.449
And then you are responsible of setting
a value before using the variable.

101
00:06:19.449 --> 00:06:23.407
If you try to use
the variable without a value,

102
00:06:23.407 --> 00:06:29.205
it will crash your app or it will
make an exception on the web, okay?

103
00:06:29.205 --> 00:06:34.520
Or you can define
the semantic null level type.

104
00:06:34.520 --> 00:06:38.072
And in that case,
you use a question mark after the type,

105
00:06:38.072 --> 00:06:41.840
that one, okay,
a question mark after the type.

106
00:06:41.840 --> 00:06:48.215
That says that it's a null level string,
so it can be a string or it can be null.

107
00:06:48.215 --> 00:06:50.210
I can explicitly put a null or not.

108
00:06:50.210 --> 00:06:52.880
I don't need to explicitly
say equals to null.

109
00:06:52.880 --> 00:06:58.530
But now, it's like a Java or
a C# default object.

110
00:06:58.530 --> 00:07:02.456
It can accept null, but
I need to explicitly say so

111
00:07:02.456 --> 00:07:07.800
in the type declaration, okay,
that I accept null semantically.

112
00:07:09.300 --> 00:07:14.050
But because we haven't a null level
type now, there are some issues.

113
00:07:14.050 --> 00:07:17.678
For example,
if I try to execute this code,

114
00:07:17.678 --> 00:07:21.512
the length of myLastname, it doesn't work.

115
00:07:21.512 --> 00:07:26.040
I'm seeing an error, a compilation error.

116
00:07:26.040 --> 00:07:28.823
You cannot get the length
of a null level string.

117
00:07:28.823 --> 00:07:31.830
Why, does anyone know why?

118
00:07:31.830 --> 00:07:32.870
&gt;&gt; Because it might be null.

119
00:07:32.870 --> 00:07:34.400
&gt;&gt; Because it might be null.

120
00:07:34.400 --> 00:07:38.990
And if it's null, we cannot access
a length or a method or a property.

121
00:07:38.990 --> 00:07:43.418
We will get the famous null pointer
exception or null reference exception.

122
00:07:43.418 --> 00:07:44.910
It depends on the platform.

123
00:07:44.910 --> 00:07:46.580
And we don't want that.

124
00:07:46.580 --> 00:07:50.596
So that's why the platform, the language,

125
00:07:50.596 --> 00:07:55.530
is offering us new ways
to solve the problem.

126
00:07:55.530 --> 00:08:02.286
So we have actually two ways,
the null manual override that actually

127
00:08:02.286 --> 00:08:07.766
it's exclamation mark after
the null level variable.

128
00:08:07.766 --> 00:08:12.550
In that case,
we are assuming it's not null.

129
00:08:13.740 --> 00:08:18.570
I'm saying to the compiler, compiler,
I know this variable might be null.

130
00:08:18.570 --> 00:08:23.190
But I also know because I'm the developer
of this algorithm that it's not null, so

131
00:08:23.190 --> 00:08:24.779
go ahead and get the length.

132
00:08:24.779 --> 00:08:30.740
Of course, if it's null, you will have
a problem, a runtime error, okay?

133
00:08:30.740 --> 00:08:32.456
So you need to be very careful or

134
00:08:32.456 --> 00:08:35.828
you need to be responsible when
you are using this operator.

135
00:08:35.828 --> 00:08:41.156
And also we have the safe call operator
that is actually question mark dot.

136
00:08:41.156 --> 00:08:47.000
In this case, if it's null,
it's not going to execute length.

137
00:08:47.000 --> 00:08:51.340
So it will ignore what's after the dot,
okay?

138
00:08:51.340 --> 00:08:55.720
But because it will ignore it,
question for you,

139
00:08:55.720 --> 00:08:59.173
what do you think the type of length is?

140
00:08:59.173 --> 00:09:00.161
Is it an integer?

141
00:09:00.161 --> 00:09:01.406
Is it int?

142
00:09:04.846 --> 00:09:10.580
Int question mark, because if there is
a last name, we will have an integer.

143
00:09:10.580 --> 00:09:13.250
But if we don't have a last name,
we don't have an integer.

144
00:09:13.250 --> 00:09:18.210
So it's an optional integer,
okay, makes sense?

145
00:09:18.210 --> 00:09:20.000
So that's null safety.

146
00:09:20.000 --> 00:09:22.762
If you're coming from JavaScript
where you have never seen this,

147
00:09:22.762 --> 00:09:24.600
I mean,
it takes a while to get used to that.

148
00:09:25.750 --> 00:09:27.852
Let me say that fortunately,

149
00:09:27.852 --> 00:09:31.900
most of the Flutter framework
is not using this heavily.

150
00:09:31.900 --> 00:09:37.160
So we are going to use this only in our
own business project and our own classes.

151
00:09:37.160 --> 00:09:41.974
But if you're working with the UI,
working with the Flutter framework,

152
00:09:41.974 --> 00:09:44.000
we don't use optionals a lot.

