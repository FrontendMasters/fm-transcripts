WEBVTT

1
00:00:00.340 --> 00:00:05.160
So, the last part that I have on this
section is to talk about classes.

2
00:00:05.160 --> 00:00:07.520
I mentioned this is OOP, okay?

3
00:00:07.520 --> 00:00:08.750
Object oriented programming.

4
00:00:08.750 --> 00:00:12.840
So Dart is actually an object
oriented programming language.

5
00:00:12.840 --> 00:00:15.500
So that means everything is a class.

6
00:00:15.500 --> 00:00:18.395
So if you look at this class declaration,

7
00:00:18.395 --> 00:00:23.293
I have a person class, we will talk
about imports later, but anyway.

8
00:00:23.293 --> 00:00:28.422
I have a class here that has a property,
integer, id.

9
00:00:28.422 --> 00:00:32.021
And then it has a function,
a method, no function keyword.

10
00:00:32.021 --> 00:00:33.590
So this is pretty straightforward, okay?

11
00:00:34.730 --> 00:00:38.715
No big deal, I get that most
of you will get the syntax.

12
00:00:38.715 --> 00:00:44.109
But about creating objects of Dart,
you can use the new keyword as you're

13
00:00:44.109 --> 00:00:49.678
used to in JavaScript and other languages,
or you can omit the new keyword,

14
00:00:49.678 --> 00:00:53.785
like in other languages as
well such as Kotlin or Swift.

15
00:00:53.785 --> 00:00:57.319
So actually here you can
see it works on both cases.

16
00:00:57.319 --> 00:01:02.081
So p and q are two person objects and
it's exactly the same, okay, but

17
00:01:02.081 --> 00:01:04.932
you will see that this is the Flutter way.

18
00:01:06.430 --> 00:01:09.073
So when we have a Flutter project,

19
00:01:09.073 --> 00:01:14.005
there is a linter included in VS Code and
also in Android Studio.

20
00:01:14.005 --> 00:01:18.582
The linter will complain that you
shouldn't be using the new keyword.

21
00:01:18.582 --> 00:01:23.370
I mean, it works but it will tell you,
hey, we are not using this in Flutter.

22
00:01:23.370 --> 00:01:28.244
So it's a good idea then to get used
to not use the new keyword to create

23
00:01:28.244 --> 00:01:30.690
new instances of a class, okay?

24
00:01:30.690 --> 00:01:31.539
Make sense?

25
00:01:31.539 --> 00:01:32.970
Just that.

26
00:01:32.970 --> 00:01:34.881
What about constructors?

27
00:01:34.881 --> 00:01:41.021
So constructors, we have a primary
constructor, okay, a primary constructor.

28
00:01:41.021 --> 00:01:43.773
And then we have named constructors, okay?

29
00:01:43.773 --> 00:01:46.120
I have a typo here, constructors.

30
00:01:46.120 --> 00:01:49.103
So what is a primary constructor?

31
00:01:49.103 --> 00:01:52.692
It's the constructor that you
have with a class name, okay,

32
00:01:52.692 --> 00:01:54.977
similar to other languages like Java.

33
00:01:54.977 --> 00:01:58.510
We don't use the constructor
keyword like in JavaScript, okay?

34
00:01:58.510 --> 00:02:03.217
So it's a function with
the name of the class.

35
00:02:03.217 --> 00:02:08.600
And you can receive no arguments, one
argument, more argument, named arguments.

36
00:02:08.600 --> 00:02:11.754
It's up to you, but
you cannot create another one.

37
00:02:13.761 --> 00:02:16.750
So we have only one primary constructor,
okay?

38
00:02:16.750 --> 00:02:20.295
If you wanna create more
of these constructors,

39
00:02:20.295 --> 00:02:25.230
you need to create a named constructor,
and this is how you do that.

40
00:02:26.250 --> 00:02:28.833
So you use the name of the class,
a dot and a name,

41
00:02:28.833 --> 00:02:31.110
and typically we start the name with from.

42
00:02:32.130 --> 00:02:37.111
So you create a request from the network,
and

43
00:02:37.111 --> 00:02:41.313
you receive a URL or wherever, okay?

44
00:02:41.313 --> 00:02:42.301
Well, I should do this.

45
00:02:42.301 --> 00:02:47.632
And you create another
request from wherever, okay?

46
00:02:47.632 --> 00:02:51.798
So that's the idea, so
you have one primary constructor and

47
00:02:51.798 --> 00:02:54.668
then you have these named constructors.

48
00:02:54.668 --> 00:02:59.755
So what about,
let me remove this for a second.

49
00:02:59.755 --> 00:03:02.503
And let's see this behavior.

50
00:03:02.503 --> 00:03:07.305
So it's actually pretty common when you're
doing OOP, object oriented programming.

51
00:03:07.305 --> 00:03:10.193
You're receiving
the constructor arguments and

52
00:03:10.193 --> 00:03:13.410
assign those arguments into properties.

53
00:03:13.410 --> 00:03:15.568
This is exactly what I'm doing.

54
00:03:15.568 --> 00:03:19.572
I have an id, and
I'm saving that id in our property and

55
00:03:19.572 --> 00:03:24.620
receiving a url, and
I'm saving that url in my property.

56
00:03:24.620 --> 00:03:30.960
Because this is actually so common,
we have a shorthand here in Dart.

57
00:03:30.960 --> 00:03:35.973
The shortcut is that
instead of using here,

58
00:03:35.973 --> 00:03:40.986
id, we use this.id, and here this.url,

59
00:03:40.986 --> 00:03:46.824
if I do this,
I don't need the assignment, okay?

60
00:03:46.824 --> 00:03:49.764
So just by saying this.id,

61
00:03:49.764 --> 00:03:54.545
this.url, it's going to be that property.

62
00:03:54.545 --> 00:03:58.439
It's going to assign that property
automatically, makes sense?

63
00:03:58.439 --> 00:04:02.083
And if your contractor has no more code,

64
00:04:02.083 --> 00:04:07.227
we can even end the contractor
there with semi column, so

65
00:04:07.227 --> 00:04:12.818
we replace curly braces,
the code block, with a semicolon.

66
00:04:15.040 --> 00:04:15.860
Okay, make sense?
So, it's just that.

67
00:04:15.860 --> 00:04:20.528
Also, when you do this,
you can get rid of the type,

68
00:04:20.528 --> 00:04:26.488
because the type is going to infer
from the property declaration.

69
00:04:26.488 --> 00:04:27.603
Make sense?

70
00:04:27.603 --> 00:04:29.655
So yeah, it look fine.

71
00:04:29.655 --> 00:04:34.387
And now if you want more constructors,
well, it's Request.from, and

72
00:04:34.387 --> 00:04:35.880
you put a name.

73
00:04:35.880 --> 00:04:42.990
So for example, from, we are going
to create a request from a URL.

74
00:04:44.590 --> 00:04:50.066
So, and then you receive here a url.

75
00:04:50.066 --> 00:04:53.489
And if you want, you can call the other
contractor as well with colon,

76
00:04:53.489 --> 00:04:55.240
we will see that in the next sample.

77
00:04:55.240 --> 00:04:58.727
So I don't wanna mess with this.

78
00:04:58.727 --> 00:05:04.007
So now if we go back to your original
sample, the code that you have, okay?

79
00:05:04.007 --> 00:05:10.315
If you look at this named constructor
fromData, it says this.id, this.url.

80
00:05:10.315 --> 00:05:12.681
So it means it receives the id and
the url, and

81
00:05:12.681 --> 00:05:15.001
it's saving the values in the properties.

82
00:05:15.001 --> 00:05:19.126
And there is no code, but if you want,
you can have a code block and

83
00:05:19.126 --> 00:05:20.410
do something else.

84
00:05:23.085 --> 00:05:25.406
Okay, makes sense?

85
00:05:25.406 --> 00:05:26.451
Yep.

86
00:05:26.451 --> 00:05:29.779
&gt;&gt; Could you receive
this with optional thing?

87
00:05:29.779 --> 00:05:31.116
&gt;&gt; Yeah.

88
00:05:31.116 --> 00:05:33.221
&gt;&gt; I'm just wondering-
&gt;&gt; But in this case here,

89
00:05:33.221 --> 00:05:34.033
they must be optional.

90
00:05:34.033 --> 00:05:34.631
&gt;&gt; I'm just wondering about exactly.
I'm

91
00:05:34.631 --> 00:05:35.772
wondering if this is would
assign it automatically.

92
00:05:35.772 --> 00:05:38.103
&gt;&gt; What do you wanna do?

93
00:05:38.103 --> 00:05:39.822
If you wanna-
&gt;&gt; Just optional like-

94
00:05:39.822 --> 00:05:41.815
&gt;&gt; I mean, can receive here optional,

95
00:05:41.815 --> 00:05:42.880
like-
&gt;&gt; No, but with this,

96
00:05:42.880 --> 00:05:44.113
can you do with this optional or not?

97
00:05:44.113 --> 00:05:45.890
&gt;&gt; No, because it's not optional here.

98
00:05:45.890 --> 00:05:48.971
So if you use this,
if you use the shorthand,

99
00:05:48.971 --> 00:05:51.740
it must be the same type as the property.

100
00:05:51.740 --> 00:05:53.430
Because if not, it's not a property.

101
00:05:53.430 --> 00:05:56.347
It's a different value.

102
00:05:56.347 --> 00:06:00.160
And then, you can receive an optional, and

103
00:06:00.160 --> 00:06:05.208
then you ask if the id is not null,
then you do it manually,

104
00:06:05.208 --> 00:06:09.975
okay, like this, and if not,
you apply the full one.

105
00:06:09.975 --> 00:06:12.880
I don't know, you can use ternary
operator if you want for this as well.

106
00:06:14.160 --> 00:06:20.494
But yeah, you cannot use
a shorthand in that situation.

107
00:06:20.494 --> 00:06:23.792
&gt;&gt; Why would you default ie to zero?

108
00:06:26.247 --> 00:06:28.642
&gt;&gt; Just because I was playing with
the idea of putting an option,

109
00:06:28.642 --> 00:06:30.032
it doesn't make any sense, yeah.

110
00:06:30.032 --> 00:06:32.530
&gt;&gt; So is there a notion
of a default constructor?

111
00:06:33.860 --> 00:06:36.532
&gt;&gt; So-
&gt;&gt; You can't create requests right now

112
00:06:36.532 --> 00:06:37.670
without assigning it, right?

113
00:06:38.770 --> 00:06:41.046
Well, now you can, from data you can.

114
00:06:41.046 --> 00:06:42.870
&gt;&gt; Let me see if I get what you're saying.

115
00:06:42.870 --> 00:06:49.290
So right now, I can request with id and
url or calling this named constructor.

116
00:06:49.290 --> 00:06:52.164
So, how do you call the named constructor?

117
00:06:52.164 --> 00:06:57.650
Well, I need to create a function
to actually play with this.

118
00:06:57.650 --> 00:07:03.052
And if you wanna create a variable,
okay, let's create a request.

119
00:07:03.052 --> 00:07:07.320
I can make a request with
a default constructor or fromData.

120
00:07:08.450 --> 00:07:11.574
And because this accepts null,
I can pass null, actually.

121
00:07:11.574 --> 00:07:17.387
So that's the difference, and null will
get here as null and it will save as zero.

122
00:07:21.110 --> 00:07:22.179
Okay, make sense?

123
00:07:22.179 --> 00:07:24.808
Something that it's interesting in Dart is

124
00:07:24.808 --> 00:07:28.361
that when you are inside
a conditional asking for not null,

125
00:07:28.361 --> 00:07:33.000
we know for sure that it's not null here,
okay, in this code block.

126
00:07:33.000 --> 00:07:35.710
That means I don't need
to unwrap the optional.

127
00:07:37.520 --> 00:07:40.560
Remember that we had to do that, for
example, for the length or whatever.

128
00:07:41.610 --> 00:07:45.586
I don't need to actually do that here.

129
00:07:45.586 --> 00:07:48.516
In fact, if I do that,
I get a warning saying, hey,

130
00:07:48.516 --> 00:07:51.998
there is no effect here because
the receiving can't be null.

131
00:07:51.998 --> 00:07:54.533
And you say, but it can be null.

132
00:07:54.533 --> 00:07:56.510
I mean, the variable can be null.

133
00:07:56.510 --> 00:08:00.550
But we are in the if, we are in
the condition where we know it's not null.

134
00:08:00.550 --> 00:08:02.280
Fortunately, we don't need to do this.

135
00:08:04.070 --> 00:08:05.420
That's good, that's good news.

136
00:08:06.500 --> 00:08:08.830
In other languages, that's not possible.

137
00:08:08.830 --> 00:08:11.090
So you always need to unwrap the optional.

138
00:08:11.090 --> 00:08:16.003
So here the compiler is smart
enough to know that you are in,

139
00:08:16.003 --> 00:08:18.851
let's say in a path, in a branch,

140
00:08:18.851 --> 00:08:24.277
where your code makes that ID
mandatory and you know it's there.

141
00:08:24.277 --> 00:08:29.980
So you don't need to deal with the
optional, with the null safety operators.

142
00:08:29.980 --> 00:08:33.566
Okay, make sense?

143
00:08:33.566 --> 00:08:38.520
A more advanced idea that I can
tell you at this point regarding

144
00:08:38.520 --> 00:08:43.250
named constructors is you can
make them a factory, okay?

145
00:08:43.250 --> 00:08:45.970
So what's the idea when
you make them a factory?

146
00:08:45.970 --> 00:08:48.190
We're going to see one later.

147
00:08:48.190 --> 00:08:51.680
When you make them a factory,
it's not actually a constructor.

148
00:08:51.680 --> 00:08:55.017
It's a factory, okay, so
what's the difference?

149
00:08:55.017 --> 00:09:01.069
It's actually using the abstract factory
design pattern from the original Gang of

150
00:09:01.069 --> 00:09:07.044
Four, if you have ever played with those
design patterns, OOP design patterns.

151
00:09:07.044 --> 00:09:11.900
Actually, a constructor will always
return something of type request.

152
00:09:11.900 --> 00:09:14.364
I don't have a return here.

153
00:09:14.364 --> 00:09:17.860
So in a constructor you
don't return yourself.

154
00:09:17.860 --> 00:09:20.100
You don't do this, okay?

155
00:09:20.100 --> 00:09:24.210
Well, when you have a factory,
you need to return an option.

156
00:09:25.210 --> 00:09:28.720
And the idea of a factory,
the factory can return null.

157
00:09:30.480 --> 00:09:34.115
The factory can return
an object of your type, or

158
00:09:34.115 --> 00:09:38.559
sometimes the factory can
return an object of a sub-type.

159
00:09:38.559 --> 00:09:43.635
For example, based on the arguments
I decide to return not a request but

160
00:09:43.635 --> 00:09:48.470
an HTTP request or a socket request,
that is a subclass of request.

161
00:09:48.470 --> 00:09:54.779
So a factory can return subclasses,
objects of a subclass, or null.

162
00:09:54.779 --> 00:10:00.090
Because the factory will say no,
I'm not gonna construct an option,

163
00:10:00.090 --> 00:10:05.323
because I know the arguments are wrong or
something happens, okay?

164
00:10:05.323 --> 00:10:06.780
So we can also create
factories using this.

165
00:10:08.250 --> 00:10:13.320
Inheritance work like this with extends,
like in Java, in JavaScript.

166
00:10:13.320 --> 00:10:17.590
In this case I create a constructor
receiving two arguments.

167
00:10:17.590 --> 00:10:20.514
And I'm extending from
the super constructor,

168
00:10:20.514 --> 00:10:24.040
this is how you call
the super constructor.

169
00:10:24.040 --> 00:10:28.171
And I don't have a code, but I can also
open code here and do something else.

170
00:10:33.056 --> 00:10:36.576
Okay, so if you end with a semi colon,
you don't have a code block, if not,

171
00:10:36.576 --> 00:10:38.500
you have a code block.

172
00:10:38.500 --> 00:10:41.700
And you can use named parameters,
for example, in the constructor.

173
00:10:43.270 --> 00:10:45.000
And we are going to see
these a lot in Flutter.

174
00:10:46.180 --> 00:10:50.009
Flutter is full of named
constructors everywhere.

175
00:10:53.327 --> 00:10:56.812
Okay, it's the same as a function,
because a constructor is just a function.

176
00:10:56.812 --> 00:11:00.067
&gt;&gt; So for the factory, how do you call it,
is it like a static method?

177
00:11:00.067 --> 00:11:01.303
&gt;&gt; It's like a static method, yeah.

178
00:11:01.303 --> 00:11:02.407
It's the same as the constructor,
actually.

179
00:11:02.407 --> 00:11:02.907
&gt;&gt; Okay, I'm good.

180
00:11:03.930 --> 00:11:05.340
&gt;&gt; Question from the chat.

181
00:11:05.340 --> 00:11:08.531
&gt;&gt; When should you use classes and
when interfaces?

182
00:11:08.531 --> 00:11:13.916
Most of the time I use interfaces
because most of the object-oriented

183
00:11:13.916 --> 00:11:19.391
code is back-end specific or
the application just needs to display and

184
00:11:19.391 --> 00:11:25.429
manipulate data but the back end needs
to follow programming best practices.

185
00:11:25.429 --> 00:11:27.430
&gt;&gt; Okay, let's see, first,
do we have interfaces here?

186
00:11:27.430 --> 00:11:32.980
So if I type interface, and i do something
like this, actually it will complain.

187
00:11:32.980 --> 00:11:37.650
It says, variables,
you can define const, final, var.

188
00:11:37.650 --> 00:11:41.382
So actually we don't have interface.

189
00:11:41.382 --> 00:11:44.448
So if you're coming from Java or
other language,

190
00:11:44.448 --> 00:11:47.223
you don't have interfaces
here as the idea.

191
00:11:47.223 --> 00:11:50.660
So, there are many other design
patterns that we use here.

192
00:11:50.660 --> 00:11:55.014
I'm not saying that you don't
have a way to emulate interfaces.

193
00:11:55.014 --> 00:12:01.170
But let's say that in Dart, you will
most of the time be creating classes.

194
00:12:01.170 --> 00:12:05.732
We don't have something
simpler such as structures,

195
00:12:05.732 --> 00:12:08.715
or something to follow protocols.

196
00:12:08.715 --> 00:12:13.175
There are many design patterns that
you can use, but most of the time,

197
00:12:13.175 --> 00:12:16.062
we're going to be
creating classes in Dart.

198
00:12:17.572 --> 00:12:18.769
&gt;&gt; Is from required?

199
00:12:20.845 --> 00:12:23.871
&gt;&gt; Are you talking about this,

200
00:12:23.871 --> 00:12:29.940
like if you wanna name your
constructor differently?

201
00:12:29.940 --> 00:12:30.780
No, it's not required.

202
00:12:30.780 --> 00:12:35.124
It's actually part of a guideline,
a style guideline.

203
00:12:35.124 --> 00:12:40.164
So now you know that when you wanna crate
object, use the class of the object, dot,

204
00:12:40.164 --> 00:12:44.779
and you see if there is a from something,
but it's actually not mandatory.

205
00:12:44.779 --> 00:12:50.793
We are going to see later in Flutter
that one of the widgets that we're

206
00:12:50.793 --> 00:12:57.660
going to use, a widget is a UI class,
has something known as a builder.

207
00:12:57.660 --> 00:13:03.256
And you will see that it's not actually
using all the time that from prefix.

208
00:13:03.256 --> 00:13:05.140
&gt;&gt; You said in the named constructors.

209
00:13:07.120 --> 00:13:07.992
&gt;&gt; Is in?

210
00:13:07.992 --> 00:13:10.416
&gt;&gt; From in the named constructors.

211
00:13:10.416 --> 00:13:14.520
&gt;&gt; So from is actually part of the,
it's like a function.

212
00:13:14.520 --> 00:13:18.640
It's a function that will create
an instance of your request, and

213
00:13:18.640 --> 00:13:21.550
it will execute your code also, okay?

214
00:13:21.550 --> 00:13:22.893
But this is a function name.

215
00:13:22.893 --> 00:13:27.533
So anything that goes in a function name
will work, but we tend to use the from

216
00:13:27.533 --> 00:13:32.580
keyword, remember, this is if you
wanna have more than one constructor.

217
00:13:32.580 --> 00:13:37.428
The default constructor is this one,
mainly called primary constructor or

218
00:13:37.428 --> 00:13:38.951
default constructor.

219
00:13:38.951 --> 00:13:42.126
Then you can have more
constructors with names.

220
00:13:42.126 --> 00:13:46.912
They work like when you're having
a static method in other languages

221
00:13:46.912 --> 00:13:50.059
returning objects, like a factory kind of.

222
00:13:50.059 --> 00:13:52.030
&gt;&gt; How about in abstract class?

223
00:13:52.030 --> 00:13:56.386
&gt;&gt; Okay, so if your question is,
if I can create abstract classes?

224
00:13:56.386 --> 00:13:58.124
Yes, I can.

225
00:13:58.124 --> 00:14:00.770
So I have AbstractRequest, and
of course, what's the difference?

226
00:14:00.770 --> 00:14:05.369
You cannot create the instances of
an abstract class or put a parenthesis,

227
00:14:05.369 --> 00:14:06.590
my bad.

228
00:14:06.590 --> 00:14:09.217
And, of course,
you can extend from an abstract class and

229
00:14:09.217 --> 00:14:11.480
create an actual concrete
class that you can use.

230
00:14:11.480 --> 00:14:14.607
So yeah, we do have abstract classes,
the same as in Java or

231
00:14:14.607 --> 00:14:16.370
other languages with that idea.

232
00:14:17.710 --> 00:14:19.825
Are we going to use that?

233
00:14:19.825 --> 00:14:26.186
In, Flutter, no, unless you are creating
your own data model with abstract classes.

234
00:14:26.186 --> 00:14:29.938
No, we don't see that a lot,
but it's there, okay?

235
00:14:29.938 --> 00:14:31.250
So if you wanna use it, it's there.

