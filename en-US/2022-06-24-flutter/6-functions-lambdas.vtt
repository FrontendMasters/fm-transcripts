WEBVTT

1
00:00:00.170 --> 00:00:02.032
Functions are pretty straightforward.

2
00:00:02.032 --> 00:00:06.089
And mostly if you're coming from
JavaScript, it's just the same, but

3
00:00:06.089 --> 00:00:08.295
without the function keyword, okay?

4
00:00:08.295 --> 00:00:10.409
So we just write the function.

5
00:00:10.409 --> 00:00:16.713
Something that we have is an implicit
return type that is empty here.

6
00:00:16.713 --> 00:00:17.570
For example,

7
00:00:17.570 --> 00:00:22.505
you can explicitly specify that you need
to return something from this function.

8
00:00:22.505 --> 00:00:27.418
You can use void to should say
that I'm not returning anything.

9
00:00:27.418 --> 00:00:32.098
And that's the default operation
when you don't specify the type, or

10
00:00:32.098 --> 00:00:35.300
you can specify the type
that you want to return.

11
00:00:35.300 --> 00:00:37.433
For example, I'm going to return a string.

12
00:00:37.433 --> 00:00:41.554
This is similar to Java or
to C, C++ as well.

13
00:00:41.554 --> 00:00:46.594
You put the type that you'll return
before the name of the function, okay?

14
00:00:46.594 --> 00:00:47.497
Does it makes sense?.

15
00:00:47.497 --> 00:00:52.397
And of course, if you have a return type,
you must return something from the type,

16
00:00:52.397 --> 00:00:54.223
if not, it's not gonna work.

17
00:00:54.223 --> 00:00:56.244
It's not going to compile.

18
00:00:56.244 --> 00:00:58.473
So far, so good, I guess.

19
00:00:58.473 --> 00:01:00.159
What about arguments?

20
00:01:00.159 --> 00:01:02.894
Well, arguments work like this.

21
00:01:02.894 --> 00:01:04.812
We use the type as well.

22
00:01:04.812 --> 00:01:06.292
We cannot use var here,

23
00:01:06.292 --> 00:01:11.335
because it needs to know the type of
the argument that you're expecting, okay?

24
00:01:11.335 --> 00:01:16.513
So that's the simple way
to create the sum function.

25
00:01:16.513 --> 00:01:21.684
It receives two integers and
return an operation over that integer.

26
00:01:21.684 --> 00:01:23.502
Remember, this is the return type.

27
00:01:23.502 --> 00:01:29.263
So what you are returning
actually must be of that type.

28
00:01:29.263 --> 00:01:34.271
This is new, something that have that

29
00:01:34.271 --> 00:01:39.912
is the ability to define named arguments.

30
00:01:39.912 --> 00:01:41.347
So what is the idea?

31
00:01:41.347 --> 00:01:46.209
The idea is that I can create another
version of the same variable, for example,

32
00:01:46.209 --> 00:01:48.010
asking something like this.

33
00:01:48.010 --> 00:01:53.350
I can say that I want this argument

34
00:01:53.350 --> 00:01:57.556
should be named as a and b.

35
00:01:57.556 --> 00:02:00.839
They are, by default, optional, but

36
00:02:00.839 --> 00:02:06.817
if I want them to make mandatory,
I can apply a require property first.

37
00:02:06.817 --> 00:02:10.875
I know that this seems weird,
so let's create one here, so

38
00:02:10.875 --> 00:02:13.404
we can understand what's going on.

39
00:02:13.404 --> 00:02:20.035
So, for example, I can have here
a function that will print a customer.

40
00:02:20.035 --> 00:02:23.914
And let's say that the customer
will receive the name.

41
00:02:23.914 --> 00:02:29.473
So I have a string name, and
it has an age or, I don't know, a balance,

42
00:02:29.473 --> 00:02:35.893
let's make it double, a balance, and
if it's active, it's going to be a bool.

43
00:02:35.893 --> 00:02:37.886
So I'm going to print this,
just that, okay?

44
00:02:37.886 --> 00:02:43.805
So print, I can print comma separator,
so the name, the balance, and isActive.

45
00:02:43.805 --> 00:02:48.754
How we're going to call this function,
Well,

46
00:02:48.754 --> 00:02:52.742
it's complaining here because I
need to convert this into a string,

47
00:02:52.742 --> 00:02:55.026
because print receives only strings.

48
00:02:55.026 --> 00:02:59.268
Something quick, a quick way to
convert anything to a string is to use

49
00:02:59.268 --> 00:03:03.157
a string and then the dollar sign inside,
for example, okay?

50
00:03:03.157 --> 00:03:04.842
That's a simple way to do that.

51
00:03:04.842 --> 00:03:07.367
I might have other issues here,
but anyway.

52
00:03:07.367 --> 00:03:13.025
So also, you can make separate prints,
because it will be simple to

53
00:03:13.025 --> 00:03:18.807
understand now that I'm going to
change the signature of this file.

54
00:03:18.807 --> 00:03:21.498
So how do you call your own function?

55
00:03:21.498 --> 00:03:25.666
So if I wanna call print,
it's printCustomer, and

56
00:03:25.666 --> 00:03:28.045
then you pass the arguments.

57
00:03:28.045 --> 00:03:30.201
So, simple, right?

58
00:03:30.201 --> 00:03:33.642
So I have Jane, with balance, and

59
00:03:33.642 --> 00:03:38.758
it's not active, so
it's false, semi-colon.

60
00:03:38.758 --> 00:03:40.085
So that's one way.

61
00:03:40.085 --> 00:03:47.078
Okay, cool, but what we can do
is make some arguments optional.

62
00:03:47.078 --> 00:03:53.929
How to make the arguments optional,
I can put them within curly braces.

63
00:03:53.929 --> 00:03:58.789
If you do that, okay,
now that becomes a name argument,

64
00:03:58.789 --> 00:04:03.266
and name arguments
are optional by default, okay?

65
00:04:03.266 --> 00:04:09.228
If I want it to be mandatory,
I can use required.

66
00:04:09.228 --> 00:04:11.886
You will get what this is in a minute.

67
00:04:11.886 --> 00:04:16.360
So I added now, I have two standard

68
00:04:16.360 --> 00:04:20.997
arguments and one named argument.

69
00:04:20.997 --> 00:04:25.287
What's the difference now is
that the third one needs a name.

70
00:04:25.287 --> 00:04:29.986
So I actually need to say isActive: false

71
00:04:31.818 --> 00:04:36.681
So when you create a function,
you need to make a decision.

72
00:04:36.681 --> 00:04:40.667
Do I want all the arguments as usual,
like classic arguments?

73
00:04:40.667 --> 00:04:43.630
Do I want all of them with names?

74
00:04:43.630 --> 00:04:47.123
Or I can make a mix.

75
00:04:47.123 --> 00:04:53.095
The first argument is unnamed, and
then I can make the double also here.

76
00:04:53.095 --> 00:04:57.456
I put them in the same curly braces, and
I can make them optional or required.

77
00:04:57.456 --> 00:05:02.161
So now, 200 doesn't work,

78
00:05:02.161 --> 00:05:06.878
and I can say balance:200.

79
00:05:06.878 --> 00:05:10.914
The idea is that now we can make
the function call more semantic,

80
00:05:10.914 --> 00:05:15.695
because now I say, I'm going to print
Jane, but it has a balance of 200,

81
00:05:15.695 --> 00:05:17.823
and it's currently not active.

82
00:05:17.823 --> 00:05:20.746
Does it make sense?

83
00:05:20.746 --> 00:05:24.688
And you can make all of them like this,
named.

84
00:05:24.688 --> 00:05:30.603
And when they are named, I can also change
the order in what I'm calling them.

85
00:05:30.603 --> 00:05:33.815
Because they have a name,
they know where that goes.

86
00:05:33.815 --> 00:05:39.259
So, of course,
balance will go to the second argument.

87
00:05:39.259 --> 00:05:40.446
Does it makes sense?

88
00:05:40.446 --> 00:05:41.756
I mean, it's not complicated.

89
00:05:41.756 --> 00:05:47.279
It's different, and
Flutter is heavily using this, okay?

90
00:05:47.279 --> 00:05:52.568
So we are going to see this a lot
within Flutter, named arguments.

91
00:05:52.568 --> 00:05:54.365
Make sense?

92
00:05:54.365 --> 00:05:56.669
&gt;&gt; What happens if you took Jane out?

93
00:05:56.669 --> 00:05:59.706
&gt;&gt; It's not gonna work because
it will tell you, I mean,

94
00:05:59.706 --> 00:06:04.014
the signature will tell you that there
is one positional argument expected.

95
00:06:04.014 --> 00:06:08.075
And then you have positional arguments and
named arguments.

96
00:06:08.075 --> 00:06:12.410
Positional arguments are the ones that
are based in their position, okay?

97
00:06:12.410 --> 00:06:16.865
Now, we are not following the signature,
so it's not gonna comply.

98
00:06:16.865 --> 00:06:22.660
It's mandatory to set the name as
the first positional argument.

99
00:06:25.290 --> 00:06:28.307
&gt;&gt; So that string name is almost required.

100
00:06:28.307 --> 00:06:29.875
&gt;&gt; Yeah, all of them are required.

101
00:06:29.875 --> 00:06:30.442
&gt;&gt; Yeah.

102
00:06:30.442 --> 00:06:33.637
&gt;&gt; Okay, because I said so
with the required keywords.

103
00:06:33.637 --> 00:06:37.930
So all of them are required,
but the last two arguments,

104
00:06:37.930 --> 00:06:42.320
you can put them in any order,
and also you must name them.

105
00:06:42.320 --> 00:06:46.074
That's the difference, okay?

106
00:06:46.074 --> 00:06:48.602
To finish the function sanction,

107
00:06:48.602 --> 00:06:52.882
we also have lambda expressions or
anonymous functions.

108
00:06:52.882 --> 00:06:57.313
In that case, it's a variable
of type function, capital F.

109
00:06:57.313 --> 00:07:01.407
Of course, I can use var as well,
instead of this.

110
00:07:01.407 --> 00:07:03.527
And how does it work?

111
00:07:03.527 --> 00:07:06.729
We're going to see this
a lot within Flutter.

112
00:07:06.729 --> 00:07:11.221
So we will remember
this a couple of times.

113
00:07:11.221 --> 00:07:16.225
We use parentheses with
the arguments declaration inside,

114
00:07:16.225 --> 00:07:18.882
and then the code in CodeBlock.

115
00:07:18.882 --> 00:07:19.983
So this is a function.

116
00:07:23.245 --> 00:07:25.397
And it receives number and it's ready.

117
00:07:25.397 --> 00:07:28.899
But this is a variable
containing a function.

118
00:07:28.899 --> 00:07:33.637
So I can pass this as an argument, I can
receive the second return, one of these.

119
00:07:33.637 --> 00:07:37.154
This is like writing in JavaScript
something like this, okay?

120
00:07:37.154 --> 00:07:41.814
When you create an anonymous
function like that in JavaScript,

121
00:07:41.814 --> 00:07:44.154
this is the equivalent, okay?

122
00:07:44.154 --> 00:07:46.720
And because we have arrow
functions in JavaScript,

123
00:07:46.720 --> 00:07:48.829
we also have arrow functions here in Dart.

124
00:07:48.829 --> 00:07:53.719
The only difference is that we
use arrow functions with the same

125
00:07:53.719 --> 00:07:58.063
fat arrow equals greater than only for
one expression.

126
00:07:58.063 --> 00:08:02.874
So we use CodeBlock when you have several

127
00:08:02.874 --> 00:08:07.269
sentences, several expressions.

128
00:08:07.269 --> 00:08:12.593
And we use arrow functions like lambda,
quick lambda expressions,

129
00:08:12.593 --> 00:08:17.112
only accepting one sentence
that has an implicit return.

130
00:08:17.112 --> 00:08:21.279
So there is an implicit return here, okay?

131
00:08:21.279 --> 00:08:22.547
So let me show you this.

132
00:08:22.547 --> 00:08:26.737
If I wanna use the same
function without this,

133
00:08:26.737 --> 00:08:30.502
I put this in a CodeBlock and
I add return.

134
00:08:32.115 --> 00:08:33.313
And semicolon.

135
00:08:33.313 --> 00:08:35.947
So, actually, semicolon here as well.

136
00:08:35.947 --> 00:08:42.019
myArrow and myArrow2 are doing exactly
the same, but with different syntax.

137
00:08:42.019 --> 00:08:45.454
Does it make sense?

138
00:08:45.454 --> 00:08:50.086
So the arrow function is smaller and
faster.

139
00:08:50.086 --> 00:08:54.153
&gt;&gt; I'm just thinking, I mean, this is only
the case where you actually have to use

140
00:08:54.153 --> 00:08:55.989
the keyword function in this type.

141
00:08:55.989 --> 00:08:59.801
&gt;&gt; Well, actually I don't need
to use the keyword function,

142
00:08:59.801 --> 00:09:03.166
because I can create a variable or
a final with this.

143
00:09:03.166 --> 00:09:05.600
That's not the keyword, that's a type.

144
00:09:05.600 --> 00:09:06.167
&gt;&gt; Okay.

145
00:09:06.167 --> 00:09:07.050
&gt;&gt; Okay, that's the type.

146
00:09:07.050 --> 00:09:07.763
&gt;&gt; Okay.

147
00:09:07.763 --> 00:09:08.618
&gt;&gt; That's the type.

148
00:09:08.618 --> 00:09:11.910
Bu it was a good one, right, because,
yeah, it seems like a keyword, but

149
00:09:11.910 --> 00:09:14.019
it's not actually a keyword,
it's the type.

150
00:09:14.019 --> 00:09:19.802
The variable or the mutable variable or
the constant is actually of type function.

151
00:09:19.802 --> 00:09:24.452
But I can use implicit typing, and
now I'll need to set the type.

152
00:09:24.452 --> 00:09:27.812
And you can see here that
the type of my arrow,

153
00:09:27.812 --> 00:09:30.825
it's a function with receiving joins.

154
00:09:30.825 --> 00:09:31.525
Yeah.

155
00:09:31.525 --> 00:09:36.316
&gt;&gt; So the functions that you created
earlier, they don't have semicolons after

156
00:09:36.316 --> 00:09:40.684
the function definition, but
these do, because they're a block?.

157
00:09:40.684 --> 00:09:46.786
&gt;&gt; Yeah, so the question is, actually,
why do I have a semicolon there, right?

158
00:09:46.786 --> 00:09:51.578
So because, think about this,
I have a variable integer, okay?

159
00:09:51.578 --> 00:09:54.442
So I have my age, it's 4?

160
00:09:54.442 --> 00:09:56.047
Do I need a semicolon at the end?

161
00:09:56.047 --> 00:09:57.126
Yes.

162
00:09:57.126 --> 00:10:00.360
Now, instead of being a 4,
it's a function.

163
00:10:00.360 --> 00:10:07.881
So I open this O arrow function, so
how do you do this arrow function?

164
00:10:07.881 --> 00:10:09.243
You do this.

165
00:10:09.243 --> 00:10:13.229
So I still need the semicolon because
the semicolon goes to the var

166
00:10:13.229 --> 00:10:14.760
declaration sentence.

167
00:10:14.760 --> 00:10:18.869
If you do that in a separate lines,
you still need the semicolon anyway.

168
00:10:21.266 --> 00:10:22.960
Okay, that's why you have the semicolon.

169
00:10:22.960 --> 00:10:26.809
And when you have the normal function
declaration, you don't need a semicolon,

170
00:10:26.809 --> 00:10:28.984
because you don't use
this as an expression,

171
00:10:28.984 --> 00:10:32.359
it's not actually an expression,
the sentence within the language.

172
00:10:32.359 --> 00:10:34.892
It's a declaration, so
it's something different.

173
00:10:37.766 --> 00:10:40.966
Anyway, the good new is that the IDE
will tell you that if you're

174
00:10:40.966 --> 00:10:42.572
missing the semicolon, okay?

175
00:10:42.572 --> 00:10:47.417
And there's a quick fix,
that on Visual Studio Code is Ctrl + dot,

176
00:10:47.417 --> 00:10:49.850
or Cmd + dot on the Mac.

177
00:10:49.850 --> 00:10:54.486
And on Android Studio,
it's Alt+Enter or Option Return.

178
00:10:54.486 --> 00:10:57.903
So if I say here Cmd + dot,
it will say, okay,

179
00:10:57.903 --> 00:11:01.603
I wanna insert the semicolon, yeah, okay?

180
00:11:01.603 --> 00:11:03.524
So the IDE will help you.

181
00:11:03.524 --> 00:11:10.060
We are going to use the IDE lot to improve
our productivity in Flutter, okay?

182
00:11:10.060 --> 00:11:10.641
Make sense?

183
00:11:10.641 --> 00:11:11.257
Yeah.

184
00:11:11.257 --> 00:11:17.436
&gt;&gt; Was there a reason why they do
a single expression in their fat arrow?

185
00:11:17.436 --> 00:11:18.286
&gt;&gt; Where, which line?

186
00:11:18.286 --> 00:11:23.688
&gt;&gt; So line 67, I'm kinda
comparing that to arrow functions

187
00:11:23.688 --> 00:11:28.994
in JavaScript,
because you can have multiple commands.

188
00:11:28.994 --> 00:11:29.780
&gt;&gt; Yeah, here,

189
00:11:29.780 --> 00:11:31.925
if you use the arrow function,
&gt;&gt; Yeah,

190
00:11:31.925 --> 00:11:33.803
&gt;&gt; It's only one expression that has

191
00:11:33.803 --> 00:11:34.972
an implicit return.

192
00:11:34.972 --> 00:11:37.644
&gt;&gt; Yeah, do you know the history
on that or why they do that?

193
00:11:37.644 --> 00:11:41.975
&gt;&gt; I don't have the history, but
the thing is that if you don't want that,

194
00:11:41.975 --> 00:11:42.905
you have this.

195
00:11:42.905 --> 00:11:46.082
I think this is coming from other
languages, not from JavaScript, okay?

196
00:11:46.082 --> 00:11:50.745
So I mean, if this was JavaScript,
it was like this.

197
00:11:50.745 --> 00:11:55.873
While here, when you have multiple and
we have the code block, they say,

198
00:11:55.873 --> 00:12:00.848
we don't need the arrow function,
we just remove the arrow sentence.

199
00:12:00.848 --> 00:12:04.191
So if you ask me why they're not
using the arrow for the code block,

200
00:12:04.191 --> 00:12:05.876
I don't have the answer for you.

201
00:12:05.876 --> 00:12:09.920
But there are many languages that is
like this, that the arrow is only for

202
00:12:09.920 --> 00:12:11.192
lambda expressions.

203
00:12:11.192 --> 00:12:15.512
And the definition of a lambda expression,
on some languages,

204
00:12:15.512 --> 00:12:19.754
is actually just one line,
just for functional programming.

205
00:12:19.754 --> 00:12:25.897
And for that, you don't wanna
do multiple sentences, only one.

206
00:12:25.897 --> 00:12:29.705
And I think we have to live with that,
picking different syntax for

207
00:12:29.705 --> 00:12:31.140
different situations.

