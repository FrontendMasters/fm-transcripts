WEBVTT

1
00:00:00.400 --> 00:00:02.560
&gt;&gt; Erik Reinert: Okay, so
now here's the fun part.

2
00:00:02.560 --> 00:00:05.520
Here is the main TF file.

3
00:00:05.520 --> 00:00:09.920
So I'm going to go through this one rather
quickly because there's a lot in here.

4
00:00:09.920 --> 00:00:14.396
But I want to show you the complexity of
something that does not have a module

5
00:00:14.396 --> 00:00:15.676
wrapped around it and

6
00:00:15.676 --> 00:00:20.400
how annoying it can actually be sometimes
to do complex things with Amazon.

7
00:00:20.400 --> 00:00:26.240
So this ECS cluster I purposely
did not use a module with is.

8
00:00:26.240 --> 00:00:27.440
It is a little verbose.

9
00:00:27.440 --> 00:00:30.968
But the main reason why I didn't use
a module with it is because I don't really

10
00:00:30.968 --> 00:00:33.200
like any modules that
exist out there right now.

11
00:00:33.200 --> 00:00:37.694
For ecs, my goal is to really
just create a cluster,

12
00:00:37.694 --> 00:00:42.400
create instances and
get containers on top of it.

13
00:00:42.400 --> 00:00:45.389
But there's a lot of other things
you can do with ECS too, and

14
00:00:45.389 --> 00:00:47.120
it was just too much cruft for me.

15
00:00:47.120 --> 00:00:50.880
So the first thing we create
is an ECS cluster itself.

16
00:00:50.880 --> 00:00:56.710
Now when we say an ECS cluster,
there's really nothing that gets created.

17
00:00:56.710 --> 00:01:00.619
It's kind of just like an entry
in a database, because an ECS

18
00:01:00.619 --> 00:01:05.630
cluster is really all of the instances
that are attached to the cluster.

19
00:01:05.630 --> 00:01:10.093
So the work here really isn't creating
the cluster, it's making sure that all

20
00:01:10.093 --> 00:01:14.223
of the instances have the roles and
policies that they need and can connect

21
00:01:14.223 --> 00:01:17.910
to the cluster and authenticate
the right way and all that stuff.

22
00:01:17.910 --> 00:01:20.900
So when we talk about the ECS cluster,
the.

23
00:01:20.900 --> 00:01:22.900
That's actually the only
resource you need.

24
00:01:22.900 --> 00:01:23.780
That's it.

25
00:01:23.780 --> 00:01:27.220
You just do that, you give it a name and
then you're done.

26
00:01:27.220 --> 00:01:28.260
There's a small.

27
00:01:28.260 --> 00:01:30.020
There's a couple of settings
that you can do here.

28
00:01:30.020 --> 00:01:32.740
Like, you'll see I have
container insights enabled.

29
00:01:32.740 --> 00:01:37.278
This will be helpful when we wanna look
really deeply into a service's metrics and

30
00:01:37.278 --> 00:01:38.580
things like that.

31
00:01:38.580 --> 00:01:42.980
But outside of that,
it's just that one definition.

32
00:01:42.980 --> 00:01:46.813
Then we start jumping into
the auto-scaling group,

33
00:01:46.813 --> 00:01:50.040
which is really the beef of a ECS cluster.

34
00:01:50.040 --> 00:01:53.040
And so the first thing we have is a role,
right?

35
00:01:53.040 --> 00:01:57.280
So we create a role for
the cluster and then what we do is.

36
00:01:57.280 --> 00:02:00.372
You remember how in the UI yesterday,
I told you guys to like,

37
00:02:00.372 --> 00:02:03.800
look through that list of all
the predefined roles and stuff?

38
00:02:03.800 --> 00:02:06.840
Well, you can also use
them in your automation.

39
00:02:06.840 --> 00:02:08.560
So that's what's really, really nice.

40
00:02:08.560 --> 00:02:12.557
Again, going back to that whole, like,
Amazon knows that there's a lot of,

41
00:02:12.557 --> 00:02:15.890
like, things you have to get around
to get something created, so

42
00:02:15.890 --> 00:02:20.311
they've created helpful things to kind of
like just say, well, if you just use this,

43
00:02:20.311 --> 00:02:21.490
this will solve this.

44
00:02:21.490 --> 00:02:25.170
Problem and you'll be pretty much
good to go for most general cases.

45
00:02:25.170 --> 00:02:26.410
And so that's what I'm doing here.

46
00:02:26.410 --> 00:02:33.410
And if you read the role name, it says
Amazon EC2 container service for EC2 role.

47
00:02:33.410 --> 00:02:36.552
Basically all that means is,
is that the container

48
00:02:36.552 --> 00:02:40.950
service works on top of EC2 instances,
which is exactly what we want.

49
00:02:40.950 --> 00:02:43.190
We're going to be creating EC2 instances.

50
00:02:44.230 --> 00:02:46.390
We then create an instance profile.

51
00:02:47.830 --> 00:02:55.430
So with users we use roles,
with instances, we use instance profiles.

52
00:02:56.710 --> 00:03:01.813
That's how we make sure that an instance
can have permission for anything inside

53
00:03:01.813 --> 00:03:07.920
of that instance to connect to S3, connect
to SQS, publish, queue messages, whatever.

54
00:03:07.920 --> 00:03:13.200
We give it an instance profile and then we
attach that role to the instance profile.

55
00:03:13.200 --> 00:03:17.190
And that does mean that whatever
that role can do, that user or

56
00:03:17.190 --> 00:03:21.680
that automation will be able to
do on top of that EC2 instance.

57
00:03:21.680 --> 00:03:25.307
And so it is really nice to use these,
because if you want to make it so

58
00:03:25.307 --> 00:03:28.554
a certain set of instances can
just work with this stuff, but

59
00:03:28.554 --> 00:03:32.057
then they can't communicate with
this other stuff or whatever,

60
00:03:32.057 --> 00:03:36.410
then you can make sure that there's really
good role isolation and stuff there.

61
00:03:38.730 --> 00:03:42.855
Another thing to note is again,
we're dealing with instances,

62
00:03:42.855 --> 00:03:46.890
so you will see the private
key thing pop up again.

63
00:03:46.890 --> 00:03:51.930
But you'll notice again that we're
generating this for a separate purpose.

64
00:03:51.930 --> 00:03:54.650
We generated a bastion SSH key.

65
00:03:54.650 --> 00:03:57.377
This time I'm generating
a cluster SSH key,

66
00:03:57.377 --> 00:04:02.325
which would mean that I would want to take
this SSH key, put it on the bastion node,

67
00:04:02.325 --> 00:04:07.207
so that people connecting to the bastion
node could then jump into EC2 instances

68
00:04:07.207 --> 00:04:09.830
inside of the cluster to debug if needed.

69
00:04:09.830 --> 00:04:13.510
And that's exactly what you would do
if you wanted to debug an instance.

70
00:04:13.510 --> 00:04:16.749
You would first go to
the bastion node SSH in, and

71
00:04:16.749 --> 00:04:20.470
then that node would have
the key pair to the instances.

72
00:04:20.470 --> 00:04:23.070
You would get the IP address
of the cluster node.

73
00:04:23.070 --> 00:04:27.822
You want to work with SSH with that key or
with the cluster key, and then bam,

74
00:04:27.822 --> 00:04:30.770
you're inside of that instance now.

75
00:04:30.770 --> 00:04:34.491
So again, bastion's not like the most
seamless experience, but it will get you

76
00:04:34.491 --> 00:04:37.810
to where you need to be and it will
allow you to debug things if you need.

77
00:04:37.810 --> 00:04:42.210
So that's also why we store
the cluster key inside of ssm.

78
00:04:42.210 --> 00:04:46.410
So if developers need access to it, or
we need access to it, we can get it.

79
00:04:46.410 --> 00:04:50.606
And another thing to note,
remember in this data file here,

80
00:04:50.606 --> 00:04:53.830
I looked up a Amazon specific entry.

81
00:04:53.830 --> 00:04:56.710
Well, I can do the exact same
thing with my own things.

82
00:04:56.710 --> 00:05:01.653
So if down the road I wanted to precede
instances with this key or whatever,

83
00:05:01.653 --> 00:05:05.889
then I could just easily look this
key up in my parameter store and

84
00:05:05.889 --> 00:05:09.830
then use it inside of other
automation in other places.

85
00:05:09.830 --> 00:05:11.390
So parameter store is really nice.

86
00:05:11.390 --> 00:05:13.430
That's all I'm trying to say,
and that's why I like it.

87
00:05:14.550 --> 00:05:16.870
So then we create a launch template.

88
00:05:16.870 --> 00:05:21.190
A launch template works
with an auto scaling group.

89
00:05:21.190 --> 00:05:25.606
The easiest way to describe what a launch
template does is it is the parameters that

90
00:05:25.606 --> 00:05:29.670
defines the instances that
the autoscaler will be provisioning.

91
00:05:29.670 --> 00:05:33.196
It can only take one
instance settings at a time,

92
00:05:33.196 --> 00:05:37.070
meaning you can't have
multiple launch templates.

93
00:05:37.070 --> 00:05:40.187
For an auto scaling group,
you can really only have one, but

94
00:05:40.187 --> 00:05:42.950
you can have multiple versions
of a launch template.

95
00:05:42.950 --> 00:05:44.706
So if you make a change to it, or

96
00:05:44.706 --> 00:05:49.980
if you want to revert back to a previous
set of changes, you can easily do that.

97
00:05:49.980 --> 00:05:51.017
But if you look at it,

98
00:05:51.017 --> 00:05:54.140
it's pretty much the same thing
as an instance configuration.

99
00:05:54.140 --> 00:05:57.100
You tell it the AMI or
the image ID that you want.

100
00:05:57.100 --> 00:06:01.820
In this case, you'll notice that we're
using the parameter from our data lookup.

101
00:06:01.820 --> 00:06:04.401
We also have an instance type.

102
00:06:04.401 --> 00:06:06.742
There's a little bit of
extra work going on here,

103
00:06:06.742 --> 00:06:10.060
which is you'll notice that there's a for
each.

104
00:06:10.060 --> 00:06:12.540
Can anyone guess what I'm doing here?

105
00:06:12.540 --> 00:06:16.423
So you're basically looping
through all of the providers and

106
00:06:16.423 --> 00:06:20.979
then out of that you generate like
a new dictionary template or object and

107
00:06:20.979 --> 00:06:24.370
then you basically repurpose
that into the code.

108
00:06:24.370 --> 00:06:25.890
Exactly, yeah.

109
00:06:25.890 --> 00:06:32.450
So I have a variable that I'm passing to
this cluster called capacity providers.

110
00:06:32.450 --> 00:06:35.378
Remember we said var dot
means that that had to

111
00:06:35.378 --> 00:06:39.570
have been a variable from
outside coming into the module.

112
00:06:39.570 --> 00:06:43.524
And so
what that means is that our ECS clusters

113
00:06:43.524 --> 00:06:47.180
are configurable on the instance level.

114
00:06:48.540 --> 00:06:53.993
And to go a little bit further, what that
means is that if I wanted to make it so

115
00:06:53.993 --> 00:06:59.980
that I could change the disk size for all
of the cluster instances, I could do that.

116
00:06:59.980 --> 00:07:05.900
If I wanted to change the key name for
specific instances, I could do that.

117
00:07:05.900 --> 00:07:08.855
It just means that I'm iterating and

118
00:07:08.855 --> 00:07:14.080
creating multiple launch
templates with that foreach value.

119
00:07:14.080 --> 00:07:18.926
So when we say for each on a resource, it
just simply means that we are looping over

120
00:07:18.926 --> 00:07:23.040
it and then we're creating a bunch
of resources based off of it.

121
00:07:23.040 --> 00:07:25.952
So yeah, we would have,
by the time we ran this,

122
00:07:25.952 --> 00:07:30.789
we would have multiple launch templates
depending on the capacity, provider or

123
00:07:30.789 --> 00:07:32.800
configurations that we give it.

124
00:07:32.800 --> 00:07:35.000
But we'll look at that more
in a minute once you see it.

125
00:07:35.000 --> 00:07:37.280
I think once you see it from
the other side, it'll make sense.

126
00:07:38.840 --> 00:07:43.400
So another thing down here at the bottom,
we're still in the instance section.

127
00:07:43.400 --> 00:07:46.760
But you had asked earlier, how does
the user data get into the instance?

128
00:07:46.760 --> 00:07:47.960
There it is right there.

129
00:07:47.960 --> 00:07:52.955
So we use user data, we import it as
a file, and then these are variables

130
00:07:52.955 --> 00:07:57.640
here that are expected in the template and
then they get replaced.

131
00:07:57.640 --> 00:08:02.360
So again, cluster name is
the cluster name right here.

132
00:08:03.540 --> 00:08:06.340
Right, Cool.

133
00:08:06.340 --> 00:08:11.136
Another thing to kind of note is,
like I said or like Miguel said,

134
00:08:11.136 --> 00:08:13.940
this is supposed to be a loop, right?

135
00:08:13.940 --> 00:08:19.460
And so in this case it says
each value market type spot.

136
00:08:19.460 --> 00:08:23.982
And what that's saying is,
is that, hey, if this,

137
00:08:23.982 --> 00:08:28.906
if this specific configuration
has a market type of spot,

138
00:08:28.906 --> 00:08:33.240
then add that market type
to the instance profile.

139
00:08:33.240 --> 00:08:37.240
Meaning basically turn on
spot instances if we want to.

140
00:08:41.240 --> 00:08:43.080
That's why these capacity groups are.

141
00:08:44.920 --> 00:08:45.760
Is that what they're called?

142
00:08:45.760 --> 00:08:48.040
Capacity?
No, sorry, capacity providers.

143
00:08:48.040 --> 00:08:51.160
That's why these capacity
providers are configurable.

144
00:08:51.160 --> 00:08:55.424
Because sometimes you might want
spot instances in your ECS cluster,

145
00:08:55.424 --> 00:08:57.520
sometimes you may want on demand,

146
00:08:57.520 --> 00:09:01.760
sometimes you may want instances
of this size versus that size.

147
00:09:01.760 --> 00:09:04.880
And that's one of the things
we have set here.

148
00:09:04.880 --> 00:09:10.292
I can set the instance type or the size,
depending on what capacity provider,

149
00:09:10.292 --> 00:09:14.960
and then I can assign containers
to those capacity providers.

150
00:09:14.960 --> 00:09:19.797
So I can say like, all these containers
run on the spot capacity provider, all of

151
00:09:19.797 --> 00:09:24.510
these containers run on the on demand
capacity provider and things like that.

152
00:09:24.510 --> 00:09:29.225
So you get a little bit of that
kubernetes feel of workflow, scheduling,

153
00:09:29.225 --> 00:09:31.470
placement and whatnot.

154
00:09:31.470 --> 00:09:34.550
But that's about as far as it goes.

155
00:09:34.550 --> 00:09:37.630
To be fair,
it's not as complex as kubernetes.

156
00:09:37.630 --> 00:09:40.670
What's the reason you have the base64
encode your template files?

157
00:09:41.790 --> 00:09:44.990
That's just a cloud init thing.

158
00:09:44.990 --> 00:09:46.979
They want it as a base 64 so

159
00:09:46.979 --> 00:09:52.270
that it can be easily transferred over
a request or something like that.

160
00:09:53.430 --> 00:09:59.319
So you base64 encode it just so
that you can then decode it and

161
00:09:59.319 --> 00:10:03.737
get the full exact script and
then encode it and

162
00:10:03.737 --> 00:10:07.710
just have a large file base 64 encoder.

163
00:10:07.710 --> 00:10:14.288
So really quickly, for example,
if I was to go in here and

164
00:10:14.288 --> 00:10:19.358
be like /bin/bash, set EU pipe, fail and

165
00:10:19.358 --> 00:10:25.935
then be like echo "hello
world" W-R-L-D like this,

166
00:10:25.935 --> 00:10:31.828
then that'd be hard to make
as a parameter in this,

167
00:10:31.828 --> 00:10:36.960
it's expecting just a string value.

168
00:10:36.960 --> 00:10:41.640
It'd be especially hard to transmit that
over a network request of some sort.

169
00:10:41.640 --> 00:10:46.306
And so what we do is we just
encode it into this value and

170
00:10:46.306 --> 00:10:51.182
then that value is what actually
gets translated here so

171
00:10:51.182 --> 00:10:56.100
that the network request
can be successful.

172
00:10:56.100 --> 00:11:00.600
And then what happens is when
Cloud Init gets this value,

173
00:11:00.600 --> 00:11:05.380
it then goes and says, all right,
well, I want to decode.

174
00:11:05.380 --> 00:11:08.820
And when we do decode, we get our script.

175
00:11:10.020 --> 00:11:14.822
So it's just a way of encoding the data so
that it's easy to transmit the data and

176
00:11:14.822 --> 00:11:19.480
then re encode it or decode it later so
that you can actually run the scripts and

177
00:11:19.480 --> 00:11:20.080
stuff.

178
00:11:20.080 --> 00:11:24.222
Yeah, because scripts are normally
like multiline strings and

179
00:11:24.222 --> 00:11:25.760
all that kind of stuff.

