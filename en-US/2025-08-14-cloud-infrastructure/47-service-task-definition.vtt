WEBVTT

1
00:00:00.320 --> 00:00:03.589
&gt;&gt; Erik Reinert: Now we've
got our main.tf, and

2
00:00:03.589 --> 00:00:09.440
this is really where the meat
of the service deployment is.

3
00:00:11.920 --> 00:00:16.668
We have a really cool standardization
that we've created that you may

4
00:00:16.668 --> 00:00:19.564
have noticed by now
that I'm using over and

5
00:00:19.564 --> 00:00:24.880
over again, which is I'm using
parameter store as a database.

6
00:00:24.880 --> 00:00:28.780
I'm using parameter store as a way
of generating thing in automation or

7
00:00:28.780 --> 00:00:30.190
in other places.

8
00:00:30.190 --> 00:00:32.910
And I'm just saying, put it here,
let me access it later, right?

9
00:00:35.390 --> 00:00:39.972
Just like in App Runner, we want a way of
storing parameters for services and making

10
00:00:39.972 --> 00:00:45.230
sure that they're securely stored, that
we can easily edit them in the future.

11
00:00:45.230 --> 00:00:49.039
We don't wanna have to edit them through
Terraform, we just wanna edit them in

12
00:00:49.039 --> 00:00:52.110
the actual UI and then redeploy
the service if we want, right?

13
00:00:54.110 --> 00:00:58.560
One of the things each service
gets is a set of parameters for

14
00:00:58.560 --> 00:01:01.870
all of the secrets that you give it.

15
00:01:01.870 --> 00:01:03.630
And you'll understand
this more in a second.

16
00:01:03.630 --> 00:01:08.867
But think about the App Runner
that we deployed,

17
00:01:08.867 --> 00:01:16.030
how it has a Google client id,
Google client secret postgres URL.

18
00:01:17.310 --> 00:01:22.244
In this situation,
what we do is we tell the service we

19
00:01:22.244 --> 00:01:26.530
want a secret for
that environment variable.

20
00:01:26.530 --> 00:01:28.930
We want a secret for
this environment variable.

21
00:01:28.930 --> 00:01:31.570
We want a secret for
this environment variable.

22
00:01:31.570 --> 00:01:35.206
And what it does is it goes out and
it creates parameters with

23
00:01:35.206 --> 00:01:39.730
basically the word example in it or
something like placeholder, right?

24
00:01:40.850 --> 00:01:45.730
Then now that it's created,
you go in and you add your values.

25
00:01:45.730 --> 00:01:49.734
And now you can manage the resource
without having to manage the value in

26
00:01:49.734 --> 00:01:51.500
the resource.

27
00:01:51.500 --> 00:01:53.420
And so,
that's exactly what we're doing here.

28
00:01:53.420 --> 00:01:55.112
We're saying, okay, well,

29
00:01:55.112 --> 00:01:59.820
I still want the UI to be the thing that's
the source of truth, not Terraform.

30
00:01:59.820 --> 00:02:03.202
And so what we're gonna do is we're gonna
say, okay, I need a secret for this,

31
00:02:03.202 --> 00:02:05.820
I need a secret for this,
I need a secret for this.

32
00:02:05.820 --> 00:02:09.298
Go ahead and provision those for me and
then I'll go in later, update them and

33
00:02:09.298 --> 00:02:10.380
redeploy the service.

34
00:02:11.420 --> 00:02:14.140
So this is just like how I like using it.

35
00:02:14.140 --> 00:02:16.636
Some people would say,
just put it in Terraform state and

36
00:02:16.636 --> 00:02:17.740
manage it with Terraform.

37
00:02:18.820 --> 00:02:23.580
But again, for starters,
you don't have time to manage Terraform.

38
00:02:23.580 --> 00:02:27.100
Maybe you just wanna move really fast,
sometimes the UI is nice, right?

39
00:02:27.100 --> 00:02:29.770
Sometimes it's really nice to just
go click real quick deploy done out

40
00:02:29.770 --> 00:02:31.380
the door, right?

41
00:02:31.380 --> 00:02:33.420
Other times it's nice to use Terraform.

42
00:02:33.420 --> 00:02:36.660
But when you use Terraform,
you have to always use it pretty much.

43
00:02:36.660 --> 00:02:38.820
And so, I like this approach better.

44
00:02:38.820 --> 00:02:42.260
Also, if you have development teams,
this makes it a little easier for them.

45
00:02:42.260 --> 00:02:45.660
They don't have to copy code and
push pipelines and stuff.

46
00:02:45.660 --> 00:02:47.750
They have a more direct window.

47
00:02:47.750 --> 00:02:51.014
And then you can create policies that
let certain people do certain things,

48
00:02:51.014 --> 00:02:53.190
read versus write,
like all that kind of stuff.

49
00:02:53.190 --> 00:02:58.390
So basically out of the box secrets
in the service module itself.

50
00:02:58.390 --> 00:03:00.230
We get a log_group per service.

51
00:03:00.230 --> 00:03:03.185
So this again is the permission
side where we say, okay,

52
00:03:03.185 --> 00:03:06.390
let's create a log_group where
all of our logs will go.

53
00:03:06.390 --> 00:03:08.120
So whenever we get a log with a service,

54
00:03:08.120 --> 00:03:12.070
it will automatically get shipped to
CloudWatch and then we can review it.

55
00:03:12.070 --> 00:03:15.670
Here's our execution IAM role that
we created, here's our policy.

56
00:03:17.360 --> 00:03:19.152
You'll see that we attach some,

57
00:03:19.152 --> 00:03:23.520
again, some of those pre existing
policies that we talked about before.

58
00:03:23.520 --> 00:03:25.200
This just makes life easier.

59
00:03:25.200 --> 00:03:28.316
Things like being able to
read only from the registry,

60
00:03:28.316 --> 00:03:31.280
basically allowing us to pull images.

61
00:03:31.280 --> 00:03:36.125
What's nice about this is when
you start using ECR very heavily,

62
00:03:36.125 --> 00:03:42.410
having to give access to clusters and
resources is incredibly annoying.

63
00:03:42.410 --> 00:03:46.218
And so this role becomes very handy
because now you just attach it to

64
00:03:46.218 --> 00:03:49.850
the nodes or attach it to the service and
bam, you're done.

65
00:03:49.850 --> 00:03:52.050
Now it can pull everything from ECR.

66
00:03:52.050 --> 00:03:53.690
You have complete authentication.

67
00:03:53.690 --> 00:03:55.186
You don't have to worry about if.

68
00:03:55.186 --> 00:03:57.170
No, is it gonna be able to
pull this image or not?

69
00:03:57.170 --> 00:03:57.690
No, it's fine.

70
00:03:57.690 --> 00:04:00.370
We gave it the read only role,
it can pull any image.

71
00:04:00.370 --> 00:04:02.730
We also add the container for service.

72
00:04:02.730 --> 00:04:05.963
So this is just a ECS,

73
00:04:05.963 --> 00:04:10.820
my God, the naming, ECS role.

74
00:04:12.660 --> 00:04:13.564
This will make it so

75
00:04:13.564 --> 00:04:16.900
that there's container service
specific things that it'll allow.

76
00:04:18.180 --> 00:04:21.665
We have the main task role and
then finally, [LAUGH] finally we get to

77
00:04:21.665 --> 00:04:25.620
the task definition and
stuff we might recognize a little bit.

78
00:04:25.620 --> 00:04:28.820
So again, you'll notice that there
is in fact a execution role.

79
00:04:28.820 --> 00:04:30.220
There is a task role.

80
00:04:30.220 --> 00:04:34.240
So it does take two separate roles, which
is why we had to define things twice and

81
00:04:34.240 --> 00:04:34.900
all of that.

82
00:04:36.110 --> 00:04:41.537
The family name, this is just something
arbitrary, related to whatever you

83
00:04:41.537 --> 00:04:48.110
want to namespace this, for example, we
call it just the full name of the service.

84
00:04:48.110 --> 00:04:53.230
You could name it the application itself,
you could name it the organization.

85
00:04:53.230 --> 00:04:55.630
It's totally up to you, but
it's just an arbitrary name.

86
00:04:55.630 --> 00:04:58.270
It doesn't have to be anything specific.

87
00:04:58.270 --> 00:05:00.910
Then we get into the container definition.

88
00:05:00.910 --> 00:05:05.088
And as I said earlier, you can write JSON,
but you have to write it really weirdly.

89
00:05:05.088 --> 00:05:07.379
May I introduce the JSON encode function?

90
00:05:07.379 --> 00:05:12.337
[LAUGH] What we're doing here is
we are actually writing pure JSON,

91
00:05:12.337 --> 00:05:15.360
but we're doing it with HCL.

92
00:05:15.360 --> 00:05:20.395
And so I'm using it to first write
in HCL and then use the JSON

93
00:05:20.395 --> 00:05:27.200
decode function to turn it into and
parse it to JSON once it evaluates it.

94
00:05:27.200 --> 00:05:33.230
And so in this configuration we can see
how many CPUs we want if it's essential.

95
00:05:33.230 --> 00:05:37.310
Essential means that it just runs all
the time versus a one time process.

96
00:05:38.430 --> 00:05:43.090
The image where we're actually
pulling the image from memory name.

97
00:05:43.090 --> 00:05:46.670
If we have port mappings,
what's the port, right?

98
00:05:46.670 --> 00:05:48.682
So if we define port in the service,

99
00:05:48.682 --> 00:05:51.310
remember var means that
it's a module value.

100
00:05:51.310 --> 00:05:53.870
So that means we can change and add ports.

101
00:05:53.870 --> 00:05:59.240
So if we add a port, map that container
port for us environment variables.

102
00:05:59.240 --> 00:06:03.732
Remember I told you that we can configure
this service and then create secrets for

103
00:06:03.732 --> 00:06:04.560
it as well.

104
00:06:04.560 --> 00:06:06.480
So here are the secrets.

105
00:06:06.480 --> 00:06:09.760
And then, we actually have
our logging set up as well.

106
00:06:09.760 --> 00:06:14.262
And so you could see that we tell it
that the options are the awslog-group,

107
00:06:14.262 --> 00:06:18.080
which is the group that we
created in cloudwatch the region.

108
00:06:18.080 --> 00:06:22.240
This is why we needed the region, so that
we can tell it where that log group is.

109
00:06:22.240 --> 00:06:27.030
And then a stream prefix which is
just really for the logs themselves.

110
00:06:27.030 --> 00:06:28.630
And that's the task definition.

111
00:06:30.310 --> 00:06:34.253
A couple of things to take away about
task definitions are they are the actual

112
00:06:34.253 --> 00:06:36.150
configuration of your service.

113
00:06:36.150 --> 00:06:39.954
So the way ECS really kind of works
underneath the hood is it has these

114
00:06:39.954 --> 00:06:42.829
documents that represents
your configurations,

115
00:06:42.829 --> 00:06:44.790
kind of like instance templates.

116
00:06:44.790 --> 00:06:47.390
Remember how earlier we
had launch templates?

117
00:06:47.390 --> 00:06:52.510
Sorry, for our instance, this is a launch
template for a task in a container.

118
00:06:52.510 --> 00:06:54.990
So these are not
the containers themselves.

119
00:06:54.990 --> 00:06:58.030
Meaning that if we just created this,
we would get nothing.

120
00:06:59.710 --> 00:07:04.910
This means that, yeah, this is just
the configuration of that service.

121
00:07:04.910 --> 00:07:09.277
What we're gonna do is we're going
to launch a service with this task

122
00:07:09.277 --> 00:07:10.190
definition.

123
00:07:10.190 --> 00:07:12.510
And that's when we're actually
going to get a container.

124
00:07:14.430 --> 00:07:18.730
I just want you to understand that this is
a config more than it is running an actual

125
00:07:18.730 --> 00:07:19.910
service.

126
00:07:19.910 --> 00:07:22.020
We'll get to that in a minute.

127
00:07:22.020 --> 00:07:26.630
And Miguel, that's actually where
the third role comes into play.

128
00:07:26.630 --> 00:07:29.350
So the first two were for
the task definition.

129
00:07:29.350 --> 00:07:34.114
The third one is for the service to
launch that task definition, and so

130
00:07:34.114 --> 00:07:36.950
yeah, we create a service role.

131
00:07:36.950 --> 00:07:39.444
We attach a EC2 container service role,

132
00:07:39.444 --> 00:07:42.230
which is a different one
related to services.

133
00:07:43.270 --> 00:07:45.773
We set up a target group.

134
00:07:45.773 --> 00:07:50.565
So going back to the whole, how does a
load balancer know when there's traffic or

135
00:07:50.565 --> 00:07:52.690
not and how to drain it and whatnot.

136
00:07:52.690 --> 00:07:55.810
This is exactly that connector
to the load balancer.

137
00:07:55.810 --> 00:08:00.606
The target group basically gets assigned
to the load balancer saying, hey,

138
00:08:00.606 --> 00:08:05.842
this target group has a port with this,
it has a deregistration, or basically, how

139
00:08:05.842 --> 00:08:11.090
long it should wait before it completely
takes it out of the load balancer.

140
00:08:11.090 --> 00:08:14.070
And then, what VPC is it attached to?

141
00:08:14.070 --> 00:08:18.874
And then we create a listener that
that target group binds with.

142
00:08:18.874 --> 00:08:22.788
And so the listener then says, okay, well,

143
00:08:22.788 --> 00:08:29.590
we want to forward all traffic to
the target group, which we created, right?

144
00:08:29.590 --> 00:08:33.812
And then we wanna attach
it to port 80 listener,

145
00:08:33.812 --> 00:08:37.439
that we have in the load balancer, right?

146
00:08:37.439 --> 00:08:41.159
So this makes it so that we can listen
on port 80 in the load balancer and

147
00:08:41.159 --> 00:08:45.520
then route to port 5000 or
whatever else that we want, right?

148
00:08:45.520 --> 00:08:49.555
And so, yeah, once we have the target
group, as well as the listener rule in

149
00:08:49.555 --> 00:08:52.600
place, we are now ready to
actually start that service.

150
00:08:52.600 --> 00:08:57.277
And again, just to give that
traffic flow as one more example,

151
00:08:57.277 --> 00:09:02.132
what that means is that when
the load balancer gets your request,

152
00:09:02.132 --> 00:09:07.430
it's first gonna hit the main listener
that we created in the cluster,

153
00:09:07.430 --> 00:09:12.890
and then that listener on 80 will
forward it to the listener rule.

154
00:09:12.890 --> 00:09:18.847
If the listener rule matches, it could be
a host header, it could be a path, right?

155
00:09:18.847 --> 00:09:22.545
So, for example, in the future,
if you wanna make it so

156
00:09:22.545 --> 00:09:25.933
that you have more services
over specific routes,

157
00:09:25.933 --> 00:09:30.610
that would be the listener rule that
it adds for that service, right?

158
00:09:30.610 --> 00:09:34.260
So in this case, we're just gonna do
slash, meaning it's gonna do everything.

159
00:09:34.260 --> 00:09:36.946
And so what will happen is the listener
rule will say, yeah, yeah,

160
00:09:36.946 --> 00:09:38.260
I have something for slash.

161
00:09:38.260 --> 00:09:43.025
And then the listener rule will tell it to
forward that traffic to the target group,

162
00:09:43.025 --> 00:09:44.980
which is the service itself.

163
00:09:44.980 --> 00:09:47.846
And that's this last one right here.

164
00:09:47.846 --> 00:09:52.201
So the aws_ecs_service resource
takes the cluster value,

165
00:09:52.201 --> 00:09:55.140
takes the desired count as well, right?

166
00:09:55.140 --> 00:09:56.940
So right now we're setting it to one.

167
00:09:56.940 --> 00:10:00.370
We do have auto scaling, so we don't
really have to worry about this value.

168
00:10:00.370 --> 00:10:01.410
We can just set it to one.

169
00:10:01.410 --> 00:10:05.090
However, this is also what it
will scale down to, right?

170
00:10:05.090 --> 00:10:09.922
So if you want five or seven by default or
whatever, you can set that to.

171
00:10:09.922 --> 00:10:14.290
Your IAM role, your actual service
IAM role, your task definition.

172
00:10:14.290 --> 00:10:19.290
Again, the thing that we described
earlier, your capacity_provider_strategy.

173
00:10:19.290 --> 00:10:23.730
So this basically says, which capacity
providers do you want it to go into?

174
00:10:23.730 --> 00:10:28.101
Now, what's really cool about this is if
you're in a scenario where you're like,

175
00:10:28.101 --> 00:10:32.472
okay, I want spot instances and I want on
demand, and I want 75% spot and 25% on

176
00:10:32.472 --> 00:10:36.620
demand, then you can set up these provider
strategies to where you can do that.

177
00:10:36.620 --> 00:10:40.508
You can say okay,
base 1 capacity provider spot 75% and

178
00:10:40.508 --> 00:10:43.073
then you can add another one of these and

179
00:10:43.073 --> 00:10:48.460
then you can say base 2 capacity provider
something else weight 25%, right?

180
00:10:48.460 --> 00:10:52.199
And then it will balance the cluster
out or balance the services out

181
00:10:52.199 --> 00:10:56.910
to make sure that you have that much of
a support spread across them as well.

182
00:10:56.910 --> 00:10:58.430
Then we set up the load_balancer.

183
00:10:58.430 --> 00:11:01.888
So we actually just say
the container_name, the container_port and

184
00:11:01.888 --> 00:11:03.390
then that target_group arn.

185
00:11:03.390 --> 00:11:06.390
And now we've actually bound
everything together, right?

186
00:11:06.390 --> 00:11:10.030
So we created the task definition, right?

187
00:11:10.030 --> 00:11:13.230
We created the target rule
from the load balancer.

188
00:11:13.230 --> 00:11:17.070
So load balancer's over here,
task definition on ECS is over here.

189
00:11:17.070 --> 00:11:19.950
And then we join them together
with the service, right?

190
00:11:19.950 --> 00:11:24.213
So the service is the joiner of all of
these things together to actually start

191
00:11:24.213 --> 00:11:25.150
the container.

