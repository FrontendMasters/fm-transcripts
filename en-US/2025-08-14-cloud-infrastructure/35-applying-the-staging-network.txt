[00:00:00]
>> Erik Reinert: So we've created our bastion file, we've created our locals file, our main file, our output, our security group and our variables file. Awesome. Now the last thing we want to do is we actually want to use this module. We just created it. Now I want to provision a whole bunch of stuff with it.

[00:00:15]
If I do it in the main at the root repository, I'm outside of my staging module, which means that if I copy this and paste it, I won't get that network module inside of it. I'll have to copy and paste the network module too. So what I want to do is I actually want to do the whole module inside of a module scenario.

[00:00:34]
And so what we're going to do is, is we're actually going to go into environment, go to that blank main TF file, and then I'm going to add my first module, which is my network module. And so if I reopen this really quickly, you'll see that I again, I use module, I say network, right?

[00:00:53]
The source is directory up network, right. So I'm literally referencing a directory. Then you'll see here, it's the variables that I provided before. Now again, to go back to your question, this is hard coded, meaning that again, if I take that environment, the higher level environment module, and I copy and paste it and I create a new network or I create a new environment, then those two environments will have the exact same CIDRs.

[00:01:22]
But if I wanted to, and again, I don't do this, but if I wanted to, I could do this. I could say variable cider. Okay, thanks for not helping me at all, copilot. And then, we'll say like type string. And then, if I go here, now what I can do is I can say, var cider here, and then go up a level to where I have that whole like high level composability.

[00:01:53]
And then here I would say cider equals this. And then I'd be like, okay, well I know I use this on staging. So now when I go to create prod, right, I want to use 100. And now I've created two separate networks. But the only thing I needed to change was the cider.

[00:02:14]
And that's a higher level value in the environment, so I can just easily change that. And then bam, everything's mapped up and ready to go. So if you were in a scenario where you had to do something like that, that's basically how you would make it really easy to give multiple CIDRs to multiple networks.

[00:02:34]
Let me go ahead and delete that really quickly though. 10.0.0.16. That is missing a dot zero. All right, so we're doing that, we'll get rid of the cider here. We don't need that. Now we have our very first problem that we're trying to solve inside of our environment.

[00:03:00]
Again, this isn't just a module, but it's a solution to something that we need, which is an entire network that should come out of it. Now, what I'm gonna do is I'm gonna go to the top level, I'm gonna do Terraform in it again because, why? Because I created a whole bunch of modules, right?

[00:03:17]
So once I do Terraform Init, it's going to go out and then you'll see, look, now it's even adding more stuff, right? And it even went out onto the Internet and made sure that it downloaded anything that I was using remotely, like any remote modules or anything like that, right?

[00:03:33]
Now when I run Terraform Plan, I should actually have like some resources. So let's do Terraform Plan. Okay? And so remember how I told you that if I didn't update that value, it would fail? Well, it did, so let me quickly grab the IP address of here and plan, so there we go.

[00:04:03]
You can see that Terraform is now saying, hey, I've got a whole bunch of resources. And actually for the three or four modules that we used, look at how many resources it's creating. You would have had to do that all yourself if you hadn't used a module. So even though we used like three or four modules, we're getting 63 resources created, which is a lot, right?

[00:04:26]
Like that's actually crazy. So if I scrolled up to this, which I'm not gonna scroll up too far because I don't want to dox the IP address I just added. But for example, look at this subnet, the public subnet. Do you see how it automatically calculated the address as well as the CIDR to it 21.

[00:04:45]
So it's 176.21, that's everything that that subnet module I was telling you about before is doing. It's going out looking at my CIDR base of 10.0.0.16 and then saying, okay, cool. Well, you told me you want 500 IPs. Great. Well this is from there to here. This is the address space that you can have to calculate.

[00:05:05]
So again, it's really nice and it's really easy. Use something like that to do it. Now that we have a plan we are actually in the situation where we're ready to apply. I'm going to do Terraform Apply. And off we go, we should start provisioning, there you go.

[00:05:23]
We're now provisioning our network. Now this is going to take a little while, so if we want we can go ahead and pause here and let everything get provisioned. But basically what you're seeing now is Terraform. Go through the process of creating everything in, in my environment. And you can see, yeah, it's creating security groups, it's creating route tables, it's creating VPCs, it's creating every subnets, everything we need.

[00:05:49]
But the thing I want you to note is look at the naming convention module, staging module, network module, vpc awsroutetable. Da, da, da, da. Another thing that's really nice about composing things in modules is it isolates the resources really, really well. And once you get really comfortable with writing modules, the naming conventions kind of really show you exactly where and what they're provisioning.

[00:06:14]
So in this case, if we were looking at this and I was just like looking at it head on first, I would go, okay, well we're provisioning, networking stuff inside of the staging environment. Awesome. So that naming convention can actually be helpful as well, just knowing where everything is and what it is.

[00:06:31]
But yeah, we have created our first module or our first like part of our new infrastructure.

