[00:00:00]
>> Erik Reinert: Now, that we've figured out how the application runs, we've confirmed that it runs locally, we're ready to actually start putting the application in the cloud. We've covered all of our bases. I know that if I run into any bugs or any problems or anything like that, I should be good to go.

[00:00:14]
Now what I want to do is actually start working on. Cool, let's get our deployment out the door. Let's take the code as it is. I should expect that this code in this state should now just run in the cloud. So the first thing we're going to want to do is we're going to actually go to Amazon.

[00:00:30]
So I'm going to go to Amazon and then I am going to go to the console. So everybody go to the main console here at the front, and then I'm going to, up in the top bar, type in ecr. Has anyone here ever worked with ECR before? Does anyone know what it is?

[00:00:52]
So ECR is Amazon's Elastic Container Registry. We said that we want to get this up and running as minimally as humanly possible, but we want to use containers. That means that we have to have our image stored somewhere in the cloud. We have to put that image somewhere so that the thing that's running our service is able to access it.

[00:01:20]
That's all we really care about. But that's the requirement. And what I like to do when I'm building things or trying to think about how to solve things, I look at my most closest problem and then go, okay, let me just solve this problem and then I'll solve the next one, and then I'll solve the next one.

[00:01:37]
I don't really take huge problems on with tons of questions at once. I like to look at it very simply. So if we were to go, I want to get my container running up in the cloud, the first thing we need to do is put that image somewhere.

[00:01:49]
Amazon has a service called Elastic Container Registry and I can create a repository to put all of my images in. And you can see here that I already have one for the preview. This is basically what we're trying to do. I'm going to click Create Repository up in the top right hand corner.

[00:02:06]
Then, I'm going to type in fem md service. You'll notice that on the left here there's a URL. The only thing I want you to take away from this is this value right here. This value is your account id. Amazon separates all of its resources based off of account ID.

[00:02:24]
And more often than not, you'll see your account ID and permissions or URLs or whatever. So just take note of this URL and just copy it. Just put it off to the side, put it in your editor, do whatever you want, but just take note of that URL, because we're going to want that in the future.

[00:02:42]
We're not going to change anything else. We're not going to worry about immutability or mutability or whatever. We're just going to type in FEMFD service and then we're going to click Create. What you could do is, once you see that it's been created, you can see I have it right here.

[00:02:58]
You can actually click on it and then do something like click View, push commands. Then you'll see in here that Amazon actually provides us a nice little UI to kind of show you how to get started. The two most important things I want you to kind of note are the git login password, and then the tagging down here.

[00:03:21]
So if you've ever used Docker before, you've probably had to authenticate with like a registry at some point to push up an image. And this is how you authenticate with Amazon's registry. So what I want you to do really quickly is I want you to copy this URL or copy this first line.

[00:03:37]
So just click Code copied right there. Then I want in your terminal to stop running the program, close out any other windows if you need, and then paste in that command just like that. Then hit Enter. It should take a second, but then it should say login succeeded once you've logged in.

[00:03:59]
We now know that we can basically push images. So if I wanted to, I could be like, docker image, push, whatever, we're authenticated. So the next thing we need to do is we need to create a docker file. Like, we don't anything to actually build, right? Like, if we look here, there's no.

[00:04:11]
There's a Docker compose. That's great that we got that, but we didn't get a Docker file, right? So we actually need to create one now. So I'm going to create a new file, right? I'm just going to say touch Docker file in the directory in the main directory, and then I'm just going to open up that file and I'm going to copy and paste over for you guys exactly what we want.

[00:04:31]
Now, if you've ever started with Docker before, this is a very simple, simple Docker file. This is one of the most common Docker files approaches, which is very Simply at the top, we tell it which image we want to use. And nine times out of 10, when you're getting started, you're using just a language image.

[00:04:52]
You'll notice here I'm using golang. We set up a working directory. So in this case, I'm telling Docker, hey, inside of the container, when you build, I want you to change to the app directory, which more than likely is empty. That's where I want to do all of my work.

[00:05:10]
Then I'm going to copy my go mod and my go sum into that directory. That means that when this copy happens, it will be AppGo mod and app Go sum. Now, really quickly, can anyone tell me why I'm just copying those two files to start? Does anyone know why am I copying just the go mod and the go.

[00:05:34]
Sum.
>> Speaker 2: To initialize, I guess, the project, the code and everything, download the dependencies that it may have.
>> Erik Reinert: Yeah. So Docker has caching built into it, which is nice. So if you have something that's really labor-intensive, like downloading a ton of dependencies or things like that, you can tell Docker to just do that part first so that in the future.

[00:05:58]
If another file changes, it doesn't have to run that command over and over and over again. If you've ever used Node Modules or NPM install inside of a container, it's pretty much the same effect where you take a package JSON, a package lock, you do the NPM install and then you copy all of your source code again.

[00:06:16]
That's exactly what we're doing here. We're copying in the main stuff and then we do a go mod download. This will make sure that it downloads all the dependencies for the application. But then, here is where we will break cache if we make any changes, right? So as long as I don't change the go mod or the go sum every time I rebuild this image, it will only start from here, which will save time in development.

[00:06:42]
I don't have to worry about doing like, it's just saving time, really. That's the easiest way to put it. It just saves time. So then after we do our go mod download, we copy. So we do dot, dot, right? This is a very simple copy everything in my current directory to everything in the directory I'm inside of the Docker container.

[00:07:02]
So that case, this means that I am copying everything into app. And it also does mean that I'm recopying go mod and go some. If you're like, does that mean that that's happening? Yes, it totally does. But it doesn't matter at this point. We've already copied it once.

[00:07:16]
We've already cached what we wanted to cache, so it doesn't really matter if it gets moved again. It's not that big of a deal. We know our build command, so our build command should be go build O. In this case, I'm just calling it main. So I'm just saying go build main.

[00:07:30]
Go or main, and then I'm doing dot at the end to tell it to build in the current directory as well. Then the last two things are Docker specific. We tell it the port we want it to expose on, and then we tell it the application that we want it to actually run.

[00:07:44]
So that's it, pretty straightforward, very simple Docker file, nothing too crazy about it. The next thing I want to do is I want to follow the commands actually inside of the push commands. So if I go back in here, you'll notice that there's a build command, Docker build T.

[00:08:06]
So I can just copy this, paste this in, and then hit Enter. And if this works for you, then you should start seeing Docker basically do the exact same thing.
>> Speaker 2: That Dockerfile, like the syntax or whatever you want to call that. Is that Docker specific, like the copy run?

[00:08:30]

>> Erik Reinert: Yeah, those are all Docker specific syntax. And the Docker file is unique to Docker itself. There are technically, I think Podman has its own POD file or something like that. But no, that's the basic Docker. Yeah, dope, okay, so cool. We built our image. Awesome. Now, I'm gonna make one small change here.

[00:08:56]
For those of you who are on ARM PCs or ARM intel, or on ARM, sorry, processors, you'll notice that before we ran this command, right? Cool, that's awesome. But if you're on one of the new MacBook Pros, this will not work for you. And you might be like, why?

[00:09:15]
Well, because you just built an image for ARM64, which means that if I want to deploy this image, I need to Deploy to an ARM64 processor. There's a way of getting around this, and I'm going to show it to you, which is I can tell Docker with the Build X command.

[00:09:30]
So not build, but Build X what platform I want to actually build for. So what I want you to do is, even though we ran this build command, I want you to then run this build command underneath it. So Docker build X build platform, Linux amd64 tag fem fd service latest so just run that command directly.

[00:10:00]

>> Speaker 2: All of us are just.
>> Erik Reinert: All of us, yeah, yeah. Everybody, Yeah. I mean, if it works, you may not. It may not work for you, but if it does, then yeah. So I'm going to hit Enter, and you'll notice that it actually does everything again from scratch.

[00:10:19]
That's because this time it's actually pulling the AMD 64 version of the image, running the build and making sure that everything works. On AMD 64, we did technically just do a multi platform build. We first built it on ARM, if you're on an ARM PC. And then we reran it with AMD 64 to make sure that it gets built properly.

[00:10:41]
And there you go.
>> Speaker 2: What's the colon latest there at the end? That's the main difference I'm seeing between the one copied from AWS and the one that you have.
>> Erik Reinert: Yeah. So Docker images have what are called tags, and those are like. So the first part here is the name of the image, but then this is the actual version of the image that I want, right?

[00:11:09]
So latest is kind of like a convention in Docker that simply says I want to get the absolute latest image that's available. So they just use the latest tag. However, I am like slightly. Well, I'm autistic and I'm very deliberate with everything I do, so I like to be explicit.

[00:11:27]
So I always put it in regardless. But you don't actually have to that If you want, you can just remove latest and you'd be fine. But I have really weird quirks and that's one of them. I would rather see it than not, but if you remove it, it'll still be tagged as latest.

[00:11:40]
Yeah, we generated credentials, we ran our postgres locally, we made sure that the application works locally, so we know the app works. We made a Docker file for it and then we built that dockerfile to make sure that that is all good as well. So the last thing we really need to do is simply tag and push it.

[00:11:59]
So what I'm going to do is in the commands here, you'll notice that we have a third line that says Docker tag, fem, fd, service, latest, blah, blah, blah, blah, blah. So I'm going to copy that third line and then I'm just going to paste that in. So I'm just taking exactly what is in the document and then enter.

[00:12:24]
If I do that, what I've effectively just done is. And it's hard to see because my text is so big. Let me reset the font size here. There you go. You'll see that I have Two tags. Now I have one with my normal FEM FD service tag on latest, and then I have another one with a much longer.

[00:12:43]
Remember that URL I told you about before from ecr? Well, it tacked on that URL in front of it and it made that the name of the image, latest. So basically, we're setting this up to be pushed to Amazon ECR. And so the last thing we can do is we can copy that last command, docker, push, paste that and then hit Enter.

[00:13:07]
And if your credentials are set up and everything's good to go, you should start seeing your image get pushed to Amazon cloud. I like how somebody in chat's talking about the image size. Don't worry, we'll get to that. It is a chunky container. So if everything works, everything is good, then you can close this window out, you can click on your image in ECR and sure enough, we should see our latest image tag right there.

[00:13:39]
You just took your very first step to working on a deployment, which is, as we said in the beginning of this phase, I just want to get my app running right and I want to be able to connect it to a database. Well, we just did the first part of the running, which is our image work or our application works.

[00:13:56]
We know how to configure it, we can build it, and now we've put it up in the cloud so that other things can use it.

