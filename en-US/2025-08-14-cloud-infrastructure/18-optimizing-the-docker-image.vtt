WEBVTT

1
00:00:00.400 --> 00:00:02.269
&gt;&gt; Erik Reinert: So one of the things
that's nice about the Docker CLI

2
00:00:02.269 --> 00:00:04.320
is there's a lot of really cool
things you can do with it.

3
00:00:04.320 --> 00:00:07.736
For example, one of the things you
can do is you can give it, like,

4
00:00:07.736 --> 00:00:10.120
formatting against log
output that you want.

5
00:00:10.120 --> 00:00:13.045
So if I wanted to see how big
my images were in general,

6
00:00:13.045 --> 00:00:16.212
I could run that command and
you'll see here that.

7
00:00:16.212 --> 00:00:20.800
Wow, the latest image is 400 megabytes,
right?

8
00:00:20.800 --> 00:00:22.040
That's kind of a big image.

9
00:00:22.040 --> 00:00:24.720
Can anyone tell me why
this is such a big image?

10
00:00:26.810 --> 00:00:28.970
&gt;&gt; Speaker 2: It's got a lot
of packages you don't use.

11
00:00:28.970 --> 00:00:32.416
&gt;&gt; Erik Reinert: Yep,
if we look at the Docker file, though,

12
00:00:32.416 --> 00:00:37.610
what is one thing in particular that
might make this big by default?

13
00:00:38.650 --> 00:00:39.730
&gt;&gt; Speaker 2: The public image.

14
00:00:39.730 --> 00:00:41.529
&gt;&gt; Erik Reinert: The public image,
exactly, yeah.

15
00:00:41.529 --> 00:00:43.450
We're using a language image, right?

16
00:00:43.450 --> 00:00:45.210
So, we're using a Golang image.

17
00:00:45.210 --> 00:00:47.290
Means that Golang is
gonna be installed in it.

18
00:00:47.290 --> 00:00:49.530
All the tools for Golang,
blah, blah, blah, blah, blah.

19
00:00:49.530 --> 00:00:51.450
That's just going to make
it heavier by default.

20
00:00:51.450 --> 00:00:52.540
Right?

21
00:00:52.540 --> 00:00:55.420
So what would be better to use?

22
00:00:55.420 --> 00:00:57.780
Can anyone guess what might
be a better image to use?

23
00:00:57.780 --> 00:00:59.740
And I will note, it's already in the tag.

24
00:00:59.740 --> 00:01:01.980
It's just not the appropriate one.

25
00:01:01.980 --> 00:01:02.860
&gt;&gt; Speaker 2: Base Alpine.

26
00:01:02.860 --> 00:01:04.620
&gt;&gt; Erik Reinert: Base Alpine,
yeah, exactly.

27
00:01:04.620 --> 00:01:07.624
So what's kind of neat is Golang and

28
00:01:07.624 --> 00:01:12.700
all these other images out
there use base images, right?

29
00:01:12.700 --> 00:01:19.840
So, you'll notice that my Golang image
has 12 or 1.24.2 dash Alpine, right?

30
00:01:19.840 --> 00:01:24.160
That means that underneath the Golang
image, there's an Alpine image.

31
00:01:24.160 --> 00:01:29.770
So realistically, I should be able to
build everything in the Golang image and

32
00:01:29.770 --> 00:01:33.600
then just move those outputs
to a much smaller image.

33
00:01:33.600 --> 00:01:35.280
And that's exactly what we want to do.

34
00:01:35.280 --> 00:01:37.200
That's the next step
of what we want to do.

35
00:01:38.240 --> 00:01:42.703
So the first thing we're going to do is
we're going to update the Docker file by

36
00:01:42.703 --> 00:01:46.370
including what we're missing,
which is our Goose installer.

37
00:01:46.370 --> 00:01:51.130
Like I said, we want to run
Goose in the container, right?

38
00:01:51.130 --> 00:01:53.290
So we need to actually
add it to the container.

39
00:01:53.290 --> 00:01:57.206
And then the next thing we're going to
do is we're going to update this copy

40
00:01:57.206 --> 00:02:00.130
down here to be a little
bit more granular, right?

41
00:02:00.130 --> 00:02:03.183
We don't need to necessarily copy,
like static,

42
00:02:03.183 --> 00:02:07.090
which has a whole bunch of files in it,
and main Js and templates.

43
00:02:07.090 --> 00:02:10.490
And, you know,
we don't have to copy all of that at once.

44
00:02:10.490 --> 00:02:14.560
What we really want to do is just say,
okay, copy all of our go code.

45
00:02:14.560 --> 00:02:15.320
Just the go code.

46
00:02:15.320 --> 00:02:17.200
That's all we really care about for
this, right?

47
00:02:17.200 --> 00:02:20.960
So, we're saying main go and
then we're gonna do dot.

48
00:02:20.960 --> 00:02:24.896
This will make it so that when I copy,
I'm only going to copy the main go and

49
00:02:24.896 --> 00:02:26.880
then I'm going to build off of that.

50
00:02:26.880 --> 00:02:30.499
Now what's cool about this is now
if I make template changes or

51
00:02:30.499 --> 00:02:33.072
anything like that, I won't have to like,

52
00:02:33.072 --> 00:02:37.760
if I make a JavaScript change, I shouldn't
have to rebuild my go code, right?

53
00:02:37.760 --> 00:02:41.800
And so, this makes it even faster
because now I don't have to worry about

54
00:02:41.800 --> 00:02:46.120
those changes impacting my build times and
performance and stuff like that.

55
00:02:47.640 --> 00:02:51.282
Now the next thing we're gonna do is
we're gonna add what you are saying,

56
00:02:51.282 --> 00:02:53.120
which is the rest of the big changes.

57
00:02:53.120 --> 00:02:57.200
So underneath this line here under
the main, we're gonna do two things.

58
00:02:57.200 --> 00:03:02.663
We're actually gonna delete
the existing lines underneath it and

59
00:03:02.663 --> 00:03:07.160
then I'm going to add a whole
new what is called stage.

60
00:03:08.460 --> 00:03:13.448
So in a Docker file, you can do
the normal kind of traditional thing,

61
00:03:13.448 --> 00:03:18.140
which is you can create one
stage which does everything.

62
00:03:18.140 --> 00:03:19.660
And that's what this is right here.

63
00:03:21.020 --> 00:03:25.716
But if you wanna make it so it builds
multiple images or tries multiple things,

64
00:03:25.716 --> 00:03:28.220
you can do them in what are called stages.

65
00:03:29.340 --> 00:03:35.310
The first thing we'll do is at the very
top we're going to say as build.

66
00:03:35.310 --> 00:03:37.030
Because now we're making this a stage.

67
00:03:37.030 --> 00:03:41.550
This isn't the final output,
it's just a stage that we're going to use.

68
00:03:41.550 --> 00:03:43.765
Then if we go down to the bottom,

69
00:03:43.765 --> 00:03:47.630
you'll see that I can add
the rest of my second stage.

70
00:03:47.630 --> 00:03:51.642
You'll see that I have another from
here underneath my first stage,

71
00:03:51.642 --> 00:03:54.990
meaning that I'm creating
a whole new stage.

72
00:03:54.990 --> 00:03:58.675
Then I'm doing a couple of things, like
setting an environment variable to set

73
00:03:58.675 --> 00:04:00.990
the version of Dockerize
that I want to download.

74
00:04:00.990 --> 00:04:03.230
Don't worry, I'll show you
what Dockerize is in a second.

75
00:04:05.370 --> 00:04:07.290
I install it, right?

76
00:04:07.290 --> 00:04:09.290
I then go into my.

77
00:04:09.290 --> 00:04:10.970
I go into app again.

78
00:04:10.970 --> 00:04:14.810
You'll notice up here we go into app,
but down here we go into app as well.

79
00:04:14.810 --> 00:04:16.010
Can anyone guess why?

80
00:04:16.010 --> 00:04:17.850
Why do I have to go into app twice?

81
00:04:18.890 --> 00:04:20.330
&gt;&gt; Speaker 2: It's a separate image.

82
00:04:20.330 --> 00:04:21.410
&gt;&gt; Erik Reinert: Yeah,
it's a brand new image.

83
00:04:21.410 --> 00:04:22.610
It's an entirely new stage.

84
00:04:22.610 --> 00:04:23.330
So we have to.

85
00:04:23.330 --> 00:04:26.710
Anything that you did in the previous
stage that you want to make sure is

86
00:04:26.710 --> 00:04:28.330
replicated, you may have to re.

87
00:04:28.330 --> 00:04:30.810
Add to get back to that state, right?

88
00:04:30.810 --> 00:04:34.128
So we go into app and
then what we do is we say, hey,

89
00:04:34.128 --> 00:04:38.410
I don't want you to copy from
my source code like down here.

90
00:04:38.410 --> 00:04:42.090
I want you to actually
copy from the build stage.

91
00:04:42.090 --> 00:04:45.808
What's cool about this
is now when we built

92
00:04:45.808 --> 00:04:50.890
our Go application up here,
I can now use it down here.

93
00:04:50.890 --> 00:04:54.810
And you'll notice that it is in app or
app main.

94
00:04:54.810 --> 00:04:59.738
That's because I'm downloading the the
path from a previous build stage or

95
00:04:59.738 --> 00:05:04.590
the output from a binary in the previous
build stage into this build stage.

96
00:05:05.630 --> 00:05:09.513
&gt;&gt; Speaker 2: You still need the Golang
image first because you need the GO

97
00:05:09.513 --> 00:05:11.470
compiler to build those.

98
00:05:11.470 --> 00:05:12.190
&gt;&gt; Erik Reinert: Exactly.

99
00:05:12.190 --> 00:05:13.150
Yeah, exactly.

100
00:05:13.150 --> 00:05:17.336
Yeah, we need to compile it with Go, but
we don't want to actually keep that for

101
00:05:17.336 --> 00:05:18.990
our production image.

102
00:05:18.990 --> 00:05:21.930
We just want to make sure that we
basically we want to build it in

103
00:05:21.930 --> 00:05:25.212
a little environment and
then take those two binaries and go, okay,

104
00:05:25.212 --> 00:05:28.520
let's put you into this nice clean and
simple environment.

105
00:05:28.520 --> 00:05:30.360
And so that's what we're doing.

106
00:05:30.360 --> 00:05:34.040
We copy the main build and
then we also copy Goose.

107
00:05:34.040 --> 00:05:38.698
Now the reason why we copy Goose is
because Goose has to be compiled and

108
00:05:38.698 --> 00:05:40.560
installed with Go as well.

109
00:05:40.560 --> 00:05:43.640
There's no other real easy way
to use Goose, unfortunately.

110
00:05:43.640 --> 00:05:48.953
So we use the Go image to not just compile
our application, but we actually use it to

111
00:05:48.953 --> 00:05:54.600
compile and install Goose, which we then
copy that binary into our final image.

112
00:05:54.600 --> 00:06:00.045
Right, then we add our migrations,
our static directory, our templates,

113
00:06:00.045 --> 00:06:05.000
we add our expose 8080 and
then we set up our command as before.

114
00:06:05.000 --> 00:06:09.241
Right, so now what I'm gonna do
really fast is just double check,

115
00:06:09.241 --> 00:06:11.000
make sure we are all good.

116
00:06:11.000 --> 00:06:15.160
I think we are cool.

117
00:06:15.160 --> 00:06:17.820
Okay, I'm going to save this.

118
00:06:17.820 --> 00:06:22.538
Then what I'm going to do really quickly
is I'm going to go back to the make file

119
00:06:22.538 --> 00:06:27.820
because I need to make a small change and
it's right in the Build Image section.

120
00:06:27.820 --> 00:06:31.260
Basically right now,
if I was to build this.

121
00:06:31.260 --> 00:06:32.020
Let's just do it.

122
00:06:32.020 --> 00:06:33.180
Make Build Image.

123
00:06:38.220 --> 00:06:41.580
You'll notice that these
are building simultaneously.

124
00:06:41.580 --> 00:06:45.180
Stage 2 and Stage 1 are basically
building right on top of each other.

125
00:06:45.180 --> 00:06:49.930
So you'll see that right now the build
stage is currently installing GOs.

126
00:06:51.210 --> 00:06:54.896
Then we're waiting because we've already
completed the stages that we could in

127
00:06:54.896 --> 00:06:56.170
the second stage.

128
00:06:56.170 --> 00:06:59.930
This is how BuildX and
Docker works with stages.

129
00:06:59.930 --> 00:07:03.726
It will do as much as it can in one of
the stages before it hits a dependency of

130
00:07:03.726 --> 00:07:06.010
another stage, and then it'll just wait.

131
00:07:07.450 --> 00:07:12.509
The downside to this though, is because
I didn't tell it which stage I want

132
00:07:12.509 --> 00:07:17.568
it to specifically build for this image,
it's going to take both stages,

133
00:07:17.568 --> 00:07:22.570
compile it into one image, and
it's going to be even bigger.

134
00:07:22.570 --> 00:07:26.090
That's because I didn't tell
it separate the images.

135
00:07:26.090 --> 00:07:32.650
I just told it I want two build stages and
I want you to glue those together.

136
00:07:32.650 --> 00:07:39.930
Now if I do image,
let's see, where's format?

137
00:07:42.260 --> 00:07:46.220
Yeah, now you'll see it's actually,
no, this one's 90 megabits.

138
00:07:46.220 --> 00:07:50.620
But actually, it did it exactly the way
that I wanted it to, nevermind.

139
00:07:50.620 --> 00:07:54.802
I guess maybe that's, that's kind of what
we wanted, but it still didn't give us

140
00:07:54.802 --> 00:07:59.300
the exact image that we wanted because
again, we built them together, basically.

141
00:07:59.300 --> 00:08:03.645
So what I want to do is I want
to go to the make file and

142
00:08:03.645 --> 00:08:07.900
I want to build these
separately just to be sure.

143
00:08:07.900 --> 00:08:13.458
So what I'm going to do is
I'm going to delete this and

144
00:08:13.458 --> 00:08:18.600
then I'm just going to say, hey, do both.

145
00:08:18.600 --> 00:08:23.230
So first use BuildX to
target the build stage and

146
00:08:23.230 --> 00:08:28.554
focus on just doing that first,
and then take the cache

147
00:08:28.554 --> 00:08:33.560
from that stage and
rerun the actual build itself.

148
00:08:34.840 --> 00:08:39.821
What happens is this gets built into an
entirely separate image so that no cache

149
00:08:39.821 --> 00:08:45.600
or anything like that is stor stored in
the image that we want to actually deploy.

150
00:08:45.600 --> 00:08:50.377
Then the second build command will make
sure that we still use the cache from that

151
00:08:50.377 --> 00:08:54.320
previously built image, so
we don't have to repeat anything.

152
00:08:54.320 --> 00:08:58.880
But then it'll make sure that it only
builds and uses the latest stage.

153
00:08:58.880 --> 00:09:01.136
Now if I do make build image,

154
00:09:01.136 --> 00:09:06.118
you see that they run in sequence and
then if I do format, yeah,

155
00:09:06.118 --> 00:09:11.610
you'll still see that it was separated,
but you'll also see.

156
00:09:11.610 --> 00:09:12.370
Yeah, there you go.

157
00:09:12.370 --> 00:09:17.210
You'll see that my build image
is actually 1.59 gigs, right?

158
00:09:17.210 --> 00:09:21.665
So that's how much cache I could have
potentially pushed up if I hadn't made

159
00:09:21.665 --> 00:09:25.850
sure that those two images were
explicitly separate, right?

160
00:09:25.850 --> 00:09:30.016
Another thing that's really nice about
this though is that if you want to have

161
00:09:30.016 --> 00:09:34.374
build cache, then you just build it as
a separate image, push it up to the cloud,

162
00:09:34.374 --> 00:09:38.120
and now others can use that build
cache if you want to as well, right?

163
00:09:38.120 --> 00:09:42.208
So having these as two separate images in
general just works nice because it means

164
00:09:42.208 --> 00:09:45.153
that there's flexibility with
like where this exists and

165
00:09:45.153 --> 00:09:48.800
where this exists, but
they are completely separate.

166
00:09:48.800 --> 00:09:51.000
And so, yeah,
now we've created two images.

167
00:09:51.000 --> 00:09:54.959
We've created our build image,
which is again 1.59 gigs, and

168
00:09:54.959 --> 00:09:57.807
then our final image,
which is 90 megabytes,

169
00:09:57.807 --> 00:10:03.290
which is obviously a lot smaller than
the 381 megabytes that we had before.

170
00:10:03.290 --> 00:10:05.050
&gt;&gt; Speaker 2: What all is getting cached?

171
00:10:06.410 --> 00:10:09.102
&gt;&gt; Erik Reinert: When we say
cache in the Docker sense,

172
00:10:09.102 --> 00:10:12.650
we mean every layer that
took to build that image.

173
00:10:14.170 --> 00:10:18.080
If I go ahead and
I open up the Docker file really quickly,

174
00:10:18.080 --> 00:10:21.256
if I don't make a single
change to the image and

175
00:10:21.256 --> 00:10:25.247
then I push that image up and
then I tell another dev, hey,

176
00:10:25.247 --> 00:10:30.080
if you want to use my build cache,
you just pull down my image, right?

177
00:10:30.080 --> 00:10:32.120
Then they'll get the entire build cache.

178
00:10:32.120 --> 00:10:32.800
They'll get everything.

179
00:10:33.840 --> 00:10:38.308
But if they say, for example,
they made a change in migrations or

180
00:10:38.308 --> 00:10:43.200
static or templates, then they would
get all of the stuff before that.

181
00:10:44.560 --> 00:10:45.520
Does that make sense?

182
00:10:46.800 --> 00:10:54.480
So, if they made a change in here and
they didn't, they changed like.

183
00:10:54.480 --> 00:10:59.469
Well, basically they didn't change
anything, but anything outside of the Go

184
00:10:59.469 --> 00:11:04.457
files, then this would never get built and
they would have this 1.5 gigabyte

185
00:11:04.457 --> 00:11:08.040
image always available and
ready to them if they needed.

186
00:11:10.360 --> 00:11:12.360
This also makes pipelines go faster.

187
00:11:13.400 --> 00:11:16.326
So if you build a build image and
then you want to make it so

188
00:11:16.326 --> 00:11:18.818
that you don't have to rebuild that image,
but

189
00:11:18.818 --> 00:11:21.960
you want to use it in CI because
it has all of your tools in it.

190
00:11:21.960 --> 00:11:23.000
Think about it like that.

191
00:11:23.000 --> 00:11:26.900
If you're running CI and you need to
install all the tools we just did, you'd

192
00:11:26.900 --> 00:11:31.850
probably create steps to install this,
install this, install that, install that.

193
00:11:31.850 --> 00:11:33.370
Where I work, we don't do that.

194
00:11:33.370 --> 00:11:37.530
Where I work, we use the build
image to run all of the stuff.

195
00:11:37.530 --> 00:11:40.144
So we build the image,
we push it up to the registry, and

196
00:11:40.144 --> 00:11:42.760
then when we run a CI job,
we just pull that image down and

197
00:11:42.760 --> 00:11:46.970
we run everything through the image so
that our tooling is portable.

198
00:11:46.970 --> 00:11:51.390
So that's another valuable way of pushing
it up, caching it, pulling it down,

199
00:11:51.390 --> 00:11:55.560
running all the things, you need to push
it back up, sort of force and so on.

