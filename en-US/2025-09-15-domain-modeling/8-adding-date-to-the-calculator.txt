[00:00:00]
>> Mike North: Let's finally get to the calculating the date. So we've already got something here that's using this location repository, which there's one declared in an outer scope here or sorry, in the class. But we're finding one record where the ID is of this format. So we're gomms make sure that that looks right.

[00:00:31]
We're going to just. Console log. What is this request thing coming in? We'll take a look at it, we'll make sure the ID looks right, we'll log the location and then we're just going to. Quickly we're going to fetch the list of temperature ranges. And to keep things simple, let's just find the first month that appears to satisfy the range.

[00:00:49]
And we're just going to return the first of the month as the date. You could interpolate. But that's not the point of what we're trying to focus on here. So first let's say. Sorry, let me make sure we're focusing on the right thing here. I actually don't think that this is going to be needed.

[00:01:13]
Let's focus on the calculatedate function. It's the same thing here, but this is where we really need to focus. So I wanna log the locationId and the temperature. And I can delete this underscore. Cause now it's a used variable. And you can see we have a little mini schema here.

[00:01:36]
Cause we hadn't created that temperature type for the starting point code. But let's see what actually comes through when we hit that calculate button. Date button. So we're going to go back to our ui. Sorry, hit save, go back to our UI and let's select a location. Minneapolis.

[00:01:56]
And I wanna know when we're over 122 degrees in Minneapolis. No, let's go with 50 degrees Fahrenheit, estimate date. And I expect this to fail because we haven't built this out yet. But let's take a look at what the request looks like going out. So we've got a locationId.

[00:02:19]
It already has this LOC prefix. So we're going to keep that in mind. Then we've got a value. This is just our temperature type coming through Again, going back to our code here. What we can do is say, well, we don't need this anymore actually, sorry, we can cast it to this type of.

[00:02:42]
Because all we're doing here is we're telling TypeScript that this prefix exists. This is a template literal type, where it's like any string that begins with locust. See if we get the Location out. So we're gonna hit estimate date again. I keep going the wrong way. What are we seeing?

[00:03:14]
Location with id. This not found. All right, so the first thing we want to do. Remember I said the database is recreated each time we hit save. We want to load the app again. I'm going to put these next to each other so I don't have to swipe across too many things.

[00:03:33]
We're going to load this app again because these location IDs keep changing. Minneapolis, 50 degrees Fahrenheit. Estimate date. What do we get back? We get back December 31st. So this is just l the hard-coded date that we get back. So what this tells me is we're going to go back to our code here and we should see we've loaded a location.

[00:04:03]
Here's the instance of the class. Interesting, monthly temps undefined. So there are two ways we could handle this. One would be, well, we can go and grab the location id. We can query that table, get all the monthly temps that match the location. But there's a shortcut. If we just do this, and I'm gonna have to reload.

[00:04:41]
We don't need this anymore. Estimate date and let's go back to our code. We should see that that is now populated. And it is. Sorry, that's other logging that's happening there. Let me get rid of some of the other logging so it's super clear. It's in our loading.

[00:05:18]
So we don't need that anymore. I think this is it. Look at that. An array of monthly temperature ranges with commas in between them. And if we scroll up high enough, there we go, we have a location and there are monthly temps. So we've basically just traversed this relationship and it's turned into two queries.

[00:05:39]
One to get the location, one as a batch, get to fetch all of the monthly temps that we're interested in. Now all we have to do is iterate over those temps. Cool. What's the temp that the user passed in? Where are we getting that temperature? Perfect. If MT min value is greater than temperature value return new date.

[00:06:42]
We could just do that. So this should give us maybe something other than December 31st. Let's check it out. So reloading Minnesota. Minneapolis, Fahrenheit 50. Interesting. We still get 1231. What we're missing here is our unit conversion. I think we already have in temperature. Well, let's save time.

[00:07:15]
You could do some unit conversion here, but for now I'm just going to make the equivalent request in celsius, which is 10 degrees. And look at that, we've got six, one. So we've modeled monthly temperature range, we've modeled this value object of a temperature and we've wired it up so that it's all working in the temperature date calculator.

[00:07:43]
Next we're going to turn our attention towards seed packets and really focus in on value objects and have a discussion about what is most meaningful in order to deal with this user interface where we can have the back of a seed packet and structure some data for what's useful for your gardener in order to keep this well organized.

