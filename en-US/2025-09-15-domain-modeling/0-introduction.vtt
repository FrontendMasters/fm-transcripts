WEBVTT

1
00:00:00.320 --> 00:00:02.760
&gt;&gt; Mike North: Welcome to
Domain Modeling for Humans and AI.

2
00:00:02.760 --> 00:00:06.608
My name is Mike north and I'm a principal
staff engineer and product architect at

3
00:00:06.608 --> 00:00:10.880
Stripe and I've been a front end
master's instructor for over 10 years.

4
00:00:10.880 --> 00:00:15.564
Today I'm going to be talking to
you about taking a complex problem,

5
00:00:15.564 --> 00:00:20.250
studying it, working closely with
domain experts and AI agents that

6
00:00:20.250 --> 00:00:26.140
you're using to sort of structure your
code and define your architecture.

7
00:00:26.140 --> 00:00:29.267
And how do we take those
complex business problems and

8
00:00:29.267 --> 00:00:33.995
translate them into manageable units of
code that are self contained, where you

9
00:00:33.995 --> 00:00:39.020
can evolve over time quickly and easily as
the requirements of your software change.

10
00:00:40.700 --> 00:00:44.220
So what am I focusing in on here?

11
00:00:44.220 --> 00:00:47.180
What is domain modeling and
why am I here to talk to you about this?

12
00:00:47.180 --> 00:00:51.582
A big part of what I do at Stripe is I
work closely with teams to make sure that

13
00:00:51.582 --> 00:00:55.985
the foundational building blocks we
are creating layer up in a way where we

14
00:00:55.985 --> 00:00:59.180
can offer low level and
high level things and we don't

15
00:00:59.180 --> 00:01:04.270
end up having to change our APIs all the
time and change our products all the time.

16
00:01:04.270 --> 00:01:09.255
So at the lowest level you can think we
have the concept of money moving between

17
00:01:09.255 --> 00:01:14.510
two places because Stripe is at its
core a payments processing company.

18
00:01:14.510 --> 00:01:18.919
On top of that we have this concept of
a payment with a payment method and

19
00:01:18.919 --> 00:01:23.626
you can layer up and up and eventually
you get to these drop in checkout forms

20
00:01:23.626 --> 00:01:26.190
that are sort of turnkey and ready to go.

21
00:01:26.190 --> 00:01:29.110
And they have concepts like
shipping options and all of that.

22
00:01:29.110 --> 00:01:32.990
And so being able to really think
about all of those building blocks and

23
00:01:32.990 --> 00:01:35.509
how they layer up is a valuable skill.

24
00:01:35.509 --> 00:01:39.110
And Stripe really focuses in on this.

25
00:01:39.110 --> 00:01:43.274
Part of this is involving is studying
your problem space to discover the key

26
00:01:43.274 --> 00:01:46.315
entities, their relationships
with each other, and

27
00:01:46.315 --> 00:01:51.590
any constraints that are at the essence of
the problem that you're trying to solve.

28
00:01:51.590 --> 00:01:55.212
Then of course the process of
taking that mental model and

29
00:01:55.212 --> 00:01:58.390
translating that into
a software architecture.

30
00:02:01.910 --> 00:02:05.750
In this course we're going to be talking
a little bit about domain driven design.

31
00:02:05.750 --> 00:02:08.550
Now this is a 20 year old concept.

32
00:02:08.550 --> 00:02:10.510
There are many good books about this.

33
00:02:10.510 --> 00:02:13.900
Eric Evans has a great book on this topic.

34
00:02:13.900 --> 00:02:17.180
We're going to borrow some ideas from
this that are particularly useful.

35
00:02:17.180 --> 00:02:19.920
Like any software architecture concept,

36
00:02:19.920 --> 00:02:23.740
you don't want to be adhering
to these ideas too rigidly.

37
00:02:23.740 --> 00:02:26.091
You should think about them
as tools in the toolbox and

38
00:02:26.091 --> 00:02:28.140
you pull them out when
they're useful to you.

39
00:02:28.140 --> 00:02:32.780
But there are a couple gems that are at
the core of domain driven design

40
00:02:32.780 --> 00:02:37.020
that I think every software
engineer should be applying.

41
00:02:37.020 --> 00:02:41.378
Particularly in a world where
we are increasingly using

42
00:02:41.378 --> 00:02:45.282
agentic coding tools to
Help us author software.

43
00:02:45.282 --> 00:02:48.107
You're collaborating with product
owners and customers, and

44
00:02:48.107 --> 00:02:50.400
you're collaborating with an AI as well.

45
00:02:50.400 --> 00:02:53.806
If you bake the same language and
the same concepts into

46
00:02:53.806 --> 00:02:57.732
your code as the way the business
is referring to these things,

47
00:02:57.732 --> 00:03:03.142
you have a better shot at working together
collaboratively to develop this solution,

48
00:03:03.142 --> 00:03:07.510
even though you're the person
that's writing the code.

49
00:03:07.510 --> 00:03:12.814
Another point here, why domain
modeling is important, at least for

50
00:03:12.814 --> 00:03:17.750
me, this represents a part of
the engineering career ladder.

51
00:03:17.750 --> 00:03:22.486
So you can think of becoming
a staff engineer as learning

52
00:03:22.486 --> 00:03:26.790
how to deal with technical
ambiguity very well.

53
00:03:26.790 --> 00:03:30.950
That's often part of what it
means to be a staff engineer.

54
00:03:30.950 --> 00:03:34.781
Someone takes a well defined problem and
gives it to you, and

55
00:03:34.781 --> 00:03:40.041
your job is to sort of figure out like,
all right, what frameworks are available,

56
00:03:40.041 --> 00:03:43.520
what libraries,
what off the shelf tooling can I use?

57
00:03:44.880 --> 00:03:48.800
It's sort of up to you to define
how that solution takes shape.

58
00:03:48.800 --> 00:03:53.225
Domain modeling is a great tool for
handling business ambiguity, and

59
00:03:53.225 --> 00:03:57.440
that is ambiguity in the problem space,
not the solution space.

60
00:03:57.440 --> 00:04:02.337
So if someone just gives
you a vague problem like,

61
00:04:02.337 --> 00:04:07.235
I've got a video course
website to teach front end

62
00:04:07.235 --> 00:04:11.300
engineers, how should I set this up?

63
00:04:11.300 --> 00:04:12.500
What do people need?

64
00:04:12.500 --> 00:04:17.100
What are the important entities that
are at the essence of solving that problem

65
00:04:17.100 --> 00:04:18.500
in any meaningful way?

66
00:04:19.700 --> 00:04:25.772
This is a really important part of growing
your career at that more senior level,

67
00:04:25.772 --> 00:04:29.346
as sort of the lines
between product manager and

68
00:04:29.346 --> 00:04:32.919
engineer start to blur
together a little bit and

69
00:04:32.919 --> 00:04:38.590
you start to think about like this
architect track of your career.

70
00:04:38.590 --> 00:04:43.150
So why do I feel like domain modeling is
a useful concept to teach in TypeScript?

71
00:04:43.150 --> 00:04:46.590
Well, TypeScript types
are incredibly expressive.

72
00:04:46.590 --> 00:04:48.750
They're not the most
expressive in the world.

73
00:04:48.750 --> 00:04:53.158
Like if you look at Rust,
they have this concept of lifetimes, and

74
00:04:53.158 --> 00:04:57.804
right in the types, you can see some
representation of Are you allowed

75
00:04:57.804 --> 00:05:01.690
to mutate this object that's
passed to you or not?

76
00:05:01.690 --> 00:05:03.498
TypeScript can't do that
because underneath it

77
00:05:03.498 --> 00:05:06.410
is the JavaScript programming language and
we don't have those concepts.

78
00:05:06.410 --> 00:05:11.466
But TypeScript strikes this really
nice balance between being incredibly

79
00:05:11.466 --> 00:05:16.450
expressive and relatively simple to read,
as well as being widely used.

80
00:05:16.450 --> 00:05:20.254
Which means it doesn't matter if
your company is using protobufs or

81
00:05:20.254 --> 00:05:23.524
JSON schemas, or
whatever representation you choose for

82
00:05:23.524 --> 00:05:28.600
representing contracts between system
components of whatever you're building.

83
00:05:28.600 --> 00:05:31.540
Usually you can start with
TypeScript interfaces and types, and

84
00:05:31.540 --> 00:05:33.960
you can generate whatever
you need based on that.

85
00:05:33.960 --> 00:05:38.913
So increasingly this is being used
as sort of a source of truth for

86
00:05:38.913 --> 00:05:44.161
shapes of objects, contracts
between things, even public APIs.

87
00:05:44.161 --> 00:05:48.698
There are some nice frameworks like,
I think it's type API, that

88
00:05:48.698 --> 00:05:53.643
really let you use a set of TypeScript
interfaces as the source of truth,

89
00:05:53.643 --> 00:05:57.230
and then you can generate
SDKs based on those types.

90
00:05:58.990 --> 00:06:00.797
So to study domain modeling,

91
00:06:00.797 --> 00:06:04.350
we're going to need a complex
problem space to dive into.

92
00:06:05.550 --> 00:06:10.166
Selfishly, I'm going to have you all work
with me to solve a real problem that

93
00:06:10.166 --> 00:06:11.310
I have.

94
00:06:11.310 --> 00:06:15.560
I have a fairly substantial
vegetable garden, and here it is.

95
00:06:15.560 --> 00:06:19.800
I took a picture a couple days ago before
I flew out to Minneapolis to film this.

96
00:06:20.920 --> 00:06:24.400
And you can see I've got a lot
of these metal things here.

97
00:06:24.400 --> 00:06:25.840
These are called raised beds.

98
00:06:25.840 --> 00:06:28.680
So they're just like, metal sort of bins.

99
00:06:28.680 --> 00:06:29.880
They don't have a bottom.

100
00:06:29.880 --> 00:06:32.637
And you fill them with soil, and
you put some rocks in the bottom so

101
00:06:32.637 --> 00:06:33.400
they drain well.

102
00:06:33.400 --> 00:06:37.560
But, like, ultimately,
you're planting things in them.

103
00:06:37.560 --> 00:06:42.378
So you can see here, like, I've arranged
them, you can see a couple little,

104
00:06:42.378 --> 00:06:45.444
like, these are tomato
plants that are growing,

105
00:06:45.444 --> 00:06:49.330
and I've got close to
40 of these things now.

106
00:06:49.330 --> 00:06:50.450
It's a lot to manage.

107
00:06:51.650 --> 00:06:57.010
The story starts with figuring out
what kind of seeds you wanna order.

108
00:06:57.010 --> 00:07:01.060
And once you start ordering seeds
from some of these companies,

109
00:07:01.060 --> 00:07:05.490
they will send you these catalogs
where it's just like this one here.

110
00:07:05.490 --> 00:07:09.580
The whole seed catalog is probably,
you know, 2 inches thick.

111
00:07:09.580 --> 00:07:11.807
And you can flip through this and
see, like,

112
00:07:11.807 --> 00:07:14.380
every variety of tomato
you could ever imagine.

113
00:07:14.380 --> 00:07:18.460
And you order seeds, and then you
end up with a collection like this.

114
00:07:18.460 --> 00:07:20.034
And it's a lot like,

115
00:07:20.034 --> 00:07:26.540
this is a collection that I've amassed
over maybe three, four, five years.

116
00:07:26.540 --> 00:07:31.500
Some of these are old, which means
they're less likely to be effective.

117
00:07:31.500 --> 00:07:34.293
Right.
It's not food that expires necessarily

118
00:07:34.293 --> 00:07:35.460
where it goes bad.

119
00:07:35.460 --> 00:07:38.760
But the older the seeds are,
the less likely they are to work.

120
00:07:38.760 --> 00:07:41.680
And so figuring that out is challenging.

121
00:07:41.680 --> 00:07:43.600
These seeds all need to be.

122
00:07:43.600 --> 00:07:48.040
They turn into plants which want to go
into the ground at different times, right?

123
00:07:48.040 --> 00:07:52.034
Some of these, they're fine to
plant in the dead of winter.

124
00:07:52.034 --> 00:07:52.960
It's totally fine.

125
00:07:52.960 --> 00:07:54.640
Like broccoli, you can do that.

126
00:07:54.640 --> 00:07:58.543
But sweet basil with really soft leaves,

127
00:07:58.543 --> 00:08:06.040
that if it gets anywhere near a frost,
it's gonna absolutely get wiped out.

128
00:08:06.040 --> 00:08:10.920
And so just figuring out, like, when you
plant things, what's still good to use?

129
00:08:10.920 --> 00:08:13.400
How far apart do you plant these things?

130
00:08:13.400 --> 00:08:15.400
There is a lot of complexity here.

131
00:08:16.760 --> 00:08:20.630
After I start with the seeds, like,
during the winter, I have these

132
00:08:20.630 --> 00:08:25.000
little hydroponic bins where I drop
seeds into each of these Little baskets.

133
00:08:25.000 --> 00:08:29.433
There's a little growing sponge in there,
and you put a seed in, and

134
00:08:29.433 --> 00:08:31.350
it'll grow purely in water.

135
00:08:31.350 --> 00:08:35.285
So there's water in this black bin and
you put some nutrients in there and

136
00:08:35.285 --> 00:08:36.150
it'll grow.

137
00:08:36.150 --> 00:08:38.830
So now we have, like,
an additional level of complexity here.

138
00:08:38.830 --> 00:08:43.285
Like, these have to sort of get
started indoors at the right time so

139
00:08:43.285 --> 00:08:48.630
that they go outside whenever it's right
for the plant, whatever that means.

140
00:08:48.630 --> 00:08:51.596
We're gonna have to figure that out and
model that somehow,

141
00:08:51.596 --> 00:08:53.350
and then they get planted outside.

142
00:08:54.720 --> 00:08:58.256
And you can see here,
when I do plant these,

143
00:08:58.256 --> 00:09:02.280
I separate plants by some
certain distance here.

144
00:09:02.280 --> 00:09:03.760
So this is a zucchini plant.

145
00:09:03.760 --> 00:09:06.731
It's going to get very big,
and these are little peppers,

146
00:09:06.731 --> 00:09:08.640
and they'll stay relatively small.

147
00:09:08.640 --> 00:09:11.200
And so, like,
how far apart do we put these things?

148
00:09:11.200 --> 00:09:15.496
There are a lot of properties of these
plants that we need to model if we're

149
00:09:15.496 --> 00:09:18.893
going to solve the problem of
organizing my raised beds and

150
00:09:18.893 --> 00:09:20.920
my seed collection effectively.

151
00:09:23.400 --> 00:09:26.640
So we're gonna work on a piece of
software today to make this a lot easier.

152
00:09:26.640 --> 00:09:31.360
And we're gonna apply domain modeling in
order to keep the complexity contained.

153
00:09:31.360 --> 00:09:35.201
We're gonna have some business rules,
like what should be planted next to other

154
00:09:35.201 --> 00:09:37.640
things, or
how far apart should things be spaced.

155
00:09:37.640 --> 00:09:42.358
And we're gonna see how it's easy
to contain this business logic and

156
00:09:42.358 --> 00:09:46.520
make it modular so
that hopefully you can see that over time.

157
00:09:46.520 --> 00:09:51.240
If we were to add 20 rules to this, like,
how much water does the plant need?

158
00:09:51.240 --> 00:09:52.680
How much sunlight does it need?

159
00:09:52.680 --> 00:09:54.680
What kind of fertilizer
should it be using?

160
00:09:54.680 --> 00:10:00.290
Like, all of that could be modeled and
added onto this in a way where the overall

161
00:10:00.290 --> 00:10:06.158
complexity of the software is not going
to skyrocket as the user's needs evolve.

162
00:10:06.158 --> 00:10:10.680
So there are kind of two main
pages we're gonna focus on here.

163
00:10:10.680 --> 00:10:12.680
One is the seed collection.

164
00:10:12.680 --> 00:10:17.001
So this is going to be solving kind of
this problem here where we're incredibly

165
00:10:17.001 --> 00:10:17.920
disorganized.

166
00:10:17.920 --> 00:10:21.560
Like, how do we model one
of these seed packets?

167
00:10:21.560 --> 00:10:23.240
What information goes on the back?

168
00:10:24.280 --> 00:10:27.224
I'm going to play sort of your user here,
and

169
00:10:27.224 --> 00:10:31.484
you're going to learn how to sort
of tease information out of me so

170
00:10:31.484 --> 00:10:37.560
that you can identify, like, what are the
most useful aspects of this to flesh out?

171
00:10:37.560 --> 00:10:39.584
Right.
You could go in so many directions, but,

172
00:10:39.584 --> 00:10:41.971
like, part of what we're
trying to learn here is, like,

173
00:10:41.971 --> 00:10:44.280
how do you get to the essence
of what's most important?

174
00:10:45.780 --> 00:10:49.513
Then the more involved
part of this workshop,

175
00:10:49.513 --> 00:10:55.460
after we solve the seed collection in
a basic way, we have waiting for us.

176
00:10:55.460 --> 00:10:58.662
A drag and drop user interface
where you can grab these tiles,

177
00:10:58.662 --> 00:11:00.460
each of which represents a plant.

178
00:11:00.460 --> 00:11:03.820
And you can see carrots has
this little down arrow.

179
00:11:03.820 --> 00:11:05.700
There are many types of carrots here.

180
00:11:05.700 --> 00:11:07.540
You can drag them into the raised bed.

181
00:11:07.540 --> 00:11:13.256
And we're going to think about validation,
logic, and how do we model the idea

182
00:11:13.256 --> 00:11:19.370
of putting a plant in a bed, moving it
within a bed, moving it across beds.

183
00:11:19.370 --> 00:11:23.690
We'll talk a little bit later
about transactionality.

184
00:11:23.690 --> 00:11:26.693
Which of these operations
should be atomic,

185
00:11:26.693 --> 00:11:30.730
meaning either all succeeds or
all fails versus which ones?

186
00:11:30.730 --> 00:11:33.999
Is it okay that things
are temporarily out of sync and

187
00:11:33.999 --> 00:11:37.210
will eventually converge
on a consistent result?

