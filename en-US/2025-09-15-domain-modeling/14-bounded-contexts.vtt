WEBVTT

1
00:00:00.160 --> 00:00:04.412
&gt;&gt; Mike North: The next topic we're going
to talk about is what domain driven design

2
00:00:04.412 --> 00:00:06.800
describes as bounded contexts.

3
00:00:06.800 --> 00:00:14.012
You could think about a bounded context
as kind of an area of a problem space or

4
00:00:14.012 --> 00:00:18.295
a domain model where
a ubiquitous language,

5
00:00:18.295 --> 00:00:22.013
a common shared language applies, and

6
00:00:22.013 --> 00:00:27.560
there is internal consistency
within a bounded context.

7
00:00:27.560 --> 00:00:33.562
So, for example, if you had a very
generic model name like item,

8
00:00:33.562 --> 00:00:39.675
where maybe we consider there's
an item planted in a raised bed and

9
00:00:39.675 --> 00:00:46.790
it happens to be a plant, or maybe item
means other things in other contexts.

10
00:00:48.150 --> 00:00:52.765
The purpose of this bounded context is
really to create a bubble where you

11
00:00:52.765 --> 00:00:57.306
don't have to add all these namespace
qualifiers where you're like,

12
00:00:57.306 --> 00:01:00.660
this is a grid placeable item with ID and
metadata.

13
00:01:00.660 --> 00:01:04.020
That's what we're going to call
our class for a particular entity.

14
00:01:05.140 --> 00:01:10.287
Part of the value of this is it's almost
like identifying a related family

15
00:01:10.287 --> 00:01:15.269
of entities and their relationships and
their constraints that you can

16
00:01:15.269 --> 00:01:20.750
kind of draw a circle around and
say, this is a neatly bundled thing.

17
00:01:20.750 --> 00:01:25.964
And like TypeScript Monorepo's course,
we might consider making this

18
00:01:25.964 --> 00:01:32.031
a separate package because there's some
self contained complexity there and we can

19
00:01:32.031 --> 00:01:38.590
use simple terminology while always noting
we're operating within that context.

20
00:01:38.590 --> 00:01:43.492
Well, it turns out that there's
another context in this app beyond

21
00:01:43.492 --> 00:01:46.200
sort of seeds and plants.

22
00:01:46.200 --> 00:01:50.054
There's the context that has to do with
this user interface, which we're about to

23
00:01:50.054 --> 00:01:53.082
start working on for being able to
drag plants into raised beds and

24
00:01:53.082 --> 00:01:55.800
arrange them and
get some feedback based on our planting.

25
00:01:57.080 --> 00:02:02.200
Our UI has a model that looks like this.

26
00:02:02.200 --> 00:02:06.390
We have workspaces, zones,
item placements, and

27
00:02:06.390 --> 00:02:09.960
those item placements relate to items.

28
00:02:09.960 --> 00:02:13.730
So you could think of this as sort of.

29
00:02:13.730 --> 00:02:15.410
It's a very generic ui.

30
00:02:15.410 --> 00:02:19.095
Like you could use this same drag and
drop UI to build a chess game or

31
00:02:19.095 --> 00:02:20.850
something like that.

32
00:02:20.850 --> 00:02:26.939
In essence, it's a grid with
draggable tiles that are placed at

33
00:02:26.939 --> 00:02:32.930
XY coordinates on a grid and
maybe they relate to a chess piece.

34
00:02:32.930 --> 00:02:37.105
So we might have a model of like bishop or
knight or pawn, and

35
00:02:37.105 --> 00:02:42.620
that would be part of the visual
representation of that thing on the grid.

36
00:02:42.620 --> 00:02:46.900
And maybe there are multiple grids and
you can move things across chessboards.

37
00:02:46.900 --> 00:02:50.432
For some reason,
the analogy's breaking down, but

38
00:02:50.432 --> 00:02:53.820
the UI has no idea about
this gardening concept.

39
00:02:53.820 --> 00:02:57.420
And so what we would say is,
well, that's a bounded context.

40
00:02:57.420 --> 00:03:01.260
Item in this case is
just like in this world.

41
00:03:02.950 --> 00:03:08.410
Well, we've since interfered with our
plant construction here, but in the world

42
00:03:08.410 --> 00:03:13.636
of the gardening app here, it's just sort
of like these things that you can drag

43
00:03:13.636 --> 00:03:19.910
onto the grid like it's the pepper plant
or it's the cherry tree or whatever it is.

44
00:03:19.910 --> 00:03:24.560
And so
we're about to create a gardening related,

45
00:03:24.560 --> 00:03:29.426
bounded context of our own
that will involve sort of,

46
00:03:29.426 --> 00:03:34.183
at its root,
we may have this concept of garden, but

47
00:03:34.183 --> 00:03:40.590
there are different beds in that
garden and plants within those beds.

48
00:03:40.590 --> 00:03:42.430
And so
we're going to have to model all of that.

49
00:03:42.430 --> 00:03:45.614
But we can say the terminology
we're going to use

50
00:03:45.614 --> 00:03:49.270
when speaking garden belongs
in that bounded context.

51
00:03:49.270 --> 00:03:52.510
And when we're speaking about grids and
workspaces and zones,

52
00:03:52.510 --> 00:03:54.310
that belongs in the other context.

53
00:03:56.780 --> 00:03:59.940
All right, but
how do we bridge those worlds?

54
00:03:59.940 --> 00:04:03.180
Well, we need what's called
an anti corruption layer.

55
00:04:03.180 --> 00:04:06.620
This is like DDD terminology,
but you have built these before.

56
00:04:06.620 --> 00:04:12.620
It effectively is a way to keep
clean modeling in two areas.

57
00:04:12.620 --> 00:04:14.832
Or sometimes you have clean modeling and

58
00:04:14.832 --> 00:04:18.140
very dirty modeling in a legacy
code base or something.

59
00:04:18.140 --> 00:04:23.091
The anti corruption layer is
a very closely scoped layer

60
00:04:23.091 --> 00:04:28.358
that you use to kind of convert
between the important domain

61
00:04:28.358 --> 00:04:33.730
models that are at the essence
of the app you're building and

62
00:04:33.730 --> 00:04:36.910
whatever else they need to talk to.

63
00:04:36.910 --> 00:04:40.203
Right.
This is what's going to avoid kind of

64
00:04:40.203 --> 00:04:43.885
contaminating our garden and
our raised bed and

65
00:04:43.885 --> 00:04:48.870
our plant and our seed packet with
the drag and drop UI concepts.

66
00:04:49.910 --> 00:04:52.870
And we have this already right today.

67
00:04:52.870 --> 00:04:57.420
It kind of exists in the route handlers
where we're adapting between what our

68
00:04:57.420 --> 00:05:00.290
domain services spit out,
like a seed packet and

69
00:05:00.290 --> 00:05:04.510
the HTTP response that needs to be
passed back up to our user interface.

70
00:05:04.510 --> 00:05:07.470
So you might argue that's kind
of an anti corruption layer.

71
00:05:07.470 --> 00:05:11.223
It would be even cleaner if we
were to say, you know what,

72
00:05:11.223 --> 00:05:16.231
we're actually going to turn some of
that transformation, we're going to

73
00:05:16.231 --> 00:05:21.709
refactor it into functions, and we might
create a new package that purely serves as

74
00:05:21.709 --> 00:05:26.750
this layer to adapt between our domain
services and what the UI wants to get.

75
00:05:26.750 --> 00:05:30.476
And then the request handling is
just sort of leveraging that and

76
00:05:30.476 --> 00:05:33.030
we can further separate concerns that way.

