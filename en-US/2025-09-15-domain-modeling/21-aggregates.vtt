WEBVTT

1
00:00:00.320 --> 00:00:04.281
&gt;&gt; Mike North: The last topic I wanna
cover today is dealing with this concept

2
00:00:04.281 --> 00:00:07.120
of aggregates in domain driven design.

3
00:00:07.120 --> 00:00:11.905
And this has to do with
thinking about consistency,

4
00:00:11.905 --> 00:00:15.120
by that I mean data consistency.

5
00:00:15.120 --> 00:00:18.242
So imagine this scenario,

6
00:00:18.242 --> 00:00:23.680
we're able to move plants
within a raised bed.

7
00:00:23.680 --> 00:00:29.996
And let's say we build a system
that is modeled this way,

8
00:00:29.996 --> 00:00:36.981
where we would say we've got
a task that needs to be performed.

9
00:00:47.290 --> 00:00:52.249
&gt;&gt; Mike North: And we build a nice little
semantic action, right, instead of saying,

10
00:00:52.249 --> 00:00:56.883
I have this big update API call and
I'm gonna set the new array of your

11
00:00:56.883 --> 00:01:00.648
items within your bed and
here are the XY coordinates.

12
00:01:00.648 --> 00:01:06.930
Let's say we had a really nice
thing that kind of looks this,

13
00:01:17.322 --> 00:01:18.405
&gt;&gt; Mike North: Right,

14
00:01:18.405 --> 00:01:23.054
something like this spiritually.

15
00:01:23.054 --> 00:01:26.149
And let's say our app's really popular and

16
00:01:26.149 --> 00:01:30.990
we end up having to get big beefy
databases to handle all of this.

17
00:01:30.990 --> 00:01:34.798
And we decide that what
we can do is we can say,

18
00:01:34.798 --> 00:01:40.011
if we implement something called charting,
which is the idea

19
00:01:40.011 --> 00:01:46.228
of saying we actually have multiple
databases and Seth's raised beds and

20
00:01:46.228 --> 00:01:51.560
my raised beds, they can actually
be on different databases.

21
00:01:51.560 --> 00:01:52.120
It's fine.

22
00:01:52.120 --> 00:01:56.280
We can kind of spread the data out
a little bit, there's no ambiguity.

23
00:01:56.280 --> 00:01:59.518
Like Mike's raised beds
are always on database A,

24
00:01:59.518 --> 00:02:03.080
Seth's are on database B,
and everything's fine.

25
00:02:03.080 --> 00:02:07.273
And maybe in fact we can sort of mix them
up a little bit where like I might have

26
00:02:07.273 --> 00:02:11.800
some beds on database A, some on database
B, but it doesn't affect this because

27
00:02:11.800 --> 00:02:16.760
this, you can think of this as like one,
right, happening in one place.

28
00:02:16.760 --> 00:02:22.760
But what happens when we want to write
across those different concepts?

29
00:02:22.760 --> 00:02:27.603
You could imagine how we would
say we've got bed one and

30
00:02:27.603 --> 00:02:30.346
bed two and we've got a plant.

31
00:02:36.440 --> 00:02:42.081
&gt;&gt; Mike North: When we start getting
into this, it gets really interesting

32
00:02:42.081 --> 00:02:47.490
where we're trying to move
this into another bed.

33
00:02:47.490 --> 00:02:54.680
Now if we were to say, look,
there's an update plant position,

34
00:02:54.680 --> 00:02:59.270
or let's say it's something like this.

35
00:03:00.786 --> 00:03:05.530
&gt;&gt; Mike North: Think about
what might happen if one side

36
00:03:05.530 --> 00:03:10.480
of this fails and the other succeeds.

37
00:03:10.480 --> 00:03:13.840
This inevitably happens once in a while.

38
00:03:13.840 --> 00:03:18.574
We think about our big distributed
systems as having some number of

39
00:03:18.574 --> 00:03:22.720
nines of reliability and
sometimes errors are thrown.

40
00:03:22.720 --> 00:03:27.724
But imagine a world where I'm trying
to move plant from bed 1 to bed 2 and

41
00:03:27.724 --> 00:03:32.909
the remove plant operation fails, but
the add plant operation succeeds.

42
00:03:32.909 --> 00:03:35.857
And so now I've cloned this plant somehow.

43
00:03:35.857 --> 00:03:37.260
Like there are two of it.

44
00:03:38.460 --> 00:03:42.674
Or you could have it disappear
entirely where you remove it and

45
00:03:42.674 --> 00:03:44.300
then add plant fails.

46
00:03:44.300 --> 00:03:45.537
And you could say, well,

47
00:03:45.537 --> 00:03:49.260
let's check the success of the first
call before proceeding with the second.

48
00:03:49.260 --> 00:03:56.620
But sometimes you lose
state if you do that.

49
00:03:56.620 --> 00:04:03.700
Okay, you check to see if imagine remove
plant is successful, add plant fails.

50
00:04:03.700 --> 00:04:06.960
Are you gonna add it back
into the prior raised bed?

51
00:04:06.960 --> 00:04:11.051
What you're trying to do there,
if you go in that direction,

52
00:04:11.051 --> 00:04:16.166
is you're trying to create this illusion
that there is an atomic operation,

53
00:04:16.166 --> 00:04:21.595
that both of these things, the removal
from the old bed, the addition to the new,

54
00:04:21.595 --> 00:04:25.880
is a single operation that either
all succeeds or all fails.

55
00:04:25.880 --> 00:04:32.200
And this is really important when we
think about what is the aggregate here.

56
00:04:32.200 --> 00:04:39.240
And I would say in this case it's this,
&gt;&gt; Mike North: Garden.

57
00:04:39.240 --> 00:04:44.831
Because what you could do is you could
say, no, no, no, it's really garden.

58
00:04:53.640 --> 00:04:54.760
&gt;&gt; Mike North: It's really like this.

59
00:04:55.880 --> 00:05:00.180
And what you could do, if you get
deeper into databases and things,

60
00:05:00.180 --> 00:05:05.159
you can create what's called a database
transaction, it's basically doing

61
00:05:05.159 --> 00:05:09.720
the in one atomic operation that
either all succeeds or all fails.

62
00:05:09.720 --> 00:05:14.920
It's the removal of the plant from bed 1
and the placement of the plant in bed 2.

63
00:05:14.920 --> 00:05:19.249
Inevitably, especially if you work on
something with significant complexity,

64
00:05:19.249 --> 00:05:21.640
you're going to have
to make these choices.

65
00:05:21.640 --> 00:05:28.130
You're gonna have to decide what
are the atomic operations you can perform.

66
00:05:28.130 --> 00:05:32.643
And usually what that means
is we would say this,

67
00:05:32.643 --> 00:05:38.050
actually, I'm gonna change
the model here a little bit.

68
00:05:39.170 --> 00:05:42.770
We'd say this whole thing and
I'm gonna have to move this to back.

69
00:05:43.890 --> 00:05:47.702
This is the aggregate,

70
00:05:47.702 --> 00:05:52.849
that whole larger rectangle and

71
00:05:52.849 --> 00:05:57.614
the garden, we would say is as

72
00:05:57.614 --> 00:06:01.820
a lot of aggregates have.

73
00:06:03.340 --> 00:06:05.500
Can I move this to the front, please?

74
00:06:05.500 --> 00:06:09.509
Yep, perfect and this to the front.

75
00:06:12.712 --> 00:06:13.795
&gt;&gt; Mike North: Well,
we can move it in here.

76
00:06:13.795 --> 00:06:15.180
It's fine.

77
00:06:15.180 --> 00:06:20.550
You'd say, well,
garden is kind of like the root node.

78
00:06:20.550 --> 00:06:24.310
And so often when you pick an aggregate,
you have to say, what is the entity?

79
00:06:24.310 --> 00:06:28.830
That's sort of the main
purpose of this thing.

80
00:06:28.830 --> 00:06:32.683
And yes, there may be like a lot of
other things embedded within it,

81
00:06:32.683 --> 00:06:36.750
but the important thing is like
choosing the transactional boundary.

82
00:06:36.750 --> 00:06:39.990
And in doing that you're making choices.

83
00:06:39.990 --> 00:06:43.782
You're saying, well,
within this brown box here,

84
00:06:43.782 --> 00:06:47.080
that's where we are internally consistent.

85
00:06:48.200 --> 00:06:52.164
You're never gonna be able to
load the page at a weird time and

86
00:06:52.164 --> 00:06:56.920
see a plant has been added to a new
zone but not removed from another zone.

87
00:06:56.920 --> 00:07:00.279
And that would be internally inconsistent.

88
00:07:00.279 --> 00:07:05.784
But it does also mean when you make
choices like this, you're designing for

89
00:07:05.784 --> 00:07:11.032
inconsistency, at least momentarily,
to appear in other places where

90
00:07:11.032 --> 00:07:16.728
it may be okay in a neighborhood where
you're moving a bunch of plants around.

91
00:07:16.728 --> 00:07:22.494
All right, two different gardens may
be one is totally fresh data and

92
00:07:22.494 --> 00:07:25.150
the other is somewhat stale.

93
00:07:25.150 --> 00:07:30.143
But at least the totality of data
within each of those two gardens will

94
00:07:30.143 --> 00:07:34.750
be the same level of freshness,
if that makes sense.

95
00:07:34.750 --> 00:07:39.428
So thinking about this as part of your
domain modeling is really important,

96
00:07:39.428 --> 00:07:44.255
especially working at Stripe, when
you're thinking about transactions and

97
00:07:44.255 --> 00:07:46.978
refunds and
ledgers that have to all add up.

98
00:07:46.978 --> 00:07:51.758
So that at any moment in time when you
load this page, you're not seeing that

99
00:07:51.758 --> 00:07:57.480
the balance in your account is different
than what you're seeing in another page.

100
00:07:57.480 --> 00:08:03.810
So sometimes these can be
really important to your user.

101
00:08:03.810 --> 00:08:08.778
And personally, I find this to be kind of
one of the trickiest areas to have those

102
00:08:08.778 --> 00:08:11.090
relatable discussions with users.

103
00:08:12.290 --> 00:08:18.290
And often you wanna hone in
on this idea of freshness.

104
00:08:18.290 --> 00:08:23.353
Is it okay to view this data if it's
stale, but at least it's all the same

105
00:08:23.353 --> 00:08:27.850
amount of stale and
you're never seeing a partial state there.

106
00:08:27.850 --> 00:08:32.387
And if you talk to an accountant about
that and they're like, you're gonna show

107
00:08:32.387 --> 00:08:36.856
me a ledger where certain items are still
waiting to sort of percolate through,

108
00:08:36.856 --> 00:08:38.740
that's useless.

109
00:08:38.740 --> 00:08:41.300
That's gonna be a real problem there.

110
00:08:41.300 --> 00:08:43.237
So this is the concept of aggregates and

111
00:08:43.237 --> 00:08:45.830
designing transactional
boundaries with intent.

