[00:00:00]
>> Mike North: So we've parsed some basic information about location, but we need to do a very similar thing with these monthly temperature records. And I'm going to, while we're doing that, convert to that 4 await. It's not really a for loop, but it's a for loop with an await inside each turn of the loop.

[00:00:20]
Because now we're not just doing seven things, we're doing seven times 12. And that is surely enough to warrant not racing all of those writes to a database concurrently. So instead of this map here, we're going to do just a standard for loop. And this is, I believe, already an async function.

[00:00:44]
So we're great here. So we can say locations, it's an array of locations initialized to an empty array. Const declaration is fine. We're not reassigning this array to a different array, although we will be filling it. We can just at the bottom return locations because we're going to handle the asynchrony differently within the function.

[00:01:15]
And just to give us a little bit of focus here, and here's how we'll change things.
>> Mike North: An old school for loop and we're going to do the exact same thing in here that we were doing before. There's my locRepo. Let's see, we need a locData.
>> Mike North: There's my locData, and there's no return in each turn of the for loop.

[00:02:04]
But
>> Mike North: If we do this the way we've restructured this. Sorry, let.
>> Speaker 2: Let, yeah.
>> Mike North: We could totally do a for of loop, but I like the logging opportunities of having that index in there. So instead of quickly mapping over everything that we find in the file and then waiting for all those promises in parallel to resolve, we're waiting for each save operation to resolve.

[00:02:35]
Only then when that's resolved do we push it into the array. We should end up with a solution that works equally well here. I mean, we're sort of serializing all of those location persistences, but it's like microseconds. It's fine. What this lets us do is after we create the location, we can start to do other things like create a monthly temperature.

[00:03:14]
And to do that we'll need the other repo monthly temperature range, again being careful to choose the entity, not just the type of empty repo. So just like the same deal here, this is just another instance of that repo class that deals in these monthly temperature ranges. We're going to do a very similar thing like what we did here, mtrepo.create and here are my params and then we'll fill those in and then ultimately we're going to do this.

[00:03:59]

>> Mike North: Right. So this is the monthly temperature and we'll see if we even need to go beyond that, whether we're just sort of awaiting this or whether we'll end up using that variable. At the very least we could log it out for now and then delete that. But it's our time to perform this association.

[00:04:16]
So the first thing is location. So that's great, we've got that relationship wired up. Now what are the other things we need? We need a month, a min and a max. So let's worry about the month. Now we're going to have to do this inside a loop because each location has multiple pieces of temperature data, one for each month.

[00:04:48]

>> Mike North: We'll call it month data.
>> Mike North: We'll do a for await loop here to make Eslin happy. LocData monthly temperatures, here we go. Wrap the whole thing in a loop, boom. Okay, now what should the month be? We could just do this, but we're going to do that.

[00:05:17]
Keep it consistent with the date object and then min. So what do we want from min? We've got a value and we've got a unit and unit can be C or F. It's not type checking against it yet, but it will. There you go. So yeah, we could say it's a deep partial of this.

[00:05:52]
That's what it's type checking against. So you really wanna see that type checking come through. You can use the satisfies keyword and even without this now you should see.
>> Mike North: This is just ESLINT being touchy. We'll just keep going here. This is going to be monthdata.temperaturerange.min and we can see the tuples coming through here.

[00:06:31]
We've got number and a C or an F. So we can pull this apart up here, something like this.
>> Mike North: Min value minunit, max value, max unit and wire it up
>> Mike North: And basically the same thing for max.
>> Mike North: Let's see. What am I doing wrong? Interesting. Did we forget a piece a bit of our type information?

[00:07:26]
We did. There's the min, we need a max too.
>> Speaker 3: While you're on this, is it possible to pull in the type for the temperature range unit and then make a Zod object out of that type?
>> Mike North: You absolutely.
>> Speaker 3: Could in the future.
>> Mike North: In fact, that's why we do this.

[00:07:50]
We could say we could even pull in the whole temperature schema given our data file, sort of. No we couldn't because of the tuple representation temperature unit schema we could use for that. So here's how that would work. It's just for this union type piece.
>> Mike North: There you go.

[00:08:14]
Using little chunks of Zod schema. Absolutely, we're aligning with the same C and F because that's a common piece between our API contract and the way data is stored in this file. Great, now we've got our min and our max. Sure. We save each locations data. So I'm going to hit save again.

[00:08:42]
When you're in dev mode, your server restarts. Every time you hit save, the database is deleted and it's recreated again. So we should be able to see if this is working just by looking at our SQLite database. Let's see if we've got table entries. We do. We've got our months.

[00:09:02]
There's month zero, here's a location ID, and you can see like this key up here indicates you can't see this tooltip very easily, but it says it's a foreign key. So that means if we needed to do a join on this later, like this is an index column.

[00:09:18]
It makes traversing that relationship between monthly temperature data and location really, really fast.

