WEBVTT

1
00:00:00.560 --> 00:00:04.371
&gt;&gt; Mike North: So we've parsed some
basic information about location, but

2
00:00:04.371 --> 00:00:09.000
we need to do a very similar thing with
these monthly temperature records.

3
00:00:09.000 --> 00:00:14.697
And I'm going to, while we're doing that,
convert to that 4 await.

4
00:00:14.697 --> 00:00:17.506
It's not really a for loop, but it's a for

5
00:00:17.506 --> 00:00:20.880
loop with an await inside
each turn of the loop.

6
00:00:20.880 --> 00:00:26.290
Because now we're not just doing seven
things, we're doing seven times 12.

7
00:00:26.290 --> 00:00:30.541
And that is surely enough
to warrant not racing

8
00:00:30.541 --> 00:00:35.490
all of those writes to
a database concurrently.

9
00:00:35.490 --> 00:00:41.330
So instead of this map here, we're
going to do just a standard for loop.

10
00:00:41.330 --> 00:00:44.090
And this is, I believe,
already an async function.

11
00:00:44.090 --> 00:00:45.570
So we're great here.

12
00:00:45.570 --> 00:00:49.783
So we can say locations,

13
00:00:49.783 --> 00:00:54.397
it's an array of locations

14
00:00:54.397 --> 00:00:59.820
initialized to an empty array.

15
00:00:59.820 --> 00:01:01.220
Const declaration is fine.

16
00:01:01.220 --> 00:01:03.545
We're not reassigning this
array to a different array,

17
00:01:03.545 --> 00:01:04.860
although we will be filling it.

18
00:01:06.700 --> 00:01:10.635
We can just at the bottom return
locations because we're going to handle

19
00:01:10.635 --> 00:01:13.420
the asynchrony differently
within the function.

20
00:01:15.420 --> 00:01:21.351
And just to give us a little bit of focus
here, and here's how we'll change things.

21
00:01:38.040 --> 00:01:39.720
&gt;&gt; Mike North: An old school for loop and

22
00:01:39.720 --> 00:01:44.610
we're going to do the exact same thing
in here that we were doing before.

23
00:01:48.130 --> 00:01:50.530
There's my locRepo.

24
00:01:50.530 --> 00:01:53.102
Let's see, we need a locData.

25
00:01:59.417 --> 00:02:04.246
&gt;&gt; Mike North: There's my locData, and
there's no return in each turn of the for

26
00:02:04.246 --> 00:02:04.770
loop.

27
00:02:04.770 --> 00:02:09.865
But
&gt;&gt; Mike North: If we do this the way

28
00:02:09.865 --> 00:02:13.959
we've restructured this.

29
00:02:15.239 --> 00:02:15.826
Sorry, let.

30
00:02:15.826 --> 00:02:16.999
&gt;&gt; Speaker 2: Let, yeah.

31
00:02:16.999 --> 00:02:18.891
&gt;&gt; Mike North: We could totally do a for
of loop, but

32
00:02:18.891 --> 00:02:22.199
I like the logging opportunities
of having that index in there.

33
00:02:24.678 --> 00:02:28.708
So instead of quickly mapping over
everything that we find in the file and

34
00:02:28.708 --> 00:02:33.135
then waiting for all those promises in
parallel to resolve, we're waiting for

35
00:02:33.135 --> 00:02:35.620
each save operation to resolve.

36
00:02:35.620 --> 00:02:38.820
Only then when that's resolved
do we push it into the array.

37
00:02:38.820 --> 00:02:42.980
We should end up with a solution
that works equally well here.

38
00:02:44.180 --> 00:02:49.062
I mean, we're sort of serializing
all of those location

39
00:02:49.062 --> 00:02:53.460
persistences, but it's like microseconds.

40
00:02:53.460 --> 00:02:54.980
It's fine.

41
00:02:54.980 --> 00:03:01.631
What this lets us do is after
we create the location,

42
00:03:01.631 --> 00:03:10.110
we can start to do other things
like create a monthly temperature.

43
00:03:14.590 --> 00:03:21.567
And to do that we'll need the other
repo monthly temperature range,

44
00:03:21.567 --> 00:03:29.160
again being careful to choose the entity,
not just the type of empty repo.

45
00:03:30.600 --> 00:03:35.374
So just like the same deal here,
this is just another instance of that repo

46
00:03:35.374 --> 00:03:39.640
class that deals in these
monthly temperature ranges.

47
00:03:39.640 --> 00:03:45.972
We're going to do a very similar
thing like what we did here,

48
00:03:45.972 --> 00:03:53.297
mtrepo.create and here are my params and
then we'll fill those in and

49
00:03:53.297 --> 00:03:57.658
then ultimately we're going to do this.

50
00:03:59.028 --> 00:03:59.660
&gt;&gt; Mike North: Right.

51
00:03:59.660 --> 00:04:03.635
So this is the monthly temperature and
we'll see if we even need to

52
00:04:03.635 --> 00:04:07.321
go beyond that, whether we're
just sort of awaiting this or

53
00:04:07.321 --> 00:04:10.020
whether we'll end up using that variable.

54
00:04:10.020 --> 00:04:12.540
At the very least we could log it out for
now and then delete that.

55
00:04:13.580 --> 00:04:16.580
But it's our time to
perform this association.

56
00:04:16.580 --> 00:04:18.540
So the first thing is location.

57
00:04:21.110 --> 00:04:24.390
So that's great,
we've got that relationship wired up.

58
00:04:24.390 --> 00:04:26.550
Now what are the other things we need?

59
00:04:26.550 --> 00:04:28.550
We need a month, a min and a max.

60
00:04:29.670 --> 00:04:31.350
So let's worry about the month.

61
00:04:32.790 --> 00:04:37.183
Now we're going to have to do this
inside a loop because each location has

62
00:04:37.183 --> 00:04:40.796
multiple pieces of temperature data,
one for each month.

63
00:04:48.560 --> 00:04:50.416
&gt;&gt; Mike North: We'll call it month data.

64
00:04:54.099 --> 00:04:56.640
&gt;&gt; Mike North: We'll do a for
await loop here to make ESLint happy.

65
00:04:59.520 --> 00:05:03.120
LocData monthly temperatures, here we go.

66
00:05:04.720 --> 00:05:09.280
Wrap the whole thing in a loop, boom.

67
00:05:09.280 --> 00:05:11.200
Okay, now what should the month be?

68
00:05:13.610 --> 00:05:17.930
We could just do this, but
we're going to do that.

69
00:05:17.930 --> 00:05:23.530
Keep it consistent with
the date object and then min.

70
00:05:23.530 --> 00:05:25.770
So what do we want from min?

71
00:05:25.770 --> 00:05:32.798
We've got a value and
we've got a unit and unit can be C or F.

72
00:05:32.798 --> 00:05:39.140
It's not type checking against it yet,
but it will.

73
00:05:42.500 --> 00:05:43.140
There you go.

74
00:05:47.140 --> 00:05:52.340
So yeah,
we could say it's a deep partial of this.

75
00:05:52.340 --> 00:05:53.780
That's what it's type checking against.

76
00:05:55.780 --> 00:05:59.740
So you really wanna see that
type checking come through.

77
00:05:59.740 --> 00:06:03.523
You can use the satisfies keyword and

78
00:06:03.523 --> 00:06:07.434
even without this now you should see.

79
00:06:13.941 --> 00:06:17.910
&gt;&gt; Mike North: This is
just ESLINT being touchy.

80
00:06:19.430 --> 00:06:20.550
We'll just keep going here.

81
00:06:20.550 --> 00:06:26.936
This is going to be
monthdata.temperaturerange.min and

82
00:06:26.936 --> 00:06:31.540
we can see the tuples coming through here.

83
00:06:31.540 --> 00:06:36.174
We've got number and a C or an F.

84
00:06:36.174 --> 00:06:42.714
So we can pull this apart up here,
something like this.

85
00:06:51.140 --> 00:06:56.276
&gt;&gt; Mike North: Min value min unit,
max value,

86
00:06:56.276 --> 00:07:02.223
max unit and wire it up
&gt;&gt; Mike North: And

87
00:07:02.223 --> 00:07:06.235
basically the same thing for max.

88
00:07:20.430 --> 00:07:21.230
&gt;&gt; Mike North: Let's see.

89
00:07:21.230 --> 00:07:22.546
What am I doing wrong?

90
00:07:22.546 --> 00:07:23.190
Interesting.

91
00:07:23.190 --> 00:07:26.270
Did we forget a piece a bit
of our type information?

92
00:07:26.270 --> 00:07:27.470
We did.

93
00:07:27.470 --> 00:07:29.630
There's the min, we need a max too.

94
00:07:31.790 --> 00:07:37.215
&gt;&gt; Speaker 3: While you're on this,
is it possible to pull in the type for

95
00:07:37.215 --> 00:07:43.790
the temperature range unit and
then make a Zod object out of that type?

96
00:07:43.790 --> 00:07:44.544
&gt;&gt; Mike North: You absolutely.

97
00:07:44.544 --> 00:07:45.630
&gt;&gt; Speaker 3: Could in the future.

98
00:07:45.630 --> 00:07:47.310
&gt;&gt; Mike North: In fact,
that's why we do this.

99
00:07:50.480 --> 00:07:54.391
We could say we could even
pull in the whole temperature

100
00:07:54.391 --> 00:07:57.942
schema given our data file, sort of.

101
00:07:57.942 --> 00:08:01.950
No we couldn't because of
the tuple representation

102
00:08:01.950 --> 00:08:05.840
temperature unit schema we could use for
that.

103
00:08:05.840 --> 00:08:07.920
So here's how that would work.

104
00:08:07.920 --> 00:08:09.507
It's just for this union type piece.

105
00:08:13.930 --> 00:08:14.490
&gt;&gt; Mike North: There you go.

106
00:08:14.490 --> 00:08:17.050
Using little chunks of Zod schema.

107
00:08:17.050 --> 00:08:22.328
Absolutely, we're aligning with the same
C and F because that's a common

108
00:08:22.328 --> 00:08:27.530
piece between our API contract and
the way data is stored in this file.

109
00:08:27.530 --> 00:08:29.690
Great, now we've got our min and our max.

110
00:08:31.130 --> 00:08:31.630
Sure.

111
00:08:36.170 --> 00:08:40.259
We save each locations data.

112
00:08:40.259 --> 00:08:42.739
So I'm going to hit save again.

113
00:08:42.739 --> 00:08:46.219
When you're in dev mode,
your server restarts.

114
00:08:46.219 --> 00:08:50.979
Every time you hit save, the database
is deleted and it's recreated again.

115
00:08:50.979 --> 00:08:55.361
So we should be able to see if this is
working just by looking at our SQLite

116
00:08:55.361 --> 00:08:56.099
database.

117
00:08:58.019 --> 00:08:59.659
Let's see if we've got table entries.

118
00:08:59.659 --> 00:09:00.179
We do.

119
00:09:01.619 --> 00:09:02.739
We've got our months.

120
00:09:02.739 --> 00:09:08.151
There's month zero, here's a location ID,
and you can see like this key up here

121
00:09:08.151 --> 00:09:14.060
indicates you can't see this tooltip very
easily, but it says it's a foreign key.

122
00:09:14.060 --> 00:09:18.420
So that means if we needed to do a join on
this later, like this is an index column.

123
00:09:18.420 --> 00:09:22.357
It makes traversing that relationship
between monthly temperature data and

124
00:09:22.357 --> 00:09:24.060
location really, really fast.

