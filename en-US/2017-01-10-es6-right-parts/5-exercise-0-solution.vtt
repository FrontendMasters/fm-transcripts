WEBVTT

1
00:00:00.000 --> 00:00:04.041
[MUSIC]

2
00:00:04.041 --> 00:00:07.179
&gt;&gt; Kyle Simpson: Rather than take
a whole bunch of time to go through and

3
00:00:07.179 --> 00:00:11.993
type all of this stuff, I'm simply gonna
walk you through the fixed version which

4
00:00:11.993 --> 00:00:14.042
is included with your exercises.

5
00:00:14.042 --> 00:00:15.990
Let's talk about a few
things that are going on.

6
00:00:15.990 --> 00:00:16.590
First off.

7
00:00:17.940 --> 00:00:21.169
I've taken that if and made it into
an arrow function on line one,

8
00:00:21.169 --> 00:00:23.469
I'll zoom in so
it's a little easier to read.

9
00:00:23.469 --> 00:00:27.345
And you notice that the if the in the
other one didn't have any variables in it,

10
00:00:27.345 --> 00:00:30.461
but I took advantage of being
able to declare variables without

11
00:00:30.461 --> 00:00:34.147
statements by putting variable names
as unused parameters in that iffy.

12
00:00:34.147 --> 00:00:38.180
And they're unused because
down here at the bottom,

13
00:00:38.180 --> 00:00:42.224
the pair that executes it
doesn't pass anything in.

14
00:00:42.224 --> 00:00:46.120
So those are the unused variable names
that I can then start assigning to.

15
00:00:46.120 --> 00:00:49.692
So for example, I then open up my
arrow function and I open up or

16
00:00:49.692 --> 00:00:54.025
print the c set because, I'm going to
put multiple statements together or

17
00:00:54.025 --> 00:00:57.421
multiple expressions together
using my comma operator.

18
00:00:57.421 --> 00:01:02.074
And because of the operator
precedence of the comma operator,

19
00:01:02.074 --> 00:01:08.235
if I did that without the parentheses set
it would bind less tightly than the arrow.

20
00:01:08.235 --> 00:01:12.700
So I have to wrap the multiple expressions
that I'm gonna string together with commas

21
00:01:12.700 --> 00:01:16.732
in a parentheses set so, the first
expression is I'm gonna say foo equals and

22
00:01:16.732 --> 00:01:19.600
I'm gonna make foo equals
to another arrow function.

23
00:01:19.600 --> 00:01:24.070
The reason for that, is because
in another expression down here.

24
00:01:24.070 --> 00:01:25.110
This one.

25
00:01:25.110 --> 00:01:28.800
Which is again part of that outer
parenthesis set this expression calls foo.

26
00:01:28.800 --> 00:01:30.430
And then I set.

27
00:01:30.430 --> 00:01:33.140
So here, it looks an awful
lot like a function body.

28
00:01:33.140 --> 00:01:35.340
But I'm using commas
instead of semicolons,

29
00:01:35.340 --> 00:01:36.580
because these aren't statements.

30
00:01:36.580 --> 00:01:39.840
These are expressions
inside of a comma list.

31
00:01:39.840 --> 00:01:43.760
Cuz it's so I wanted to get rid of
my curly brace pair and all of that.

32
00:01:43.760 --> 00:01:46.704
So each one of these individual ones,

33
00:01:46.704 --> 00:01:50.942
is an expression rather than
a standalone statement.

34
00:01:50.942 --> 00:01:55.803
So my foo function is an arrow,
I take advantage of being able to declare

35
00:01:55.803 --> 00:02:00.582
my x but also to declare a y, cuz I'm
gonna want that y the one that was in

36
00:02:00.582 --> 00:02:04.327
its own standalone declaration and
then I want that y.

37
00:02:04.327 --> 00:02:08.011
So I'm going to use that y and I also
use a trick that I haven't showed yet,

38
00:02:08.011 --> 00:02:10.448
which is default parameter
values to go ahead and

39
00:02:10.448 --> 00:02:14.210
make the assignment of it instead
of having to do a separate one.

40
00:02:14.210 --> 00:02:15.970
Now here's an interesting trick.

41
00:02:15.970 --> 00:02:19.894
I use a regular function and we'll come
back to why I use a regular function here,

42
00:02:19.894 --> 00:02:20.702
but question for

43
00:02:20.702 --> 00:02:23.955
you is that a function statement or
is that a function expression?

44
00:02:25.687 --> 00:02:27.330
&gt;&gt; Kyle Simpson: Who thinks they know?

45
00:02:31.087 --> 00:02:34.391
&gt;&gt; Kyle Simpson: The fact that I didn't
get an immediate answer is kind of

46
00:02:34.391 --> 00:02:38.610
the point, cuz it looks an awful lot
like an expression statement but,

47
00:02:38.610 --> 00:02:43.250
because it's part of a, because it is
the concise body for an arrow function,

48
00:02:43.250 --> 00:02:45.782
it's actually a function expression or,

49
00:02:45.782 --> 00:02:49.907
it's a name function expression
rather than a function statement.

50
00:02:49.907 --> 00:02:54.578
Anyway, I have a named function expression
which is that is the concise body for

51
00:02:54.578 --> 00:02:56.612
that particular arrow function.

52
00:02:56.612 --> 00:03:01.251
It would've taken a z, but
I also take advantage of baz and

53
00:03:01.251 --> 00:03:05.814
obj on unused parameters for
my variable declarations.

54
00:03:05.814 --> 00:03:08.466
Now because I have a regular
French function curly brace,

55
00:03:08.466 --> 00:03:10.261
I don't need to do any turn areas here.

56
00:03:10.261 --> 00:03:13.257
I can just do my regular if else but
we're gonna,

57
00:03:13.257 --> 00:03:17.145
don't worry we're gonna use turn
areas here in just a moment.

58
00:03:17.145 --> 00:03:19.741
I do need to do a return statement and
I call my z.map,

59
00:03:19.741 --> 00:03:23.070
here's another case where I
can use an arrow function.

60
00:03:23.070 --> 00:03:26.660
So I throw in my arrow function here.

61
00:03:27.690 --> 00:03:32.770
This is the arrow function, but I also
assign that arrow function to a baz.

62
00:03:32.770 --> 00:03:35.822
Because assignment statements or
assignment expressions,

63
00:03:35.822 --> 00:03:38.116
have the value that is
assigned as the return.

64
00:03:38.116 --> 00:03:42.520
So I can assign and
pass in the value all at the same time.

65
00:03:42.520 --> 00:03:44.984
That way, we're not having to
have a separate statement.

66
00:03:44.984 --> 00:03:49.358
And the reason it needed to be named
is because I needed to refer to it

67
00:03:49.358 --> 00:03:55.640
recursively by name, so I needed a name
that the arrow function was assigned to.

68
00:03:55.640 --> 00:03:59.600
Now, down here these
are regular old statements but,

69
00:03:59.600 --> 00:04:01.510
I now I use an arrow function.

70
00:04:02.840 --> 00:04:08.090
And this is my concise body again
with parentheses around it and

71
00:04:08.090 --> 00:04:12.650
a comma operator to separate my two
statements, and there is my this keyword.

72
00:04:12.650 --> 00:04:15.720
Taking advantage of the fact that this
arrow function won't have its own, so

73
00:04:15.720 --> 00:04:19.120
it will come to this outer
function to get this keyword.

74
00:04:20.590 --> 00:04:23.040
Finally I have to make
sure to do my return obj.

75
00:04:24.470 --> 00:04:26.017
The rest of these should
be pretty straightforward.

76
00:04:26.017 --> 00:04:29.857
Let's look at the setTimeout again I
use an arrow function I use the open

77
00:04:29.857 --> 00:04:33.450
parentheses set here,
didn't need any variable declarations.

78
00:04:33.450 --> 00:04:38.313
Because console.log is a function call,
it doesn't need any kind

79
00:04:38.313 --> 00:04:43.330
of curly braces around it,
because it's an expression call.

80
00:04:43.330 --> 00:04:46.160
So I can just simply
have that as the body.

81
00:04:46.160 --> 00:04:51.120
And finally my reduce, my reducer,
uses an arrow function.

82
00:04:51.120 --> 00:04:52.060
It's got two parameters.

83
00:04:52.060 --> 00:04:55.220
So I need to list both of those
with a parentheses set around it.

84
00:04:57.050 --> 00:04:57.592
Now.

85
00:04:57.592 --> 00:05:02.193
The last thing I wanna point out about
this exercise is, and this was the thing I

86
00:05:02.193 --> 00:05:06.881
messed up and it took me like 10 or 15
minutes to figure out why I messed it up.

87
00:05:06.881 --> 00:05:09.720
Cuz I had made this into
an arrow function first.

88
00:05:10.870 --> 00:05:12.030
Seems reasonable.

89
00:05:12.030 --> 00:05:13.360
Why not if we're going all out.

90
00:05:13.360 --> 00:05:16.830
Let's go and make all these arrow
functions, and I made the example and

91
00:05:16.830 --> 00:05:21.310
I still forgot the fact that you can't
use a .call on an arrow function.

92
00:05:21.310 --> 00:05:23.550
Well you can but it has no effect.

93
00:05:23.550 --> 00:05:26.260
Cuz you try to bind the disc
context of an arrow function.

94
00:05:26.260 --> 00:05:27.040
It doesn't have one.

95
00:05:27.040 --> 00:05:31.852
So it's just gonna ignore
that .call that you make.

96
00:05:31.852 --> 00:05:35.866
So if you have a place in your code
where you need to make a .call, or

97
00:05:35.866 --> 00:05:39.449
a a .apply, or a .bind or some,
any one of the ways that you

98
00:05:39.449 --> 00:05:44.082
do with this binding on something if you
need a thing to have of this binding.

99
00:05:44.082 --> 00:05:49.038
The trick here was I needed this
thing to adopt it's this context from

100
00:05:49.038 --> 00:05:51.442
an outer scope, that had a this.

101
00:05:51.442 --> 00:05:55.306
But if the outer scope of this arrow
function had been another arrow function,

102
00:05:55.306 --> 00:05:58.068
it would have had to just keep
going up and keep going up.

103
00:05:58.068 --> 00:06:02.436
So you're gonna have to have it an arrow
function inside of a regular function,

104
00:06:02.436 --> 00:06:05.120
if you want it to be able
to adopt in this context.

105
00:06:06.250 --> 00:06:07.180
The point I'm trying to make is,

106
00:06:07.180 --> 00:06:10.245
you're not going to be able to
replace all functions with arrows.

107
00:06:10.245 --> 00:06:14.960
And you're gonna have to be really
careful about which ones can, and

108
00:06:14.960 --> 00:06:16.810
which ones can't, and
under what kind of conditions.

109
00:06:18.380 --> 00:06:22.260
Now I deliberately made this big, and
hairy, and messy just to illustrate all

110
00:06:22.260 --> 00:06:25.190
those different things probably
your code isn't gonna be quite so

111
00:06:25.190 --> 00:06:28.840
bad, but you want to be careful
as you're writing your code.

112
00:06:30.320 --> 00:06:31.240
Any questions?

113
00:06:31.240 --> 00:06:33.750
Looks like there's a question in chat.

114
00:06:33.750 --> 00:06:39.580
Can you explain lines 13 and
14 with the parentheses there?

115
00:06:39.580 --> 00:06:41.390
So this is an arrow function.

116
00:06:41.390 --> 00:06:46.310
It's got a concise body which we start
on line 13 and finish on line 14.

117
00:06:46.310 --> 00:06:50.475
Because there are two separate
assignments that I wanna make,

118
00:06:50.475 --> 00:06:55.370
first is object.length = 1 and
the next one is object [O] = this.w.

119
00:06:55.370 --> 00:06:58.630
Those would normally be two separate
statements that I would semi colon and

120
00:06:58.630 --> 00:07:02.610
put inside of a curly brace pair, but
because I'm arrow functioning here

121
00:07:02.610 --> 00:07:07.590
I want to just use one parentheses set,
because if I took off the parentheses.

122
00:07:09.190 --> 00:07:13.130
The comma operator binds less tightly
than the arrow which would have meant,

123
00:07:13.130 --> 00:07:16.470
that only this would have
been the arrow function.

124
00:07:16.470 --> 00:07:19.110
We wanted the whole thing to
be the arrow function so,

125
00:07:19.110 --> 00:07:23.270
we have to bind the comma
inside of the parentheses set.

126
00:07:23.270 --> 00:07:26.889
TO get that whole two lines
to be the concise body.

127
00:07:26.889 --> 00:07:29.865
Hopefully that answer that.

128
00:07:29.865 --> 00:07:32.572
Any other questions that I missed and-
&gt;&gt; Speaker 2: Yeah this is along the same

129
00:07:32.572 --> 00:07:37.740
lines, can you just state what it is in
JavaScript that makes it so, that you can

130
00:07:37.740 --> 00:07:43.010
just put a comma and turn to different
statements into one expression, I think.

131
00:07:43.010 --> 00:07:46.243
&gt;&gt; Kyle Simpson: The comma operator is
defined as being able to do exactly that,

132
00:07:46.243 --> 00:07:47.158
which is to take,

133
00:07:47.158 --> 00:07:51.317
it's not two statements, it's two
expressions that can be chained together.

134
00:07:51.317 --> 00:07:56.448
Any general place where

135
00:07:56.448 --> 00:08:03.636
I had foo(3) ; bar(4);.

136
00:08:03.636 --> 00:08:05.707
It's entirely valid JavaScript for
me to do that.

137
00:08:05.707 --> 00:08:10.916
&gt;&gt; Speaker 3: And that's not ES6, that's-
&gt;&gt; Kyle Simpson: That's JavaScript ES0.

138
00:08:10.916 --> 00:08:13.870
The comma operator.

139
00:08:13.870 --> 00:08:17.820
Like I said, when your ES6 arrow
functioning, the thing you really wanna

140
00:08:17.820 --> 00:08:22.020
do as much as possible is pull out
every kind of weird esoteric grammar

141
00:08:22.020 --> 00:08:26.340
trick that you can, to get rid of all the
curly braces and semi colons and stuff.

142
00:08:26.340 --> 00:08:28.396
So, comma operator is a favorite
of writing arrow functions.

143
00:08:33.421 --> 00:08:36.581
&gt;&gt; Speaker 2: Can you explain
the difference between expression and

144
00:08:36.581 --> 00:08:39.070
statement, just to clarify.

145
00:08:39.070 --> 00:08:41.540
&gt;&gt; Kyle Simpson: I'm not
gonna go fully into that.

146
00:08:41.540 --> 00:08:42.954
Check out my types in grammar book.

147
00:08:42.954 --> 00:08:44.259
I think it might be chapter five.

148
00:08:44.259 --> 00:08:47.100
I cover the difference between
expression and statement.

149
00:08:47.100 --> 00:08:50.820
In English grammar,
the English language grammar,

150
00:08:50.820 --> 00:08:53.910
the closest analogue is
the difference between a sentence,

151
00:08:53.910 --> 00:08:57.020
which is a statement and
a phrase, which is an expression.

152
00:08:57.020 --> 00:08:58.850
Sentences are made up of phrases.

153
00:08:58.850 --> 00:09:00.838
Statements are made up of expressions.

154
00:09:00.838 --> 00:09:05.705
But in JavaScript a statement can't
be used in place of an expression,

155
00:09:05.705 --> 00:09:09.365
but an expression can be used
in place of a statement.

156
00:09:09.365 --> 00:09:11.441
&gt;&gt; Speaker 4: And do you go into that
in your advanced JavaScript course?

157
00:09:11.441 --> 00:09:14.506
&gt;&gt; Kyle Simpson: I do also cover that in
the advanced JavaScript course here on

158
00:09:14.506 --> 00:09:17.161
Frontend Masters and
in the types and grammar book.

159
00:09:17.161 --> 00:09:21.099
&gt;&gt; Speaker 2: Another question, if the set
time out is not returning any value,

160
00:09:21.099 --> 00:09:25.830
would it be a bad practice to use curly
braces in the arrow function on line 12?

161
00:09:29.337 --> 00:09:31.730
&gt;&gt; Kyle Simpson: Curly braces here.

162
00:09:31.730 --> 00:09:34.630
Would it be a bad practice to
throw curly braces around it?

163
00:09:34.630 --> 00:09:38.293
Again, what you're gonna have is you're
gonna have the ES6 police jump out of

164
00:09:38.293 --> 00:09:39.722
the shadows and scream at you.

165
00:09:39.722 --> 00:09:43.260
That you're supposed to be avoiding
curly braces where ever you can.

166
00:09:43.260 --> 00:09:46.288
Sorry the curly brace would of been here.

167
00:09:46.288 --> 00:09:50.477
There's nothing grammatically
wrong with it, but

168
00:09:50.477 --> 00:09:55.236
stylistically if you're going
all in on arrow functions,

169
00:09:55.236 --> 00:09:59.916
usually you're gonna wanna go
all in on arrow functions.

170
00:10:03.295 --> 00:10:04.835
&gt;&gt; Speaker 5: The ES6 police.

171
00:10:04.835 --> 00:10:09.410
&gt;&gt; Speaker 2: [LAUGH]
So in your opinion,

172
00:10:09.410 --> 00:10:12.650
if you're using arrow functions at all for
what they're intended for,

173
00:10:12.650 --> 00:10:17.840
would be that the replacement of
the this operator in that instance.

174
00:10:17.840 --> 00:10:21.460
&gt;&gt; Kyle Simpson: The place where it
really actually was useful in my opinion

175
00:10:21.460 --> 00:10:22.910
was right here.

176
00:10:22.910 --> 00:10:25.760
That's where the arrow function
was actually justified.

177
00:10:25.760 --> 00:10:29.490
All the other usages of it,
I think are gonna dodgy.

178
00:10:29.490 --> 00:10:30.250
My own opinion.

179
00:10:30.250 --> 00:10:31.166
Yes?
&gt;&gt; Speaker 2: Another

180
00:10:31.166 --> 00:10:33.048
question from the chat room.

181
00:10:33.048 --> 00:10:34.087
&gt;&gt; Kyle Simpson: We got
an active chat room today.

182
00:10:34.087 --> 00:10:35.637
I love this, it's great.

183
00:10:35.637 --> 00:10:37.113
&gt;&gt; Speaker 2: Well this is real stuff,
right.

184
00:10:37.113 --> 00:10:42.278
Is baz as a named arrow
function on line five.

185
00:10:42.278 --> 00:10:46.710
&gt;&gt; Kyle Simpson: Baz
a named arrow function, no.

186
00:10:46.710 --> 00:10:49.000
There's no such thing as
a named arrow function.

187
00:10:49.000 --> 00:10:53.669
Baz is an arrow function,
that gets assigned to the baz variable.

188
00:10:54.770 --> 00:10:58.820
That's what's happening on line five
there is an arrow function here, the part

189
00:10:58.820 --> 00:11:03.330
that I've highlighted that then gets
assigned to a lexical variable called baz,

190
00:11:03.330 --> 00:11:06.590
which was this one use
parameter from line three.

191
00:11:06.590 --> 00:11:08.480
So it's just assigned to it.

192
00:11:08.480 --> 00:11:10.430
Would it have name inferencing?

193
00:11:10.430 --> 00:11:10.950
Yes.

194
00:11:10.950 --> 00:11:12.104
It would have name inferencing.

195
00:11:12.104 --> 00:11:15.275
So if we were to call out
the .name property of it or

196
00:11:15.275 --> 00:11:18.522
if that were to have thrown
an error in the console,

197
00:11:18.522 --> 00:11:21.709
then it would have said
quote baz as the name of it.

198
00:11:21.709 --> 00:11:25.401
But there's no such thing
as a named arrow function,

199
00:11:25.401 --> 00:11:29.846
there is such a thing as a name
inference arrow function I guess.

200
00:11:33.540 --> 00:11:35.590
&gt;&gt; Speaker 2: Follow up on that.

201
00:11:35.590 --> 00:11:38.986
&gt;&gt; Kyle Simpson: So it can be a reference
even when used as a parameter.

202
00:11:41.732 --> 00:11:44.761
&gt;&gt; Kyle Simpson: I don't know what
named reference is referring to here.

203
00:11:47.250 --> 00:11:49.924
&gt;&gt; Kyle Simpson: No such thing in
my opinion as a named reference.

204
00:11:54.516 --> 00:11:55.493
&gt;&gt; Kyle Simpson: Thanks Mike.

205
00:11:55.493 --> 00:11:59.547
[LAUGH]
ES6 police.

206
00:12:01.582 --> 00:12:04.506
&gt;&gt; Kyle Simpson: If there's not
a Twitter account for ES6 police,

207
00:12:04.506 --> 00:12:07.648
there should be by the end of my class,
that somebody.

208
00:12:07.648 --> 00:12:09.846
[LAUGH]
&gt;&gt; Speaker 5: Is the type of arrow

209
00:12:09.846 --> 00:12:11.498
function in an object.

210
00:12:11.498 --> 00:12:12.393
That's what Ryan is asking.

211
00:12:12.393 --> 00:12:15.470
&gt;&gt; Kyle Simpson: Is the type
of arrow function an object?

212
00:12:15.470 --> 00:12:18.600
It's a function object just like
a regular function is an object,

213
00:12:18.600 --> 00:12:20.850
it just has special syntactic rules to it.

214
00:12:20.850 --> 00:12:22.380
Few special behaviors to it,

215
00:12:22.380 --> 00:12:26.070
but from the perspective of it being
an object, yes it's still an object.

