WEBVTT

1
00:00:00.076 --> 00:00:02.470
&gt;&gt; Lukas Ruebbelke: It's review time.

2
00:00:02.470 --> 00:00:05.470
Angular big picture,
Angular 2 big picture.

3
00:00:05.470 --> 00:00:11.070
So in the context of the big picture,
what is the purpose of NgModule?

4
00:00:17.404 --> 00:00:18.313
&gt;&gt; Lukas Ruebbelke: Don't be afraid.

5
00:00:21.534 --> 00:00:24.468
&gt;&gt; Lukas Ruebbelke: So your mouth is half
moving there like you wanna say something.

6
00:00:26.251 --> 00:00:29.347
&gt;&gt; Speaker 2: Yeah, so
in this current project,

7
00:00:29.347 --> 00:00:35.240
NgModule is where we tie it all
together in Bootstrap, the app.

8
00:00:35.240 --> 00:00:36.500
&gt;&gt; Lukas Ruebbelke: Yeah.

9
00:00:36.500 --> 00:00:39.720
&gt;&gt; Speaker 2: So it happens to
the only module in there, but

10
00:00:39.720 --> 00:00:41.340
there could be others.

11
00:00:41.340 --> 00:00:44.170
&gt;&gt; Lukas Ruebbelke: So there is one
more for the routing, but you're right.

12
00:00:44.170 --> 00:00:44.979
&gt;&gt; Speaker 2: That's true, yeah.

13
00:00:44.979 --> 00:00:46.995
&gt;&gt; Lukas Ruebbelke: So
think of essentially,

14
00:00:46.995 --> 00:00:52.034
NgModule as an organization
mechanism to organize things to tell

15
00:00:52.034 --> 00:00:57.547
Angular how essentially it should be
compiled or how it fits together.

16
00:00:59.305 --> 00:01:01.480
&gt;&gt; Lukas Ruebbelke: And so
just when I think of NgModule,

17
00:01:01.480 --> 00:01:05.690
I just think of it is as just a container
where Angular things go into, so

18
00:01:05.690 --> 00:01:08.513
that Angular knows where everything is,
yes?

19
00:01:08.513 --> 00:01:10.610
&gt;&gt; Speaker 3: Comment in from the chat.

20
00:01:10.610 --> 00:01:13.050
Christie is saying organization.

21
00:01:13.050 --> 00:01:13.555
&gt;&gt; Lukas Ruebbelke: Yes.

22
00:01:13.555 --> 00:01:17.790
&gt;&gt; Speaker 3: And Javier group features
that are meaningful to our business.

23
00:01:17.790 --> 00:01:19.780
&gt;&gt; Lukas Ruebbelke: Perfect,
so that's great.

24
00:01:19.780 --> 00:01:21.980
Essentially it allows you to organize or

25
00:01:21.980 --> 00:01:25.080
group features that
are meaningful to the business.

26
00:01:25.080 --> 00:01:29.888
And so for instance, if you have
something that may need to be peeled off

27
00:01:29.888 --> 00:01:32.463
into a different application or etc.

28
00:01:32.463 --> 00:01:36.205
Well, you can break those into modules or
NgModules as you see fit.

29
00:01:39.127 --> 00:01:41.273
&gt;&gt; Lukas Ruebbelke: So
what do we use routes for?

30
00:01:46.287 --> 00:01:47.202
&gt;&gt; Speaker 2: Routing.

31
00:01:47.202 --> 00:01:47.819
&gt;&gt; Lukas Ruebbelke: Routing.

32
00:01:47.819 --> 00:01:48.708
&gt;&gt; Speaker 2: [LAUGH]
&gt;&gt; Lukas Ruebbelke: And

33
00:01:48.708 --> 00:01:50.060
what does that entail, my friend?

34
00:01:51.410 --> 00:01:54.690
&gt;&gt; Speaker 2: Your URL or
different state change.

35
00:01:54.690 --> 00:02:01.660
&gt;&gt; Lukas Ruebbelke: There we go,
so state change, keep going.

36
00:02:01.660 --> 00:02:06.590
So when we go to a specific URL, so
think of a URL that's really just

37
00:02:06.590 --> 00:02:09.400
a serialize representation of
the state of the application.

38
00:02:11.110 --> 00:02:15.465
So for instance, if we have a route
that's forward slash items,

39
00:02:15.465 --> 00:02:20.389
we're telling Angular based on this URL,
we want to be in an items state.

40
00:02:24.267 --> 00:02:25.560
&gt;&gt; Lukas Ruebbelke: Right, so Russ has it.

41
00:02:25.560 --> 00:02:28.990
So mapping state to component.

42
00:02:28.990 --> 00:02:37.070
Interestingly enough, IC routes is being
yet another organizational mechanism.

43
00:02:37.070 --> 00:02:42.190
It allows you to organize your
application into discrete

44
00:02:42.190 --> 00:02:48.270
levels of state that you can then
represent and navigate directly to.

45
00:02:48.270 --> 00:02:50.600
And Angular is responsible for the state.

46
00:02:51.840 --> 00:02:58.240
I'm going to map it to this representation
of components on the screen.

47
00:02:58.240 --> 00:02:59.320
So for instance,

48
00:02:59.320 --> 00:03:02.910
a really simple example that we have
is that when we go to the item state.

49
00:03:02.910 --> 00:03:08.110
We're mapping that state or
that URL to take the item's component and

50
00:03:08.110 --> 00:03:10.790
load it into our router outlet.

51
00:03:10.790 --> 00:03:14.940
But when we go to the widget's URL,

52
00:03:14.940 --> 00:03:18.110
then it's saying take the widget's
state essentially and

53
00:03:18.110 --> 00:03:20.880
take the widget's component and
put it into the router outlet.

54
00:03:20.880 --> 00:03:24.200
So think of it as just really
a dynamic mechanism for

55
00:03:24.200 --> 00:03:27.430
organizing your application
into levels of state.

56
00:03:28.930 --> 00:03:32.670
And so when you start to think of
your application as a machine or

57
00:03:32.670 --> 00:03:38.500
you have these kind of levels of state or
state application can be in.

58
00:03:38.500 --> 00:03:42.091
Routing is just a really
convenient mechanism for

59
00:03:42.091 --> 00:03:45.945
moving between those items or
those levels of state.

60
00:03:48.681 --> 00:03:53.119
&gt;&gt; Lukas Ruebbelke: Okay,
what role does components play?

61
00:03:56.551 --> 00:03:59.306
&gt;&gt; Lukas Ruebbelke: I
think you have an answer.

62
00:03:59.306 --> 00:04:00.825
&gt;&gt; Speaker 4: Another
organization mechanism?

63
00:04:00.825 --> 00:04:03.164
&gt;&gt; Lukas Ruebbelke: Yes,
another organization mechanism.

64
00:04:03.164 --> 00:04:08.495
[LAUGH] So that's absolutely right,
let's expand on that.

65
00:04:11.776 --> 00:04:14.210
&gt;&gt; Lukas Ruebbelke: What do you think,
let's ask your colleague here.

66
00:04:15.370 --> 00:04:20.740
&gt;&gt; Speaker 5: I mean it's kind
of the view of your app and

67
00:04:23.210 --> 00:04:27.200
the code that runs when
you interact with the app.

68
00:04:27.200 --> 00:04:30.990
&gt;&gt; Lukas Ruebbelke: So you say view and
code, you're absolutely right,

69
00:04:30.990 --> 00:04:31.720
it's two parts.

70
00:04:33.050 --> 00:04:38.450
And then together, they come together, so
we'll talk about this a little bit more.

71
00:04:38.450 --> 00:04:42.830
But that forms essentially a building
block for your applications.

72
00:04:42.830 --> 00:04:46.640
So at the end of the day,
it is an organizational mechanism but

73
00:04:46.640 --> 00:04:51.350
it's really the core
atomic building block.

74
00:04:51.350 --> 00:04:54.821
Among really module state and
all the routes and

75
00:04:54.821 --> 00:04:58.219
everything at the bottom
of it is components.

76
00:04:58.219 --> 00:05:00.765
And then what we'll find out is that you
can have a component with components,

77
00:05:00.765 --> 00:05:02.200
components, components.

78
00:05:02.200 --> 00:05:06.700
But even though it's components all
the way down, it's still just components.

79
00:05:06.700 --> 00:05:12.620
So at the core, at the fundamental,
the essence of everything are components.

80
00:05:15.340 --> 00:05:15.850
Any questions?

81
00:05:15.850 --> 00:05:16.390
Make sense?

82
00:05:16.390 --> 00:05:17.530
Pretty simple.

83
00:05:17.530 --> 00:05:19.360
We have an atom, we have a component.

84
00:05:19.360 --> 00:05:23.459
Everything is built on top of that.

85
00:05:23.459 --> 00:05:24.630
So what are services for?

86
00:05:26.670 --> 00:05:28.355
Yes, they're an organizational mechanism.

87
00:05:28.355 --> 00:05:30.760
[LAUGH]
&gt;&gt; Speaker 2: Encapsulating

88
00:05:30.760 --> 00:05:31.730
business logic.

89
00:05:31.730 --> 00:05:32.970
&gt;&gt; Lukas Ruebbelke: Yes, thank you.

90
00:05:34.040 --> 00:05:39.140
So the idea is that you want your
components to be as thin as possible,

91
00:05:39.140 --> 00:05:43.350
essentially to consume just enough data to

92
00:05:43.350 --> 00:05:49.010
satisfy the view that the component owns.

93
00:05:49.010 --> 00:05:54.540
And just enough logic to
essentially capture user events and

94
00:05:54.540 --> 00:05:57.760
convey it to a service.

95
00:05:57.760 --> 00:06:03.110
The reason being is that if you
have business logic in a component,

96
00:06:03.110 --> 00:06:06.830
that logic is now coupled to that
component and you can no longer reuse it.

97
00:06:08.272 --> 00:06:13.150
So in Angular 1, a really common scenario
is I've got this stuff in my controller.

98
00:06:14.290 --> 00:06:17.320
What happens if another
controller needs to use it?

99
00:06:17.320 --> 00:06:19.990
Well, the answer is you basically
extract it out into a service, so

100
00:06:19.990 --> 00:06:22.770
that two controllers
can consume that data.

101
00:06:24.320 --> 00:06:26.840
Same thing with services in Angular 2 is,

102
00:06:26.840 --> 00:06:31.000
what happens if you have two
components that need to share data?

103
00:06:32.370 --> 00:06:35.500
Well, it goes into the service.

104
00:06:35.500 --> 00:06:38.030
Not only that,
it's when you have business logic and

105
00:06:38.030 --> 00:06:41.890
it's in a service,
it's much easier to test.

106
00:06:41.890 --> 00:06:45.980
The reason being is because with
a component, that Angular 2 has actually

107
00:06:45.980 --> 00:06:50.550
done some pretty good job or a pretty
good job streamline testing in Angular 2.

108
00:06:50.550 --> 00:06:58.390
But it's really easy to test in ES6
class without any Angular dependencies.

109
00:06:58.390 --> 00:07:02.500
And so that was one of the problems with
Angular1 is all I wanna test is directive,

110
00:07:03.890 --> 00:07:04.540
how do I do that?

111
00:07:04.540 --> 00:07:08.760
Well, I've actually got to simulate
DOM when I write my unit test.

112
00:07:08.760 --> 00:07:12.510
You would actually write a quasi isimal
fragment, you basically speed it up,

113
00:07:12.510 --> 00:07:16.420
initialize it and then you would
try to test it really, really hard.

114
00:07:16.420 --> 00:07:20.379
But by extracting things out into
purely in a perative context i.e,

115
00:07:20.379 --> 00:07:22.000
in the ES6 class.

116
00:07:22.000 --> 00:07:25.980
It makes it much easier to test and
move around.

117
00:07:25.980 --> 00:07:27.310
Makes sense?

118
00:07:27.310 --> 00:07:27.816
Good.

119
00:07:27.816 --> 00:07:31.992
&gt;&gt; Speaker 3: There's some confusion

120
00:07:31.992 --> 00:07:36.965
about component in the chat.

121
00:07:36.965 --> 00:07:39.380
&gt;&gt; Lukas Ruebbelke: Yeah, so I think Hans
and David, they're absolutely right.

122
00:07:39.380 --> 00:07:45.080
So one is the basic building block but
Angular is a component tree.

123
00:07:45.080 --> 00:07:47.300
So you'll have your top root component and

124
00:07:47.300 --> 00:07:50.680
then everything is essentially
built off of that.

125
00:07:55.940 --> 00:08:02.020
So, looking at this code here,
we've talked about NgModule But

126
00:08:02.020 --> 00:08:07.570
what mechanism is in play in
these three lines of code?

127
00:08:17.664 --> 00:08:20.010
&gt;&gt; Lukas Ruebbelke: I'll give you a hint,
organizational mechanism.

128
00:08:23.315 --> 00:08:24.470
&gt;&gt; Speaker 6: Creating a new component?.

129
00:08:25.860 --> 00:08:27.100
&gt;&gt; Lukas Ruebbelke: So yes.

130
00:08:27.100 --> 00:08:29.330
I mean we are creating a component but
more so.

131
00:08:31.920 --> 00:08:35.080
On the first two lines,
what are we doing?.

132
00:08:38.930 --> 00:08:41.320
&gt;&gt; Speaker 6: Pulling in
resources that are required.

133
00:08:41.320 --> 00:08:45.020
&gt;&gt; Lukas Ruebbelke: Yep, so
essentially, pulling in other modules.

134
00:08:46.460 --> 00:08:51.390
And then, at the last line,
we're exporting our class.

135
00:08:51.390 --> 00:08:56.360
And so
this is modules at a framework level, or

136
00:08:56.360 --> 00:09:01.400
rather, a language level&lt;&lt; And
so you'll see this a lot.

137
00:09:01.400 --> 00:09:07.470
And up until RC5 this is actually what
we used to construct our applications.

138
00:09:07.470 --> 00:09:10.410
We'd import things and
wire it up into metadata.

139
00:09:10.410 --> 00:09:16.630
Module has simplified that but
we still use ES6 modules

140
00:09:16.630 --> 00:09:21.280
as a fundamental make it four or
an application so

141
00:09:21.280 --> 00:09:25.390
just other one of the biggest
difference is from somebody from for

142
00:09:25.390 --> 00:09:29.580
instance ES5 into ES6 slash type script is

143
00:09:31.250 --> 00:09:35.820
wrapping their mind around really
importing and exporting functionality.

144
00:09:35.820 --> 00:09:41.040
But this super nice because now Just like
we have dependency injection, in a sense,

145
00:09:41.040 --> 00:09:47.020
you are supplying a dependency for your

146
00:09:47.020 --> 00:09:52.709
code to use, so we know for a fact
that this item's component needs this

147
00:09:54.294 --> 00:09:58.580
functionality, as well as the component,
so we simply provide it.

148
00:09:58.580 --> 00:10:02.740
And we very specifically and
explicitly can state

149
00:10:02.740 --> 00:10:05.750
its requirements at the top of
the file and just pull those in.

150
00:10:06.760 --> 00:10:10.240
Whereas with ES5, well, how did that work?

151
00:10:10.240 --> 00:10:16.070
Well, if you go to the index.html page,
and you look into the bottom of the page,

152
00:10:16.070 --> 00:10:22.850
a lot of times you would have 20,
30, 40, 50 script files.

153
00:10:22.850 --> 00:10:27.950
And I think even let's just

154
00:10:27.950 --> 00:10:33.730
go back to the browser here.

155
00:10:33.730 --> 00:10:39.870
This is one of the downsides
of using S5 is you have to

156
00:10:39.870 --> 00:10:45.250
declare everything in kind of one place
and then its implied that it's available.

157
00:10:45.250 --> 00:10:51.558
The problem is that if anybody ever gotten
these out of order like things will break.

158
00:10:51.558 --> 00:10:57.194
With modules that is elevated and

159
00:10:57.194 --> 00:11:02.980
so That alone simply is one.

160
00:11:02.980 --> 00:11:07.680
Organize your application but then satisfy

161
00:11:07.680 --> 00:11:12.520
dependencies is really, really powerful.

162
00:11:12.520 --> 00:11:15.030
Let's just walk through
these real quick and

163
00:11:15.030 --> 00:11:20.440
talk about what is the purposes
of These properties.

164
00:11:20.440 --> 00:11:22.640
So bootstrap let's start with an easy one.

165
00:11:24.890 --> 00:11:28.281
What does the bootstrap property do?

166
00:11:31.024 --> 00:11:32.980
&gt;&gt; Speaker 7: App loads.

167
00:11:32.980 --> 00:11:37.090
So gonna launch app component.

168
00:11:38.740 --> 00:11:42.130
&gt;&gt; Lukas Ruebbelke: So what your telling
it is we're going to when we bootstrap

169
00:11:42.130 --> 00:11:45.720
we're saying we want to first
bootstrap to the module but

170
00:11:45.720 --> 00:11:49.570
then when the module loads
the entry point is component.

171
00:11:49.570 --> 00:11:52.580
And so
that becomes our top level component.

172
00:11:52.580 --> 00:11:55.880
As a result of this if you go
to your index dot HTML you

173
00:11:55.880 --> 00:12:00.880
will see the app component
selector in the HTML so

174
00:12:00.880 --> 00:12:05.158
that it actually has Kind of an anchor or
entry point into the template.

175
00:12:05.158 --> 00:12:07.498
Okay, providers?

176
00:12:10.518 --> 00:12:11.500
&gt;&gt; Speaker 8: Services.

177
00:12:11.500 --> 00:12:12.890
&gt;&gt; Lukas Ruebbelke: Yes, so

178
00:12:12.890 --> 00:12:17.790
this is where we define our services for
our application.

179
00:12:17.790 --> 00:12:21.910
And so by putting them into the providers
array, Angular now knows that they're

180
00:12:21.910 --> 00:12:27.430
there, and they can supply them to as
you know for dependency injection.

181
00:12:28.510 --> 00:12:29.820
Now Imports.

182
00:12:36.200 --> 00:12:41.800
Yes so now we're importing
additional modules that we need So

183
00:12:41.800 --> 00:12:45.370
for instance, the browser module,
so that essentially encapsulates

184
00:12:45.370 --> 00:12:48.400
the browser functionality as
well as kind of Angular core.

185
00:12:48.400 --> 00:12:52.510
But the Angular team has
broken out Angular 2, and

186
00:12:52.510 --> 00:12:59.830
two kind of smaller modules, so
that you can define them as necessary.

187
00:12:59.830 --> 00:13:07.450
So you might actually have an application
That doesn't use any hdp calls.

188
00:13:07.450 --> 00:13:11.980
It may not be that kind of application,
so therefore you don't need to import it.

189
00:13:11.980 --> 00:13:15.060
You don't need to incur the overhead or
it.

190
00:13:15.060 --> 00:13:18.000
Or, you may have an application
that just doesn't have any form,

191
00:13:18.000 --> 00:13:20.670
that's purely for display purposes.

192
00:13:20.670 --> 00:13:21.430
Yes?

193
00:13:21.430 --> 00:13:22.470
&gt;&gt; Speaker 4: Can you just repeat again

194
00:13:22.470 --> 00:13:24.500
the [INAUDIBLE]
the declaration&lt;&lt; The providers,

195
00:13:24.500 --> 00:13:28.360
these providers with the service, and
the declaration was with what again?

196
00:13:28.360 --> 00:13:32.513
&gt;&gt; Lukas Ruebbelke: Well, you just got to
my last and final question for this slide.

197
00:13:32.513 --> 00:13:36.395
What are declarations for?

198
00:13:38.718 --> 00:13:40.982
&gt;&gt; Speaker 9: Components.

199
00:13:40.982 --> 00:13:42.743
&gt;&gt; Lukas Ruebbelke: Components.

200
00:13:43.850 --> 00:13:50.940
And, essentially, anything that has a view
class or that will live in the dom.

201
00:13:50.940 --> 00:13:53.480
So, aka, components.

202
00:13:53.480 --> 00:13:54.870
So this is where your components go.

203
00:13:54.870 --> 00:13:57.700
So components for declarations.

204
00:13:57.700 --> 00:14:01.610
Imports, you import your dependencies.

205
00:14:01.610 --> 00:14:03.830
Providers is for services.

206
00:14:03.830 --> 00:14:08.270
And then bootstrap is for your component

207
00:14:08.270 --> 00:14:12.750
that you want to bootstrap when that
module is loaded or bootstrapped.

208
00:14:14.855 --> 00:14:17.340
&gt;&gt; Lukas Ruebbelke: Yup, so we're getting
a lot of good answers in the chats.

209
00:14:18.730 --> 00:14:19.280
&gt;&gt; Speaker 3: A question?

210
00:14:19.280 --> 00:14:19.780
&gt;&gt; Lukas Ruebbelke: Yes?

211
00:14:20.850 --> 00:14:25.160
&gt;&gt; Speaker 3: I notice that
the bootstrap is an array.

212
00:14:25.160 --> 00:14:27.710
Which implies you can have
more than one entry point?

213
00:14:30.900 --> 00:14:33.830
&gt;&gt; Lukas Ruebbelke: I believe that's so,
but I've never done it.

214
00:14:35.000 --> 00:14:37.710
So that may be the case,
if somebody would like to try that out.

215
00:14:38.830 --> 00:14:42.930
I think you can,
&gt;&gt; Lukas Ruebbelke: I wonder if you could.

216
00:14:45.340 --> 00:14:47.060
So, we'll maybe try that over lunch.

217
00:14:47.060 --> 00:14:47.920
&gt;&gt; Speaker 3: Try that over lunch.

218
00:14:47.920 --> 00:14:48.760
&gt;&gt; Lukas Ruebbelke: That's
a good question.

219
00:14:48.760 --> 00:14:52.510
&gt;&gt; Speaker 3: Yeah.
Shouldn't be hard to give it a go.

220
00:14:52.510 --> 00:14:55.800
&gt;&gt; Lukas Ruebbelke: I think you possibly,
so at one point, you simply had a single

221
00:14:55.800 --> 00:15:00.100
top level, but they may have changed
that with NG module, to where you could

222
00:15:00.100 --> 00:15:03.310
actually have two components and
bootstrap them both in parallel.

223
00:15:05.230 --> 00:15:10.000
Okay so what is the entry
point to our application here?

224
00:15:19.448 --> 00:15:21.810
&gt;&gt; Lukas Ruebbelke: So
we just went through the app module

225
00:15:24.100 --> 00:15:25.337
&gt;&gt; Lukas Ruebbelke: Now what's happening

226
00:15:25.337 --> 00:15:28.523
here
&gt;&gt; Lukas Ruebbelke: specifically at

227
00:15:28.523 --> 00:15:29.240
the last line?

228
00:15:36.143 --> 00:15:36.903
&gt;&gt; Lukas Ruebbelke: We were bootstrapping?

229
00:15:36.903 --> 00:15:38.801
What are we bootstrapping?

230
00:15:38.801 --> 00:15:39.908
The app module.

231
00:15:39.908 --> 00:15:41.020
&gt;&gt; Speaker 10: The app module.

232
00:15:43.348 --> 00:15:47.430
&gt;&gt; Lukas Ruebbelke: Which
then loads app component.

233
00:15:47.430 --> 00:15:54.830
And one of the reasons why we
have platform browsers Dynamic

234
00:15:54.830 --> 00:15:59.940
is because, web bootstrapping it
specifically for a browser context,

235
00:15:59.940 --> 00:16:06.091
because you can actually run angular In
other, essentially rendering targets.

236
00:16:06.091 --> 00:16:10.899
So you can actually, I know that electron
is a target that they're working on, but

237
00:16:10.899 --> 00:16:13.734
you can actually run
Angular on the server side.

238
00:16:13.734 --> 00:16:18.267
You can bootstrap Angular
to use web workers.

239
00:16:18.267 --> 00:16:21.650
There's a lot of different ways to
spin up an Angular application.

240
00:16:21.650 --> 00:16:26.597
And so this is why we have
this platformBrowserDynamic,

241
00:16:26.597 --> 00:16:32.584
which then we use to call
bootstrapModule and bootstrapAppModule.

242
00:16:34.100 --> 00:16:37.866
And so this is why we have
this war with Angular 1,

243
00:16:37.866 --> 00:16:42.900
it was just ngAapp and
you're good to go like it's bootstrapped.

244
00:16:42.900 --> 00:16:48.337
With Angular 2, we have a lot more

245
00:16:48.337 --> 00:16:54.906
options about how we want to handle that.

246
00:16:54.906 --> 00:16:58.063
So, what is the basic
structure of a route?

247
00:17:01.049 --> 00:17:03.927
&gt;&gt; Lukas Ruebbelke: There's kind of
two main things I'm looking for.

248
00:17:03.927 --> 00:17:08.793
If you have good eyesight,
you may be able to see on the slide,

249
00:17:08.793 --> 00:17:11.425
but I expect commentary on this.

250
00:17:11.425 --> 00:17:15.337
&gt;&gt; Speaker 5: It's an array of objects
that has a path and a component.

251
00:17:15.337 --> 00:17:16.832
&gt;&gt; Lukas Ruebbelke: Nailed it.

252
00:17:16.832 --> 00:17:17.871
Path and a component.

253
00:17:17.871 --> 00:17:19.808
So, what's another property we
could possible have on there?

254
00:17:19.808 --> 00:17:20.413
&gt;&gt; Speaker 5: Children.

255
00:17:20.413 --> 00:17:21.212
&gt;&gt; Lukas Ruebbelke: Children.
&gt;&gt; Speaker 8: Children.

256
00:17:21.212 --> 00:17:22.368
&gt;&gt; Speaker 5: Redirect.

257
00:17:22.368 --> 00:17:24.951
&gt;&gt; Lukas Ruebbelke: Redirect
too is another good one.

258
00:17:24.951 --> 00:17:31.898
So once you understand path and
component, you'll use that a lot.

259
00:17:31.898 --> 00:17:36.371
Redirect to for kind of your base path,

260
00:17:36.371 --> 00:17:43.975
if you wanna redirect to a specific
route or what does asterisk do.

261
00:17:43.975 --> 00:17:44.745
&gt;&gt; Speaker 6: Catchall.

262
00:17:44.745 --> 00:17:45.357
&gt;&gt; Lukas Ruebbelke: Catchall.

263
00:17:45.357 --> 00:17:48.868
So it's a wild card route,
wild card route.

264
00:17:48.868 --> 00:17:53.730
Now as we learned yesterday
that if we hit a wild card,

265
00:17:53.730 --> 00:18:00.550
it's just going to take ItemsComponent and
put it into the router outlet.

266
00:18:00.550 --> 00:18:06.464
The problem is and
why there may be a good reason to do this,

267
00:18:06.464 --> 00:18:11.776
the caveat is you are now in
a crazy potential URL that

268
00:18:11.776 --> 00:18:18.927
you have now loaded a state or
a component that doesn't match the URL.

269
00:18:18.927 --> 00:18:20.384
Remember, your URL,

270
00:18:20.384 --> 00:18:25.678
think of it as essentially a serialized
version of the state of your application,

271
00:18:25.678 --> 00:18:31.296
you're now in like crazy state and you're
actually showing something that is valid.

272
00:18:31.296 --> 00:18:34.278
&gt;&gt; Speaker 3: Quick question, which
file did that bootstrap code come from?

273
00:18:34.278 --> 00:18:37.110
Where you had said that one line
where you get that bootstrap?

274
00:18:37.110 --> 00:18:38.800
What file did that come from?

275
00:18:38.800 --> 00:18:39.771
&gt;&gt; Speaker 6: Main.ts.

276
00:18:39.771 --> 00:18:40.464
&gt;&gt; Speaker 3: Main.ts.

277
00:18:40.464 --> 00:18:41.236
&gt;&gt; Lukas Ruebbelke: Main.ts.

278
00:18:41.236 --> 00:18:43.785
So let me just, I think I have it here.

279
00:18:43.785 --> 00:18:48.979
If we go to, yeah, so main.ts and

280
00:18:48.979 --> 00:18:53.468
it's right here in the root.

281
00:18:59.258 --> 00:18:59.970
&gt;&gt; Lukas Ruebbelke: There we go.

282
00:18:59.970 --> 00:19:03.955
So, we're bootstrapping in main.ts.

283
00:19:06.398 --> 00:19:09.221
&gt;&gt; Lukas Ruebbelke: And
notice it's pulling in app module and

284
00:19:09.221 --> 00:19:14.154
that's all it needs to basically kick
things off and since we're here.

285
00:19:18.473 --> 00:19:19.163
&gt;&gt; Lukas Ruebbelke: Of course,

286
00:19:19.163 --> 00:19:22.544
I think there's a ton of
index.html's in this project.

287
00:19:25.231 --> 00:19:28.338
&gt;&gt; Lukas Ruebbelke: You notice
here that in our index.html,

288
00:19:28.338 --> 00:19:33.238
we have essentially our selector for
our topple over component.

289
00:19:35.838 --> 00:19:40.116
&gt;&gt; Lukas Ruebbelke: And what you can
do is, cuz there's a question about we

290
00:19:40.116 --> 00:19:44.681
had loading or something,
you can put something in here.

291
00:19:44.681 --> 00:19:47.832
So this spinner will exist until,

292
00:19:47.832 --> 00:19:52.732
essentially the module or
the component's loaded.

293
00:19:52.732 --> 00:19:57.398
And so especially for the top level
component, it's very common to actually

294
00:19:57.398 --> 00:20:00.931
put the, really a preloader
right in there in the middle.

295
00:20:00.931 --> 00:20:04.290
So it can run and
then that component is loaded, and

296
00:20:04.290 --> 00:20:09.311
it will then essentially replace that
item with the actual component view.

297
00:20:09.311 --> 00:20:14.022
So if somebody was wondering
why that is there, it's for

298
00:20:14.022 --> 00:20:18.357
UI purposes,
because those things are important.

299
00:20:18.357 --> 00:20:20.208
I'm looking at you, CSS designer.

300
00:20:20.208 --> 00:20:21.393
We love you.

301
00:20:21.393 --> 00:20:25.486
&gt;&gt; Speaker 2: Do you know
the idea of putting in more or

302
00:20:25.486 --> 00:20:34.181
less a simplified version of your page
while it's loading from an SEO standpoint?

303
00:20:34.181 --> 00:20:36.350
&gt;&gt; Lukas Ruebbelke: Yes,
we know about that.

304
00:20:36.350 --> 00:20:38.329
&gt;&gt; Speaker 2: Okay.
&gt;&gt; Lukas Ruebbelke: So the question is do

305
00:20:38.329 --> 00:20:43.815
I know, but I'm gonna rephrase
that question slightly is,

306
00:20:43.815 --> 00:20:47.258
is there a mechanism or a technique for

307
00:20:47.258 --> 00:20:52.990
providing a simplified version
of the page for SEO purposes?

308
00:20:52.990 --> 00:20:58.037
And there's a project called
Angular Universal which is officially

309
00:20:58.037 --> 00:21:03.605
supported by Angular and what this does
is it allows you to actually render,

310
00:21:03.605 --> 00:21:09.452
take your first pass of your Angular
application and it renders at the service.

311
00:21:09.452 --> 00:21:13.659
So instead of essentially loading a blank
template and then filling it in as

312
00:21:13.659 --> 00:21:18.064
the data comes in, it will actually fill
that template in at the server serve,

313
00:21:18.064 --> 00:21:20.837
essentially the first
pass of the application.

314
00:21:20.837 --> 00:21:25.880
And then once it loads, Angular will then
pick it up and kinda fill in the rest.

315
00:21:25.880 --> 00:21:27.520
And so, it's a super awesome project.

316
00:21:27.520 --> 00:21:29.928
My friend Jeff Whelpley started it and

317
00:21:29.928 --> 00:21:33.020
the reason why he did it
was he works at Get Human.

318
00:21:33.020 --> 00:21:35.495
He's the CTO and a lot of their,

319
00:21:35.495 --> 00:21:41.374
essentially their revenue is based on
people finding them on the Internet.

320
00:21:41.374 --> 00:21:44.520
So, that's a real SEO case.

321
00:21:44.520 --> 00:21:48.420
Now I kind of bristle a little
bit when SEO comes up,

322
00:21:48.420 --> 00:21:55.068
because I find that it's generally find
a straw man argument of like JavaScript.

323
00:21:55.068 --> 00:21:57.479
Well, what about that SEO thing?

324
00:21:57.479 --> 00:22:01.289
And I've found that when I really press
somebody for, what are you building?

325
00:22:01.289 --> 00:22:03.510
What do you need SEO for?

326
00:22:03.510 --> 00:22:05.702
And a lot of times, you find, well,

327
00:22:05.702 --> 00:22:09.301
I'm building this single page
application where the user logs in.

328
00:22:09.301 --> 00:22:14.478
Wait a second or you're building
really a complex application

329
00:22:14.478 --> 00:22:19.264
with various levels of state and
you're like why would you

330
00:22:19.264 --> 00:22:24.257
want to index that on,
why would you even want that indexed?

331
00:22:24.257 --> 00:22:28.002
Or I mean, I've literally, well,
the user logs in and then well,

332
00:22:28.002 --> 00:22:31.780
you certainly don't wanna
index user specific state.

333
00:22:31.780 --> 00:22:36.113
And so there are definitely cases for
SEO, but I think throwing

334
00:22:36.113 --> 00:22:40.935
SEO just out there is like well,
what about JavaScript and SEO and

335
00:22:40.935 --> 00:22:46.359
it's like well there are ways to handle
that if you really have an SEO problem.

336
00:22:46.359 --> 00:22:49.319
&gt;&gt; Speaker 2: More so
also or in addition to that,

337
00:22:49.319 --> 00:22:52.588
I should say just from a response time.

338
00:22:52.588 --> 00:22:55.179
&gt;&gt; Lukas Ruebbelke: Yes, so
that's actually a better example.

339
00:22:55.179 --> 00:22:57.518
&gt;&gt; Speaker 2: That's really
kind of what I meant.

340
00:22:57.518 --> 00:23:00.617
Yeah, the response time giving
them something immediately.

341
00:23:00.617 --> 00:23:01.460
&gt;&gt; Lukas Ruebbelke: Yep.

342
00:23:01.460 --> 00:23:03.918
&gt;&gt; Speaker 2: Since being
these apps get pretty large.

343
00:23:03.918 --> 00:23:08.818
And on a mobile like you had
said yesterday, last calls.

344
00:23:08.818 --> 00:23:12.358
&gt;&gt; Lukas Ruebbelke: Yep, I would
definitely check out Angular Universal and

345
00:23:12.358 --> 00:23:14.202
there's some stuff around,

346
00:23:14.202 --> 00:23:18.628
just progressive write applications
like web a lot of really

347
00:23:18.628 --> 00:23:23.294
interesting things you can do to really
get that first render really fast.

348
00:23:28.189 --> 00:23:29.250
&gt;&gt; Lukas Ruebbelke: So,
let's make a comment.

349
00:23:29.250 --> 00:23:32.838
Let your public site handle the SEO and
keep it out of the app.

350
00:23:32.838 --> 00:23:38.142
So a lot of times, again, using the right
tool for the right job is if you have just

351
00:23:38.142 --> 00:23:43.221
a lot of content like that's really not
a good candidate for an application.

352
00:23:43.221 --> 00:23:47.971
Use it, for instance, my blog is in
WordPress, because that's the best

353
00:23:47.971 --> 00:23:52.887
tool for displaying a lot of content and
managing it like it's not Angular.

354
00:23:52.887 --> 00:23:56.766
And so again,
using the right tool for the job and

355
00:23:56.766 --> 00:24:02.700
it's totally fine to have just
a static single page, a static page.

356
00:24:02.700 --> 00:24:07.720
Now for your public site, and then Angular
handles all of the application step so

357
00:24:07.720 --> 00:24:10.150
really even segmenting that
out is a good example but

358
00:24:10.150 --> 00:24:13.950
performance on the other hand,
that is important.

359
00:24:13.950 --> 00:24:18.720
And I think Angular Universal
is a trick to that.

360
00:24:20.020 --> 00:24:20.940
Well one of the tools.

361
00:24:22.180 --> 00:24:22.680
Okay?

362
00:24:24.320 --> 00:24:24.920
Where were we?

363
00:24:27.040 --> 00:24:28.340
So we did the wild card route.

364
00:24:30.740 --> 00:24:32.830
All right, so back to you.

365
00:24:32.830 --> 00:24:35.500
What are the two main
pieces of a component?

366
00:24:37.410 --> 00:24:40.040
Yeah I was pointing at you.

367
00:24:41.090 --> 00:24:42.550
&gt;&gt; Speaker 7: The template.

368
00:24:42.550 --> 00:24:43.050
&gt;&gt; Lukas Ruebbelke: Yes.

369
00:24:44.140 --> 00:24:48.850
&gt;&gt; Speaker 7: Meta data and class.

370
00:24:48.850 --> 00:24:50.830
&gt;&gt; Lukas Ruebbelke: So, template and

371
00:24:50.830 --> 00:24:53.556
class, they are kind
of the two big pieces.

372
00:24:53.556 --> 00:24:59.430
And then, I'm just jumping through here.

373
00:24:59.430 --> 00:25:03.790
So, anyway, I'll talk about meta data in
a second, let's kind of back this up here,

374
00:25:03.790 --> 00:25:07.630
let's talk about components,
one of the classes.

375
00:25:07.630 --> 00:25:10.090
So what does implements OnInit do here?

376
00:25:14.963 --> 00:25:17.840
&gt;&gt; Speaker 10: You're declaring your
component is gonna react to that event and

377
00:25:17.840 --> 00:25:20.190
OnInit, you're gonna implement that.

378
00:25:20.190 --> 00:25:22.690
&gt;&gt; Lukas Ruebbelke: Yes,
for the most part.

379
00:25:22.690 --> 00:25:24.300
Could you expand?

380
00:25:24.300 --> 00:25:27.390
Specifically, when we say implements.

381
00:25:27.390 --> 00:25:28.530
So OnInit is what?

382
00:25:28.530 --> 00:25:31.190
&gt;&gt; Speaker 10: Is an event in Angular.

383
00:25:32.730 --> 00:25:36.900
&gt;&gt; Lukas Ruebbelke: Kind of but in this
case right here, it is an interface.

384
00:25:38.060 --> 00:25:42.270
So we're simply saying that this
class is going to implement

385
00:25:43.500 --> 00:25:45.970
whatever is defined within this interface.

386
00:25:47.470 --> 00:25:53.170
And so in this case if you go to
the OnInit interface then there is

387
00:25:55.150 --> 00:25:59.690
an ngOnInit method that by
implementing the interface we

388
00:25:59.690 --> 00:26:04.140
are now contractually
obligated to implement it.

389
00:26:05.230 --> 00:26:09.000
So again there's nothing
forcing us to do it.

390
00:26:09.000 --> 00:26:13.220
But TypeScript,
it essentially development time and

391
00:26:13.220 --> 00:26:17.083
compile time will call you out
if you have failed to do so.

392
00:26:17.083 --> 00:26:23.434
So, with that said how does ngOnInit work?

393
00:26:28.751 --> 00:26:30.873
&gt;&gt; Speaker 3: Good comments
in the chat room right now.

394
00:26:36.041 --> 00:26:40.490
&gt;&gt; Lukas Ruebbelke: Yap so
Javier actually had it so

395
00:26:40.490 --> 00:26:46.703
you use it to, well
&gt;&gt; Lukas Ruebbelke: Not quite actually.

396
00:26:49.224 --> 00:26:52.678
&gt;&gt; Lukas Ruebbelke: So Hans actually
had it, so it's really a life cycle

397
00:26:52.678 --> 00:26:57.950
specifically it's when the bindings for
your component have been satisfied.

398
00:26:59.020 --> 00:27:02.047
The reason why we use this is because.

399
00:27:04.693 --> 00:27:08.095
&gt;&gt; Lukas Ruebbelke: We need to
perform when we load our component,

400
00:27:08.095 --> 00:27:13.154
when we have initialization logic we
need a place to put it especially

401
00:27:13.154 --> 00:27:19.210
when that logic has a dependency on
data that's coming from a parent.

402
00:27:19.210 --> 00:27:23.660
So the big takeaway here
is keep your instructor

403
00:27:24.880 --> 00:27:29.040
light weight, you can use it for
basic assignment.

404
00:27:29.040 --> 00:27:33.210
But a lot of times,
you will have it simply for

405
00:27:33.210 --> 00:27:36.760
dependency injection to define it.

406
00:27:36.760 --> 00:27:41.470
And then you will handle your
initialization in ngOnInit.

407
00:27:41.470 --> 00:27:45.724
Because you can safely assume
that any kind of dependencies, or

408
00:27:45.724 --> 00:27:50.230
data dependencies via binding,
has been satisfied at that point.

409
00:27:55.850 --> 00:27:56.751
&gt;&gt; Lukas Ruebbelke: So.

410
00:28:00.498 --> 00:28:05.300
&gt;&gt; Lukas Ruebbelke: What do we do to
inject a dependency into our component?

411
00:28:07.135 --> 00:28:08.284
&gt;&gt; Lukas Ruebbelke: And
just rephrase this.

412
00:28:12.182 --> 00:28:12.890
&gt;&gt; Lukas Ruebbelke: Yes?

413
00:28:12.890 --> 00:28:13.430
&gt;&gt; Speaker 3: Question,

414
00:28:13.430 --> 00:28:16.530
so then I'm having a hard time
finding which file is this one from.

415
00:28:19.380 --> 00:28:23.416
&gt;&gt; Lukas Ruebbelke: So
this is purely for discussion purposes.

416
00:28:23.416 --> 00:28:31.590
But it is [INAUDIBLE]
So this not a specific file

417
00:28:31.590 --> 00:28:36.730
but if you went to items component you
would see a similar version of this.

418
00:28:36.730 --> 00:28:42.670
But our items component has
a dependency on the items service.

419
00:28:42.670 --> 00:28:43.885
How do we get it in there?

420
00:28:46.637 --> 00:28:47.841
&gt;&gt; Speaker 2: The constructor.

421
00:28:47.841 --> 00:28:48.491
&gt;&gt; Lukas Ruebbelke: &lt;&lt; Yes.

422
00:28:50.724 --> 00:28:56.054
&gt;&gt; Lukas Ruebbelke: So in our constructor,
what does the private keyword do?.

423
00:29:00.789 --> 00:29:03.500
&gt;&gt; [INAUDIBLE]
&gt;&gt; Lukas Ruebbelke: Yes.

424
00:29:03.500 --> 00:29:04.730
Very good.

425
00:29:04.730 --> 00:29:06.320
So it is constructor assignment.

426
00:29:06.320 --> 00:29:08.106
But what it does now.

427
00:29:08.106 --> 00:29:11.680
Assigns a variable or

428
00:29:11.680 --> 00:29:15.470
property on that class that we can
then use outside of the constructor.

429
00:29:17.080 --> 00:29:23.790
So therefore on ngOnInit,
we can then reference this .itemsService.

430
00:29:23.790 --> 00:29:24.290
Yes.

431
00:29:25.350 --> 00:29:27.370
&gt;&gt; Speaker 11: If you have private,
can you also have public?

432
00:29:27.370 --> 00:29:28.070
&gt;&gt; Lukas Ruebbelke: Yeah.

433
00:29:28.070 --> 00:29:31.610
&gt;&gt; Speaker 11: And then does that make
it a member variable of the class and

434
00:29:31.610 --> 00:29:34.330
available to whoever uses that component?

435
00:29:34.330 --> 00:29:37.830
&gt;&gt; Lukas Ruebbelke: So technically,
when things are compiled, so

436
00:29:37.830 --> 00:29:40.070
typescript is a super set of VS 6.

437
00:29:40.070 --> 00:29:42.210
ES 6 is a superset of VS 5.

438
00:29:42.210 --> 00:29:47.010
So at the end of the day,
everything is being compiled into ES 5.

439
00:29:47.010 --> 00:29:52.630
So it's important to point out,
that public and private and

440
00:29:52.630 --> 00:29:57.530
the different assets modifiers
are strictly at really

441
00:29:57.530 --> 00:30:02.320
a kind of development time and
compile time in the form of warnings.

442
00:30:03.890 --> 00:30:07.000
But once it's into ES 5 there's nothing
to actually keep it from doing that.

443
00:30:08.280 --> 00:30:13.410
So, once it's been compiled to DS-5,
there's no concept of public and private.

444
00:30:13.410 --> 00:30:17.920
But what you could do is,
if you needed to access this,

445
00:30:17.920 --> 00:30:23.620
or what you wanted to control this, so
by default I set things to private.

446
00:30:23.620 --> 00:30:29.670
And therefore if I tried to access the
item's service outside of this component,

447
00:30:29.670 --> 00:30:33.560
for some reason,
TypeScript would be like, hey.

448
00:30:33.560 --> 00:30:34.380
This thing's private.

449
00:30:34.380 --> 00:30:34.950
You can't touch it.

450
00:30:36.320 --> 00:30:39.210
But you could do, you know, public.

451
00:30:39.210 --> 00:30:42.180
So, for instance, you had,
a better use case.

452
00:30:42.180 --> 00:30:44.390
You had a service that references, maybe,

453
00:30:44.390 --> 00:30:47.150
another service that you
want to make available.

454
00:30:48.160 --> 00:30:49.850
To something else.

455
00:30:49.850 --> 00:30:53.390
You can set that to the public.

456
00:30:53.390 --> 00:30:54.930
Yes.
&gt;&gt; Speaker 3: I had a question from way

457
00:30:54.930 --> 00:30:56.980
early this morning before we began.

458
00:30:56.980 --> 00:30:59.665
And it's like 45 minutes ago.

459
00:30:59.665 --> 00:31:02.970
[LAUGH] But it's appropriate to right now.

460
00:31:02.970 --> 00:31:03.610
&gt;&gt; Lukas Ruebbelke: Good.

461
00:31:03.610 --> 00:31:04.860
&gt;&gt; Speaker 3: I think.

462
00:31:06.310 --> 00:31:07.040
Let's see.

463
00:31:07.040 --> 00:31:10.660
Are all functions that I
declare in the service public?

464
00:31:10.660 --> 00:31:15.010
Can I declare some function that
takes object, modify it, and

465
00:31:15.010 --> 00:31:21.030
return in a service that's not
accessable to anything outside of it?

466
00:31:21.030 --> 00:31:23.800
&gt;&gt; Lukas Ruebbelke: So
by default everything is public.

467
00:31:23.800 --> 00:31:27.616
But then you can basically set
it to private if you would like.

468
00:31:32.963 --> 00:31:34.216
&gt;&gt; Lukas Ruebbelke: Let's see here.

469
00:31:34.216 --> 00:31:35.084
Make sure.

470
00:31:35.084 --> 00:31:38.770
Yeah, so
ngOnInit runs after the constructor.

471
00:31:38.770 --> 00:31:41.770
The constructor will run
pretty much right away.

472
00:31:41.770 --> 00:31:45.650
But then certain things need to happen,
bindings need to be satisfied,

473
00:31:45.650 --> 00:31:49.110
tablet needs to be initialized,
and then ngOnInit will run.

474
00:31:49.110 --> 00:31:53.791
So that's really important that
ngOnInit runs after the constructor.

475
00:31:58.052 --> 00:32:01.270
&gt;&gt; Lukas Ruebbelke: Okay,
back to you my friend.

476
00:32:01.270 --> 00:32:05.080
How do we connect our template and
component class?

477
00:32:05.080 --> 00:32:05.740
&gt;&gt; Speaker 7: Metadata.

478
00:32:05.740 --> 00:32:08.150
&gt;&gt; Lukas Ruebbelke: Metadata, all right.

479
00:32:08.150 --> 00:32:11.450
I'm just throwing you these, we're
playing slow pitch softball right here.

480
00:32:11.450 --> 00:32:12.967
Hit it over the fence, it's easy.

481
00:32:15.160 --> 00:32:18.645
&gt;&gt; Lukas Ruebbelke: So
what are two things a component must have?

482
00:32:21.781 --> 00:32:24.830
&gt;&gt; Speaker 2: Elevator and template URL.

483
00:32:24.830 --> 00:32:25.710
&gt;&gt; Lukas Ruebbelke: Yes, kind of.

484
00:32:25.710 --> 00:32:28.300
So selector and a template.

485
00:32:28.300 --> 00:32:32.814
So you could, as you do template inline,
but it has to have a selector and

486
00:32:32.814 --> 00:32:33.630
a template.

487
00:32:35.318 --> 00:32:36.573
&gt;&gt; Lukas Ruebbelke: And
because of that then,

488
00:32:36.573 --> 00:32:38.690
we essentially have our three main pieces.

489
00:32:38.690 --> 00:32:41.296
Template, it always comes with a class,
and

490
00:32:41.296 --> 00:32:46.109
then the metadata then provides a way for
us to get it into our Angular application.

491
00:32:49.853 --> 00:32:52.617
&gt;&gt; Lukas Ruebbelke: So
I'm coming right back to you.

492
00:32:52.617 --> 00:32:54.936
What's another way to define
a component template?

493
00:32:54.936 --> 00:33:00.579
We have template URL,
what's another way to do this?

494
00:33:00.579 --> 00:33:01.290
&gt;&gt; Speaker 2: Inline?

495
00:33:01.290 --> 00:33:02.626
&gt;&gt; Lukas Ruebbelke: Inline, yes.

496
00:33:05.240 --> 00:33:06.404
&gt;&gt; Speaker 2: Please don't do that.

497
00:33:06.404 --> 00:33:09.000
[LAUGH]
&gt;&gt; Lukas Ruebbelke: So

498
00:33:09.000 --> 00:33:14.440
that actually leads to the question of why
might we use one instead of the other?

499
00:33:14.440 --> 00:33:17.345
Cuz I think there's use cases for both.

500
00:33:20.141 --> 00:33:21.400
&gt;&gt; Speaker 2: Size, simplicity.

501
00:33:21.400 --> 00:33:24.290
&gt;&gt; Lukas Ruebbelke: Yes,
keeping things small, very specific.

502
00:33:25.340 --> 00:33:29.739
So if you're every writing a class, or

503
00:33:29.739 --> 00:33:34.537
a constructor, or really a template, and

504
00:33:34.537 --> 00:33:41.354
you start to realize my goodness,
I'm on line 400.

505
00:33:41.354 --> 00:33:44.178
You probably should stop and realize hey,

506
00:33:44.178 --> 00:33:48.890
this is the canary in the coal mine,
and it just toppled over dead.

507
00:33:48.890 --> 00:33:53.364
That is generally an indication
that something has went wrong and

508
00:33:53.364 --> 00:33:59.074
you have not achieved the appropriate
level of abstraction for your application.

509
00:34:00.868 --> 00:34:01.793
&gt;&gt; Lukas Ruebbelke: And it's just,

510
00:34:01.793 --> 00:34:06.160
on the surface it's really like,
that totally makes sense.

511
00:34:06.160 --> 00:34:08.440
I've just seen it so
many times where somebody's like hey,

512
00:34:08.440 --> 00:34:12.450
will you look at my code, and
can you help me fix this problem?

513
00:34:12.450 --> 00:34:15.368
And you look in their constructor or
their component class, and

514
00:34:15.368 --> 00:34:16.890
it's 1,200 lines of code.

515
00:34:18.923 --> 00:34:21.157
&gt;&gt; Lukas Ruebbelke: And so
hopefully, in that situation,

516
00:34:21.157 --> 00:34:25.910
I can figure out what they're doing,
as in, this line here is wrong.

517
00:34:25.910 --> 00:34:31.340
But, did you know, you have
an architectural problem that's way worse.

518
00:34:31.340 --> 00:34:35.000
And so this is one of the things,
I've mentioned clean code.

519
00:34:35.000 --> 00:34:39.025
But this is one of the things that
Robert Martin really hits on,

520
00:34:39.025 --> 00:34:44.700
is,you want to keep things small,
fine-grained, and very specific.

521
00:34:44.700 --> 00:34:47.783
So this is single-responsibility
principle.

522
00:34:47.783 --> 00:34:52.308
Because when you mix
responsibilities together, and

523
00:34:52.308 --> 00:34:57.027
you need to then repeat some
piece of that responsibility

524
00:34:57.027 --> 00:35:01.640
somewhere else,
you have no way to reuse it.

525
00:35:01.640 --> 00:35:05.800
Then you have to figure out how to
actually abstract that responsibility or

526
00:35:05.800 --> 00:35:09.530
that code out,
that functionality into something else.

527
00:35:10.620 --> 00:35:16.160
Not only that, is when you have code
that's doing more then one thing,

528
00:35:16.160 --> 00:35:16.970
well how do you test it?

529
00:35:18.630 --> 00:35:23.340
If you have a function doing three things,
the only way to test that is,

530
00:35:23.340 --> 00:35:25.540
you have to test all three things.

531
00:35:25.540 --> 00:35:29.530
And you have to test
the possible permutations

532
00:35:29.530 --> 00:35:32.100
that those three things will do.

533
00:35:33.750 --> 00:35:36.370
And so I'll talk about this
more in Reactive Angular.

534
00:35:36.370 --> 00:35:39.890
But really one, you wanna minimize state,

535
00:35:39.890 --> 00:35:44.260
or for complexity,
you need to minimize state.

536
00:35:44.260 --> 00:35:48.010
But in doing so, you need to think about
how to actually minimize the control flow

537
00:35:48.010 --> 00:35:49.245
through your application.

538
00:35:49.245 --> 00:35:53.520
And when you have a function that
internally is doing three things,

539
00:35:53.520 --> 00:35:58.790
that's one, how do you test
the middle thing in isolation?

540
00:35:58.790 --> 00:36:02.310
You can't, because now it's
couples with everything else.

541
00:36:02.310 --> 00:36:06.120
And so even just expanding on this a bit,
I think it's really important,

542
00:36:06.120 --> 00:36:07.980
and you would see this
a lot more in Angular 1,

543
00:36:07.980 --> 00:36:11.830
but keeping imperative logic
out of your templates.

544
00:36:11.830 --> 00:36:17.036
And so I would see things like ngIf a and
b or c or

545
00:36:17.036 --> 00:36:24.170
d equals 123, find out what
you mean to me, or something.

546
00:36:24.170 --> 00:36:30.087
You just see this logic statement, and
it's like, well how do you test that?

547
00:36:30.087 --> 00:36:32.500
How do you possibly
test that bit of logic?

548
00:36:32.500 --> 00:36:36.130
Well you can't,
because it's coupled into the component.

549
00:36:36.130 --> 00:36:39.010
And so what you really want at
the end of the day is small

550
00:36:39.010 --> 00:36:43.880
pieces of code that really do one thing,
with a clear input and output.

551
00:36:43.880 --> 00:36:48.910
So that your method has a component
contract, that when I call this method,

552
00:36:48.910 --> 00:36:54.170
and I put this in, I'm going to
get this out, every single time.

553
00:36:54.170 --> 00:36:59.081
And so this is a high-level
architectural discussion, but

554
00:36:59.081 --> 00:37:04.181
this is why one, I think using
inline templates is a good kind of

555
00:37:04.181 --> 00:37:09.400
a canary in a coal mine for,
are my components specific enough?

556
00:37:11.290 --> 00:37:16.926
Now to flip to the other side,
where would this maybe not be appropriate?

557
00:37:22.840 --> 00:37:26.259
&gt;&gt; Lukas Ruebbelke: So one,
I'll just throw this out here,

558
00:37:26.259 --> 00:37:30.482
is we have somebody,
a designer, a UI designer,

559
00:37:30.482 --> 00:37:36.534
who their primary function is to
build out pixel-perfect HTML in CSS.

560
00:37:38.557 --> 00:37:41.354
&gt;&gt; Lukas Ruebbelke: There are a lot of
moving parts when it comes to Angular 2

561
00:37:41.354 --> 00:37:42.935
specifically.

562
00:37:42.935 --> 00:37:45.605
And it may not be appropriate or

563
00:37:45.605 --> 00:37:50.660
compassionate to subject them
to an Angular 2 workflow.

564
00:37:50.660 --> 00:37:54.813
I just know designers that,
they're great on a tablet drawing or

565
00:37:54.813 --> 00:37:58.990
doing mock ups, and Photoshop is
their jam or really now Sketch.

566
00:37:58.990 --> 00:38:03.489
And then you're like okay what I need
you to do is go install npm and Node.

567
00:38:03.489 --> 00:38:08.550
And then we're gonna do this, and
then we're gonna run the Angular CLI,

568
00:38:08.550 --> 00:38:10.500
and then you need to download WebStorm,
and

569
00:38:10.500 --> 00:38:15.450
then we need to configure your TypeScript
compiler, and you're gonna lose them.

570
00:38:16.480 --> 00:38:23.150
And so I think by using these external
assets, if your workflow is of such,

571
00:38:23.150 --> 00:38:29.990
you can decouple that development
piece from the main workflow.

572
00:38:29.990 --> 00:38:32.090
So that somebody can go,
they can do the templates,

573
00:38:32.090 --> 00:38:35.360
they can deliver them to you,
and you can leave them external.

574
00:38:35.360 --> 00:38:42.370
Or even if you so want, you can then chop
them up yourself, and make them inline.

575
00:38:42.370 --> 00:38:46.360
But that,
your workflow may not support it.

576
00:38:46.360 --> 00:38:49.500
And I think with Angular 1, there was
a really good designer story for that.

577
00:38:49.500 --> 00:38:53.500
Where you could know just enough HTML to
really kind of do some interesting things.

578
00:38:53.500 --> 00:38:56.968
Angular 2 is getting there,
but I think inline templates,

579
00:38:56.968 --> 00:38:58.941
I think that makes it a bit harder.

580
00:39:01.572 --> 00:39:02.660
&gt;&gt; Speaker 2: One quick question.

581
00:39:02.660 --> 00:39:07.260
I understand the style URLs,
where you can have different style sheets.

582
00:39:07.260 --> 00:39:14.080
Can you give a real-world case of
why you'd do multiple right here?

583
00:39:14.080 --> 00:39:15.440
&gt;&gt; Lukas Ruebbelke: So
maybe like a base style sheet?

584
00:39:16.510 --> 00:39:18.360
And then a component-specific style sheet.

585
00:39:19.950 --> 00:39:23.676
&gt;&gt; Speaker 2: Wouldn't the base
be pulled in a lot earlier?

586
00:39:23.676 --> 00:39:29.870
&gt;&gt; Lukas Ruebbelke: Maybe, I mean,
so you may wanna pull it in at the,

587
00:39:29.870 --> 00:39:33.360
let's say you have a smart component,
or a container component.

588
00:39:33.360 --> 00:39:34.850
You have specific for that feature.

589
00:39:36.570 --> 00:39:40.550
But then for this particular thing,
you wanna pull it in very specific.

590
00:39:40.550 --> 00:39:45.762
So it just allows you essentially nth
degree of granularity and control.

591
00:39:54.338 --> 00:39:57.200
&gt;&gt; Lukas Ruebbelke: All right,
let's talk about binding.

592
00:39:57.200 --> 00:40:01.390
What is the easiest way to
bind to a simple text value?

593
00:40:01.390 --> 00:40:06.230
If anybody's done Angular 1,
I expect that they will have this answer.

594
00:40:09.190 --> 00:40:10.650
What's that?

595
00:40:10.650 --> 00:40:11.900
&gt;&gt; Speaker 11: Interpolation.

596
00:40:11.900 --> 00:40:13.600
&gt;&gt; Lukas Ruebbelke: Interpolation, yes.

597
00:40:13.600 --> 00:40:14.500
String interpolation.

598
00:40:16.350 --> 00:40:21.250
So what's the best binding for
sending data to the template?

599
00:40:21.250 --> 00:40:24.290
So they have a property in our class and

600
00:40:24.290 --> 00:40:27.900
we wanna make it available
to our template.

601
00:40:29.000 --> 00:40:31.720
By the way, Rush, you're exactly right,
it's interpolation.

602
00:40:34.020 --> 00:40:39.253
So class to template, which one is that?

603
00:40:39.253 --> 00:40:39.909
What's that?

604
00:40:39.909 --> 00:40:40.823
&gt;&gt; Speaker 12: Property binding.

605
00:40:40.823 --> 00:40:44.229
&gt;&gt; Lukas Ruebbelke: Property binding,
sweet, all right, and

606
00:40:44.229 --> 00:40:47.360
from the template back to the class?

607
00:40:47.360 --> 00:40:49.300
&gt;&gt; Speaker 12: Event binding
&gt;&gt; Lukas Ruebbelke: Event binding.

608
00:40:49.300 --> 00:40:53.080
Man, like one of the most fundamental
things, you guys are nailing it.

609
00:40:53.080 --> 00:40:56.685
All right, so how do we keep
things in sync between both?

610
00:40:56.685 --> 00:40:58.305
&gt;&gt; Speaker 2: [INAUDIBLE] in a box.

611
00:40:58.305 --> 00:41:01.661
&gt;&gt; Lukas Ruebbelke: I
heard a banana in a box.

612
00:41:01.661 --> 00:41:07.142
[LAUGH] Yes, it is a,
&gt;&gt; Lukas Ruebbelke: Banana in a box,

613
00:41:07.142 --> 00:41:08.700
or to a data binding.

614
00:41:08.700 --> 00:41:11.846
So the question is,
what is actually happening here?

615
00:41:16.944 --> 00:41:19.175
&gt;&gt; Lukas Ruebbelke: So again,
What do the brackets mean?

616
00:41:19.175 --> 00:41:21.073
&gt;&gt; Speaker 12: Property value.

617
00:41:21.073 --> 00:41:22.675
&gt;&gt; Lukas Ruebbelke: Parentheses?

618
00:41:22.675 --> 00:41:24.588
&gt;&gt; Speaker 12: [INAUDIBLE] data binding.

619
00:41:24.588 --> 00:41:27.323
&gt;&gt; Lukas Ruebbelke: And
if one sends from template to class and

620
00:41:27.323 --> 00:41:31.716
class to template, and
we combine them together, as I've said.

621
00:41:31.716 --> 00:41:35.928
Two one way streets side by side
is really just a two way street.

622
00:41:35.928 --> 00:41:39.130
And so this is what we're doing.

623
00:41:39.130 --> 00:41:45.080
So to that end, on ngModel,

624
00:41:45.080 --> 00:41:49.490
if you took out the parenthesis,
it would just be one way.

625
00:41:49.490 --> 00:41:55.410
You would set the property but there'd be
no way to set it back to the thing and

626
00:41:55.410 --> 00:42:00.090
so that's what actually
using the parentheses does.

627
00:42:01.820 --> 00:42:03.450
&gt;&gt; Speaker 13: So
is that really a convenience method?

628
00:42:03.450 --> 00:42:06.780
You can do the same thing by having
separate property and event bindings?

629
00:42:07.950 --> 00:42:09.190
&gt;&gt; Lukas Ruebbelke: You can.

630
00:42:09.190 --> 00:42:15.410
So for instance, you could do input and
capture that within that.

631
00:42:15.410 --> 00:42:19.320
Say value, whatever you want it to be.

632
00:42:19.320 --> 00:42:23.380
Like my value equals event.value.

633
00:42:23.380 --> 00:42:27.770
And so you can very much separate
those out and have them side by side.

634
00:42:27.770 --> 00:42:29.410
So it's just a convenience method.

635
00:42:29.410 --> 00:42:34.890
With ngModel, basically picking
up on text input, I believe.

636
00:42:34.890 --> 00:42:38.120
So as you type, it's actually
internally capturing that event and

637
00:42:38.120 --> 00:42:38.800
then surfacing it.

638
00:42:40.240 --> 00:42:42.830
And we'll revisit this concept

639
00:42:42.830 --> 00:42:46.740
in component driven architecture when we
start talking about inputs and outputs.

640
00:42:46.740 --> 00:42:49.650
Because I suspect I haven't done it.

641
00:42:49.650 --> 00:42:51.720
So you can actually do
custom two way data binding.

642
00:42:53.230 --> 00:43:00.260
To where we could pick any property,
or any attribute, and make it two way.

643
00:43:00.260 --> 00:43:04.850
There's a way to do that, and in doing so,
I'm pretty certain that I could

644
00:43:04.850 --> 00:43:09.990
actually write ngModel from scratch, if I
wanted, so just something to think about.

645
00:43:12.760 --> 00:43:16.338
Okay,
&gt;&gt; Lukas Ruebbelke: I'm bringing this

646
00:43:16.338 --> 00:43:20.180
diagram up because we're going to
revisit this heavily in the next module.

647
00:43:21.450 --> 00:43:25.520
So on your left hand side,

648
00:43:25.520 --> 00:43:29.310
so stage left, or I don't even
know how that works, never mind.

649
00:43:29.310 --> 00:43:32.958
So template to class,
what binding goes there?

650
00:43:37.913 --> 00:43:39.742
&gt;&gt; Lukas Ruebbelke: And
from class to template?

651
00:43:42.959 --> 00:43:48.611
&gt;&gt; Lukas Ruebbelke: Property, yes.

652
00:43:48.611 --> 00:43:50.970
Very good, okay.

653
00:43:50.970 --> 00:43:51.470
So what is this?

654
00:43:53.832 --> 00:43:55.077
&gt;&gt; Speaker 13: Interpolation.

655
00:43:55.077 --> 00:43:56.630
&gt;&gt; Lukas Ruebbelke: Interpolation.

656
00:43:56.630 --> 00:43:58.050
What do we have here?

657
00:43:58.050 --> 00:43:59.150
&gt;&gt; Speaker 13: Property binding.

658
00:43:59.150 --> 00:44:00.240
&gt;&gt; Lukas Ruebbelke: Property binding,
yeah a lot.

659
00:44:00.240 --> 00:44:02.270
Don't they have a class?

660
00:44:02.270 --> 00:44:02.920
What do we have here?

661
00:44:02.920 --> 00:44:05.970
This side of the room, you're banned for
the next two questions.

662
00:44:05.970 --> 00:44:08.120
Over here.
&gt;&gt; Speaker 14: Event binding.

663
00:44:08.120 --> 00:44:08.750
&gt;&gt; Lukas Ruebbelke: Event binding.

664
00:44:09.960 --> 00:44:15.080
So you're super quiet but I wager you
are way ahead of us right now so.

665
00:44:15.080 --> 00:44:16.100
Event binding.

666
00:44:16.100 --> 00:44:18.230
Yes, he sure can hear it.

667
00:44:18.230 --> 00:44:20.520
All right,
I'm no longer fooled by that ruse.

668
00:44:20.520 --> 00:44:23.972
And what do we have here?

669
00:44:25.616 --> 00:44:26.800
&gt;&gt; Speaker 15: Two way.

670
00:44:26.800 --> 00:44:29.960
&gt;&gt; Lukas Ruebbelke: Two way binding, yes.

671
00:44:29.960 --> 00:44:33.460
&gt;&gt; Speaker 3: Martin is asking in the chat
room, could you give an example of when

672
00:44:33.460 --> 00:44:39.000
you would use a property squares
instead of a value, curly braces?

673
00:44:41.330 --> 00:44:42.736
&gt;&gt; Lukas Ruebbelke: So the question is,

674
00:44:42.736 --> 00:44:47.056
when would you use a property
binding versus interpolation?

675
00:44:47.056 --> 00:44:51.785
&gt;&gt; Speaker 3: He just came back and
said you didn't explain it, so sorry.

676
00:44:51.785 --> 00:44:56.078
&gt;&gt; Lukas Ruebbelke: Yep, so it's worth
mentioning because they do talk about this

677
00:44:56.078 --> 00:45:00.857
specifically in the Angular docs is that,
there are times when you can

678
00:45:00.857 --> 00:45:05.069
use them both but generally for
kind of simple string values,

679
00:45:05.069 --> 00:45:10.890
like I have an H1 tag and I wanna put
something in, I'll just do interpolation.

680
00:45:10.890 --> 00:45:17.320
But anything that really can
update over time or is dynamic or

681
00:45:17.320 --> 00:45:20.920
is going to be a property on the element
itself, then I use property binding.

682
00:45:24.300 --> 00:45:30.900
Alright, so
how do components in directive differ?

683
00:45:30.900 --> 00:45:35.815
This is for all my one.x homies that are
coming to Angular 2 for the first time,

684
00:45:35.815 --> 00:45:39.635
that always comes up like, what's
the difference between a component and

685
00:45:39.635 --> 00:45:41.200
a directive?

686
00:45:41.200 --> 00:45:43.790
&gt;&gt; Speaker 2: Doesn't have a template.

687
00:45:43.790 --> 00:45:45.704
&gt;&gt; Lukas Ruebbelke: Yes,
I mean, that is at the core.

688
00:45:50.082 --> 00:45:53.440
&gt;&gt; Lukas Ruebbelke: Directives
do not have templates.

689
00:45:53.440 --> 00:45:58.150
They are only there to
modify existing elements.

690
00:45:58.150 --> 00:45:59.370
Yep, Russ, you got it.

691
00:45:59.370 --> 00:46:00.789
No templates in directives.

692
00:46:04.372 --> 00:46:05.920
&gt;&gt; Lukas Ruebbelke: So
this is an interesting question.

693
00:46:07.440 --> 00:46:09.102
How is a service like a component?

694
00:46:14.859 --> 00:46:17.640
&gt;&gt; Speaker 2: It's a class
wrap with metadata.

695
00:46:17.640 --> 00:46:20.350
&gt;&gt; Lukas Ruebbelke: Boom, nailed it.

696
00:46:20.350 --> 00:46:21.700
It's like that song, C is for cookie?

697
00:46:22.800 --> 00:46:25.910
The C is for class and
that's good enough for me, okay?

698
00:46:27.670 --> 00:46:29.630
There's a few more things in here.

699
00:46:31.010 --> 00:46:32.680
So at a high level,
that's absolutely right.

700
00:46:32.680 --> 00:46:34.330
Like the shape is almost identical.

701
00:46:34.330 --> 00:46:36.910
What about the constructor?

702
00:46:40.180 --> 00:46:42.940
Dependency injection is just the same,
it's exactly the same?

703
00:46:44.190 --> 00:46:47.190
Methods and properties, exactly the same?

704
00:46:47.190 --> 00:46:55.220
I would say really the main difference
between a component, wait a second.

705
00:46:55.220 --> 00:46:55.950
How are the different?

706
00:46:55.950 --> 00:46:58.280
I'm not going to answer
my own question now.

707
00:46:58.280 --> 00:47:02.290
There's one kind of specific thing I
think that really sets them apart.

708
00:47:02.290 --> 00:47:05.062
But other than that,
other than the metadata,

709
00:47:05.062 --> 00:47:07.773
I think they're almost indistinguishable.

710
00:47:12.847 --> 00:47:17.240
&gt;&gt; Lukas Ruebbelke: What do components
have happening under the hood that we

711
00:47:17.240 --> 00:47:18.460
can hook into?

712
00:47:18.460 --> 00:47:18.960
&gt;&gt; Speaker 2: Events?

713
00:47:21.420 --> 00:47:24.190
&gt;&gt; Lukas Ruebbelke: Events,
lifecycle hooks, that's the difference.

714
00:47:24.190 --> 00:47:28.640
The reason why we have those is because
when a component is added to the DOM, or

715
00:47:28.640 --> 00:47:31.480
taken from the DOM and
is being initialized there's kind of

716
00:47:31.480 --> 00:47:37.370
this sequence of events that needs
to happen that we can then tap into.

717
00:47:37.370 --> 00:47:39.640
Whereas a service,
because it never lives in the DOM,

718
00:47:40.900 --> 00:47:44.880
the only really event that we need
to know about is the constructor.

719
00:47:44.880 --> 00:47:48.140
Has the service been instantiated?

720
00:47:48.140 --> 00:47:50.030
But after that,
its methods and properties.

721
00:47:50.030 --> 00:47:54.380
And even to that point,
component lifecycle hooks are really just

722
00:47:54.380 --> 00:47:57.230
methods that implicitly
get called by Angular.

723
00:47:58.730 --> 00:47:59.652
And it's that simple.

724
00:48:04.902 --> 00:48:08.802
&gt;&gt; Lukas Ruebbelke: So apparently I just
accidentally answered a question in, or

725
00:48:08.802 --> 00:48:12.630
rather yeah, I actually did
answer a question in the chat.

726
00:48:12.630 --> 00:48:16.460
So that's the difference really, it's
because services do not live in the DOM,

727
00:48:16.460 --> 00:48:20.080
they don't really have that component
lifecycle that components have.

