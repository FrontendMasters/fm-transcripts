WEBVTT

1
00:00:00.110 --> 00:00:03.560
&gt;&gt; Francesca Sadikin: So
what is considered quality code?

2
00:00:03.560 --> 00:00:07.169
When I was learning how to code,
I knew my code sucked, but

3
00:00:07.169 --> 00:00:11.369
I thought I was going to learn what
quality code looked like when I was

4
00:00:11.369 --> 00:00:15.460
joining a big company and
I was gonna be paid to code.

5
00:00:15.460 --> 00:00:20.141
But you might be surprised that
the code you see in companies, big and

6
00:00:20.141 --> 00:00:23.299
small, can sometimes suck for
many reasons.

7
00:00:23.299 --> 00:00:27.273
So you can't use what you see
as a good pattern to copy.

8
00:00:27.273 --> 00:00:31.854
So this is my question for you all,
what is considered quality code?

9
00:00:31.854 --> 00:00:34.753
&gt;&gt; Speaker 2: It meets the user's needs,
&gt;&gt; Francesca Sadikin: Meets the user's

10
00:00:34.753 --> 00:00:35.603
need, okay?

11
00:00:38.629 --> 00:00:45.011
&gt;&gt; Speaker 2: Somewhat flexible to
expanding use cases, its performance.

12
00:00:45.011 --> 00:00:48.968
&gt;&gt; Francesca Sadikin: Yes, are these your
answers or [LAUGH] answers for this?

13
00:00:48.968 --> 00:00:51.391
&gt;&gt; Speaker 2: Yeah, they're my answers.

14
00:00:51.391 --> 00:00:53.154
It's subjective, right?

15
00:00:53.154 --> 00:00:54.488
&gt;&gt; Francesca Sadikin: It's subjective,
okay.

16
00:00:54.488 --> 00:00:57.538
&gt;&gt; Speaker 2: Yeah, so different people
have different opinions on it, but.

17
00:00:59.448 --> 00:01:00.234
Yeah, I think,

18
00:01:00.234 --> 00:01:03.948
the first thing that Mark said was good
where does it solve the problem at hand.

19
00:01:03.948 --> 00:01:06.051
&gt;&gt; Francesca Sadikin: Yes,
definitely important.

20
00:01:06.051 --> 00:01:08.338
&gt;&gt; Speaker 2: I'll read a few from online.

21
00:01:08.338 --> 00:01:12.194
&gt;&gt; Speaker 3: I think the very first
thing is, he has to solve the problem.

22
00:01:12.194 --> 00:01:16.475
And then the second thing is,
he has to be readable.

23
00:01:16.475 --> 00:01:19.396
You have to comment it out so
that people can see what you're doing.

24
00:01:19.396 --> 00:01:22.684
Other people can work on your code.

25
00:01:22.684 --> 00:01:24.354
&gt;&gt; Speaker 2: Yeah, that's online.

26
00:01:24.354 --> 00:01:29.034
Folks said, self-documenting,
easy to understand by a new person,

27
00:01:29.034 --> 00:01:32.784
not spaghetti like logic,
jumping around everywhere.

28
00:01:35.184 --> 00:01:42.304
They're a lot focused on writing
code that will be read by people.

29
00:01:42.304 --> 00:01:46.050
It's easy to read,
maintain, and extend, yeah.

30
00:01:46.050 --> 00:01:49.966
&gt;&gt; Francesca Sadikin: That's a lot
of- Yes, a lot of great answers, and

31
00:01:49.966 --> 00:01:54.169
I hear the answer that I was
going to give also in there.

32
00:01:55.559 --> 00:02:00.947
So essential I believe that at the heart
of it, code is going to change.

33
00:02:00.947 --> 00:02:05.684
So good quality code, good code and
I heard this answer as well,

34
00:02:05.684 --> 00:02:10.688
it's maintainable code,
which means it's easy to keep stable and

35
00:02:10.688 --> 00:02:14.797
it's easy to change, so it's extendable.

36
00:02:14.797 --> 00:02:20.562
So I think that tactics such as readable
code, unit tests, performing code and

37
00:02:20.562 --> 00:02:26.113
all of it, of course, solving
the real requirements that was given.

38
00:02:26.113 --> 00:02:29.293
These are all techniques to
make it more maintainable.

39
00:02:29.293 --> 00:02:33.103
Maintainable code is also often simple and
straightforward.

40
00:02:33.103 --> 00:02:37.945
So readable code will always trump clever
code that is somewhat unreadable in

41
00:02:37.945 --> 00:02:42.788
a professional setting because it just
makes it easier for others to come in,

42
00:02:42.788 --> 00:02:47.103
quickly understand what's happening and
make modifications.

43
00:02:47.103 --> 00:02:48.610
Let's not forget,

44
00:02:48.610 --> 00:02:54.469
working code is always going to be more
important than clean and perfect code.

45
00:02:54.469 --> 00:02:57.768
And balancing the delivery of features and

46
00:02:57.768 --> 00:03:03.171
accruing technicals that is a delicate
balance that every company and

47
00:03:03.171 --> 00:03:06.845
every team will be engaging
in moving forward.

48
00:03:06.845 --> 00:03:11.098
So here's just a little rundown
of some clean code basics.

49
00:03:11.098 --> 00:03:15.262
A lot of these I learned through
this book called Clean Code,

50
00:03:15.262 --> 00:03:19.672
a Handbook of Agile Software Craftsmanship
by Robert C Martin,

51
00:03:19.672 --> 00:03:23.202
I think that's a very popular book for
engineers.

52
00:03:23.202 --> 00:03:27.438
But for a few of you who may
not have seen that before,

53
00:03:27.438 --> 00:03:33.890
just a few tactics are to use descriptive
naming, lean into maybe even longer,

54
00:03:33.890 --> 00:03:38.149
more descriptive naming
versus very vague things.

55
00:03:38.149 --> 00:03:43.132
Writing decoupled code, so that just means
that different parts of your code base

56
00:03:43.132 --> 00:03:46.754
are independent and
don't rely too heavily on each other.

57
00:03:46.754 --> 00:03:50.981
Essentially, it helps you avoid a tangled
mess where changing one part breaks

58
00:03:50.981 --> 00:03:52.854
everything else.

59
00:03:52.854 --> 00:03:55.974
Follow the single
responsibility principle.

60
00:03:55.974 --> 00:04:00.175
That's a very fancy way of just saying
that whatever size of code you're working

61
00:04:00.175 --> 00:04:03.203
with, whether it's functions or
modules or libraries,

62
00:04:03.203 --> 00:04:06.793
each one should hopefully
have a single responsibility.

63
00:04:06.793 --> 00:04:10.153
Again, makes it easier for
people to understand what this should do.

64
00:04:11.303 --> 00:04:16.018
Having a clear organization of code
that applies to the way you're

65
00:04:16.018 --> 00:04:21.378
organizing your code and
then also maybe in your folder hierarchy.

66
00:04:21.378 --> 00:04:26.167
My little rule that I follow is that
things that change together should stay

67
00:04:26.167 --> 00:04:27.428
together.

68
00:04:27.428 --> 00:04:31.890
So, for example, you have a React
component, all of its tests and

69
00:04:31.890 --> 00:04:35.795
helper functions should stay
in the same directory as it,

70
00:04:35.795 --> 00:04:39.593
that just makes it easier for
engineers coming in.

71
00:04:39.593 --> 00:04:43.634
When they make a change here, they can
quickly check the related files to make

72
00:04:43.634 --> 00:04:47.253
sure that there's nothing else
that's gonna break unexpectedly.

73
00:04:49.163 --> 00:04:52.242
Using comments appropriately, so

74
00:04:52.242 --> 00:04:58.659
comments should describe why the code
is there and not what and how.

75
00:04:58.659 --> 00:05:03.346
Because ideally the code should be
readable enough that people can

76
00:05:03.346 --> 00:05:05.025
read what's going on.

77
00:05:05.025 --> 00:05:10.555
The other reason is that when you describe
what and how when people refactor

78
00:05:10.555 --> 00:05:15.908
their code, it's very easy for
them to forget to update the comments and

79
00:05:15.908 --> 00:05:20.501
now we just have a very confusing
thing for future engineers.

80
00:05:20.501 --> 00:05:24.035
Avoiding code duplication,
so this one's kind obvious.

81
00:05:24.035 --> 00:05:29.967
If you copy and paste things multiple
places, it's very prone to human error,

82
00:05:29.967 --> 00:05:35.471
you're gonna forget to update things
in all the different pace, right?

83
00:05:35.471 --> 00:05:38.438
And depending on your company culture,

84
00:05:38.438 --> 00:05:43.161
you should also be adding test
coverage and writing good tests.

85
00:05:43.161 --> 00:05:48.328
So a huge part of writing
maintainable code is writing tests.

86
00:05:48.328 --> 00:05:52.420
So we're gonna talk about one of the
biggest strengths in my own software skill

87
00:05:52.420 --> 00:05:57.458
set that helps me deliver good quality
work, which is test driven development.

88
00:05:57.458 --> 00:06:00.403
If you don't know anything
about test-driven development.

89
00:06:00.403 --> 00:06:05.276
Essentially, it just means you start with
test before you write the feature code.

90
00:06:05.276 --> 00:06:08.541
And so what that would look
like in a process is that.

91
00:06:08.541 --> 00:06:13.827
Let's say you had a big project, you're
gonna break that down into different

92
00:06:13.827 --> 00:06:18.794
conditions, and then so you're going
to start with a single condition,

93
00:06:18.794 --> 00:06:24.505
write a failing test for it, and then make
that test pass by writing the source code.

94
00:06:24.505 --> 00:06:28.712
And then you just repeat this process
over and over and over again, and

95
00:06:28.712 --> 00:06:33.350
every time you see an opportunity to
refactor because a pattern has emerged,

96
00:06:33.350 --> 00:06:37.563
that's when you refactor, and
then you do this until it's done.

97
00:06:37.563 --> 00:06:39.263
So that's really all it is.

