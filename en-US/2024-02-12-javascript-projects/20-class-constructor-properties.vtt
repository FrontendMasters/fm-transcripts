WEBVTT

1
00:00:00.150 --> 00:00:07.168
To recap what we discussed earlier,
we have this class keyword now,

2
00:00:07.168 --> 00:00:12.129
since I believe 2015 or so, in JavaScript,

3
00:00:12.129 --> 00:00:19.915
that provides that nice kind of more
familiar-feeling way of declension.

4
00:00:19.915 --> 00:00:25.305
layering kinds of objects in
a sense that's more similar

5
00:00:25.305 --> 00:00:31.143
to how they might be defined in
languages like Java or the other

6
00:00:31.143 --> 00:00:37.908
kind of classical inheritance-based
object-oriented languages.

7
00:00:37.908 --> 00:00:40.536
So, just to review some syntax.

8
00:00:40.536 --> 00:00:44.339
When we want to declare a new
class like a meme, for example,

9
00:00:44.339 --> 00:00:47.336
very important class to
have in your programs.

10
00:00:48.726 --> 00:00:54.626
We want to have a will have the class, the
name of the class capitalized convention

11
00:00:54.626 --> 00:01:00.153
and then the curly braces kind of define
what's gonna belong to this class.

12
00:01:00.153 --> 00:01:04.330
So we have a constructor method
always that is going to set

13
00:01:04.330 --> 00:01:07.202
up some properties on the this object,

14
00:01:07.202 --> 00:01:12.437
which is going to be the instance
object when we instantiate the class.

15
00:01:12.437 --> 00:01:18.053
Which we can do with the new keyword,
just like we did with new date.

16
00:01:18.053 --> 00:01:22.853
So same vibes and in this case we
can make a fancy pool meme and

17
00:01:22.853 --> 00:01:27.571
fancy pool will be super fancy and
everyone will be happy.

18
00:01:27.571 --> 00:01:28.722
Great.

19
00:01:28.722 --> 00:01:33.780
Okay, so again just reviewing we can
also define instance methods by,

20
00:01:33.780 --> 00:01:36.917
we don't have to use the function keyword.

21
00:01:36.917 --> 00:01:40.261
We can just type the name of the function,
any arguments it takes in and

22
00:01:40.261 --> 00:01:42.199
then define whatever we wanted it to do.

23
00:01:42.199 --> 00:01:47.197
So, for example, I can make poo laugh,
with a lull method,

24
00:01:47.197 --> 00:01:51.614
which very helpfully logs
to the console.lololol.

25
00:01:51.614 --> 00:01:54.455
So this is just an example obviously, but

26
00:01:54.455 --> 00:01:58.280
we can define whatever instance
methods we need there.

27
00:01:58.280 --> 00:02:05.002
And we can also override methods of, let's
say, the kind of built-in to two-string,

28
00:02:05.002 --> 00:02:11.473
or anything that might come from a parent
class, because we can also extend classes.

29
00:02:11.473 --> 00:02:16.191
Get to that in a second but
we an essentially

30
00:02:16.191 --> 00:02:21.974
intercept that prototype chain,
lookups here.

31
00:02:21.974 --> 00:02:27.351
Again, every object is going to ultimately
have at the top of its food chain or

32
00:02:27.351 --> 00:02:34.384
prototype chain, it's going to have object
to object, everybody's favorite object.

33
00:02:34.384 --> 00:02:36.504
And so those methods like to string and

34
00:02:36.504 --> 00:02:41.089
whatnot we can override and if there are
other prototypes up the prototype chain.

35
00:02:41.089 --> 00:02:45.902
We can also override those as well by
declaring whatever instance methods we

36
00:02:45.902 --> 00:02:46.661
need here.

37
00:02:47.831 --> 00:02:51.111
And again, we use that this
keyword to refer to the instance.

38
00:02:52.451 --> 00:02:57.355
So that's how we get this
particular memes text.

39
00:02:59.106 --> 00:03:02.561
Okay, one thing we also might encounter,
and

40
00:03:02.561 --> 00:03:07.699
this will be familiar to folks who
have worked with other languages,

41
00:03:07.699 --> 00:03:11.529
again, like the more
traditional OOP languages.

42
00:03:11.529 --> 00:03:14.762
Is that we can declare getter and

43
00:03:14.762 --> 00:03:19.796
setter functions that
JavaScript will basically

44
00:03:19.796 --> 00:03:24.705
use to pretend that an object
has a property that I

45
00:03:24.705 --> 00:03:29.879
can access with the dot
notation that I'm used to.

46
00:03:30.929 --> 00:03:36.159
So if I have a, let's say,
a more complicated property that

47
00:03:36.159 --> 00:03:42.434
needs a little processing, or maybe I
want to do some kind of check on it.

48
00:03:42.434 --> 00:03:47.998
I can define a get and
a set with these little keywords function

49
00:03:47.998 --> 00:03:53.563
that is the name of the property
that I want it to have.

50
00:03:53.563 --> 00:04:00.652
And then I will be able to
access fancypoo.imageType.

51
00:04:00.652 --> 00:04:05.779
And it will give me the return value,
for example, in this case,

52
00:04:05.779 --> 00:04:10.722
were splitting out the name of
the image path to separate it into

53
00:04:10.722 --> 00:04:14.661
the name of the file and
the extension of the file.

54
00:04:14.661 --> 00:04:19.088
And so if I try to access imgType,
it will spit out the,

55
00:04:19.088 --> 00:04:25.825
In just the jpg part of this file, so for
example, this is a tiny example of course,

56
00:04:25.825 --> 00:04:29.899
but you can have kind of
more complex operations.

57
00:04:29.899 --> 00:04:34.678
You can expose data from instance
objects through a property

58
00:04:34.678 --> 00:04:39.089
that is indirectly accessed
through the dot notation.

59
00:04:39.089 --> 00:04:43.137
So you can do a little processing you
can do some checks X, for example.

60
00:04:43.137 --> 00:04:46.376
And we can also, with the sector,

61
00:04:46.376 --> 00:04:51.937
we can use that to assign
a new value to the property.

62
00:04:51.937 --> 00:04:55.904
And under the hood,
JavaScript is going back and

63
00:04:55.904 --> 00:04:58.817
doing whatever else it needs to do.

64
00:04:58.817 --> 00:05:02.452
So in this case, it's actually
going into the image property and

65
00:05:02.452 --> 00:05:05.904
also updating that because of
the way that we've set this up.

66
00:05:05.904 --> 00:05:11.453
So if I assign a new value,
like PNG to the image type property,

67
00:05:11.453 --> 00:05:17.213
then later when I want to look up
the value of the image property and

68
00:05:17.213 --> 00:05:19.119
not just image type.

69
00:05:19.119 --> 00:05:21.728
I will see that, okay,
we've done some processing,

70
00:05:21.728 --> 00:05:25.473
we've messed with the data
of this particular instance.

71
00:05:25.473 --> 00:05:30.547
So for those more used to
kind of that mental model of

72
00:05:30.547 --> 00:05:35.857
protecting the good old
encapsulation idea of trying

73
00:05:35.857 --> 00:05:40.702
to protect the internals
of the object from use.

74
00:05:40.702 --> 00:05:46.454
By whoever out there in the world randos
on the Internet, we can't have that.

75
00:05:46.454 --> 00:05:48.617
So if there's any processing or

76
00:05:48.617 --> 00:05:53.112
any secret kind of data that needs
to be used or anything like that.

77
00:05:53.112 --> 00:05:58.330
That can be put in these kind of fancier
getter-setter methods, which then

78
00:05:58.330 --> 00:06:03.973
expose whatever data you want to users as
if it was a regular JavaScript property.

79
00:06:03.973 --> 00:06:07.845
So full extra fanciness
a little tuxedo for us.

80
00:06:07.845 --> 00:06:13.100
Okay another thing that,
again sometimes might be useful for

81
00:06:13.100 --> 00:06:19.985
that encapsulation idea that is coming
from object-oriented programming is.

82
00:06:19.985 --> 00:06:24.975
Sometimes you want private
data that only can be

83
00:06:24.975 --> 00:06:29.843
accessed from internal
processing functions

84
00:06:29.843 --> 00:06:34.882
within this object, within this class.

85
00:06:34.882 --> 00:06:41.400
So, for example, I can have
a private property called image.

86
00:06:41.400 --> 00:06:45.856
I can make my image property
private by putting the hash symbol,

87
00:06:45.856 --> 00:06:51.790
pound, whatever we call it these days,
in front of the property name.

88
00:06:51.790 --> 00:06:53.765
And JavaScript interprets that specially.

89
00:06:53.765 --> 00:06:56.703
And note, this is not like in quotes,
in a string.

90
00:06:56.703 --> 00:07:02.270
This is actually, we're just, .pound,
is what we're typing when we access

91
00:07:02.270 --> 00:07:08.250
this property, and that is only going
to work within this class definition.

92
00:07:08.250 --> 00:07:12.689
So, if I try and
access that on an instance object,

93
00:07:12.689 --> 00:07:17.253
uh-uh, JavaScript says,
uh-uh, not allowed.

94
00:07:17.253 --> 00:07:20.568
So, let's see how this works, and
it's the same for methods as well.

95
00:07:20.568 --> 00:07:25.018
Well, so for
example here I've updated the constructor.

96
00:07:25.018 --> 00:07:30.097
So now we're keeping the image a secret
and we've made it private property.

97
00:07:30.097 --> 00:07:32.614
And one other note is that you need to so

98
00:07:32.614 --> 00:07:37.727
we saw earlier that you can declare which
properties an object is gonna have on

99
00:07:37.727 --> 00:07:43.607
that above that construct line at
the beginning of the class declaration.

100
00:07:43.607 --> 00:07:47.067
You don't have to if there
are public properties,

101
00:07:47.067 --> 00:07:50.295
JavaScript all just figure
it out expose them.

102
00:07:50.295 --> 00:07:52.221
But for private properties,

103
00:07:52.221 --> 00:07:57.074
you do need to declare them up there
before the constructor definition, so

104
00:07:57.074 --> 00:08:02.324
that then you can use them in the rest of
your methods including the constructor.

105
00:08:02.324 --> 00:08:06.763
So just one note there, and
this one might be missing the whisper,

106
00:08:06.763 --> 00:08:09.731
[LAUGH] which was added later, the yeah.

107
00:08:09.731 --> 00:08:16.002
Again, the getters and setters then
could expose that private data,

108
00:08:16.002 --> 00:08:20.571
that private property,
by pulling that data in and

109
00:08:20.571 --> 00:08:26.038
then returning whatever, or
doing the set operation.

110
00:08:26.038 --> 00:08:31.980
And so in this case, we've got
an image property via these getter and

111
00:08:31.980 --> 00:08:36.796
setter functions so
that a user is gonna be able to access

112
00:08:36.796 --> 00:08:41.214
this data by .image and
not .hashimage emerged.

113
00:08:42.864 --> 00:08:47.403
Anyway, so
this is how we can kind of use that

114
00:08:47.403 --> 00:08:52.576
secret data private
properties within our code.

115
00:08:52.576 --> 00:08:53.514
And okay, sorry.

116
00:08:53.514 --> 00:08:57.237
And yes, the same works for methods.

117
00:08:57.237 --> 00:09:01.742
For example, I can have a public method
that's like, yelling what the text is in

118
00:09:01.742 --> 00:09:06.592
uppercase, but I could also have a private
method that's just secretly whispering.

119
00:09:07.802 --> 00:09:11.926
And this is just called once
in the constructor, but

120
00:09:11.926 --> 00:09:17.472
this will only be able to be called
from within this class definition.

121
00:09:19.502 --> 00:09:25.018
Okay so what this all means for
your user of your beautifully laid out,

122
00:09:25.018 --> 00:09:29.974
very well thought out API of
this object that you've created,

123
00:09:29.974 --> 00:09:34.574
that's very important because
people need their memes.

124
00:09:34.574 --> 00:09:37.148
Isn't that what we're building the web for
anyway?

125
00:09:37.148 --> 00:09:41.587
It's basically a meme hosting
cat GIF hosting solution.

126
00:09:42.647 --> 00:09:45.906
So, okay, so
if we now have our fancy poo and

127
00:09:45.906 --> 00:09:49.974
we try to access the .image
property doesn't exist.

128
00:09:49.974 --> 00:09:53.746
And if I try to access
the private hash image property,

129
00:09:53.746 --> 00:09:56.780
I actually get an error
JavaScript like no,

130
00:09:56.780 --> 00:10:01.768
not only like that image is image
without the hash is undefined.

131
00:10:01.768 --> 00:10:04.828
So regular JavaScript
undefines everywhere.

132
00:10:04.828 --> 00:10:09.148
But the hash image will give an error if
I'm trying to access it outside of that

133
00:10:09.148 --> 00:10:10.348
class declaration.

134
00:10:12.028 --> 00:10:18.009
However, because of those getter and
setters, I can access the .image property.

135
00:10:18.009 --> 00:10:23.751
And I can set a new value,
thanks to my setter function, which then,

136
00:10:23.751 --> 00:10:30.095
internally, the class declaration is
telling itself how to process that.

137
00:10:30.095 --> 00:10:34.249
And how to use the private property under
the hood, but it stays under the hood.

138
00:10:34.249 --> 00:10:39.042
I only expose what I want via
that public property image.

139
00:10:39.042 --> 00:10:42.725
I'm just emphasizing
the difference [LAUGH] here.

140
00:10:42.725 --> 00:10:47.629
And likewise, for methods, hash
whisper won't work, I'll get an error,

141
00:10:47.629 --> 00:10:50.635
but I can yell from just anywhere.

142
00:10:50.635 --> 00:10:52.525
Maybe it should have been reversed, but

143
00:10:52.525 --> 00:10:56.036
this is why we have to be thoughtful about
what we expose [LAUGH] to our users.

144
00:10:56.036 --> 00:11:01.335
In any case, okay so for those folks
coming from that more object oriented

145
00:11:01.335 --> 00:11:06.646
paradigm, where we have concepts like
encapsulation where the idea is.

146
00:11:06.646 --> 00:11:12.606
Do you want the object to expose
an interface, to users that abstracts away

147
00:11:12.606 --> 00:11:19.291
whatever internal mechanisms are going
on under the hood to make it work?

148
00:11:19.291 --> 00:11:24.450
And so that's kind of a big, a big mood
[LAUGH] in object-oriented programming and

149
00:11:24.450 --> 00:11:29.387
JavaScript now, again, with that
interesting kind of circular influence of

150
00:11:29.387 --> 00:11:32.181
the Java language throughout the decades.

151
00:11:32.181 --> 00:11:35.929
Not just Java, but
similar languages as well,

152
00:11:35.929 --> 00:11:40.905
allows us to do that now with
this hash private property stuff.

