WEBVTT

1
00:00:00.148 --> 00:00:04.117
&gt;&gt; Kyle Simpson: A third way for a
function to be called is with the .call or

2
00:00:04.117 --> 00:00:05.616
the .apply method.

3
00:00:05.616 --> 00:00:10.606
Look at line 9, I'm calling foo, but
actually calling it using foo.call.

4
00:00:10.606 --> 00:00:12.266
I could have said foo.apply, as well.

5
00:00:12.266 --> 00:00:17.299
You'll notice that the first
argument passed to both call and

6
00:00:17.299 --> 00:00:22.729
apply is used as the this-binding for
that function invocation.

7
00:00:22.729 --> 00:00:26.817
So here, we are explicitly saying,
call foo and

8
00:00:26.817 --> 00:00:32.006
use obj as its this-context.
&gt;&gt; Kyle Simpson: Which

9
00:00:32.006 --> 00:00:37.055
is why we get bar2.
&gt;&gt; Kyle Simpson: That's a third way for

10
00:00:37.055 --> 00:00:38.210
a function to be called.

11
00:00:39.870 --> 00:00:41.840
So three rules down, default rule,

12
00:00:41.840 --> 00:00:44.420
implicit binding rule,
explicit binding rule.

13
00:00:45.620 --> 00:00:50.330
We're gonna take a slight detour and talk
about a variation of explicit binding,

14
00:00:50.330 --> 00:00:53.030
which is a problem that we often run into.

15
00:00:53.030 --> 00:00:56.790
You may have run into this before,
it's often referred to

16
00:00:56.790 --> 00:01:01.570
informally as losing the this-binding,
or having this unbound.

17
00:01:01.570 --> 00:01:05.433
What happens is, the function
call site is the important part.

18
00:01:05.433 --> 00:01:11.073
So let's say you take a function,
for example, the one from line 10,

19
00:01:11.073 --> 00:01:16.454
and you pass in 02.foo(); as
a callback to some other utility.

20
00:01:16.454 --> 00:01:19.711
And when that utility
invokes the function,

21
00:01:19.711 --> 00:01:22.457
what is its call site gonna look like?

22
00:01:22.457 --> 00:01:27.105
It's gonna override or throw away
the 02 this-binding you otherwise

23
00:01:27.105 --> 00:01:31.303
normally would have,
because it's the call site that matters.

24
00:01:31.303 --> 00:01:34.539
So one of the problems that we
have is that when we make these

25
00:01:34.539 --> 00:01:39.119
this-aware function, we are not in control
of how they're going to be invoked.

26
00:01:39.119 --> 00:01:42.326
And if we're not in control of
how they're gonna be invoked,

27
00:01:42.326 --> 00:01:45.857
then we cannot predict what their
this-keyword is gonna point to.

28
00:01:45.857 --> 00:01:49.260
It's called losing your this-binding,
everybody following that?

29
00:01:50.700 --> 00:01:55.220
So let's imagine this scenario, where I
can do something called hard binding.

30
00:01:55.220 --> 00:02:00.350
If I wanted to pass in a function, or
if I wanted to make a function that,

31
00:02:00.350 --> 00:02:04.620
no matter how it was called,
it had a predictable this?

32
00:02:04.620 --> 00:02:10.300
On line 11, I am calling what is
referred to as a hard bound function.

33
00:02:10.300 --> 00:02:13.118
Look at how foo is defined on line 9.

34
00:02:13.118 --> 00:02:19.934
foo is defined, on line 9,
to hard-code the .call into it.

35
00:02:19.934 --> 00:02:23.640
So that it forcibly says, use obj,
no matter how you're called.

36
00:02:25.200 --> 00:02:28.672
Which is why, on line 12,
if we try to override it,

37
00:02:28.672 --> 00:02:34.016
it just silently ignores that, and says,
thanks very much, I'm gonna use obj.

38
00:02:34.016 --> 00:02:37.238
So line 12 would actually
still print out bar,

39
00:02:37.238 --> 00:02:41.508
not bar2.
&gt;&gt; Kyle Simpson: Now,

40
00:02:41.508 --> 00:02:45.727
that pattern of making
a function that hard binds it,

41
00:02:45.727 --> 00:02:49.489
that explicitly says using .call or
.apply?

42
00:02:49.489 --> 00:02:54.538
The reason why this is not a rule, but
a variation, is because under the covers,

43
00:02:54.538 --> 00:02:58.484
it's using a .call or a .apply,
which is explicit binding.

44
00:02:58.484 --> 00:03:01.497
But we don't wanna go making
these functions ourselves.

45
00:03:01.497 --> 00:03:04.565
That's ugly, to have to make
a function like we do on line 9,

46
00:03:04.565 --> 00:03:06.219
we could make a utility for that.

47
00:03:06.219 --> 00:03:10.269
And it turns out there's
a utility built into JavaScript to

48
00:03:10.269 --> 00:03:14.406
make these hard bound functions,
and it's called .bind.

49
00:03:14.406 --> 00:03:19.297
On line 7, I make a hard bound
version of foo by calling .bind.

50
00:03:19.297 --> 00:03:23.132
And the first argument that I pass in,
obj,

51
00:03:23.132 --> 00:03:26.665
is the this that it will be hard bound to.

52
00:03:26.665 --> 00:03:31.457
So now, on line 9, when I call it,
it doesn't matter how I call it,

53
00:03:31.457 --> 00:03:38.417
It's always gonna use the obj as its this.
&gt;&gt; Kyle Simpson: That's

54
00:03:38.417 --> 00:03:40.586
called a hard bound function.

55
00:03:40.586 --> 00:03:45.739
So any time you've got a function that
is this-sensitive, or this aware?

56
00:03:45.739 --> 00:03:48.442
And you reference it, and
pass it in somewhere, and

57
00:03:48.442 --> 00:03:50.968
you're not gonna be in
control of the call site?

58
00:03:50.968 --> 00:03:55.909
The way to solve that problem is to,
instead of passing in the function itself,

59
00:03:55.909 --> 00:03:58.729
pass in a hard bound
version of the function.

60
00:03:58.729 --> 00:04:02.035
And then you know it's
always going to call,

61
00:04:02.035 --> 00:04:08.044
it's always gonna be called using the this
that I want it to be called with, okay?

62
00:04:08.044 --> 00:04:13.533
Now, I wanna stop for a moment and ask you
to analyze, think critically for a moment.

63
00:04:13.533 --> 00:04:20.249
Do we see the benefit to gaining some
predictability here, with these functions?

64
00:04:20.249 --> 00:04:24.965
When you say, I want it to always use,
I wanna lock it to this specific this,

65
00:04:24.965 --> 00:04:26.381
do we see the benefit?

66
00:04:26.381 --> 00:04:30.584
It allows us to pass those functions
around, and not worry about them

67
00:04:30.584 --> 00:04:34.470
losing a this, what's the downside?
&gt;&gt; Speaker 2: You lose flexibility.

68
00:04:34.470 --> 00:04:34.987
&gt;&gt; Kyle Simpson: You lose the

69
00:04:34.987 --> 00:04:36.027
flexibility, right?

70
00:04:36.027 --> 00:04:41.716
Isn't the whole reason for
the this keyword to have flexibility?

71
00:04:41.716 --> 00:04:45.332
What other system have we already
leaned about in this workshop,

72
00:04:45.332 --> 00:04:47.049
where we get predictability?

73
00:04:47.049 --> 00:04:52.815
[NOISE] Lexical scope, remember that?

74
00:04:52.815 --> 00:04:55.378
Lexical scope is all about
being fixed at author time,

75
00:04:55.378 --> 00:04:57.600
it's all about predictability.

76
00:04:57.600 --> 00:05:00.440
The this keyword is all about flexibility,

77
00:05:00.440 --> 00:05:04.060
using a function in multiple
different contexts.

78
00:05:04.060 --> 00:05:07.542
So wait a minute, we've just created a
pattern which shoots ourself in the foot.

79
00:05:07.542 --> 00:05:11.580
Hard binding takes this
whole dynamic system, and

80
00:05:11.580 --> 00:05:14.370
throws away all the dynamicism,
and makes it predictable again.

81
00:05:15.400 --> 00:05:18.282
Why would we wanna do that?

82
00:05:18.282 --> 00:05:23.602
What I'm getting at here is that there
is a tension between flexibility and

83
00:05:23.602 --> 00:05:24.961
predictability.

84
00:05:24.961 --> 00:05:28.143
There's no one right answer here,
there's a tension.

85
00:05:28.143 --> 00:05:30.187
And because there's a tension,

86
00:05:30.187 --> 00:05:35.447
you have to make subjective judgment calls
as to which is the appropriate mechanism.

87
00:05:35.447 --> 00:05:39.451
So, let me share with you
a heuristic that I use to determine,

88
00:05:39.451 --> 00:05:43.537
am I doing things the appropriate way,
is this best practice?

89
00:05:43.537 --> 00:05:46.136
Say I architect my code, and I've got all

90
00:05:46.136 --> 00:05:51.048
of these this-aware functions defined
on some object namespace somewhere.

91
00:05:51.048 --> 00:05:54.434
And let's look at all of my call sites,
and

92
00:05:54.434 --> 00:05:57.915
let's imagine that in
all of my call sites,

93
00:05:57.915 --> 00:06:03.012
they all look like maybe this one,
they all look like o2.foo.

94
00:06:03.012 --> 00:06:05.212
Okay, great, no big deal,

95
00:06:05.212 --> 00:06:10.633
because I'm using the system the way
it's appropriately designed.

96
00:06:10.633 --> 00:06:14.118
And let's say, every once in a while,
I have to make one of

97
00:06:14.118 --> 00:06:18.258
these hard bound versions,
like we see here on line 7 of this slide.

98
00:06:18.258 --> 00:06:22.240
Every once in a while, I have to make a
hard bound version, but most of the time,

99
00:06:22.240 --> 00:06:23.435
it just says o2.foo.

100
00:06:23.435 --> 00:06:28.021
In that scenario, I'm taking full
advantage of the dynamicism, and

101
00:06:28.021 --> 00:06:32.233
every once in a while,
inserting back in some predictability.

102
00:06:32.233 --> 00:06:36.756
I would say that's a pretty
reasonable usage of this mechanism.

103
00:06:36.756 --> 00:06:41.219
On the other hand, if I went to all
the trouble to put this-dot in front

104
00:06:41.219 --> 00:06:44.549
of every single property and
method reference, and

105
00:06:44.549 --> 00:06:48.275
then I found myself having to
do hard binding everywhere?

106
00:06:48.275 --> 00:06:53.363
I might then step back and say, hmm, maybe
I should just switch to lexical scope.

107
00:06:53.363 --> 00:06:57.621
Because it appears that the flexibility
isn't actually that important in this

108
00:06:57.621 --> 00:07:01.254
piece of scope, it appears
the predictability is more important.

109
00:07:03.326 --> 00:07:04.195
&gt;&gt; Kyle Simpson: The truth is,

110
00:07:04.195 --> 00:07:08.402
different parts of your code will
answer that tension differently.

111
00:07:08.402 --> 00:07:11.840
Some parts of your code,
the predictability will be more important,

112
00:07:11.840 --> 00:07:14.536
some parts,
the flexibility will be more important.

113
00:07:14.536 --> 00:07:18.632
You are a better JavaScript developer
if you can use both of those techniques

114
00:07:18.632 --> 00:07:21.392
appropriately in your code,
not one or the other.

115
00:07:21.392 --> 00:07:26.192
JavaScript is great, in part,
because it has both available to you.

116
00:07:26.192 --> 00:07:31.685
Using one all the time is not appropriate.

117
00:07:31.685 --> 00:07:35.385
I know that's our instinct, just give
me the one pattern to rule them all,

118
00:07:35.385 --> 00:07:37.227
give me the one ring to rule them all.

119
00:07:37.227 --> 00:07:41.111
But what I'm really saying is,
you need to learn to use both systems for

120
00:07:41.111 --> 00:07:43.420
what they're better at.

121
00:07:43.420 --> 00:07:47.513
If flexibility is important, if reuse of
a function across multiple contexts is

122
00:07:47.513 --> 00:07:49.810
important, use this-aware programming.

123
00:07:50.990 --> 00:07:55.440
If predictability is more important,
the lexical system is better then.

