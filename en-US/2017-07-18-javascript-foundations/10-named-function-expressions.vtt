WEBVTT

1
00:00:00.320 --> 00:00:02.734
&gt;&gt; Kyle: Talking about those named
function expressions for a moment.

2
00:00:02.734 --> 00:00:04.952
Let's dig into that question.

3
00:00:04.952 --> 00:00:06.807
If we look at this example,

4
00:00:06.807 --> 00:00:11.735
we look at two different ways that
a function expression can be created.

5
00:00:11.735 --> 00:00:15.377
One is what we would call
anonymous function expression.

6
00:00:15.377 --> 00:00:18.947
You notice the function keyword on
like one followed immediately by

7
00:00:18.947 --> 00:00:19.956
the parentheses.

8
00:00:19.956 --> 00:00:21.981
There's no name identifier.

9
00:00:21.981 --> 00:00:26.809
That is by far the most common way that
people express named function expression.

10
00:00:26.809 --> 00:00:30.648
As a matter of fact, we typically see that
most often when we pass a function as

11
00:00:30.648 --> 00:00:32.435
a call back to some other function.

12
00:00:32.435 --> 00:00:36.102
We see this function keyword immediately
followed by the parentheses set.

13
00:00:36.102 --> 00:00:39.263
And that's referred to as
an anonymous function expression.

14
00:00:39.263 --> 00:00:43.888
JQuery and other tools in libraries and
frameworks that popularize this style.

15
00:00:43.888 --> 00:00:48.862
It's also a lot easier because you just
type it out, it's almost a default kind of

16
00:00:48.862 --> 00:00:53.351
muscle memory, just to type out the word
function and put a parentheses.

17
00:00:53.351 --> 00:00:57.149
On line 5, we see an example of a function
expression that we call a named function

18
00:00:57.149 --> 00:00:58.424
expression and has a name.

19
00:00:58.424 --> 00:01:02.564
And as we just described, that name
is actually going to be accessible

20
00:01:02.564 --> 00:01:05.310
inside itself, but
not in the closing scope.

21
00:01:05.310 --> 00:01:08.076
It's okay that we have
those same names here.

22
00:01:08.076 --> 00:01:10.291
Sometimes those names will be different.

23
00:01:10.291 --> 00:01:13.374
Sometimes there is an external name that
your going to use to refer something.

24
00:01:13.374 --> 00:01:17.440
Or there's some control reason why you're
assigning it to a property of an object or

25
00:01:17.440 --> 00:01:18.082
something.

26
00:01:18.082 --> 00:01:20.916
And it needs to be called
a certain thing on the outside.

27
00:01:20.916 --> 00:01:24.403
But you might have a different and more
descriptive name that you wanna use on

28
00:01:24.403 --> 00:01:26.979
the inside, and
that's entirely okay as well, okay?

29
00:01:26.979 --> 00:01:30.820
So the question often comes up, should I
just create all my functions this way?

30
00:01:30.820 --> 00:01:34.239
And as a matter of fact, shouldn't I just
do a const here, and say const keyHandler?

31
00:01:34.239 --> 00:01:37.258
That's how a lot of people seem to do it.

32
00:01:37.258 --> 00:01:41.284
I prefer function declarations as
oppose to function expressions.

33
00:01:41.284 --> 00:01:45.574
My general rule of thumb is if a function
is going to have any more then about two

34
00:01:45.574 --> 00:01:49.666
or three lines of code I make it into
a function declaration almost without

35
00:01:49.666 --> 00:01:50.331
question.

36
00:01:50.331 --> 00:01:52.112
There is very few exceptions to that.

37
00:01:52.112 --> 00:01:55.895
I will sometimes us an inline function
expression if there is only one or

38
00:01:55.895 --> 00:01:56.912
two lines of code.

39
00:01:56.912 --> 00:01:59.885
If there is any substantial amount
of lines of code I will make it into

40
00:01:59.885 --> 00:02:01.041
a function declaration.

41
00:02:01.041 --> 00:02:04.499
Function declarations have to have names,
so there's no question.

42
00:02:04.499 --> 00:02:08.522
There is no such thing as
an anonymous function declaration.

43
00:02:08.522 --> 00:02:12.048
Actually technically there is with ES6
modules but let's not worry about that.

44
00:02:12.048 --> 00:02:15.420
Function declarations always have names,
okay?

45
00:02:15.420 --> 00:02:18.176
But it's this function expression
that we should ask about.

46
00:02:18.176 --> 00:02:19.445
Because our default,

47
00:02:19.445 --> 00:02:23.131
our instinct is to write these
anonymous function expressions.

48
00:02:23.131 --> 00:02:24.893
Many people like that short in form.

49
00:02:24.893 --> 00:02:29.281
In fact with ES6 we added the whole arrow
function form to make it even shorter and

50
00:02:29.281 --> 00:02:30.516
even more anonymous.

51
00:02:30.516 --> 00:02:34.003
We'll talk about arrow
functions later today.

52
00:02:34.003 --> 00:02:38.460
So what's the difference between
an anonymous function expression and

53
00:02:38.460 --> 00:02:40.365
a named function expression?

54
00:02:40.365 --> 00:02:41.891
What I will say is this.

55
00:02:41.891 --> 00:02:47.162
You should always, and I don't make very
many absolutes, but this is one of them.

56
00:02:47.162 --> 00:02:49.564
You should always, with no exceptions,

57
00:02:49.564 --> 00:02:54.242
prefer the named function expression
over the anonymous function expression.

58
00:02:54.242 --> 00:02:56.308
Even though it's the harder thing to do.

59
00:02:56.308 --> 00:02:58.455
Even though you have to come
up with a good name for it.

60
00:02:58.455 --> 00:02:59.678
Even though it's a little bit more typing.

61
00:02:59.678 --> 00:03:01.917
Even though it's a little
bit more verbose.

62
00:03:01.917 --> 00:03:04.052
It's always gonna be more preferable and

63
00:03:04.052 --> 00:03:07.530
there are main reasons why it's more
preferable to put a name on it.

64
00:03:07.530 --> 00:03:11.114
Let me give you some of the benefits
to think about in terms of the why

65
00:03:11.114 --> 00:03:14.641
a named function expressions is
preferable to an anonymous one.

66
00:03:14.641 --> 00:03:15.728
The first one,

67
00:03:15.728 --> 00:03:20.836
provides a handy self reference to
the functions from inside of itself.

68
00:03:20.836 --> 00:03:24.144
This is useful for a variety of things,
most notable recursion.

69
00:03:24.144 --> 00:03:27.517
If you have a function that is going
to need to recurs on its self,

70
00:03:27.517 --> 00:03:29.903
having a name inside of
it's self is useful.

71
00:03:29.903 --> 00:03:34.457
If you refer to a function from inside
of itself with an identifier that is

72
00:03:34.457 --> 00:03:36.932
actually enclosed in the outer scope.

73
00:03:36.932 --> 00:03:40.647
Like for example that first one on line
1 of the previous slide where I said var

74
00:03:40.647 --> 00:03:41.457
clickHandler.

75
00:03:41.457 --> 00:03:45.794
If I try to use the name clickHandler
inside of that function to refer to

76
00:03:45.794 --> 00:03:50.207
itself, that is not actually
a reliable self-reference because that

77
00:03:50.207 --> 00:03:53.463
variable is in an outer
scope that I don't control.

78
00:03:53.463 --> 00:03:56.988
And somebody else later might re-assign
that variable to point to some

79
00:03:56.988 --> 00:03:57.932
different value.

80
00:03:57.932 --> 00:04:00.889
So it's not a reliable self-reference.

81
00:04:00.889 --> 00:04:03.159
Other examples of self-references.

82
00:04:03.159 --> 00:04:05.648
I regularly find myself
with clickHandlers,

83
00:04:05.648 --> 00:04:07.627
with eventHandlers in particular,

84
00:04:07.627 --> 00:04:11.472
wanting to unbind the eventHandlers
as soon as it fires the first time.

85
00:04:11.472 --> 00:04:15.781
Typically the frameworks you work with
will want you to provide a reference to

86
00:04:15.781 --> 00:04:18.712
the function that was actually bound for
the event.

87
00:04:18.712 --> 00:04:22.005
So having a self-reference is far
better than using something like

88
00:04:22.005 --> 00:04:24.906
the duplicated arguments .calle or
something like that.

89
00:04:24.906 --> 00:04:29.653
You wanna have a good self reference if
you need to refer to the function object.

90
00:04:29.653 --> 00:04:33.487
For example, inspecting its
properties if you wanna recurse,

91
00:04:33.487 --> 00:04:37.393
if you wanna reference it in
an event handler like front binding.

92
00:04:37.393 --> 00:04:41.826
All of these reasons are reasons why
self-references are preferable when they

93
00:04:41.826 --> 00:04:45.744
are the name function, when they
were the named lexical identifier.

94
00:04:45.744 --> 00:04:48.835
And by the way, that identifier
in the function expression and

95
00:04:48.835 --> 00:04:52.451
the named function expression not only
is it reliable in the sense that you

96
00:04:52.451 --> 00:04:54.810
control it in the scope,
it's also read only.

97
00:04:54.810 --> 00:04:57.069
You can't reassign that to anything else.

98
00:04:57.069 --> 00:04:57.838
So you know for

99
00:04:57.838 --> 00:05:02.018
sure inside of that scope that name will
always refer to the function itself.

100
00:05:02.018 --> 00:05:05.400
As a reliable handy self reference.

101
00:05:05.400 --> 00:05:09.008
By the way, even though you
may not have an occasion for

102
00:05:09.008 --> 00:05:13.025
that right now,
sometimes those occasions grow over time.

103
00:05:13.025 --> 00:05:16.744
And it's better to have a name in place
in case you need it even if you aren't

104
00:05:16.744 --> 00:05:17.523
gonna need it.

105
00:05:17.523 --> 00:05:19.867
The consistency is important.

106
00:05:19.867 --> 00:05:25.684
Okay so that's one reason for wanting to
have a name on your function expression.

107
00:05:25.684 --> 00:05:30.519
The next one, how many of you have ever
had an error in your JavaScript program,

108
00:05:30.519 --> 00:05:31.181
anybody?

109
00:05:31.181 --> 00:05:35.674
Okay, good that's a happy occurrence that
we're all one happy big family, right?

110
00:05:35.674 --> 00:05:36.637
We've all had errors.

111
00:05:36.637 --> 00:05:40.448
How many of you have ever seen in a stack
trace in your console, anonymous function,

112
00:05:40.448 --> 00:05:43.684
anonymous function, over an over again,
line after line after line.

113
00:05:43.684 --> 00:05:45.237
Anybody seen that?

114
00:05:45.237 --> 00:05:46.399
It's super helpful, right?

115
00:05:46.399 --> 00:05:50.125
Especially in production code,
where everything's minified, so

116
00:05:50.125 --> 00:05:52.770
they all say line 1, character 32,712.

117
00:05:52.770 --> 00:05:56.108
Cuz we all know exactly what
that function is, right?

118
00:05:56.108 --> 00:05:59.482
Guess what happens if you put a name
on your function expressions.

119
00:05:59.482 --> 00:06:01.802
It uses the name in your stack trace.

120
00:06:01.802 --> 00:06:04.962
Immediately you make your
code more debuggable.

121
00:06:04.962 --> 00:06:07.884
By using those names in the stack traces.

122
00:06:07.884 --> 00:06:10.797
And by the way minifiers used
to strip out those names.

123
00:06:10.797 --> 00:06:14.304
Now the minifiers, like for
example uglify.js, at my best,

124
00:06:14.304 --> 00:06:18.673
have an option that allows you to preserve
the function name expression even if

125
00:06:18.673 --> 00:06:22.072
it's not used to preserve that
name expression as written.

126
00:06:22.072 --> 00:06:27.521
So that your minified production
code is still debuggable.

127
00:06:27.521 --> 00:06:32.485
Keeping that name expression there makes
you code more debuggable and I honestly

128
00:06:32.485 --> 00:06:37.170
think that rule, that fact in of itself
is more than enough justification.

129
00:06:37.170 --> 00:06:40.186
Because we're not not doing happy
path driven development here.

130
00:06:40.186 --> 00:06:44.464
We wanna write code that is robust
to the problems that will happen.

131
00:06:44.464 --> 00:06:49.245
And even if you can't imagine any scenario
by which this function's gonna participate

132
00:06:49.245 --> 00:06:50.213
in a stack trace,

133
00:06:50.213 --> 00:06:53.906
it's probably going to participate
in a stack trace at some point.

134
00:06:53.906 --> 00:06:55.839
So it's a good idea to
have a good handy name.

135
00:06:55.839 --> 00:07:01.047
True story, I literally have actually
been able to figure out a problem,

136
00:07:01.047 --> 00:07:05.507
knew exactly what my bug was,
without even looking at my code.

137
00:07:05.507 --> 00:07:09.665
Simply looking at the stack trace and
seeing the order of function calls.

138
00:07:09.665 --> 00:07:11.873
If they both set anonymous,
I would had no idea.

139
00:07:11.873 --> 00:07:15.210
But when I saw a call b and I was like,
wait a minute, b should have called a.

140
00:07:15.210 --> 00:07:16.859
I know exactly what's wrong with this.

141
00:07:16.859 --> 00:07:20.403
An off by one index or something right?

142
00:07:20.403 --> 00:07:26.523
So, by knowing for sure what the name is,
we can already debug our programs better.

143
00:07:26.523 --> 00:07:27.595
And even at worst,

144
00:07:27.595 --> 00:07:31.749
we're getting some kind of mental
context in which to approach the code.

145
00:07:31.749 --> 00:07:35.418
If that name says something
like handleClickPresses,

146
00:07:35.418 --> 00:07:37.749
you know kind of what happened.

147
00:07:37.749 --> 00:07:40.302
There was a key press,
there was a click that happened,

148
00:07:40.302 --> 00:07:42.273
there was some kind of this that happened.

149
00:07:42.273 --> 00:07:46.519
That gives me some kind of context and
clue as to approach my code.

150
00:07:46.519 --> 00:07:48.317
If it just says anonymous function,

151
00:07:48.317 --> 00:07:50.814
you're stuck going to look
at the rest of the code.

152
00:07:50.814 --> 00:07:54.484
The third and final reason,
the third and final benefit.

153
00:07:54.484 --> 00:07:57.951
I'd argue that this creates
more self-documenting code.

154
00:07:57.951 --> 00:08:01.628
And I just want put a caveat out here
because I'm not suggesting that all code

155
00:08:01.628 --> 00:08:05.653
should be entirely self-documenting and
there's no reason for documentation or

156
00:08:05.653 --> 00:08:06.531
using comments.

157
00:08:06.531 --> 00:08:10.690
But we can go a long way to helping
ourselves, helping our future selves and

158
00:08:10.690 --> 00:08:14.534
our other team members by coming up
with good useful names for stuff.

159
00:08:14.534 --> 00:08:17.161
If you don't come up with
crappy names like foobar baz.

160
00:08:17.161 --> 00:08:20.007
If you come up with a good
name like handleClickPresses,

161
00:08:20.007 --> 00:08:23.348
you're telling somebody I know
exactly what that's doing.

162
00:08:23.348 --> 00:08:26.408
I know that's handling the click of it,
right?

163
00:08:26.408 --> 00:08:28.729
So when you look at a function, for

164
00:08:28.729 --> 00:08:31.941
example a function being
passed to a callback.

165
00:08:31.941 --> 00:08:34.639
If it's an anonymous function expression,

166
00:08:34.639 --> 00:08:39.113
you cannot tell by that function
signature what the function's gonna do.

167
00:08:39.113 --> 00:08:42.817
So to understand that you have to first
look at where it's being passed and

168
00:08:42.817 --> 00:08:44.619
at its code body to figure that out.

169
00:08:44.619 --> 00:08:46.097
But if you give it a good name,

170
00:08:46.097 --> 00:08:50.015
you immediately given the reader of your
code more of a signal about what to do.

171
00:08:50.015 --> 00:08:54.790
Taken together, I think all three of
these reasons are an ironclad argument.

172
00:08:54.790 --> 00:08:56.639
That's why I make the absolute statement.

173
00:08:56.639 --> 00:09:01.514
There is literally no argument in favor
of the anonymous function expression

174
00:09:01.514 --> 00:09:05.265
except you are too lazy or
uncreative to come up with a name.

175
00:09:05.265 --> 00:09:11.674
It's too onerous and burdensome for you to
put a name on your function expression.

176
00:09:11.674 --> 00:09:14.933
And I'm going to completely
include myself in that.

177
00:09:14.933 --> 00:09:18.621
Because every single time I write
a function, I put it as anonymous and

178
00:09:18.621 --> 00:09:20.822
then I have to go back and I need that.

179
00:09:20.822 --> 00:09:22.530
Like I have to check myself every time.

180
00:09:22.530 --> 00:09:26.299
Because even years later I still
have this as my default habit.

181
00:09:26.299 --> 00:09:29.676
And you're gonna see a bunch of anonymous
function expressions in my slides.

182
00:09:29.676 --> 00:09:34.819
Cuz it's super easy to save space on
slides and not come up with names, right.

183
00:09:34.819 --> 00:09:38.801
But this is definitely one of
those do as I say, not as I do.

184
00:09:38.801 --> 00:09:44.143
In production code, you should always
have names on your function expressions.

185
00:09:44.143 --> 00:09:45.558
It's more future-proof.

186
00:09:45.558 --> 00:09:48.476
It's more debuggable, okay.

187
00:09:48.476 --> 00:09:53.200
[COUGH] So when people are talking
about putting names on their function

188
00:09:53.200 --> 00:09:58.018
expressions and, I don't wanna do this,
and this is hard for me.

189
00:09:58.018 --> 00:09:58.935
Here's my process.

190
00:09:58.935 --> 00:10:02.012
It's just a suggestion for
you about how to go about this.

191
00:10:02.012 --> 00:10:05.461
I've tried to get myself into the habit
than when I write a function expression,

192
00:10:05.461 --> 00:10:06.584
the very first thing I do.

193
00:10:06.584 --> 00:10:09.207
If I don't already know
what it ought to be called,

194
00:10:09.207 --> 00:10:12.200
like if I don't know
handleClickEvent is the right name.

195
00:10:12.200 --> 00:10:14.946
I put the word to do
there in capital letters.

196
00:10:14.946 --> 00:10:15.850
You know why I do that?

197
00:10:15.850 --> 00:10:17.860
Cuz I have that same
habit with my comments.

198
00:10:17.860 --> 00:10:21.066
I'll put a to-do comment and
I search through my code looking for

199
00:10:21.066 --> 00:10:22.007
to-do comments.

200
00:10:22.007 --> 00:10:25.538
And bam, it's gonna pop up if I've
accidentally left that to do placeholder

201
00:10:25.538 --> 00:10:27.401
as the name for my function expression.

202
00:10:27.401 --> 00:10:30.749
So the first thing I do is I start out
with a good placeholder instead of

203
00:10:30.749 --> 00:10:31.402
anonymous.

204
00:10:31.402 --> 00:10:33.541
There's a name there that's
gonna catch my eye and

205
00:10:33.541 --> 00:10:35.790
let me know that I need to
refactor that as some point.

206
00:10:35.790 --> 00:10:38.860
As I'm developing the function, I'm trying
to figure out what I should call it.

207
00:10:38.860 --> 00:10:42.086
And I often don't know at the beginning
of writing that function or

208
00:10:42.086 --> 00:10:43.363
what a good name for it is.

209
00:10:43.363 --> 00:10:46.328
As a matter of fact,
it often takes me multiple attempts.

210
00:10:46.328 --> 00:10:49.174
I call it something and then I work
a little more on it, and I refactor it.

211
00:10:49.174 --> 00:10:51.868
I'm like, that's a bad name now,
let me rename this thing.

212
00:10:51.868 --> 00:10:55.920
And after about the third to four time
I come up with a good useful names for

213
00:10:55.920 --> 00:10:57.257
that function, okay?

214
00:10:57.257 --> 00:10:58.571
So that's my process.

215
00:10:58.571 --> 00:11:01.511
I would encourage you to
find your own process but

216
00:11:01.511 --> 00:11:06.173
I strongly recommend you consider working
against your natural instinct and

217
00:11:06.173 --> 00:11:10.064
behavior and putting names on
all your functions expressions.

218
00:11:10.064 --> 00:11:11.392
Refactor all your code to the add.

219
00:11:11.392 --> 00:11:12.970
You had a question.

220
00:11:12.970 --> 00:11:16.306
&gt;&gt; Speaker 2: Yeah,
this would seem to be huge to me.

221
00:11:16.306 --> 00:11:18.699
I think you said yesterday,

222
00:11:18.699 --> 00:11:23.596
70% of the time coding is
actually spent reading code.

223
00:11:23.596 --> 00:11:28.018
And it would seem that it would
greatly improve when you're

224
00:11:28.018 --> 00:11:30.501
reading somebody else's code.

225
00:11:30.501 --> 00:11:31.930
And it's obvious this is your belief.

226
00:11:31.930 --> 00:11:38.126
Is this the industry belief, or is this,
all of that installed code out there,

227
00:11:38.126 --> 00:11:43.304
is this considered a best practice
by others in the general world,

228
00:11:43.304 --> 00:11:45.906
or is that a religious question?

229
00:11:45.906 --> 00:11:50.429
&gt;&gt; Kyle: I was just about to say,
adherence of my gospel of the JS books.

230
00:11:50.429 --> 00:11:51.512
They probably believe it.

231
00:11:51.512 --> 00:11:55.671
But in general I find the push
in the other direction.

232
00:11:55.671 --> 00:11:58.694
Which is one of the reasons why I
make such a big emphasis on this.

233
00:11:58.694 --> 00:12:02.944
In general I find the push towards,
no let's not optimize for readability.

234
00:12:02.944 --> 00:12:05.421
Let's optimize for
how quickly I can write stuff.

235
00:12:05.421 --> 00:12:09.696
Many of the syntactic additions to
JavaScript where it went in the direction

236
00:12:09.696 --> 00:12:13.101
of let's just remove as many
characters as we possibly can so

237
00:12:13.101 --> 00:12:15.062
that it's quicker to write code.

238
00:12:15.062 --> 00:12:19.031
And that optimizes for the development
process and actually harms, I believe,

239
00:12:19.031 --> 00:12:20.382
the readability process.

240
00:12:20.382 --> 00:12:24.362
So I'm suggesting that we go in the other
direction because I've been there in

241
00:12:24.362 --> 00:12:26.607
the trenches and I've seen both ways done.

242
00:12:26.607 --> 00:12:31.441
And it is harder to maintain code that is
more cryptic because you saved a couple of

243
00:12:31.441 --> 00:12:34.729
extra microseconds when you
were typing out the code.

244
00:12:34.729 --> 00:12:35.974
So I strongly believe it.

245
00:12:35.974 --> 00:12:39.465
I think people are starting to catch
on to that if they follow my work.

246
00:12:39.465 --> 00:12:43.246
But I do not think you will find in
general a large swathe of the industry

247
00:12:43.246 --> 00:12:44.602
that's followed that.

248
00:12:44.602 --> 00:12:50.476
In fact, you see lint or tools and things
like that that suggest the opposite,

249
00:12:50.476 --> 00:12:52.880
which I think is not a good idea.

250
00:12:52.880 --> 00:12:53.552
Yes.

251
00:12:53.552 --> 00:12:57.739
&gt;&gt; Speaker 3: In chat, Craig asked
if there's a naming convention for

252
00:12:57.739 --> 00:13:00.017
named function expressions.

253
00:13:00.017 --> 00:13:05.284
And I said there's two hard problems in
computer science, naming and caching.

254
00:13:05.284 --> 00:13:08.179
&gt;&gt; Kyle: [LAUGH] Well there's
three hard problems, right,

255
00:13:08.179 --> 00:13:13.467
because there's also counting [LAUGH]
&gt;&gt; Speaker 3: Counting, right, yeah.

256
00:13:13.467 --> 00:13:18.195
&gt;&gt; Kyle: No, so definitely there is no
one standard for the naming convention.

257
00:13:18.195 --> 00:13:21.189
I would advocate,
don't use a naming convention.

258
00:13:21.189 --> 00:13:25.582
Use a specific name for
that specific use case.

259
00:13:25.582 --> 00:13:28.828
Perhaps if you wanna think
about conventions, you can say,

260
00:13:28.828 --> 00:13:31.002
do I wanna name my functions like nouns?

261
00:13:31.002 --> 00:13:35.273
Or do I wanna name them with the verbs
in terms of what action they do?

262
00:13:35.273 --> 00:13:38.717
Do I want to name them in terms
of what their end result will be,

263
00:13:38.717 --> 00:13:40.325
like what they will return?

264
00:13:40.325 --> 00:13:42.510
You'll come up with different names for

265
00:13:42.510 --> 00:13:46.698
them, based upon maybe that broad level
macro kind of convention decision.

266
00:13:46.698 --> 00:13:49.834
But there's no way for me to say that
you should always name it this way or

267
00:13:49.834 --> 00:13:50.417
something.

268
00:13:50.417 --> 00:13:54.790
It should be consistent in terms of style,
so the casing should be the same and

269
00:13:54.790 --> 00:13:56.149
those kinds of things.

270
00:13:56.149 --> 00:13:58.970
Yeah, there's no,
there's no overriding principle there.

