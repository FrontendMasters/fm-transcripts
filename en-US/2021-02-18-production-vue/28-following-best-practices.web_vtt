WEBVTT

1
00:00:00.050 --> 00:00:05.610
So we've talked a lot now about different
categories of the view ecosystem.

2
00:00:05.610 --> 00:00:07.576
But at the end of the day, right?

3
00:00:07.576 --> 00:00:12.049
We have to remember that what makes
an an application enterprise level, or

4
00:00:12.049 --> 00:00:16.806
frankly like production grade, is a lot of
time the fact that it is easy to follow

5
00:00:16.806 --> 00:00:20.880
best practices and
that the conventions are followed.

6
00:00:20.880 --> 00:00:25.467
Because the one thing you need almost
above anything else in an enterprise level

7
00:00:25.467 --> 00:00:27.500
app is consistency.

8
00:00:27.500 --> 00:00:30.840
If you don't have that level of
consistency, then you introduce,

9
00:00:30.840 --> 00:00:34.534
as you would expect unpredictability,
into application architecture,

10
00:00:34.534 --> 00:00:37.756
which means you're going to have
either a lot of technical debt or

11
00:00:37.756 --> 00:00:40.360
simply communication debt over time.

12
00:00:40.360 --> 00:00:43.584
Because as we know, as I mentioned
earlier, I've worked on teams where like

13
00:00:43.584 --> 00:00:46.710
the contractors are working on
the other side of the world.

14
00:00:46.710 --> 00:00:50.840
And so this makes timezone
overlap like near impossible.

15
00:00:50.840 --> 00:00:54.049
And so if you can imagine if someone
writes something in a way that breaks

16
00:00:54.049 --> 00:00:57.634
convention, and they're allowed to, and
then that enters the code base, but

17
00:00:57.634 --> 00:01:00.900
then they're the only ones who
know understand or how to fix it.

18
00:01:00.900 --> 00:01:04.927
This means now you're gonna basically
lose a whole day of development

19
00:01:04.927 --> 00:01:06.300
over like these bugs.

20
00:01:06.300 --> 00:01:09.253
And if you multiply that across
multiple developers like,

21
00:01:09.253 --> 00:01:13.220
this cost me astronomical to development
processes and companies in general.

22
00:01:14.490 --> 00:01:17.191
And so that's why we're devoting
this section to really talking

23
00:01:17.191 --> 00:01:20.600
about the importance of making it
easy to follow best practices.

24
00:01:20.600 --> 00:01:22.960
When it comes to best practices and
why they're important, right?

25
00:01:22.960 --> 00:01:25.528
We've discussed some of those
things as far as they scale, but

26
00:01:25.528 --> 00:01:26.590
as developers, right?

27
00:01:26.590 --> 00:01:29.620
What does best practices mean for
us at the end of the day?

28
00:01:29.620 --> 00:01:33.070
And oftentimes this means that
we are faster at development.

29
00:01:33.070 --> 00:01:36.970
This means fewer bugs and at the same
time, because we have all these things,

30
00:01:36.970 --> 00:01:39.733
this means you have more opportunities for
learning.

31
00:01:39.733 --> 00:01:43.361
And because you have the ability to
experiment with things, and you know

32
00:01:43.361 --> 00:01:48.270
basically the boundaries in which you
can experiment without breaking things.

33
00:01:48.270 --> 00:01:53.127
But the problem with this phase best
practice, even though we use it a lot, and

34
00:01:53.127 --> 00:01:57.173
this is more or less a convention
of saying it, I prefer the term or

35
00:01:57.173 --> 00:02:01.000
the phrase chosen conventions
instead of a company.

36
00:02:01.000 --> 00:02:03.129
It's because when you're
talking to your team,

37
00:02:03.129 --> 00:02:06.000
you're trying to convince them
on certain things, right?

38
00:02:06.000 --> 00:02:11.480
Let's say for example, you really like
the flat, flat component architecture.

39
00:02:11.480 --> 00:02:15.235
If you were to go to a team who's
traditionally used to something like

40
00:02:15.235 --> 00:02:18.797
Nested architecture, and
you're like This is a best practice,

41
00:02:18.797 --> 00:02:23.030
there immediately creates this like
sort of us versus them mentality.

42
00:02:23.030 --> 00:02:27.860
Because best right by default implies that
like this is the number one thing to do,

43
00:02:27.860 --> 00:02:32.480
when as we talked a lot about, there are
reasons for either choosing one site or

44
00:02:32.480 --> 00:02:37.240
another or frankly mixing two different
approaches in the case of the flat versus

45
00:02:37.240 --> 00:02:39.480
nested folder directory structure.

46
00:02:41.600 --> 00:02:44.589
And so that's why I think
chosen conventions or frankly,

47
00:02:44.589 --> 00:02:48.920
when you're talking to them about changing
a convention, I think this is better for

48
00:02:48.920 --> 00:02:50.920
stakeholder communication.

49
00:02:50.920 --> 00:02:54.233
Because now it's not a matter
of asserting superiority or

50
00:02:54.233 --> 00:02:57.060
whether one idea is
smarter than the other.

51
00:02:57.060 --> 00:03:00.405
But whether or not like I think it
basically allows you to have those

52
00:03:00.405 --> 00:03:03.574
discussions objectively about
which convention fits best for

53
00:03:03.574 --> 00:03:06.084
their team, rather than whether or
not their team

54
00:03:06.084 --> 00:03:10.060
is following a best practice which
inherently comes with some judgment.

55
00:03:10.060 --> 00:03:11.059
And so of course,

56
00:03:11.059 --> 00:03:15.070
this brings us to the question of
what makes a convention good, right.

57
00:03:15.070 --> 00:03:19.428
And I put this quote because again, we
want to avoid this judgmental factor when

58
00:03:19.428 --> 00:03:24.300
it comes to deciding what is the team
doing this is not necessarily good or bad.

59
00:03:24.300 --> 00:03:28.025
But ultimately, like if we're talking
about the evaluation of conventions,

60
00:03:28.025 --> 00:03:30.804
there are two primary factors
that contribute to whether or

61
00:03:30.804 --> 00:03:34.485
not the convention is basically
a good fit for the team or not.

62
00:03:34.485 --> 00:03:39.369
And the first thing is that they
enable to the developers to write

63
00:03:39.369 --> 00:03:43.285
great code with a low barrier of entry.

64
00:03:43.285 --> 00:03:48.259
And so the way to think of this one is
that when you're deciding on a convention,

65
00:03:48.259 --> 00:03:53.475
if the onboarding process to figure out
how that works, is super tedious, right?

66
00:03:53.475 --> 00:03:57.479
It has a lot of basically what they call
it a number of different steps to get

67
00:03:57.479 --> 00:03:59.370
something done.

68
00:03:59.370 --> 00:04:03.293
Each additional step that you add to
the process of following some sort of

69
00:04:03.293 --> 00:04:04.708
convention is just one and

70
00:04:04.708 --> 00:04:09.710
like the likelihood of them abandoning
that halfway through is much, much higher.

71
00:04:09.710 --> 00:04:14.233
So the example of this is we talked about
automatically generating test unit tests

72
00:04:14.233 --> 00:04:17.070
with your components, for example.

73
00:04:17.070 --> 00:04:20.932
And so if you didn't have that this means
that going forward whenever a developer is

74
00:04:20.932 --> 00:04:24.352
creating a new component by default,
if they're not using a generator,

75
00:04:24.352 --> 00:04:27.883
they'll do like right click new base
button, base button w component, and

76
00:04:27.883 --> 00:04:32.020
then they'll just develop, right because
that's, that's our natural flow is to just

77
00:04:32.020 --> 00:04:34.863
like, do the thing,
solve the problem and then go forward.

78
00:04:34.863 --> 00:04:36.795
But now if you're like, by the way,

79
00:04:36.795 --> 00:04:40.500
every component should come with
some sort of basic unit tests.

80
00:04:40.500 --> 00:04:43.709
And now you're forcing the developer
to not only then create that, but

81
00:04:43.709 --> 00:04:45.420
then they have to go well.

82
00:04:45.420 --> 00:04:48.450
All right, now I have to create
a test where did the test go?

83
00:04:48.450 --> 00:04:50.940
And then you go, okay,
the test files here.

84
00:04:50.940 --> 00:04:52.220
So I create the test.

85
00:04:52.220 --> 00:04:53.500
What's the naming convention for tests?

86
00:04:53.500 --> 00:04:54.790
Are we doing dot tests?

87
00:04:54.790 --> 00:04:58.645
Are we doing dot spec and then on top of
that, then you have to also make them,

88
00:04:58.645 --> 00:05:01.142
then think of the burden of like.

89
00:05:01.142 --> 00:05:05.265
I don't really know testing because if
we're being frank about things a lot of us

90
00:05:05.265 --> 00:05:09.393
entering into this field these days don't
necessarily come with like a hardcore

91
00:05:09.393 --> 00:05:11.090
testing background.

92
00:05:11.090 --> 00:05:14.990
And so testing unlike just the reality
is often becomes an afterthought.

93
00:05:14.990 --> 00:05:16.837
So now you've added this other barrier,

94
00:05:16.837 --> 00:05:20.633
where if they're not used to writing tests
and Jess, where they kind of have an idea,

95
00:05:20.633 --> 00:05:24.150
but don't really understand,
now they need to go to a different test.

96
00:05:24.150 --> 00:05:27.290
We need to copy it and
kind of modified it accordingly.

97
00:05:27.290 --> 00:05:30.962
And at this point, you've noticed that
I've just talked through like four or five

98
00:05:30.962 --> 00:05:34.750
steps just to create a unit test for a
component that they should be working on.

99
00:05:34.750 --> 00:05:37.182
And they might lose hours
on this because as we know,

100
00:05:37.182 --> 00:05:40.889
when you're working on a team, it's
sometimes tricky to get people's help or

101
00:05:40.889 --> 00:05:44.130
sometimes people have like they
want to be self sufficient.

102
00:05:44.130 --> 00:05:47.300
And so they might feel like
intimidated to ask for help.

103
00:05:47.300 --> 00:05:52.153
And guess what, because we did not
automate this piece right this this easy

104
00:05:52.153 --> 00:05:57.007
this best practice right now like based
on this like the general convention

105
00:05:57.007 --> 00:06:01.540
of all components should
write should have unit tests.

106
00:06:01.540 --> 00:06:05.990
Without automating it,
we fail this first valid qualification.

107
00:06:05.990 --> 00:06:10.750
Which is that, the enable developers write
great code with a low barrier of entry.

108
00:06:10.750 --> 00:06:13.769
In my experience when, developers
have a scaffold for them waiting for

109
00:06:13.769 --> 00:06:17.710
them, especially with like unit tests,
they're like, that's kind of how it works.

110
00:06:17.710 --> 00:06:20.829
And I just add another IP block,
and then I just describe it,

111
00:06:20.829 --> 00:06:23.940
and then I pass my function,
and then okay, that's it.

112
00:06:23.940 --> 00:06:24.460
Okay, done.

113
00:06:24.460 --> 00:06:25.220
Moving on.

114
00:06:25.220 --> 00:06:29.726
They can focus their energy on what
matters which is writing the test, rather

115
00:06:29.726 --> 00:06:34.250
than creating the file and doing like all
this hurdles just to get to the test.

116
00:06:36.070 --> 00:06:41.174
And so with that, once you have that
piece the other thing to really consider

117
00:06:41.174 --> 00:06:45.960
then is, is it easy to refactor or
abandon because conventions come and

118
00:06:45.960 --> 00:06:50.744
go The variables that come into play
as far as whether or not you should do

119
00:06:50.744 --> 00:06:55.210
things a certain way or not can
change with either the team makeup,

120
00:06:55.210 --> 00:06:59.690
maybe the department is changing
tech stacks or whatnot.

121
00:06:59.690 --> 00:07:01.655
And so the more that these
conventions are easy to go,

122
00:07:01.655 --> 00:07:03.740
you know what this convention
isn't working for us.

123
00:07:03.740 --> 00:07:04.940
Let's abandon it.

124
00:07:04.940 --> 00:07:09.020
The better it is because this also has
the added benefit of in the future.

125
00:07:09.020 --> 00:07:12.300
If someone's like, yeah,
this is not working for us.

126
00:07:12.300 --> 00:07:15.650
You don't want to make it extremely
painful for them to get out of it.

127
00:07:15.650 --> 00:07:18.114
And so this is why a lot of
the conventions and best like,

128
00:07:18.114 --> 00:07:20.210
best practices we talked about today.

129
00:07:20.210 --> 00:07:22.252
Are lower barrier of entry,
like they more or

130
00:07:22.252 --> 00:07:24.730
less try to follow that
low barrier of entry.

131
00:07:24.730 --> 00:07:26.257
Right, so that if, for example,

132
00:07:26.257 --> 00:07:29.400
you want flatter directory
structure with your components.

133
00:07:29.400 --> 00:07:32.850
We're not saying take the time to
refactor everything onto flat, but

134
00:07:32.850 --> 00:07:36.533
maybe start by not having so many
components nested and saying like, hey,

135
00:07:36.533 --> 00:07:40.215
can we at least keep it to page level
components and seeing how the team feels

136
00:07:40.215 --> 00:07:43.870
about that, and then they might
eventually move to the next thing.

137
00:07:43.870 --> 00:07:47.983
Whereas if you're like, no, let's like
strip everything out of the directories

138
00:07:47.983 --> 00:07:51.803
and then like move and then like then
you've created a situation where people

139
00:07:51.803 --> 00:07:55.563
are going to be hesitant to try this
convention because in the event this goes

140
00:07:55.563 --> 00:07:58.939
poorly, or even just poorly
like people just don't like it.

141
00:07:58.939 --> 00:08:02.039
Now you've made it really
difficult to move backwards.

142
00:08:02.039 --> 00:08:04.379
And so this is also my belief of tooling.

143
00:08:04.379 --> 00:08:08.617
It should be easier to enter the ecosystem
it should be easy to exit the ecosystem

144
00:08:08.617 --> 00:08:11.349
and conventions similarly
should be the same way.

