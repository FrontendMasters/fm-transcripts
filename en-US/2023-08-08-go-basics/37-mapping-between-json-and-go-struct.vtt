WEBVTT

1
00:00:00.270 --> 00:00:04.115
So what I need is to create a structure
that will match that thing.

2
00:00:04.115 --> 00:00:07.220
Do we need to create a structure
with all the properties?

3
00:00:07.220 --> 00:00:08.088
Actually, no.

4
00:00:08.088 --> 00:00:11.592
I can just pick the properties
that I want, okay?

5
00:00:11.592 --> 00:00:12.681
Which is okay.

6
00:00:12.681 --> 00:00:18.140
So I can just say type, we can call
this C-E-X, CEX response, okay?

7
00:00:18.140 --> 00:00:22.429
And then it's in a structure and
then we can say, okay,

8
00:00:22.429 --> 00:00:27.814
let's say I want the, that's the pair,
maybe I just want the price,

9
00:00:27.814 --> 00:00:32.677
the low, high, last,
maybe we can take last, I don't know.

10
00:00:32.677 --> 00:00:37.406
And we can say, okay,
I have the last that is a float64.

11
00:00:39.410 --> 00:00:43.938
But we start having a couple of problems.

12
00:00:43.938 --> 00:00:46.850
First, last is lowercase l.

13
00:00:48.660 --> 00:00:52.834
Which is a problem if I want to
export this to another back cache.

14
00:00:52.834 --> 00:00:54.843
Maybe in our case,
we don't need to export it,

15
00:00:54.843 --> 00:00:57.240
because it's part of the API back cache.

16
00:00:57.240 --> 00:00:59.343
But you will know that that's the problem.

17
00:00:59.343 --> 00:01:03.762
So do I need to match one by one
the properties from the JSON and

18
00:01:03.762 --> 00:01:07.560
sometimes the JSON might include hyphens.

19
00:01:07.560 --> 00:01:10.327
That's JSON, even spaces.

20
00:01:10.327 --> 00:01:12.100
Don't do that at home.

21
00:01:12.100 --> 00:01:14.162
But you can do that in JSON.

22
00:01:14.162 --> 00:01:16.540
And of course,
I cannot have a variable with that name.

23
00:01:17.830 --> 00:01:20.915
That makes sense.
So, if I want to match one by one,

24
00:01:20.915 --> 00:01:26.530
the properties we may have problems,
we may encounter problems.

25
00:01:26.530 --> 00:01:27.763
So let me show you the solution.

26
00:01:27.763 --> 00:01:29.782
But to avoid, wasting or

27
00:01:29.782 --> 00:01:35.400
investing too much time doing that,
let me show you a tool.

28
00:01:35.400 --> 00:01:36.698
There are a lot of tools.

29
00:01:36.698 --> 00:01:41.530
If you just google json to go struct.

30
00:01:41.530 --> 00:01:44.919
You will see lots of tools.

31
00:01:44.919 --> 00:01:49.890
You can even ask maybe charge GPT or
Google Bar to do this for you,

32
00:01:49.890 --> 00:01:52.480
where you paste the json, okay?

33
00:01:52.480 --> 00:01:58.166
In this case, the JSON structure
the demo that this one, one JSON and

34
00:01:58.166 --> 00:02:04.366
it will show you and a structure at
the right ready to copy and paste, okay?

35
00:02:04.366 --> 00:02:05.884
Makes sense?

36
00:02:05.884 --> 00:02:09.721
It says if it allows
inline type definition.

37
00:02:09.721 --> 00:02:11.610
What's that?

38
00:02:11.610 --> 00:02:13.577
Well, let's say that if the JSON,

39
00:02:13.577 --> 00:02:17.128
I wanna see if I can increase
the font size a little bit like that.

40
00:02:17.128 --> 00:02:22.700
So if the JSON has another structure, for
example, it says it has the currency.

41
00:02:23.860 --> 00:02:26.773
And the currency I'm just
faking a JSON structure here.

42
00:02:26.773 --> 00:02:30.260
And the currency is another
object that has a name.

43
00:02:31.680 --> 00:02:38.269
Look what happens and the name is Bitcoin.

44
00:02:38.269 --> 00:02:43.363
Look what happens here the currency
it's of type new structure.

45
00:02:43.363 --> 00:02:45.850
Those are inline type definitions.

46
00:02:45.850 --> 00:02:47.154
If I unclick that,

47
00:02:47.154 --> 00:02:51.480
the currency is a currency extract
defined here at the bottom.

48
00:02:52.610 --> 00:02:56.966
So when you have structures
like other objects or

49
00:02:56.966 --> 00:03:03.246
arrays within the JSON, thios tool
will create all the code for that.

50
00:03:03.246 --> 00:03:07.522
And also it can be the currency,
let's say the currency is an array, so

51
00:03:07.522 --> 00:03:11.760
I can say an array, and
now you can see it's a slice of currency.

52
00:03:11.760 --> 00:03:14.475
So it works pretty good, pretty okay.

53
00:03:14.475 --> 00:03:16.780
So let me remove that.

54
00:03:16.780 --> 00:03:20.792
Let's copy the structure,
you can copy to clipboard.

55
00:03:20.792 --> 00:03:23.300
And now let's paste it here.

56
00:03:24.400 --> 00:03:26.400
I have a typo here.

57
00:03:26.400 --> 00:03:29.432
I need to replace that autogenerated name.

58
00:03:29.432 --> 00:03:30.832
And now it looks like this.

59
00:03:30.832 --> 00:03:36.720
And you know everything,
but not that part.

60
00:03:38.660 --> 00:03:39.990
So that's new.

61
00:03:39.990 --> 00:03:41.420
We haven't seen this.

62
00:03:42.810 --> 00:03:44.231
What that?
What the back tick there with

63
00:03:44.231 --> 00:03:46.030
something there?

64
00:03:46.030 --> 00:03:48.050
Well, what is that?

65
00:03:48.050 --> 00:03:51.100
So let's go full screen with this one.

66
00:03:54.796 --> 00:04:01.450
Properties in structures can contain
metadata that is just a string, okay?

67
00:04:03.480 --> 00:04:05.261
For example, I can create an Id here.

68
00:04:05.261 --> 00:04:07.349
I'll say it's an integer.

69
00:04:07.349 --> 00:04:12.061
And I can open a string and say it
will be auto automatic id, blah, blah,

70
00:04:12.061 --> 00:04:13.470
blah, blah, blah.

71
00:04:13.470 --> 00:04:18.170
It's kind of a comment that
you can add on properties.

72
00:04:18.170 --> 00:04:19.780
It's just a string.

73
00:04:19.780 --> 00:04:22.600
Will go do something with that?

74
00:04:22.600 --> 00:04:25.727
No, it's like a comment.

75
00:04:25.727 --> 00:04:30.598
However, back caches,
libraries, frameworks,

76
00:04:30.598 --> 00:04:36.699
they can read using reflection APIs,
those comments, labels.

77
00:04:38.290 --> 00:04:45.847
The json library can read metadata when
it's marshaling or unmarshaling objects.

78
00:04:45.847 --> 00:04:50.790
It can read that, and we can specify
that metadata for that library.

79
00:04:51.880 --> 00:04:57.479
Reflection APIs lets you
inspect types on the fly.

80
00:04:57.479 --> 00:05:00.727
So what it means is that
when you use json column,

81
00:05:00.727 --> 00:05:05.760
it means I'm going to give you
an instruction for the JSON library.

82
00:05:05.760 --> 00:05:09.817
Then I could add more things here for
other libraries, okay?

83
00:05:09.817 --> 00:05:15.218
It can be an object to database
mapping library or things like that,

84
00:05:15.218 --> 00:05:19.780
that can create the SQL code for
you, things like that.

85
00:05:19.780 --> 00:05:23.498
The thing is that JSON needs the the
instruction that you're going to send to

86
00:05:23.498 --> 00:05:25.022
the library in double quotes.

87
00:05:25.022 --> 00:05:28.683
So that's why I'm not using double quotes
there because then they have a quote

88
00:05:28.683 --> 00:05:29.880
problem.

89
00:05:29.880 --> 00:05:31.330
So that's why typically we use backtick.

90
00:05:31.330 --> 00:05:34.258
That is another way to
the final string in Go.

91
00:05:34.258 --> 00:05:36.486
So then we can use double quotes inside.

92
00:05:36.486 --> 00:05:39.233
So roughly, what you need is here,

93
00:05:39.233 --> 00:05:44.190
you're going to specify how is
that property named in the JSON.

94
00:05:45.540 --> 00:05:48.122
So then you can map, instead of here,

95
00:05:48.122 --> 00:05:53.070
if you say, for example, well,
first you can use capital letters now.

96
00:05:53.070 --> 00:05:58.505
And if you have one property with
a hyphen, with a space, or something like

97
00:05:58.505 --> 00:06:03.960
that, then you have a different thing
on your side, and now it would work.

98
00:06:03.960 --> 00:06:09.326
So this is the mapping definition between
the JSON and your Go structure, okay?

99
00:06:09.326 --> 00:06:11.180
That make sense?

100
00:06:13.030 --> 00:06:19.183
So we save this and now we know
that that wasn't exactly correct.

101
00:06:19.183 --> 00:06:24.320
So we actually need to create
not a cryptoRate object.

102
00:06:24.320 --> 00:06:30.365
We need to create let's say a response
object based on the CEX response.

103
00:06:30.365 --> 00:06:35.728
And that's what we're going to pass
to the unmarshall function, okay?

104
00:06:35.728 --> 00:06:40.979
So I have just changed this line and also
changed the variable that I'm sending.

105
00:06:44.039 --> 00:06:45.270
That's typically what you're going to do.

106
00:06:45.270 --> 00:06:49.550
You're not going to unmarshal a JSON
directly into your structure.

107
00:06:50.600 --> 00:06:55.780
You're going to create another
structure that represents the JSON.

108
00:06:55.780 --> 00:06:56.699
Make sense?

109
00:06:58.290 --> 00:07:00.322
And the other thing that I
need to change is the price.

110
00:07:00.322 --> 00:07:01.560
It's a fixed price.

111
00:07:01.560 --> 00:07:04.870
So now I need to get the price
from their response.

112
00:07:04.870 --> 00:07:09.170
The problem that I have at this point
is that response does not exist.

113
00:07:10.300 --> 00:07:12.299
Does anyone know why?

114
00:07:12.299 --> 00:07:13.520
The declaration is there.

115
00:07:15.290 --> 00:07:16.030
&gt;&gt; Scope code.

116
00:07:16.030 --> 00:07:19.241
&gt;&gt; The scope, because that
declaration is within the if so,

117
00:07:19.241 --> 00:07:22.450
I just need to move that declaration up.

118
00:07:22.450 --> 00:07:27.896
So then I could be using and getting
from here the last, something like that.

119
00:07:33.310 --> 00:07:40.373
Then it's complaining because
the last it's float64.

120
00:07:42.370 --> 00:07:47.365
I'm expecting a float 64 and

121
00:07:47.365 --> 00:07:50.252
last is a string.

122
00:07:50.252 --> 00:07:53.160
You say, why?

123
00:07:54.910 --> 00:07:58.939
Well, that is because that's
how the JSON is being defined.

124
00:07:58.939 --> 00:08:01.300
Last is a string.

125
00:08:01.300 --> 00:08:03.670
I don't know why,
I didn't create the service.

126
00:08:03.670 --> 00:08:07.659
If you actually want the float,
we have bid or ask, okay?

127
00:08:07.659 --> 00:08:09.332
Those are floats.

128
00:08:09.332 --> 00:08:13.375
If not,
we have to convert the string into that.

129
00:08:13.375 --> 00:08:18.305
And there is an strconv back cache
that lets you convert the strings to

130
00:08:18.305 --> 00:08:21.365
other objects, but
if not we can take bid or

131
00:08:21.365 --> 00:08:26.258
ask, Because they are actually floats or
integers.

132
00:08:26.258 --> 00:08:28.796
In this case they are integers.

133
00:08:28.796 --> 00:08:31.105
So if you look at that, I even type float.

134
00:08:31.105 --> 00:08:35.880
If I select B because it's an integer,
why it's an integer, I don't know.

135
00:08:35.880 --> 00:08:38.012
It's part of the service.

136
00:08:38.012 --> 00:08:43.136
If I press return,
it will actually add me automatically,

137
00:08:43.136 --> 00:08:46.320
the float64 converter function.

138
00:08:50.505 --> 00:08:52.680
Okay, make sense?

139
00:08:52.680 --> 00:08:55.019
Yeah, well, actually,
maybe it's not an integer.

140
00:08:55.019 --> 00:08:59.730
Maybe it was dot 0 and
we don't see the dot 0.

141
00:08:59.730 --> 00:09:03.918
So if that's the case because
ask is a float, B, no,

142
00:09:03.918 --> 00:09:06.537
because maybe it was just dot 0.

143
00:09:06.537 --> 00:09:10.849
So maybe I can go and
change this into float64.

144
00:09:10.849 --> 00:09:12.845
I would say, no, you know what?

145
00:09:12.845 --> 00:09:16.290
The marshall, that's a float.

146
00:09:16.290 --> 00:09:20.539
Even if in the current example,
it was an integer, I know it's a float.

147
00:09:20.539 --> 00:09:22.410
So you can change that.

148
00:09:22.410 --> 00:09:26.667
And then I don't need the converter.

149
00:09:28.611 --> 00:09:34.227
&gt;&gt; Is there a reason that you can't
change that data type in that structure,

150
00:09:34.227 --> 00:09:35.326
right there?

151
00:09:35.326 --> 00:09:38.304
Like you changed it from
an intuitive float64?

152
00:09:38.304 --> 00:09:41.917
Is there a reason that you can't just-
&gt;&gt; What the reason is that,

153
00:09:41.917 --> 00:09:43.010
you write this?

154
00:09:44.090 --> 00:09:44.750
You say, well, I didn't write it.

155
00:09:44.750 --> 00:09:48.690
Well actually we use
a tool to generate that.

156
00:09:48.690 --> 00:09:53.587
So the tool based on the current example
make the automatic decision that

157
00:09:53.587 --> 00:09:55.040
that's an integer.

158
00:09:55.040 --> 00:10:00.280
But maybe it was just because
of the JSON we took as a sample.

159
00:10:00.280 --> 00:10:04.141
If I change this, it's going to say,
no, no, it's a float.

160
00:10:04.141 --> 00:10:10.650
So the example that I, maybe I go
again to the same URL I refresh.

161
00:10:10.650 --> 00:10:11.544
And maybe I get a different value.

162
00:10:11.544 --> 00:10:14.960
Look at this bid now has a decimal.

163
00:10:14.960 --> 00:10:19.417
So we had that luck and we took just
one json where it was an integer.

164
00:10:19.417 --> 00:10:24.358
And yeah, that automatic tool thought
that it's always an integer, but

165
00:10:24.358 --> 00:10:26.330
it wasn't the case.

166
00:10:26.330 --> 00:10:27.253
So yeah, you can go and change it.

167
00:10:27.253 --> 00:10:29.625
Of course,
if you change that with a different type,

168
00:10:29.625 --> 00:10:33.030
completely different type you say,
this is an array in a slice.

169
00:10:33.030 --> 00:10:35.132
And then it's not an array in the JSON,

170
00:10:35.132 --> 00:10:37.948
it will give you an error
when you are unmarshaling.

171
00:10:37.948 --> 00:10:40.250
It says, no, I cannot match the structure.

172
00:10:41.884 --> 00:10:45.280
&gt;&gt; But you can't just change one
of those strings to a float64,

173
00:10:45.280 --> 00:10:47.650
because it would give you an error?

174
00:10:47.650 --> 00:10:52.285
&gt;&gt; It will throw an error on
the unmarshal operation, yeah.

175
00:10:52.285 --> 00:10:53.368
Okay, make sense?

176
00:10:53.368 --> 00:10:56.990
So let's see.

177
00:10:56.990 --> 00:11:02.890
If I run this,
I'm getting something really weird here.

178
00:11:02.890 --> 00:11:03.714
I don't like it.

179
00:11:03.714 --> 00:11:06.975
But because we're using print,

180
00:11:06.975 --> 00:11:12.916
maybe we should do something
like if we don't have an error,

181
00:11:12.916 --> 00:11:17.458
I can talk with my format library and
printf and

182
00:11:17.458 --> 00:11:22.150
say the rate for a value is another value.

183
00:11:22.150 --> 00:11:24.381
But the second value is
going to be a float.

184
00:11:24.381 --> 00:11:29.920
So if you want to float with some specific
digits, you use, for example, 2f.

185
00:11:29.920 --> 00:11:33.443
That's a float with two decimal digits.

186
00:11:33.443 --> 00:11:38.345
And then I will take
the rate.Currency as the first

187
00:11:38.345 --> 00:11:43.249
argument and
rate.Price as the second argument.

188
00:11:43.249 --> 00:11:48.915
And if I run this, it says the rate for
BTC is a lot of money.

189
00:11:48.915 --> 00:11:53.591
$36,000 at the time of
shooting this video.

190
00:11:53.591 --> 00:11:58.156
And also I can end this with a backhand,
so

191
00:11:58.156 --> 00:12:01.677
that's for a new line, \n, so

192
00:12:01.677 --> 00:12:07.417
we don't have that,
present symbol you see there,

193
00:12:07.417 --> 00:12:11.600
that means that there was no new line.

194
00:12:11.600 --> 00:12:14.141
So now if I run this, I'm getting that.

