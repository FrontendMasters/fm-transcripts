WEBVTT

1
00:00:00.030 --> 00:00:05.713
So some characteristics,
it has a strong static type system.

2
00:00:05.713 --> 00:00:09.501
So everything, we have a type,
if it's an integer,

3
00:00:09.501 --> 00:00:13.975
it's an integer, cannot be a string,
as in other languages.

4
00:00:13.975 --> 00:00:16.628
It has a C-inspired syntax.

5
00:00:16.628 --> 00:00:21.473
However, that doesn't mean it's a super
set of C as other languages such as

6
00:00:21.473 --> 00:00:22.393
objective C.

7
00:00:22.393 --> 00:00:27.210
Or it's not actually based on C,
but it has some ideas,

8
00:00:27.210 --> 00:00:31.731
for example,
we use code blocks with curly braces.

9
00:00:31.731 --> 00:00:34.867
So if you have an if, if you have
a function, you open curly braces,

10
00:00:34.867 --> 00:00:36.033
you close curly braces.

11
00:00:36.033 --> 00:00:37.903
Well, that's coming from C.

12
00:00:37.903 --> 00:00:40.977
There are other languages, Ruby, Python.

13
00:00:40.977 --> 00:00:43.743
Not following that, okay?

14
00:00:43.743 --> 00:00:45.217
So have that in mind.

15
00:00:45.217 --> 00:00:47.094
Do you need to know C to get into Go?

16
00:00:47.094 --> 00:00:48.915
No, not really.

17
00:00:48.915 --> 00:00:52.465
But if you have ever played
with other C-based languages,

18
00:00:52.465 --> 00:00:55.101
maybe you will feel at
home with some ideas.

19
00:00:55.101 --> 00:01:00.057
That can be Java, C Sharp,
C, C++, even JavaScript,

20
00:01:00.057 --> 00:01:04.316
PHP, all those languages
are coming from From C.

21
00:01:04.316 --> 00:01:07.178
It's compiled, so
actually we need to compile the code.

22
00:01:07.178 --> 00:01:11.561
We developers, we have to compile
the code to execute that.

23
00:01:11.561 --> 00:01:16.154
It's multi-paradigm, so if you ask me,
is it functional programming?

24
00:01:16.154 --> 00:01:19.997
Is it object-oriented programming?

25
00:01:19.997 --> 00:01:22.961
Actually it's up to you.

26
00:01:22.961 --> 00:01:28.880
It's not actually forcing us
into any paradigm in particular.

27
00:01:28.880 --> 00:01:32.577
The idea is to keep this simple, so

28
00:01:32.577 --> 00:01:37.043
we should try to keep this simple, okay?

29
00:01:37.043 --> 00:01:43.033
It's garbage-collected, do you know what
garbage collection means in your language?

30
00:01:43.033 --> 00:01:47.684
If anyone wants to, yeah,
&gt;&gt; Getting rid of the memory, or

31
00:01:47.684 --> 00:01:53.175
the objects that are stored in memory
that are no longer needed automatically,

32
00:01:53.175 --> 00:01:53.881
&gt;&gt; Okay, and

33
00:01:53.881 --> 00:01:57.580
you add the word objects there
that we don't have here.

34
00:01:57.580 --> 00:01:58.402
But that's fine.

35
00:01:58.402 --> 00:01:59.921
No, no, it's fine.

36
00:01:59.921 --> 00:02:01.020
So yeah, that's correct.

37
00:02:01.020 --> 00:02:05.585
So actually a language that is a garbage
collector means that when you create

38
00:02:05.585 --> 00:02:09.810
a variable, it doesn't need to be
an object, it can be any variable.

39
00:02:09.810 --> 00:02:14.165
When you don't need it anymore,
you don't need to care about that, okay?

40
00:02:14.165 --> 00:02:19.252
And unless you have
ever played with C++ or

41
00:02:19.252 --> 00:02:25.449
other languages objective C,
or even Swift for iOS.

42
00:02:25.449 --> 00:02:28.695
They don't have garbage collection.

43
00:02:28.695 --> 00:02:29.808
You are used to that, so

44
00:02:29.808 --> 00:02:33.665
maybe you even didn't know that there
were languages that they don't have that.

45
00:02:33.665 --> 00:02:36.329
There are some languages when
you create the variable,

46
00:02:36.329 --> 00:02:39.569
you also need to delete the variable
when you don't use it anymore.

47
00:02:39.569 --> 00:02:41.605
That was the idea originally.

48
00:02:41.605 --> 00:02:48.880
You create something, you delete something
before closing your app for example.

49
00:02:48.880 --> 00:02:52.273
Because if not,
you were creating memory leaks.

50
00:02:52.273 --> 00:02:56.706
That is pieces of memories of your
computer, of the operating system that

51
00:02:56.706 --> 00:03:01.004
are occupied with data, but
no one is actually using the data anymore.

52
00:03:01.004 --> 00:03:06.252
So after a while, your computer, has
no more enough memory for running other

53
00:03:06.252 --> 00:03:11.275
apps because it's occupied with parts
that are not used anymore, okay?

54
00:03:11.275 --> 00:03:14.179
Anyway, we do have garbage collection and

55
00:03:14.179 --> 00:03:17.899
the garbage collection system,
it's simplifying.

56
00:03:17.899 --> 00:03:20.955
It's like,
think about the separate process.

57
00:03:20.955 --> 00:03:25.370
That is looking into your memory and
see if you have some variables or

58
00:03:25.370 --> 00:03:29.715
objects that you have created in
memory that no one is pointing at.

59
00:03:29.715 --> 00:03:33.037
If no one is pointing at an option
in memory, it's like, well,

60
00:03:33.037 --> 00:03:34.894
no one is going to use that anymore.

61
00:03:34.894 --> 00:03:37.852
So, the garbage collector
will delete that from memory.

62
00:03:37.852 --> 00:03:43.135
So, it's a process that deletes data
that is not being used anymore.

63
00:03:43.135 --> 00:03:46.021
And why is that you don't have any points?

64
00:03:46.021 --> 00:03:51.019
Well, because the variable that was
pointing to that thing loses the scope.

65
00:03:51.019 --> 00:03:56.532
So I mean the function ends or
maybe you assign a different object so

66
00:03:56.532 --> 00:04:01.662
the the previous one has no links anymore,
things like that.

67
00:04:01.662 --> 00:04:02.975
So we don't need to care about that.

68
00:04:02.975 --> 00:04:05.397
So we create a variable and we don't care.

69
00:04:05.397 --> 00:04:07.397
I mean, I'm overreacting.

70
00:04:07.397 --> 00:04:11.854
We should care about memory management,
but in terms of deleting the variables

71
00:04:11.854 --> 00:04:15.791
that we create, that's not something
that we need to do explicitly.

72
00:04:15.791 --> 00:04:17.779
It's fast, okay?

73
00:04:17.779 --> 00:04:19.041
Remember, that was the goal.

74
00:04:19.041 --> 00:04:20.073
So it's fast and

75
00:04:20.073 --> 00:04:24.590
that's why there are a lot of Go
developers are really excited about Go.

76
00:04:24.590 --> 00:04:28.633
And when you say no, let's move to
NodeJS and say, no, no, no, no, no.

77
00:04:28.633 --> 00:04:30.376
We keep with Go.

78
00:04:30.376 --> 00:04:33.368
And typically it's because it's faster.

79
00:04:33.368 --> 00:04:37.972
It's faster than any other platform,
for example for web services or

80
00:04:37.972 --> 00:04:40.243
micro services things like that.

81
00:04:40.243 --> 00:04:43.163
And it creates a single
binary compilation.

82
00:04:43.163 --> 00:04:46.085
So we compile and we create one file.

83
00:04:46.085 --> 00:04:50.963
So it's not based, I mean you can
do things but by default it's not

84
00:04:50.963 --> 00:04:55.843
based on for example DLLs on Windows or
dynamic libraries where you

85
00:04:55.843 --> 00:05:00.657
have to create several compilations and
then link them somehow.

86
00:05:00.657 --> 00:05:02.475
Here, the idea is to make things simple.

87
00:05:02.475 --> 00:05:08.872
We create one executable output
from our code, okay?, Make sense?

88
00:05:08.872 --> 00:05:11.820
So it's not really important, but for

89
00:05:11.820 --> 00:05:15.480
you to get into the mindset
of the timeline of Go,

90
00:05:15.480 --> 00:05:21.574
the pressure has started in 2007 but
it was publicly announced in 2009.

91
00:05:21.574 --> 00:05:24.847
I was there at Google IO when
they announced that, and

92
00:05:24.847 --> 00:05:27.901
we were all kind of confused
about why do we need and

93
00:05:27.901 --> 00:05:32.875
use that language we weren't actually
understanding the reasons behind this.

94
00:05:32.875 --> 00:05:37.634
First version appeared 2012
to around 10 years ago.

95
00:05:37.634 --> 00:05:41.576
And right now we are in version one,
the training, okay?

96
00:05:41.576 --> 00:05:45.229
So if you make all the calcs,

97
00:05:45.229 --> 00:05:50.869
it's kind of two versions per year, okay?

98
00:05:50.869 --> 00:05:54.277
However, these updates are minor updates.

99
00:05:54.277 --> 00:05:58.789
In fact, there is a rule,
at least within Go 1.x,

100
00:05:58.789 --> 00:06:04.651
that every new version will be
always fully backwards compatible.

101
00:06:04.651 --> 00:06:09.782
Because they want to reduce
the risk of that in the future.

102
00:06:09.782 --> 00:06:13.298
So if they add a feature, and
sometimes they're adding features,

103
00:06:13.298 --> 00:06:17.062
sometimes they're not adding big features,
it's just solving bugs or

104
00:06:17.062 --> 00:06:20.534
increasing the performance of
that function, things like that.

105
00:06:20.534 --> 00:06:23.374
But sometimes they're adding
some minor updates and

106
00:06:23.374 --> 00:06:25.844
sometimes some new things
into the language.

107
00:06:25.844 --> 00:06:29.143
For example, they have other generics.

108
00:06:29.143 --> 00:06:32.362
We will explain what they are later, but

109
00:06:32.362 --> 00:06:38.337
they have other generics in a 1.18
that it was released like a year ago.

110
00:06:38.337 --> 00:06:43.305
So that's like a new language feature,
but it's not like other

111
00:06:43.305 --> 00:06:47.916
languages that are evolving
like faster compared with Go.

112
00:06:47.916 --> 00:06:50.414
Kotlin, Swift, even Java today,

113
00:06:50.414 --> 00:06:54.589
they are trying to keep evolving
the language all the time.

114
00:06:54.589 --> 00:06:59.698
But that also adds risks and
also adds some kind of stress to

115
00:06:59.698 --> 00:07:05.553
developers that they need to keep
being updated every six months.

116
00:07:05.553 --> 00:07:06.966
So let's see you Angular.

117
00:07:06.966 --> 00:07:10.805
Now we have Angular 25,
let's see what's new.

118
00:07:10.805 --> 00:07:13.737
They're changing how they're doing things,
so

119
00:07:13.737 --> 00:07:16.473
I need to test if my code
will still work or not.

120
00:07:16.473 --> 00:07:17.322
I need to make changes.

121
00:07:17.322 --> 00:07:22.366
Well, that stress shouldn't be here,
and you can safely update to

122
00:07:22.366 --> 00:07:27.778
a new version of Go when it appears or
you can keep it with the one you have.

123
00:07:27.778 --> 00:07:32.359
You just read the change log and
see if the updates that they have

124
00:07:32.359 --> 00:07:37.207
added are going to increase
performance on your app or something.

125
00:07:37.207 --> 00:07:40.929
But they're trying to keep backwards
compatibility all the time.

126
00:07:40.929 --> 00:07:46.783
There is only one exception to that, is
that if they found a security or something

127
00:07:46.783 --> 00:07:51.791
like that, they might change the API and
they will like give us the warning.

128
00:07:51.791 --> 00:07:52.563
Okay, you know what?

129
00:07:52.563 --> 00:07:58.419
We have to change that API because that's
not typically the normal situation.

130
00:07:58.419 --> 00:08:02.391
What about Go 2,
there is a project to create the Go 2.

131
00:08:02.391 --> 00:08:07.124
Like, okay, but it's going to
be like a new language again,

132
00:08:07.124 --> 00:08:10.870
and it's not going to force
us to move into Go 2.

133
00:08:10.870 --> 00:08:13.650
And maybe it will never happen.

134
00:08:13.650 --> 00:08:14.328
So we don't know.

135
00:08:14.328 --> 00:08:19.459
So it's not like, yeah,
in 2025 we will release Go 2, no.

136
00:08:19.459 --> 00:08:24.638
It's like a parallel project saying,
okay, with the experience that

137
00:08:24.638 --> 00:08:30.699
we have gathered over a decade with Go 1,
can we do something better or different?

138
00:08:30.699 --> 00:08:33.116
But it's going to be a different language,
and

139
00:08:33.116 --> 00:08:35.785
it's not going to be backwards compatible,
okay?

140
00:08:35.785 --> 00:08:42.094
So but there is nothing that says
that that's gonna change quickly.

