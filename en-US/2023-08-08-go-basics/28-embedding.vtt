WEBVTT

1
00:00:00.122 --> 00:00:03.463
Okay, so far we've seen structures,

2
00:00:03.463 --> 00:00:09.041
we've seen that we have a couple
of times to use capital letters.

3
00:00:09.041 --> 00:00:13.610
And although those were like the bad news,
we'll see how to add methods,

4
00:00:13.610 --> 00:00:17.235
how to define methods to these
types that we are creating.

5
00:00:17.235 --> 00:00:20.557
How to use a constructor,
how to create a factory.

6
00:00:20.557 --> 00:00:24.483
And now let me give you some
kind of a good news now.

7
00:00:24.483 --> 00:00:30.627
So let's say that now here in front end
masters we have like 2 kind of products.

8
00:00:30.627 --> 00:00:34.651
You have workshops and courses and then
a workshop is converted into a course.

9
00:00:34.651 --> 00:00:38.741
So let's say you want to create
another data structure for a workshop.

10
00:00:38.741 --> 00:00:43.856
This is a kind of moment
where you will start missing.

11
00:00:43.856 --> 00:00:50.324
We'll be right so that first package data,
because you say hey yeah I need to,

12
00:00:50.324 --> 00:00:56.803
I would like to inherit from and maybe
add some property or modify some things.

13
00:00:56.803 --> 00:01:00.526
Such as, for example,
the workshop has the same property,

14
00:01:00.526 --> 00:01:05.137
has an instructor the name, but
also has a date because it's live, okay?

15
00:01:05.137 --> 00:01:09.710
So you say, yeah,
I'm expecting something like creating

16
00:01:09.710 --> 00:01:14.383
a type name workshop,
the capital W extending from, okay?

17
00:01:14.383 --> 00:01:17.936
But yeah, no, this is Go so we won't have,

18
00:01:17.936 --> 00:01:21.886
it's an structure and
we have to deal with this.

19
00:01:21.886 --> 00:01:23.257
Should I copy and paste?

20
00:01:23.257 --> 00:01:26.182
We know that copy and
paste is not a good idea.

21
00:01:26.182 --> 00:01:27.562
So what options do we have?

22
00:01:27.562 --> 00:01:28.569
We do have options.

23
00:01:28.569 --> 00:01:34.038
Well, one option is to just create
the property here with the course.

24
00:01:34.038 --> 00:01:37.106
So we can create a course of type course.

25
00:01:37.106 --> 00:01:41.514
Which, yeah, and then add the date.

26
00:01:41.514 --> 00:01:45.086
By the way, let's use capital D.

27
00:01:45.086 --> 00:01:47.249
Do we have any type for the date?

28
00:01:47.249 --> 00:01:50.728
We don't have the date time, but

29
00:01:50.728 --> 00:01:56.827
there is a time standard library
package with a time type.

30
00:01:56.827 --> 00:02:01.128
And from that type,
we have methods to get set, and

31
00:02:01.128 --> 00:02:05.946
get the date in different formats,
and we can add dates.

32
00:02:05.946 --> 00:02:10.578
So, that's the type that we use for
dates on time.

33
00:02:10.578 --> 00:02:11.782
Yeah, it works.

34
00:02:11.782 --> 00:02:16.729
So, then when you are creating,
let's create, for example, here.

35
00:02:16.729 --> 00:02:23.538
Now and workshop on Swift Forever,
that I did a workshop on Swift so

36
00:02:23.538 --> 00:02:30.243
I'm going to create a swift Workshop
that it's going to be data.

37
00:02:30.243 --> 00:02:35.155
Use column on equal, so the shortcuts
will create a variable data.wokrshop.

38
00:02:35.155 --> 00:02:36.499
It's a workshop, okay?

39
00:02:36.499 --> 00:02:39.506
And the workshop has two
properties course and the date.

40
00:02:39.506 --> 00:02:44.627
And the course, we know it's a data
course and we can pass all the data.

41
00:02:44.627 --> 00:02:48.022
I'm going to refactor this just for
you to know.

42
00:02:48.022 --> 00:02:49.629
But will it work?

43
00:02:49.629 --> 00:02:50.291
It should.

44
00:02:50.291 --> 00:02:54.756
So this is the swift for iOS workshop and

45
00:02:54.756 --> 00:02:59.229
maybe we can set the instructor as max.

46
00:02:59.229 --> 00:03:05.173
So, and then we have the other
property comma for the date.

47
00:03:05.173 --> 00:03:09.184
And we can see that we have a now,
for example and

48
00:03:09.184 --> 00:03:12.404
then we can add some days or whatever.

49
00:03:12.404 --> 00:03:15.350
We can say now and that's all.

50
00:03:15.350 --> 00:03:19.540
So can we do that?

51
00:03:19.540 --> 00:03:20.939
Yeah, we should work.

52
00:03:20.939 --> 00:03:24.793
And then I can print f, that workshop.

53
00:03:24.793 --> 00:03:31.896
Again, capital W, and then Swift Workshop.

54
00:03:31.896 --> 00:03:34.062
The problem is that, yeah,

55
00:03:34.062 --> 00:03:38.950
Swift Workshop is not implementing
that string method, okay?

56
00:03:38.950 --> 00:03:44.101
So remember, the string method
that we created four cores,

57
00:03:44.101 --> 00:03:49.252
so it's not working here that's
why it's giving me an error

58
00:03:49.252 --> 00:03:55.517
that swiftWS it's not suitable for
Printf because we don't have it yet.

59
00:03:55.517 --> 00:03:58.713
So I mean it works.

60
00:03:58.713 --> 00:04:00.180
It's like a complex structure.

61
00:04:00.180 --> 00:04:04.937
We have a workshop with a course, but
we feel like we don't like it, right?

62
00:04:04.937 --> 00:04:10.062
I mean, it's a solution, but
it doesn't feel like the right solution.

63
00:04:10.062 --> 00:04:11.355
Do we have a better solution?

64
00:04:11.355 --> 00:04:12.565
Yes, we do.

65
00:04:12.565 --> 00:04:15.222
It's called embedding.

66
00:04:15.222 --> 00:04:21.985
With embedding, the only thing that I'm
going to do is I'm going to remove here,

67
00:04:21.985 --> 00:04:27.475
the identifier, okay, you can see
that we have the identifier and

68
00:04:27.475 --> 00:04:33.576
the type, we will remove the identifier
and just keep the type like that.

69
00:04:33.576 --> 00:04:35.310
When I'm doing this,

70
00:04:35.310 --> 00:04:40.528
this isn't merely an embedding
one type into another type, okay?

71
00:04:40.528 --> 00:04:45.084
So where I'm embedding the course within
the workshop, so now that workshop,

72
00:04:45.084 --> 00:04:47.740
now my constructor shouldn't work anymore.

73
00:04:47.740 --> 00:04:50.488
Let me start this constructor again.

74
00:04:50.488 --> 00:04:54.439
Now when I'm creating a workshop,
so that's an empty workshop.

75
00:04:54.439 --> 00:04:59.730
The workshop has, look at the properties,

76
00:04:59.730 --> 00:05:04.741
instructor, ID, name, legacy, why?

77
00:05:04.741 --> 00:05:08.997
Because it's embedding
all the other properties.

78
00:05:08.997 --> 00:05:12.760
It's embedding all
the properties from course.

79
00:05:12.760 --> 00:05:15.231
Is it extending from?

80
00:05:15.231 --> 00:05:17.424
Not, but close enough.

81
00:05:17.424 --> 00:05:19.946
So, no, but close enough.

82
00:05:19.946 --> 00:05:24.367
All the properties from course
are now part of the workshop.

83
00:05:27.228 --> 00:05:30.954
Okay, so I didn't need to copy and paste,

84
00:05:30.954 --> 00:05:34.791
I just embedded the type
within other type.

85
00:05:34.791 --> 00:05:39.545
And do we have the output also, we'll see.

86
00:05:39.545 --> 00:05:42.706
Well, first,
let me clean this up a little bit.

87
00:05:42.706 --> 00:05:44.058
Also, what about the constructor?

88
00:05:44.058 --> 00:05:50.617
The only thing is that in the constructor,
we don't have those properties.

89
00:05:50.617 --> 00:05:52.292
That's a disadvantage.

90
00:05:52.292 --> 00:05:55.252
So we have only the direct
properties such as course.

91
00:05:55.252 --> 00:05:57.596
We still have the course, okay?

92
00:05:57.596 --> 00:06:01.828
So I cannot say the name of the course
directly in the constructor, for

93
00:06:01.828 --> 00:06:04.355
that it's better to create the factory.

94
00:06:04.355 --> 00:06:10.895
Remember factories, so you can create
the function here, new workshop.

95
00:06:10.895 --> 00:06:14.302
That receives the name of the workshop.

96
00:06:14.302 --> 00:06:17.654
And maybe the instructor,

97
00:06:17.654 --> 00:06:22.472
should I capitalize these names here?

98
00:06:28.847 --> 00:06:30.345
&gt;&gt; It's a type?

99
00:06:30.345 --> 00:06:31.105
Then yes.

100
00:06:31.105 --> 00:06:33.031
&gt;&gt; The type, is this one.

101
00:06:33.031 --> 00:06:33.686
&gt;&gt; Yeah, that should be it.

102
00:06:33.686 --> 00:06:37.103
&gt;&gt; But I'm talking about
maybe no the identifiers.

103
00:06:37.103 --> 00:06:38.632
No, those are local variables.

104
00:06:38.632 --> 00:06:41.600
You can if you want, but
it won't make any difference.

105
00:06:41.600 --> 00:06:43.911
So an argument is a local
variable to the function.

106
00:06:43.911 --> 00:06:49.899
So, no need for capitalizing those,
so I'm going to return a workshop,

107
00:06:49.899 --> 00:06:54.161
so I'm going to create a variable or
I can say like W.

108
00:06:54.161 --> 00:06:58.136
That's a workshop, it's a new workshop and

109
00:06:58.136 --> 00:07:03.481
I'm going to return that W and
then I can set the name as name.

110
00:07:03.481 --> 00:07:05.880
And the instructor as the instructor.

111
00:07:05.880 --> 00:07:10.040
So now I have a better way to
construct the workshop quickly.

112
00:07:10.040 --> 00:07:14.942
By the way, what happens if
the workshop also has a name?

113
00:07:17.661 --> 00:07:19.822
We know the course has a name.

114
00:07:19.822 --> 00:07:22.831
Now we are embedding
the course into the workshop.

115
00:07:22.831 --> 00:07:26.373
And now we have two names.

116
00:07:26.373 --> 00:07:29.096
We have a problem, right?

117
00:07:29.096 --> 00:07:31.053
Does it make sense?

118
00:07:31.053 --> 00:07:31.870
What will happen?

119
00:07:31.870 --> 00:07:36.562
Well, in this case, when you access the
name, it will be the workshop's name and

120
00:07:36.562 --> 00:07:37.789
not the course name.

121
00:07:37.789 --> 00:07:39.366
If you want the course name,

122
00:07:39.366 --> 00:07:42.931
you still have the property with
the name of the type available.

123
00:07:46.489 --> 00:07:48.973
Okay, make sense?

124
00:07:48.973 --> 00:07:51.297
Do you wanna make things more complicated?

125
00:07:51.297 --> 00:07:53.279
You don't need to type this, okay?

126
00:07:53.279 --> 00:07:54.596
Because I'm going to delete that.

127
00:07:54.596 --> 00:07:59.480
But let's say I create
another type that is called,

128
00:07:59.480 --> 00:08:02.375
in fact, no, let's do this.

129
00:08:02.375 --> 00:08:06.142
I'm going to also embed an instructor.

130
00:08:06.142 --> 00:08:08.659
So, can you embed more than one?

131
00:08:08.659 --> 00:08:10.922
Yes.

132
00:08:10.922 --> 00:08:14.798
And now the workshop has all
the properties from the course,

133
00:08:14.798 --> 00:08:19.662
all the properties from the instructor,
and also a name, but let's delete

134
00:08:19.662 --> 00:08:24.536
this name and also the date, but
the instructor and course both have names.

135
00:08:26.647 --> 00:08:30.295
Okay, which is a problem.

136
00:08:30.295 --> 00:08:35.592
In that case you will work
with the embedding property,

137
00:08:35.592 --> 00:08:42.248
.instructor or .course,
you will need to disambiguate that part.

138
00:08:44.133 --> 00:08:45.050
That it make sense?

139
00:08:45.050 --> 00:08:50.029
So, this is kind of inheriting
from several classes,

140
00:08:50.029 --> 00:08:52.639
being C++ you can do that.

141
00:08:52.639 --> 00:08:56.216
This case you have different types,
and maybe,

142
00:08:56.216 --> 00:09:00.765
you have naming collisions, so
the same name of property..

143
00:09:00.765 --> 00:09:04.424
When that happens,
you will need to express okay for

144
00:09:04.424 --> 00:09:08.841
that property, you will need to
say which subtype do you want?

145
00:09:08.841 --> 00:09:12.464
Which embedded type do you wanna use?

146
00:09:12.464 --> 00:09:17.391
&gt;&gt; Can you selectively embed the type like
only take certain properties from it?

147
00:09:17.391 --> 00:09:20.222
&gt;&gt; Only some properties, no.

148
00:09:20.222 --> 00:09:24.839
For that case, you should create
a structure of types where you have

149
00:09:24.839 --> 00:09:29.213
a base type with only a few, and
then you have the other types that

150
00:09:29.213 --> 00:09:33.514
are embedding that one,
adding some, or adding some others.

151
00:09:33.514 --> 00:09:34.672
That's how you do that.

152
00:09:34.672 --> 00:09:42.162
Okay, so
now I can use my data.NewWorkshop.

153
00:09:42.162 --> 00:09:45.107
This is iOS with Swift.

154
00:09:45.107 --> 00:09:48.851
Swift with iOS,

155
00:09:48.851 --> 00:09:52.865
max instructor.

156
00:09:52.865 --> 00:09:56.255
By the way, I have a type of here,
it's not w, it's v.

157
00:09:56.255 --> 00:09:57.652
So now we have a question.

158
00:09:57.652 --> 00:10:02.968
Remember that when we were on
printing the course, okay,

159
00:10:02.968 --> 00:10:08.399
well we're bringing the course
we were using this method.

160
00:10:08.399 --> 00:10:14.599
Remember we replaced the standard
output when that method were for

161
00:10:14.599 --> 00:10:19.366
the workshop or
not because we don't have it here.

162
00:10:19.366 --> 00:10:20.527
Will it work or not?

163
00:10:20.527 --> 00:10:24.345
Well, we can test this in action so

164
00:10:24.345 --> 00:10:29.882
first I have what's going on here,
there we are.

165
00:10:29.882 --> 00:10:36.159
So let's run this and the answer is,
yes that's good news.

166
00:10:36.159 --> 00:10:39.799
So when you are embedding types,

167
00:10:39.799 --> 00:10:45.519
you're also embedding
the methods of those types.

168
00:10:45.519 --> 00:10:49.630
Okay, because we can we can do multiple
embedding that may be a problem

169
00:10:49.630 --> 00:10:50.613
as well, okay?

170
00:10:50.613 --> 00:10:54.643
So because when you have when
you're in main two types, and

171
00:10:54.643 --> 00:10:57.717
they have the same method
with the same name.

172
00:10:57.717 --> 00:11:01.087
That can lead to some issues,
or ambiguity, okay?

173
00:11:01.087 --> 00:11:02.294
But I think that's pretty cool.

174
00:11:02.294 --> 00:11:08.242
Because at the end, this looks
like inheritance, kind of, okay?

175
00:11:08.242 --> 00:11:10.234
Kind of.

176
00:11:10.234 --> 00:11:12.451
So at the end, it wasn't so bad,

177
00:11:12.451 --> 00:11:15.950
we can apply some techniques
from the OOP paradigm.

