WEBVTT

1
00:00:00.060 --> 00:00:01.736
And before going and writing,

2
00:00:01.736 --> 00:00:05.549
we are going to write two projects
before getting into the next topic.

3
00:00:05.549 --> 00:00:08.912
Let's talk a little bit about
contract structures because so

4
00:00:08.912 --> 00:00:11.184
far we did the functions and that's all.

5
00:00:11.184 --> 00:00:15.125
We have if else, that's pretty simple.

6
00:00:15.125 --> 00:00:17.620
Switch, it says reloaded.

7
00:00:17.620 --> 00:00:22.752
I have four for loops,
we don't have while or do while.

8
00:00:22.752 --> 00:00:25.882
Simplicity, we don't need a while.

9
00:00:25.882 --> 00:00:29.423
Probably, you are thinking yeah,
but sometimes the four is, well,

10
00:00:29.423 --> 00:00:31.773
you will see that the four
will be good enough.

11
00:00:31.773 --> 00:00:36.394
We don't need parentheses for
Boolean conditions.

12
00:00:36.394 --> 00:00:38.102
Typically, you write if parentheses.

13
00:00:38.102 --> 00:00:39.992
Well, not here.

14
00:00:39.992 --> 00:00:42.258
Four parentheses, not here.

15
00:00:42.258 --> 00:00:44.524
No parentheses, okay?

16
00:00:44.524 --> 00:00:49.329
And also, we have only one
type of operator for equality.

17
00:00:49.329 --> 00:00:53.947
So we have just = =, we don't have
triple equals or other weird things.

18
00:00:53.947 --> 00:00:55.794
No.

19
00:00:55.794 --> 00:00:57.689
Just one, okay?

20
00:00:57.689 --> 00:00:59.295
Pretty simple.

21
00:00:59.295 --> 00:01:03.750
If, else is typically as you're expecting,

22
00:01:03.750 --> 00:01:08.778
the only strange part is that
you can put more than one

23
00:01:08.778 --> 00:01:14.398
expression in the if condition
with semicolon is the one.

24
00:01:14.398 --> 00:01:18.902
And if you do that,
the last one is the condition, and

25
00:01:18.902 --> 00:01:23.024
then you can, for example,
create variables.

26
00:01:25.275 --> 00:01:28.305
You can create variables
in the if declaration.

27
00:01:28.305 --> 00:01:30.862
What's the point?

28
00:01:30.862 --> 00:01:35.433
The variable that you set
here will live in the if, and

29
00:01:35.433 --> 00:01:38.493
also in the else, but not outside.

30
00:01:38.493 --> 00:01:45.464
So it's kind of a special scope that
is not possible on other languages.

31
00:01:45.464 --> 00:01:49.887
You create a variable on the outer scope,
or then if it's an inner scope, you have

32
00:01:49.887 --> 00:01:53.878
a different one for the if and for
the else, for the true and for the false.

33
00:01:53.878 --> 00:01:58.173
Well, here you can create variables
whose scope will be both.

34
00:01:58.173 --> 00:02:02.768
Because they realize that's a typical
use case for example error messages or

35
00:02:02.768 --> 00:02:07.574
whatever objects that you wanna create
variables that you wanna create, and you

36
00:02:07.574 --> 00:02:12.256
want that variable to exist both on the
positive and the negative side of this.

37
00:02:12.256 --> 00:02:15.012
The switch.

38
00:02:15.012 --> 00:02:17.040
It's pretty cool, actually.

39
00:02:17.040 --> 00:02:18.523
This is the standard switch.

40
00:02:18.523 --> 00:02:21.177
The switch is a select case, so

41
00:02:21.177 --> 00:02:25.778
it's going to pick only one
of the cases that are set.

42
00:02:25.778 --> 00:02:26.939
We don't have breaks.

43
00:02:26.939 --> 00:02:31.386
If you're coming from JavaScript or other
languages, we don't need to set the break.

44
00:02:31.386 --> 00:02:36.560
Actually what you have is a special
sentence, it's fall through in

45
00:02:36.560 --> 00:02:42.473
case you want the opposite of break,
you wanna fall through to the next case.

46
00:02:42.473 --> 00:02:46.350
So in this case, if it's Saturday, you
can fall through automatically to Sunday.

47
00:02:46.350 --> 00:02:49.083
So it's going to execute the same code.

48
00:02:49.083 --> 00:02:50.698
But by default, it will break.

49
00:02:52.700 --> 00:02:54.605
Okay, make sense?

50
00:02:54.605 --> 00:02:56.951
That's kind of simple.

51
00:02:56.951 --> 00:03:01.086
But one nice thing that we
have about switch here,

52
00:03:01.086 --> 00:03:05.713
is that we can actually remove
the whole declaration and

53
00:03:05.713 --> 00:03:10.348
use case with any Boolean
condition from any variable.

54
00:03:10.348 --> 00:03:14.739
So you can use this to reduce if else,
if else, if else, if else, if.

55
00:03:17.424 --> 00:03:22.725
So it's just a switch condition
that looks pretty cool.

56
00:03:22.725 --> 00:03:26.422
Again to clean code that then
you can ask anything and

57
00:03:26.422 --> 00:03:30.049
only the first one that
gets true will be executed.

58
00:03:32.906 --> 00:03:34.089
Okay, make sense?

59
00:03:34.089 --> 00:03:39.630
And there is always a default
if no one was actually true,

60
00:03:39.630 --> 00:03:42.871
then it goes directly to the end.

61
00:03:42.871 --> 00:03:44.037
Pretty cool, right?

62
00:03:44.037 --> 00:03:45.762
The for loop.

63
00:03:45.762 --> 00:03:50.846
First, we can use it as with
the classic for, with three arguments,

64
00:03:50.846 --> 00:03:56.210
the initialization, then the condition,
and the post loop sentence.

65
00:03:56.210 --> 00:03:58.505
That's pretty common to any for.

66
00:03:58.505 --> 00:04:00.605
We can also use it
similar to what is a for

67
00:04:00.605 --> 00:04:03.227
in JavaScript if you have
experience with that.

68
00:04:03.227 --> 00:04:07.178
So when you have a collection,
it can be an array,

69
00:04:07.178 --> 00:04:09.821
it can be a map, it can be a slice.

70
00:04:09.821 --> 00:04:12.593
You prefix that with a range, and

71
00:04:12.593 --> 00:04:17.055
then when you're going to
get here is a new variable.

72
00:04:17.055 --> 00:04:21.289
Be careful :=, it's a new variable for
the index, not for

73
00:04:21.289 --> 00:04:26.365
the actual element in the collection,
that's why it's not a foreach.

74
00:04:26.365 --> 00:04:27.680
It's similar to a for in.

75
00:04:27.680 --> 00:04:32.210
You get the index, you still need
to get to the property manually.

76
00:04:32.210 --> 00:04:36.910
If you want similar to foreach,
it's the same thing range, but

77
00:04:36.910 --> 00:04:38.746
you receive two values.

78
00:04:38.746 --> 00:04:44.407
The first one is the key, the index,
and then you receive the value.

79
00:04:44.407 --> 00:04:47.433
We will use that now, so no worries.

80
00:04:47.433 --> 00:04:48.863
Do we have anything else?

81
00:04:48.863 --> 00:04:54.406
Well, actually, no, but
you can use for for while.

82
00:04:54.406 --> 00:04:57.439
Instead of having a while,
we use the same for.

83
00:04:57.439 --> 00:05:03.728
The four also accepts directly
a Boolean expression,

84
00:05:03.728 --> 00:05:08.797
and it's a Y also you
have an infinite loop.

85
00:05:08.797 --> 00:05:11.385
It's just four with no expression.

86
00:05:13.901 --> 00:05:15.752
Okay, we don't have while, just for.

87
00:05:15.752 --> 00:05:19.100
So we use the for for all the loops.

88
00:05:19.100 --> 00:05:23.082
Based on the argument that you used me,
you found there too,

89
00:05:23.082 --> 00:05:25.829
therefore, it will use one or the other.

90
00:05:25.829 --> 00:05:29.120
If, switch, for that's all you have.

