WEBVTT

1
00:00:00.130 --> 00:00:01.186
What is React Native, really?

2
00:00:01.186 --> 00:00:06.120
So if you look at your phone,
your phone is really just a small but

3
00:00:06.120 --> 00:00:07.600
incredibly powerful computer.

4
00:00:07.600 --> 00:00:12.620
You might have heard this analogy already,
but the average smartphone we

5
00:00:12.620 --> 00:00:18.060
have nowadays is a million
times more powerful than

6
00:00:18.060 --> 00:00:22.090
the Guidance Computer that sent humans
on the moon, and that is pretty crazy.

7
00:00:25.030 --> 00:00:28.990
But due to their smaller screen and touch
base interface, browsing the web on your

8
00:00:28.990 --> 00:00:35.055
smartphone is still sub optimal compared
to a desktop or a laptop experience.

9
00:00:36.580 --> 00:00:38.060
Is the fact that I looked up.

10
00:00:38.060 --> 00:00:40.280
The number of smartphone users
in the world is 3.5 billion,

11
00:00:40.280 --> 00:00:43.260
which is more than was half the world.

12
00:00:44.820 --> 00:00:49.240
And by looking at the global market share,
we find that Android and

13
00:00:49.240 --> 00:00:54.430
iOS are clearly in the lead, together they
make up like 99% of smartphone users.

14
00:00:54.430 --> 00:00:57.630
And you might be surprised
to find out because

15
00:00:57.630 --> 00:01:01.505
a lot of you might have iPhones and
might know only people who have iPhones.

16
00:01:01.505 --> 00:01:04.865
You might be surprised to learn
that Android is actually way ahead

17
00:01:04.865 --> 00:01:06.595
in terms of market share.

18
00:01:06.595 --> 00:01:07.515
And it depends on the country.

19
00:01:07.515 --> 00:01:11.395
So if you're from the US more than
half the people will have iPhones.

20
00:01:11.395 --> 00:01:13.125
Same for the UK, I think.

21
00:01:13.125 --> 00:01:19.310
But, for example in India, only, like
two or 3% of the users have smartphones.

22
00:01:19.310 --> 00:01:22.900
So really the platform that you
focus on should really depend on who

23
00:01:22.900 --> 00:01:24.800
you're building application for.

24
00:01:24.800 --> 00:01:29.620
So if you are, if you know that your
target audience will be iPhone users,

25
00:01:29.620 --> 00:01:31.770
you can get away with
mostly focusing on iPhone.

26
00:01:33.270 --> 00:01:35.220
But regardless of who your users are.

27
00:01:35.220 --> 00:01:37.760
If you target both Android and iOS,

28
00:01:37.760 --> 00:01:42.260
you can be pretty confident that 99%
of users will be able to use your app.

29
00:01:44.490 --> 00:01:49.690
Now, because phones are just tiny
computers, they have an operating system.

30
00:01:49.690 --> 00:01:54.750
And some examples of computers are a
MacBook or Adele, or Lenovo, and some

31
00:01:54.750 --> 00:01:59.210
examples of operating systems for these
computers, are MacOS, Windows or Linux.

32
00:02:00.850 --> 00:02:04.840
Now to go into the phone world,
some examples of phones are iPhone, or

33
00:02:04.840 --> 00:02:06.140
Samsung Galaxy, or

34
00:02:06.140 --> 00:02:10.390
Nexus, and some examples of phone
operating systems, iOS and Android.

35
00:02:11.830 --> 00:02:15.660
Now applications are designed to run
on a particular operating system, so

36
00:02:15.660 --> 00:02:19.200
you can't just take an iOS app and
run it on Android and vice versa.

37
00:02:19.200 --> 00:02:21.790
There's no way you can'have
a Windows app to run on Mac.

38
00:02:23.250 --> 00:02:28.150
So in order to get to this dream
of targeting 99% of our users,

39
00:02:28.150 --> 00:02:32.040
we'll have to build two apps,
one for Android and one for iOS.

40
00:02:32.040 --> 00:02:34.490
So this is what historically
has been the case.

41
00:02:34.490 --> 00:02:38.270
You have to have two development teams or
two people, or

42
00:02:38.270 --> 00:02:41.830
just one person that knows
these two environments,

43
00:02:41.830 --> 00:02:45.830
because iOS applications are written
in Objective C or Swift.

44
00:02:45.830 --> 00:02:48.400
And Android applications
are written in Java or Kotlin.

45
00:02:50.980 --> 00:02:55.380
Now, you can imagine the difficulty in
this because it's expensive, it's tedious,

46
00:02:55.380 --> 00:02:59.179
it's difficult to track features across
two completely different code sets.

47
00:03:00.270 --> 00:03:04.330
And yeah, loads of people were having
this problem and so was Facebook, and

48
00:03:04.330 --> 00:03:05.800
they decided to have a go at solving it.

49
00:03:05.800 --> 00:03:08.540
And this is where
React Native comes to play.

50
00:03:09.760 --> 00:03:13.500
The goal for
React Native was to build a solution that

51
00:03:13.500 --> 00:03:18.800
allows you to create fully native apps,
not progressive web apps or web views.

52
00:03:18.800 --> 00:03:22.683
How one code base,
one development team, one language,

53
00:03:22.683 --> 00:03:25.465
and most importantly fully extensible.

54
00:03:31.133 --> 00:03:34.050
React Native isn't actually the first or

55
00:03:34.050 --> 00:03:37.560
the only such library
that aims to do these.

56
00:03:37.560 --> 00:03:41.280
But it is incredibly powerful and
arguably the best.

57
00:03:41.280 --> 00:03:42.520
I mean, obviously, I think it's the best.

58
00:03:43.730 --> 00:03:47.700
But this is because, A,
we're building fully native apps.

59
00:03:47.700 --> 00:03:50.450
So the compiled React Native application

60
00:03:50.450 --> 00:03:54.630
is indistinguishable from
a real native application.

61
00:03:54.630 --> 00:03:57.710
And secondly,
because it's fully extensible, a little

62
00:03:57.710 --> 00:04:01.630
existing libraries basically give you
this toolbox of things that you can do.

63
00:04:01.630 --> 00:04:05.860
But if you want to do anything outside of
this, your lost, whereas in React Native,

64
00:04:05.860 --> 00:04:11.060
you'll always have the ability
to go into the native code and

65
00:04:11.060 --> 00:04:13.130
add anything that React Native
doesn't already support.

66
00:04:14.430 --> 00:04:16.289
Furthermore, it is open source,

67
00:04:16.289 --> 00:04:20.658
you can always help out with adding any
features that you think would be awesome.

68
00:04:23.089 --> 00:04:23.801
And how does it work?

69
00:04:23.801 --> 00:04:26.690
All right, we're not gonna
go crazy technical on this.

70
00:04:27.690 --> 00:04:28.980
But basically,

71
00:04:28.980 --> 00:04:33.340
React Native is built in such a way
that it targets the existing compilers.

72
00:04:33.340 --> 00:04:39.280
So there are compilers that accept Java or
Kotlin and target the Android platform.

73
00:04:39.280 --> 00:04:43.730
And there are compilers that
accept Objective C or Swift and

74
00:04:43.730 --> 00:04:45.780
target the i OS platform.

75
00:04:45.780 --> 00:04:48.150
And this is exactly what
React Native hooks into.

76
00:04:48.150 --> 00:04:52.010
And the reason this is powerful is because
these compilers are already built to

77
00:04:52.010 --> 00:04:53.340
handle this.

78
00:04:53.340 --> 00:04:57.260
And it also makes React Native fully
extensible to other platforms.

79
00:04:57.260 --> 00:04:58.920
So you can have React Native Windows,

80
00:04:58.920 --> 00:05:03.140
React Native web, React Native VR,
like you could just add more and

81
00:05:03.140 --> 00:05:06.480
more compilers here and you can still
have this one React Native code.

82
00:05:09.320 --> 00:05:09.820
Yes.

83
00:05:11.350 --> 00:05:13.920
&gt;&gt; Just curious in your experience,

84
00:05:13.920 --> 00:05:17.850
work with native apps,
just through reading like.

85
00:05:17.850 --> 00:05:22.030
I read like two different
fronts where they say,

86
00:05:22.030 --> 00:05:26.040
you can use solutions like React Native,
but there will be a point or

87
00:05:26.040 --> 00:05:31.010
a pain point where you're gonna wanna
do certain features that native

88
00:05:31.010 --> 00:05:35.640
wants to do on their application that
React Native might not support it.

89
00:05:35.640 --> 00:05:40.450
And then you have to rely on a Swift
solutions for iOS, or Java and

90
00:05:40.450 --> 00:05:43.590
Kotlin for Android.

91
00:05:43.590 --> 00:05:46.990
I'm just wondering,
at this day and age like 2020,

92
00:05:46.990 --> 00:05:51.190
the maturity of the React Native API and
if you have

93
00:05:52.750 --> 00:05:57.660
faced situations where you saw, I cannot
take this further just with React Native,

94
00:05:57.660 --> 00:06:01.780
where you needed a native
solution from those languages.

95
00:06:01.780 --> 00:06:02.660
&gt;&gt; Yes.
So

96
00:06:02.660 --> 00:06:07.110
I have had a couple of occasions where
I've had to build something native.

97
00:06:07.110 --> 00:06:10.062
And once one was for,
I think, for Android for

98
00:06:10.062 --> 00:06:15.138
linking into a particular mail provider
and the other is on my current project,

99
00:06:15.138 --> 00:06:19.836
which was actually pre-built before
my time, which is integrating with

100
00:06:19.836 --> 00:06:23.653
a payment provider that isn't
available in React Native.

101
00:06:23.653 --> 00:06:28.027
And so the platform fully supports it,

102
00:06:28.027 --> 00:06:32.938
this is one of the features
of React Native.

103
00:06:32.938 --> 00:06:35.688
It's quite straightforward,
I'm gonna say very straightforward,

104
00:06:35.688 --> 00:06:38.420
it's quite straightforward to
bridge into the native code.

105
00:06:38.420 --> 00:06:43.440
So if you have, for example,
if you need to add a new module or

106
00:06:43.440 --> 00:06:48.520
add a new component, or add some native
functionality that interacts with

107
00:06:48.520 --> 00:06:53.900
the native Java or Kotlin,
or Objective C code, there's

108
00:06:53.900 --> 00:06:57.029
a particular entry point and there's
really good guides on how to do it.

109
00:06:58.080 --> 00:06:59.780
So, it is for the extensible.

110
00:06:59.780 --> 00:07:05.070
It is a bit of like a hustle, like I
always like to say that I had written no

111
00:07:05.070 --> 00:07:08.330
Objective C code prior to
going to React Native, but

112
00:07:08.330 --> 00:07:11.260
now I write a security library.

113
00:07:11.260 --> 00:07:14.980
So, they kind of lure you in with
the promises of just Java Script, and

114
00:07:14.980 --> 00:07:18.420
then you kind of start going like,
I'll just do this little bit in Java.

115
00:07:18.420 --> 00:07:20.708
So, you do actually get to
like learn this new languages.

116
00:07:20.708 --> 00:07:26.830
Yeah, so to answer your question,
it's a bit of a hassle

117
00:07:26.830 --> 00:07:31.330
in that we try to stay in the React Native
space as much as possible.

118
00:07:31.330 --> 00:07:38.950
But if we have to go outside of it, it's
not very hard to customize it infinitely.

119
00:07:40.820 --> 00:07:43.460
Yes.
&gt;&gt; Is there a category of, or can you sort

120
00:07:43.460 --> 00:07:47.590
of categorize which apps you might
wanna stay away from with React Native?

121
00:07:47.590 --> 00:07:53.096
Like maybe highly graphical intensive or

122
00:07:53.096 --> 00:07:56.511
is that works on React Native?

123
00:07:56.511 --> 00:08:00.210
&gt;&gt; So, not at all,
you can build anything with React Native.

124
00:08:00.210 --> 00:08:01.790
So even though it's JavaScript,

125
00:08:01.790 --> 00:08:05.220
we actually hook into the native
components for each platform.

126
00:08:05.220 --> 00:08:09.950
So, whereas maybe two years ago,
there was a performance hit for

127
00:08:09.950 --> 00:08:12.640
certain really memory
intensive applications.

128
00:08:12.640 --> 00:08:16.200
As we progress,
the birth of navigation libraries and

129
00:08:16.200 --> 00:08:20.190
React Native itself,
have gone more and more performance.

130
00:08:20.190 --> 00:08:23.050
You might have heard of Hermes.

131
00:08:23.050 --> 00:08:29.420
It's like a new JavaScript compiler that
they are building at Facebook currently,

132
00:08:29.420 --> 00:08:33.250
which is optimized for
JavaScript in React Native.

133
00:08:33.250 --> 00:08:37.270
It's really interesting talk at
React Native EU, which is about Hermes.

134
00:08:37.270 --> 00:08:38.520
And that's just an example, or

135
00:08:38.520 --> 00:08:42.240
one example of the optimizations
that they're doing for React Native.

136
00:08:42.240 --> 00:08:45.180
So yeah, I don't think there's anything
you should really stay away from.

