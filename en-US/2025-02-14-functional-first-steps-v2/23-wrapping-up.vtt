WEBVTT

1
00:00:00.000 --> 00:00:02.890
&gt;&gt; Anjana Vakil: We have really burdened
our brains with a lot of stuff.

2
00:00:02.890 --> 00:00:07.089
Sure, we might have been doing very simple
little functions like push and pop and

3
00:00:07.089 --> 00:00:09.199
map and reduce, but are they so simple?

4
00:00:09.199 --> 00:00:12.262
No, we had a lot going on in there.

5
00:00:12.262 --> 00:00:17.269
We had, we talked about pure functions and
how they are far and

6
00:00:17.269 --> 00:00:21.134
away the idea behind
functional programming.

7
00:00:21.134 --> 00:00:25.957
And we talked about the opposite of
the idea, which is side effects and

8
00:00:25.957 --> 00:00:31.296
non deterministic, like depending on
other stuff outside of the function.

9
00:00:31.296 --> 00:00:37.329
We talked about recursion as a way to
execute the same chunk of code over and

10
00:00:37.329 --> 00:00:42.796
over and over again and
to operate in series of data, like arrays.

11
00:00:42.796 --> 00:00:47.870
For example, so that we can do
the type of programming that we

12
00:00:47.870 --> 00:00:53.453
are used to doing with iterative loops and
an imperative mindset.

13
00:00:53.453 --> 00:00:55.831
And we made some cool art with it and

14
00:00:55.831 --> 00:00:59.369
we also talked a lot about
higher order functions.

15
00:00:59.369 --> 00:01:02.651
Functions that operate on other functions,

16
00:01:02.651 --> 00:01:07.658
they either take in other functions or
they return other functions,

17
00:01:07.658 --> 00:01:12.768
or both and we implemented our
good friends, map, reduce, filter.

18
00:01:12.768 --> 00:01:15.768
We learned how we can use recursion for

19
00:01:15.768 --> 00:01:20.375
pretty much anything we want
in functional programming.

20
00:01:20.375 --> 00:01:23.582
We also talked about, okay,
if we don't have state,

21
00:01:23.582 --> 00:01:26.108
we don't have values changing over time.

22
00:01:26.108 --> 00:01:31.031
Or data that's mutating over time, how
do we remember information that we need?

23
00:01:31.031 --> 00:01:35.330
Do we really need to have like, massive
function signatures with like 80,000

24
00:01:35.330 --> 00:01:38.917
variables that take in all of the data
that we need to do a computation?

25
00:01:38.917 --> 00:01:42.454
No, we can take advantage of closure and

26
00:01:42.454 --> 00:01:48.183
split up that data into like
partial applications of functions.

27
00:01:48.183 --> 00:01:54.016
And we can take advantage of composition
to then take those split up functions and

28
00:01:54.016 --> 00:01:59.190
pipeline data through them so
that we get the transformations we want.

29
00:01:59.190 --> 00:02:04.297
And then finally, we talked about how
dangerous mutation can be in terms

30
00:02:04.297 --> 00:02:09.823
of having the rug pulled out from under
you and you think your data is one thing,

31
00:02:09.823 --> 00:02:13.780
but your co-worker just
updated it to something else.

32
00:02:13.780 --> 00:02:20.118
[LAUGH] Or worse yet, some magic in
the library you're using just did [LAUGH].

33
00:02:20.118 --> 00:02:23.116
We talked about how to avoid that, A,

34
00:02:23.116 --> 00:02:27.335
by making sure we avoid like
the plague any methods and

35
00:02:27.335 --> 00:02:31.951
operations in JavaScript that
are inherently mutating.

36
00:02:31.951 --> 00:02:36.429
And by asking ourselves,
how we would live without them.

37
00:02:36.429 --> 00:02:40.504
And, or by working with tools
like immer or immutable JS,

38
00:02:40.504 --> 00:02:44.925
persistent data that not only
helps us with efficient copies.

39
00:02:44.925 --> 00:02:49.721
But also in the case of immer,
lets us pretend that we're pushing to

40
00:02:49.721 --> 00:02:53.350
an array when we're actually
not messing with it.

41
00:02:53.350 --> 00:02:57.199
So we have covered a lot
of ground together today.

42
00:02:57.199 --> 00:03:00.964
I am very thankful to all of you for

43
00:03:00.964 --> 00:03:05.268
grappling with all these things, and

44
00:03:05.268 --> 00:03:09.452
I would love to know before we break.

45
00:03:09.452 --> 00:03:14.421
What you feel are some takeaways from our,

46
00:03:14.421 --> 00:03:19.527
[LAUGH] arguably very
brain hardy [LAUGH] to use

47
00:03:19.527 --> 00:03:24.231
the technical term discussions today.

48
00:03:24.231 --> 00:03:29.192
Are there certain ideas we've talked
about today that you feel like, okay,

49
00:03:29.192 --> 00:03:33.161
I don't know about all that
other pipelines or whatever, but

50
00:03:33.161 --> 00:03:37.230
I could really apply this idea to
my daily life as a programmer.

51
00:03:37.230 --> 00:03:41.241
And think a little bit more
functionally about my programs.

52
00:03:41.241 --> 00:03:46.215
Anybody have anything that they're gonna
try to kind of bring to their programming

53
00:03:46.215 --> 00:03:47.502
this is subjective.

54
00:03:47.502 --> 00:03:52.381
&gt;&gt; Speaker 2: I think it was very helpful
to see the extent of what you have to

55
00:03:52.381 --> 00:03:56.220
do to utilize it in places
where it needs state.

56
00:03:56.220 --> 00:04:02.182
Cuz most of the time when I learned
recursion, functional programming,

57
00:04:02.182 --> 00:04:06.617
like concepts,
they were a lot more, mathematical.

58
00:04:06.617 --> 00:04:12.086
And just kind of, just having all your
stay kind of in the top, most level

59
00:04:12.086 --> 00:04:17.389
somewhere where it's all followed and
controlled is where you want to have

60
00:04:17.389 --> 00:04:22.626
it when you're actually implementing
it in a higher order application.

61
00:04:22.626 --> 00:04:27.255
&gt;&gt; Anjana Vakil: So sort of getting into
that idea of pushing the impurities away,

62
00:04:27.255 --> 00:04:30.199
pushing the state to the outer edges, and

63
00:04:30.199 --> 00:04:35.348
making sure that all of the operations
that we're doing are stateless.

64
00:04:35.348 --> 00:04:38.217
Even if we do need some
state at some point,

65
00:04:38.217 --> 00:04:42.602
making sure that sandbox in a way
where we can be certain the rest of

66
00:04:42.602 --> 00:04:46.378
our program is not infected
by it like the zombie virus.

67
00:04:46.378 --> 00:04:49.216
Awesome thank you for sharing.

68
00:04:49.216 --> 00:04:53.110
&gt;&gt; Speaker 3: I'm still thinking about
performance implications especially when

69
00:04:53.110 --> 00:04:54.435
it comes to recursion.

70
00:04:54.435 --> 00:04:57.050
And that was helpful, at least in my mind,

71
00:04:57.050 --> 00:05:00.986
to picture what's happening when
you tied it to the call stack.

72
00:05:00.986 --> 00:05:06.630
And so now I'm wondering if
other more functionally designed

73
00:05:06.630 --> 00:05:12.382
languages who are maybe not
single threaded like JavaScript,

74
00:05:12.382 --> 00:05:16.305
if that would have a performance benefit?

75
00:05:16.305 --> 00:05:21.362
&gt;&gt; Anjana Vakil: I mean, this is the thing
there's a lot of optimizations that can be

76
00:05:21.362 --> 00:05:26.512
done on the language implementation
level that we as the programmers

77
00:05:26.512 --> 00:05:30.975
who use the language don't
usually think about every day.

78
00:05:30.975 --> 00:05:35.857
But that become very relevant once
you start thinking about like super

79
00:05:35.857 --> 00:05:37.931
intense data applications.

80
00:05:37.931 --> 00:05:42.205
And so, yes there are dedicated
languages that are good for this.

81
00:05:42.205 --> 00:05:45.876
Or for example, immer is an example or

82
00:05:45.876 --> 00:05:49.895
any immutable data structure library for

83
00:05:49.895 --> 00:05:55.061
JavaScript is also a performance
related tool that we

84
00:05:55.061 --> 00:06:01.171
can use clever implementations
of a lot of things like arrays.

85
00:06:01.171 --> 00:06:06.741
Or what have you that handle a lot
of that performance bottlenecks for

86
00:06:06.741 --> 00:06:10.979
us, and yes,
highly encourage folks to go try out.

87
00:06:10.979 --> 00:06:15.703
Or at least look at some other languages
that are kind of more explicitly

88
00:06:15.703 --> 00:06:18.387
designed for functional programming.

89
00:06:18.387 --> 00:06:23.285
Rather than our good friend JavaScript
that was born in a lab in 10 days,

90
00:06:23.285 --> 00:06:24.314
anyway [LAUGH].

91
00:06:24.314 --> 00:06:28.989
And yeah, highly encourage you to
go deeper again I'll leave you

92
00:06:28.989 --> 00:06:32.481
with a whole bunch of links
that you can dig into.

93
00:06:32.481 --> 00:06:37.696
I wanna give a huge thank you to
all of you for dealing with these

94
00:06:37.696 --> 00:06:43.226
hoops that I've been making you
jump through, not hoops [LAUGH].

95
00:06:43.226 --> 00:06:48.782
And for asking these great questions and
sharing these gotchas and,

96
00:06:48.782 --> 00:06:52.436
but what abouts and
that is the work, right?

97
00:06:52.436 --> 00:06:57.294
We are doing the rubber meets the road
work of actually trying to apply

98
00:06:57.294 --> 00:06:59.806
these ideas and not just sit back and

99
00:06:59.806 --> 00:07:04.190
watch some academic talk about
category theory or whatever.

100
00:07:04.190 --> 00:07:08.181
So amazing work and
I also wanna give a big shout out.

101
00:07:08.181 --> 00:07:12.086
I would not be here teaching a workshop
on functional programming had I

102
00:07:12.086 --> 00:07:16.201
not accidentally stumbled upon
functional programming in a community.

103
00:07:16.201 --> 00:07:18.449
And again, I mentioned it earlier,
it's called the recurse center.

104
00:07:18.449 --> 00:07:23.139
It's super cool so I'm not here to plug
it, but please go check out the website.

105
00:07:23.139 --> 00:07:28.008
And huge thank you to everyone that I
met there that taught me all of these

106
00:07:28.008 --> 00:07:31.264
things and
helped me bang my head against them.

107
00:07:31.264 --> 00:07:37.101
And I hope you all can now go be that
person for your team or whatever.

108
00:07:37.101 --> 00:07:39.814
Really appreciate you all,
stick in with it.

109
00:07:39.814 --> 00:07:44.571
&gt;&gt; [APPLAUSE]

