WEBVTT

1
00:00:00.000 --> 00:00:04.657
&gt;&gt; Anjana Vakil: Let us move on to
our next higher order friend, map.

2
00:00:04.657 --> 00:00:07.406
Okay, so
we have our filter function already done,

3
00:00:07.406 --> 00:00:11.472
this time, our task is to fill in the map
function and to get the tests to pass.

4
00:00:11.472 --> 00:00:15.221
Again, you still have your
array helpers down here.

5
00:00:15.221 --> 00:00:19.259
Let us put our functional brains to work.

6
00:00:24.529 --> 00:00:26.572
&gt;&gt; Anjana Vakil: Same as ever,
we've got a recursive function.

7
00:00:26.572 --> 00:00:28.547
We need a base case,
we need a recursive case.

8
00:00:28.547 --> 00:00:33.296
So our base case in this case
[LAUGH] might be a similar

9
00:00:33.296 --> 00:00:35.619
case to a previous case.

10
00:00:35.619 --> 00:00:39.473
[LAUGH] How do I know I'm already done?

11
00:00:39.473 --> 00:00:43.928
Well, if there's nothing
in my array to map over, so

12
00:00:43.928 --> 00:00:48.977
just like before,
we can take essentially this same line and

13
00:00:48.977 --> 00:00:54.125
just say, if we have nothing in the array,
then we're done.

14
00:00:54.125 --> 00:00:57.286
We've already mapped over everything
in the array, which is nothing.

15
00:00:57.286 --> 00:01:03.071
So our base case it remains the same,
and now we need our recursive case.

16
00:01:03.071 --> 00:01:08.443
So because it's recursive, it's gonna
involve some kind of call to map,

17
00:01:08.443 --> 00:01:14.176
[LAUGH] which similarly to before is not
gonna take in the exact same array value.

18
00:01:14.176 --> 00:01:18.174
So what am I gonna pass
in to map this time?

19
00:01:18.174 --> 00:01:18.770
&gt;&gt; Speaker 2: The function.

20
00:01:18.770 --> 00:01:19.849
&gt;&gt; Anjana Vakil: The same function,

21
00:01:19.849 --> 00:01:23.032
I still wanna be doing the same
transformation, exactly.

22
00:01:23.032 --> 00:01:26.711
But then instead of array,
I'm gonna pass in.

23
00:01:26.711 --> 00:01:29.521
&gt;&gt; Speaker 2: Tail.
&gt;&gt; Anjana Vakil: The tail of the array,

24
00:01:29.521 --> 00:01:31.498
tile, okay, right?

25
00:01:31.498 --> 00:01:37.181
So the middle part here is
what we still have to do.

26
00:01:37.181 --> 00:01:42.072
But I'm gonna do a similar thing
to what I did here with my filter.

27
00:01:42.072 --> 00:01:50.288
And I am going to take whatever that
array is of the mapped rest of the OA and

28
00:01:50.288 --> 00:01:54.735
smush it together with the transformed

29
00:01:54.735 --> 00:01:59.196
value that came out of the array first.

30
00:01:59.196 --> 00:02:01.940
Now here, let's try to do
this all in one line, just so

31
00:02:01.940 --> 00:02:05.223
we can feel like they elite decoders,
but also because that means

32
00:02:05.223 --> 00:02:08.698
we don't have variables that may or
may not change values over time.

33
00:02:08.698 --> 00:02:11.811
So, a little bit more functional,
a little bit more declarative.

34
00:02:11.811 --> 00:02:18.951
So, instead of setting up some variables,
I'm gonna return something map,

35
00:02:18.951 --> 00:02:23.184
is not yet that thing,
I have too many, yeah.

36
00:02:23.184 --> 00:02:28.806
And similarly to before,
we might wanna use our friend,

37
00:02:28.806 --> 00:02:34.177
the concat function, to,
&gt;&gt; Anjana Vakil: Concat

38
00:02:34.177 --> 00:02:37.547
something to the beginning of this array.

39
00:02:37.547 --> 00:02:42.677
And what that thing is,
you will walk me through.

40
00:02:42.677 --> 00:02:46.789
We are going to take.

41
00:02:46.789 --> 00:02:52.759
&gt;&gt; Speaker 2: An array?
&gt;&gt; Anjana Vakil: An array with-

42
00:02:52.759 --> 00:02:53.849
&gt;&gt; Speaker 3: Head of an array?

43
00:02:53.849 --> 00:02:58.016
&gt;&gt; Anjana Vakil: The head of our array,
but not unmodified.

44
00:02:58.016 --> 00:02:59.183
&gt;&gt; Speaker 2: We wanna
call the function on it.

45
00:02:59.183 --> 00:03:04.498
&gt;&gt; Anjana Vakil: We
wanna call the function

46
00:03:04.498 --> 00:03:09.818
on it, booms, we did it.

