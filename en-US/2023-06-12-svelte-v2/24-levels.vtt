WEBVTT

1
00:00:00.660 --> 00:00:02.680
I have one quick question about bindings.

2
00:00:03.760 --> 00:00:05.109
Are bindings synchronous?

3
00:00:08.646 --> 00:00:11.205
&gt;&gt; Okay, so there's a question about
whether bindings are synchronous or not,

4
00:00:11.205 --> 00:00:13.050
and that's a really interesting question.

5
00:00:13.050 --> 00:00:18.645
The answer is they update
the state synchronously.

6
00:00:18.645 --> 00:00:21.032
So when you have a bind
value on a text input,

7
00:00:21.032 --> 00:00:24.197
it is essentially as if you had
an on input event handler and

8
00:00:24.197 --> 00:00:27.890
you are assigning to the value
inside that event handler.

9
00:00:27.890 --> 00:00:31.438
So in that sense, it is synchronous.

10
00:00:31.438 --> 00:00:35.637
But like all state updates,
that will be batched and

11
00:00:35.637 --> 00:00:41.470
it won't update the DOM until we've
waited for the current microtask.

12
00:00:42.620 --> 00:00:46.675
Now, because you're interacting
with the element yourself,

13
00:00:46.675 --> 00:00:51.263
the binding isn't gonna need to update
the input, if that makes sense.

14
00:00:51.263 --> 00:00:55.030
Because if you have an input and
you type in some text,

15
00:00:55.030 --> 00:00:57.390
the input already has that text.

16
00:00:57.390 --> 00:01:02.655
So we don't need to wait for the binding
to go all the way around and then get fed

17
00:01:02.655 --> 00:01:08.085
back into the input as it were, because
it's already in the desired end state.

18
00:01:08.085 --> 00:01:13.055
But the update to anything else in the
DOM, the references, that piece of state,

19
00:01:13.055 --> 00:01:15.950
that will happen after
the current microtask.

20
00:01:17.070 --> 00:01:21.144
Getting super in the weeds here,
but hopefully that made sense.

21
00:01:21.144 --> 00:01:27.650
&gt;&gt; How does using await blocks
differ to using onMount as below?

22
00:01:29.300 --> 00:01:33.923
And so he's got let data
onMount in the brackets async.

23
00:01:33.923 --> 00:01:36.969
The data equals await
get data from backend.

24
00:01:36.969 --> 00:01:41.649
I found myself having
to do the blow to avoid

25
00:01:41.649 --> 00:01:47.369
undefined errors before
we migrated to SvelteKit,

26
00:01:47.369 --> 00:01:50.359
using plus page.ts load.

27
00:01:50.359 --> 00:01:54.560
So maybe I was using onMount improperly.

28
00:01:56.730 --> 00:01:58.890
&gt;&gt; So there is a little bit
of a gotcha with onMount.

29
00:01:58.890 --> 00:02:03.514
If you look at the reference
documentation, svelte.dev slash docs and

30
00:02:03.514 --> 00:02:05.180
look at the onMount area,

31
00:02:05.180 --> 00:02:09.590
it will tell you that you should
not return a promise from onMount.

32
00:02:09.590 --> 00:02:13.740
And anytime you have an async function,
that function will return a promise.

33
00:02:13.740 --> 00:02:15.615
It's just how async functions work.

34
00:02:15.615 --> 00:02:20.111
And the reason for
that is that we need to get a reference to

35
00:02:20.111 --> 00:02:24.903
the tear down callback for
when the component is onMounted.

36
00:02:24.903 --> 00:02:29.040
And that needs to happen synchronously for
a variety of reasons.

37
00:02:29.040 --> 00:02:32.963
So your onMount callbacks should
be synchronous functions.

38
00:02:32.963 --> 00:02:35.440
They should not be async functions.

39
00:02:35.440 --> 00:02:40.432
You can use async inside an onMount
function by creating an, I believe it's

40
00:02:40.432 --> 00:02:45.580
called an asynchronous immediately-invoked
function expression or IIFE.

41
00:02:48.040 --> 00:02:51.055
So you create an async function and then
you put the parentheses at the end of it,

42
00:02:51.055 --> 00:02:51.780
so it will call it.

43
00:02:51.780 --> 00:02:55.690
And you can use the await
keyword inside your IIFE, but

44
00:02:55.690 --> 00:03:00.630
you don't want the onMount callback
itself to be an async function.

45
00:03:02.270 --> 00:03:05.934
Maybe we'll change that in a future
version of Svelte, I don't know, but

46
00:03:05.934 --> 00:03:08.500
for now, avoid that per the documentation.

47
00:03:08.500 --> 00:03:10.900
&gt;&gt; How does onMount
impact the performance?

48
00:03:10.900 --> 00:03:16.863
Wouldn't the components have
a waterfall effect or some sort?

49
00:03:16.863 --> 00:03:20.904
&gt;&gt; Yes, so if you're doing your
asynchronous work inside onMount,

50
00:03:20.904 --> 00:03:24.297
by which I mean like fetching data and
things like that,

51
00:03:24.297 --> 00:03:29.510
then that work doesn't begin until
a component gets mounted to the screen.

52
00:03:29.510 --> 00:03:33.899
And if you have a component
that only becomes visible when

53
00:03:33.899 --> 00:03:39.050
the result of some async operation
completes inside a mount.

54
00:03:39.050 --> 00:03:43.221
Then if it has its own async operations,
then you'll render the parent component

55
00:03:43.221 --> 00:03:47.399
that will eventually render the child
component, which will do some async work.

56
00:03:47.399 --> 00:03:50.389
Maybe that eventually renders
another child component.

57
00:03:50.389 --> 00:03:52.565
And that is what we call a waterfall, and

58
00:03:52.565 --> 00:03:55.258
that is something that we
very much want to avoid.

59
00:03:55.258 --> 00:03:59.865
In general, I do not recommend doing data
fetching inside your onMount components.

60
00:03:59.865 --> 00:04:02.704
There is a way of doing data
fetching asynchronously,

61
00:04:02.704 --> 00:04:04.809
which we'll learn about in SvelteKit.

62
00:04:04.809 --> 00:04:08.120
And that is by far the preferred
way to deal with data.

63
00:04:08.120 --> 00:04:11.695
Not just because it avoids
that waterfall problem, but

64
00:04:11.695 --> 00:04:15.126
also because it works with
server-side rendering.

65
00:04:15.126 --> 00:04:19.094
Server-side rendering does not work
with onMount because there is no DOM on

66
00:04:19.094 --> 00:04:19.779
the server.

67
00:04:19.779 --> 00:04:21.065
You're not mounting anything.

68
00:04:21.065 --> 00:04:23.774
So when you do work inside
an onMount handler,

69
00:04:23.774 --> 00:04:28.710
that will have no effect on any
content that you are server rendering.

70
00:04:28.710 --> 00:04:32.230
SSR is a thing that we are gonna
cover in this SvelteKit workshop.

71
00:04:32.230 --> 00:04:37.082
For now the takeaway is avoid doing your
data fetching in onMount if you can.

72
00:04:37.082 --> 00:04:43.032
And come back for the SvelteKit
workshop to learn about data fetching.

73
00:04:43.032 --> 00:04:45.643
&gt;&gt; If you have lots of
await blocks in your HTML,

74
00:04:45.643 --> 00:04:48.430
would there be a better
way to organize this?

75
00:04:48.430 --> 00:04:54.016
Also, is there a way to do something like
promise dot all for multiple await blocks?

76
00:04:54.016 --> 00:04:57.270
&gt;&gt; So if you have a promise to all,
you would put that inside.

77
00:04:57.270 --> 00:05:01.538
I mean, you can have an inline promise
that all inside an await function, but

78
00:05:01.538 --> 00:05:05.937
you probably want to do any really tricky
async logic inside your script block or

79
00:05:05.937 --> 00:05:07.528
even in an external module.

80
00:05:07.528 --> 00:05:12.300
Because as the question suggests,
it can start to get a little bit hairy.

81
00:05:12.300 --> 00:05:16.730
But this again is the kind of stuff
that is better moved into your data

82
00:05:16.730 --> 00:05:20.780
fetching layer,
which happens before rendering.

83
00:05:20.780 --> 00:05:23.889
And that's something that we'll
talk about when we learn SvelteKit.

84
00:05:23.889 --> 00:05:28.961
&gt;&gt; Several people in chat
are not sure what the tick does.

85
00:05:28.961 --> 00:05:31.153
And what does it do?

86
00:05:31.153 --> 00:05:36.381
&gt;&gt; [LAUGH] Okay, so the nuts and
bolts of what tick does is,

87
00:05:36.381 --> 00:05:41.720
all right, so
when you assign to a value in a component,

88
00:05:41.720 --> 00:05:46.269
the compiler instruments
that assignment with

89
00:05:46.269 --> 00:05:51.360
a secret internal function
called invalidate.

90
00:05:51.360 --> 00:05:53.980
And invalidate has two jobs.

91
00:05:53.980 --> 00:05:59.236
It marks that value as dirty inside
the component, and it tells a scheduler

92
00:05:59.236 --> 00:06:03.920
that is shared by all components
that this component has changed.

93
00:06:04.980 --> 00:06:08.845
And when that happens,
the batching starts, so

94
00:06:08.845 --> 00:06:13.748
Svelte will create a promise
that will immediately resolve,

95
00:06:13.748 --> 00:06:17.896
and then it will wait to see
if any other state updates

96
00:06:17.896 --> 00:06:22.730
happen before that promise
resolves in the next microtask.

97
00:06:23.770 --> 00:06:28.410
If you call tick,
you will get a reference to that promise.

98
00:06:31.120 --> 00:06:35.094
So at the end of that resolution,
the DOM will be updated and

99
00:06:35.094 --> 00:06:39.530
the promise returned from your
tick function will resolve.

100
00:06:39.530 --> 00:06:42.163
If most state updates were happening,

101
00:06:42.163 --> 00:06:46.249
then it will just be like calling
await promise dot resolve.

102
00:06:46.249 --> 00:06:50.751
And it will essentially just defer
some work until the next micro task.

103
00:06:50.751 --> 00:06:54.525
Again, super in the weeds.

104
00:06:54.525 --> 00:06:59.240
Most of the time, you don't really
need to worry about how it's working.

105
00:06:59.240 --> 00:07:03.004
You just need to know that
it's gonna cause anything

106
00:07:03.004 --> 00:07:06.863
after the await tick to happen
in the next micro task.

107
00:07:06.863 --> 00:07:11.816
Which is a fancy way of saying
it will happen after the current

108
00:07:11.816 --> 00:07:16.972
execution block has happened,
but before the DOM is updated.

109
00:07:16.972 --> 00:07:19.620
So you're not gonna see
things like flicker.

110
00:07:19.620 --> 00:07:22.238
It's not like if you were doing
a set timeout or something and

111
00:07:22.238 --> 00:07:25.232
then you would potentially see things
in the page become out of sync.

112
00:07:25.232 --> 00:07:27.459
Everything will happen before
the DOM is updated but

113
00:07:27.459 --> 00:07:29.032
after the current execution block.

114
00:07:29.032 --> 00:07:30.386
Hopefully that makes sense.

115
00:07:30.386 --> 00:07:31.825
&gt;&gt; What does this dot refer to?

116
00:07:31.825 --> 00:07:32.848
&gt;&gt; It's a great question.

117
00:07:32.848 --> 00:07:36.029
Okay, so down here we have
this.selectionStart = selection and

118
00:07:36.029 --> 00:07:37.976
this.selectionEnd = selectionEnd.

119
00:07:37.976 --> 00:07:41.219
The this inside an event handler
refers to the element that

120
00:07:41.219 --> 00:07:43.600
the event handler is bound to.

121
00:07:43.600 --> 00:07:48.256
So here we're calling on
keydown = handlekeydown.

122
00:07:51.991 --> 00:07:58.402
Function blah, const

123
00:07:58.402 --> 00:08:05.826
textarea = event.currentTarget.

124
00:08:10.405 --> 00:08:13.221
And hopefully this is gonna work.

125
00:08:13.221 --> 00:08:17.447
If I press a key here, then we're gonna
see this alert(this === textarea).

126
00:08:17.447 --> 00:08:20.245
Alert the word true, it worked.

127
00:08:20.245 --> 00:08:21.210
Okay, good.

128
00:08:21.210 --> 00:08:23.219
I have remembered how the DOM works.

129
00:08:23.219 --> 00:08:27.440
Anytime you have an event handler,
this is the event target.

130
00:08:29.120 --> 00:08:35.584
Just a convenient way to to
interact with the DOM imperatively.

131
00:08:35.584 --> 00:08:38.400
Chris, you had a question.

132
00:08:38.400 --> 00:08:40.917
&gt;&gt; Yeah, going back to the use of tick and

133
00:08:40.917 --> 00:08:45.639
how that's used to help resolve promises,
is it possible then that you

134
00:08:45.639 --> 00:08:50.140
would have to call a wait tick
multiple times in the same code block?

135
00:08:50.140 --> 00:08:54.330
&gt;&gt; You should not need to know.

136
00:08:54.330 --> 00:08:58.520
Now I can't really imagine a situation
in which you would not do that.

137
00:08:58.520 --> 00:09:01.689
Unless you needed to do something like you
change some state and then you wait for

138
00:09:01.689 --> 00:09:04.621
the DOM to update so that maybe you can
take a measurement, like a width and

139
00:09:04.621 --> 00:09:06.111
a height measurement of an element.

140
00:09:06.111 --> 00:09:08.146
So that you can then set some more state,
and

141
00:09:08.146 --> 00:09:11.220
then that has a knock-on
effect that you need to await.

142
00:09:11.220 --> 00:09:15.724
I guess it's possible to get into
a situation where that's the case, but

143
00:09:15.724 --> 00:09:19.807
it's not something that you would
encounter often, certainly.

144
00:09:23.093 --> 00:09:26.168
All right,
any more questions from the Internet or

145
00:09:26.168 --> 00:09:29.110
should we move on to
the final section of Part 1?

146
00:09:29.110 --> 00:09:31.127
&gt;&gt; Just a couple of clarifications.

147
00:09:31.127 --> 00:09:32.510
So a cue is it?

148
00:09:34.430 --> 00:09:41.444
So basically a tick is like UseEffect or
UseLayoutEffect in React?

149
00:09:41.444 --> 00:09:46.299
&gt;&gt; Yeah, so UseLayoutEffect in React
is where you declare a function that is

150
00:09:46.299 --> 00:09:50.624
gonna happen every time
the dependencies of that effect change.

151
00:09:50.624 --> 00:09:56.387
When you call tick, it's happening in
some code that is already running and

152
00:09:56.387 --> 00:09:59.283
it will only happen once, of course.

153
00:09:59.283 --> 00:10:04.330
But it is you would use it in much
the same context as you would use

154
00:10:04.330 --> 00:10:09.568
UseLayoutEffect, which is to take
some measurement of the DOM or

155
00:10:09.568 --> 00:10:14.190
to do something in response
to the DOM updating.

156
00:10:14.190 --> 00:10:18.174
Whereas UseEffect you don't have the same
guarantees about the callback getting

157
00:10:18.174 --> 00:10:20.837
executed immediately after
the DOM has been updated.

158
00:10:20.837 --> 00:10:23.696
They reserve the right to do
that after a period of time.

