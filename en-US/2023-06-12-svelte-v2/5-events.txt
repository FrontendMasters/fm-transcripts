[00:00:00]
>> Now we're gonna move on to some of the fun stuff that makes Svelte really enjoyable to use. The heart of Svelte is a powerful system of reactivity for keeping the DOM in sync with your application state. So when the user interacts in your application, the state will change.

[00:00:16]
We want the view of that state to change in response. So we haven't learned about event handlers just yet, but we will soon. For now, I just want you to add the on:click= {increment} code to the button in App.svelte. And what that's telling us is that when we click this button, it will call this increment function.

[00:00:43]
But we haven't done anything inside the increment function yet, so we need to wire that up. Inside here, we're gonna change the value of count and the way that we're gonna do that is just by assigning to it. We're not using an API for this, we're not using a set state or something like that, we're just assigning to the variable.

[00:01:01]
And the compiler can see that and it'll instrument your code in such a way that says, we need to rerender specific parts of this component and it will do it as efficiently as it can. And so now when we click this button, you'll see that the number does in fact increment.

[00:01:17]

>> Someone saying they love the new Vim key bindings. Question mark them equals two.
>> Yeah, okay, so a little aside, you can use them mode in this tutorial if you're a Vim fiend. All you need to do is add vim=true in the URL bar. And now, when you select things in the editor, you're in Vim mode so I can replace this like if I think I could do CW clicks or something like that, then I can replace the entire word.

[00:01:51]
I don't know Vim, if you wanna learn Vim Frontend Masters has a great course with the primagen, I recommend that, but I'm not a Vim guy, so I'm gonna go back to the safety of vim=false. It will remember your setting, you don't need to add the query string each time.

[00:02:14]
And now we can move on to reactive declarations. Okay so we've seen that if you reference a reactive variable like count directly in your markup, it will update. But there are oftentimes when you're building user interfaces that you will have something that depends on a reactive variable. So for example you might wanna track the doubled value of count and in Svelte we have a concept called reactive declarations and they look a little bit funny, they look like this $: doubled = count.

[00:02:50]
Now, there's a call out here that says this might look a little alien. This is in fact valid JavaScript, that dollar is a syntactical construct called a label. And it's something that you use when you're using for loops and while loops, it allows you to break out to a specific part of your code.

[00:03:06]
It's not useful in most parts of your code, is only useful when you're dealing with for loops. And so it's kind of like a free piece of syntax, it's just lying around without much to do, so on the Svelte team we said well, why don't we co-op this?

[00:03:20]
Why don't we use this to declare the value that reactively updates when anything that depends on changes. So what happens is the compiler looks at that statement, doubled = count, so you need to add the times too otherwise it's not much use. And it sees that the value of doubled now depends on the value of count.

[00:03:40]
So whenever the value of count updates, the value of doubled will also update. So we can now use that inside markup after the button will add a new element, a paragraph, and we'll say count, doubled is doubled. Now, if you click the buttons, they don't want to take a wild guess as to what's gonna happen.

[00:04:05]
1 double is 2, 2 double is 4, and so on. Now you could of course just write count times 2 here, because you can use arbitrary JavaScript inside these expressions. But you might find there are cases where you are using that value in multiple places or you need to have other things that depend on the value of doubled and so reactive statements are valuable in that context.

[00:04:37]
And we're not just limited to having values that date reactively. We can also have statements that run reactively. As an example, if I console.log, the count is value of count. And if I open this in a new tab and open the console, get rid of all the junk that appears, click this and you'll see that it is logging the value of count every time I click the button.

[00:05:10]
And you can group statements together using a JavaScript block. Can add some more text here, this will also be logged when ever count changes. Right, and this now forms a group. Again look in the console, clear it out, and it's executing the entire block of code whenever anything that's referenced inside that block of code is reactively updated.

[00:05:47]
Okay so, you can even use the dollar label with things like F blocks, you can say that if the count is too large, say it's larger than 10. We'll reset it, but we'll also say. That the count is dangerously high. Now if we click this enough times, we'll get an alert warning is, that we're clicking the button too often.

[00:06:23]
So far we've been dealing with updating simple values like numbers. But because Svelte's reactivity is triggered by assignments, in other words the compiler is looking for you saying count plus equals one or count equals zero, using array methods like push and splice will not automatically cause updates. So here we have an application where clicking this button will cause this add number function to run and we're pushing a number to the array using numbers.push.

[00:06:56]
Now the compiler doesn't know that it's supposed to do anything after that, cuz it doesn't actually know what numbers is, it could be anything. And so we need to tell the compiler that anything that depends on numbers is now out of date and needs to be updated. So one way to fix that would be to add an assignment that would normally be redundant.

[00:07:16]
We'll do numbers = numbers, and now when you click the button the compiler knows what's supposed to happen and it will start adding things that array and rendering the markup correctly when we do so. Obviously that's a little bit weird, assigning a value to itself is not very idiomatic, JavaScript, it's totally fine.

[00:07:38]
But if you prefer to do something that is more idiomatic, then you can use an immutable data structure instead, you can copy the array and then append a new value to it instead. So what that would look like is get rid of the numbers.push, numbers = numbers, and we'll instead assigned to numbers first copy using spread syntax.

[00:08:01]
And then we'll add the value at the end like so. And this works as before, the difference is that we're now generating a whole new array every time we press this button Now, this can be good, or bad depending on what you're trying to do. Working with immutable data has some benefits, it means that you're not gonna run into problems where two things are mutating the same object at the same time, and one of them isn't expecting the other one to mutate it.

[00:08:32]
And mutation is at the heart of a lot of bugs in programming, but immutable objects are more expensive. If you're creating a new array every time, then you're allocating more memory and it's not gonna be a problem in a simple case like this, but copying arrays is generally going to be slower than mutating them.

[00:08:52]
So Svelt lets you do both, it lets you pick the approach that makes sense in the context of your application. It's not gonna enforce that you use immutable data like some frameworks. We can also assign directly to properties of arrays and objects, so obj.foo += 1, or array [i] = x.

[00:09:14]
Those will work the same way as assigning to the values themselves. So another way that we could solve this problem, this is gonna mutate the array, but also using an assignment is numbers.length = numbers.length + 1. And again, it works correctly.

