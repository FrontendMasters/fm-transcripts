[00:00:00]
>> We're gonna talk about DOM events as we saw in the earlier exercises where we're clicking a button. You can listen to any DOM event on any element, such as a click or a pointer move or anything else by using this little on directive. So here and inside this application, we have a div that we would like to add an event handler to.

[00:00:26]
Do on :pointermove and then we're gonna reference this handle move function up here. Right, and now if we run the mouse over the iframe, you'll see that the pointer is updating. Actually, it looks pretty wild. I don't think I realized that point and move events will give you fractional values or maybe it's because I've zoomed in this website for the sake of the workshop.

[00:00:58]
So I'm just gonna go ahead and make that look a little prettier, get some math round in there. Right, so much nicer, and of course we don't need to have a name function, like handle move. We can just declare the function in line if we want, so we can we can just copy.

[00:01:25]
Oops, we can just copy this whole thing and put it in there if we like. And I'm gonna turn it into an a anonymous arrow function, just cuz syntactically it's a lot simpler. I'm gonna change the name of the event to e, and rather than assigning to the properties individually, let's just change this to m=xe.clientX, ye.clientY.

[00:02:02]
ClientX and clientY are values that you get inside any mouse or pointer event handler and it's the same deal. It's giving us these fractional values out of a kind of a OCD. I'm gonna fix that with some math rounds. Right, and now we have an inline event handler that is causing this value here to update.

[00:02:32]
And it's totally fine to use an inline event handler as opposed to a named event handler. It's not gonna get, that function isn't gonna get recreated every time things change, which is what can happen in some frameworks. The compiler has always got your back. It's gonna try and do the right thing.

[00:02:51]
We can modify events using this concise modifier syntax. So here we have a click handler that is gonna cause an alert to appear every time we click it. We'll click that, click it again. Just gonna keep on coming, maybe we want this event to fire once and then for that event handler to be unregistered.

[00:03:12]
So we can add the ones modifier like that and now if you click it the first time, it will happen, but then after that, nothing happens at all. Right, we've got a few different modifiers that we can add, prevent default, stop propagation. Passive, non-passive, capture it once self.

[00:03:29]
You can read about this in your own time, we'll have exercises for each of these. These are just things that make your life a little bit easier when you're dealing with lots of events. And you can use multiple modifiers together by chaining them using this in text. It's not just elements that fire events, components can also fire events, but the component needs to make itself an event dispatcher.

[00:03:54]
So we've got two components in this exercise, an App.svelte and an Inner.svelte. And the app is going to listen for events from the inner, side inner. We want to create this event dispatcher by importing createEventDispatcher from Svelte. And then we'll create a new dispatch function. Now the reason that we need to do it in two steps like this, first we import, createEventDispatcher and then we create the dispatcher, is because when we call createEventDispatcher, Svelte knows that we're currently inside the inner component.

[00:04:41]
Later when we call dispatch, it knows that it's the dispatcher that belongs to that component. If we just imported a dispatch function, then Svelte would have no way of knowing which function was actually dispatching the event. Now that we've done that, so the button, if you click it, it will call this say hello function, which calls that dispatch function.

[00:05:08]
Now that we've wired that up, we can add an event handler inside App.svelte. And it's exactly the same syntax that we used with DOM elements. On message equals, then we've got a message handler set up here and the message. So we'll just feed that in like so and now if you click the button, it says hello, as you'd expect.

[00:05:34]
And there's nothing special about the name message. We could change that to say, greet and then in App.svelte, we'll change that also to greet. And a component can have as many different events as makes sense. Now in some frameworks, we don't have event systems. Instead you pass call backs as props into your components, and that's a thing that you can do in Svelte too.

[00:06:05]
It's really kind of a personal style preference. The basic advice is that your data goes down and then events come up. And whether those events are expressed using event dispatches in Svelte or whether they're expressed as callbacks that the component then calls, is really just a matter of code style.

[00:06:25]
I personally like the event style, but it's up to you, you're not forced to choose between one or the other. Okay, so facts about DOM events that you'll know if you've used the DOM a lot is that events bubble. Which is to say that if you have some element deep in your tree, you can add an event listener on any parent and the event will bubble up from the event target to where your event handler is registered.

[00:06:52]
That is not true with components, component events do not bubble. So if you want to listen to an event on some deeply nested component, the intermediate components need to forward the event upwards. And so in this case, we have the same App.svelte and Inner.svelte is in the exercise that we just did.

[00:07:10]
But there's also now this Outer.svelte which contains the inter spell component, so this is the middleman that's gonna need to forward the event from outer. Now, we could solve this by going through the whole rigmarole of importing createEventDispatcher and then creating a dispatch function and then adding an event listener to the inner here.

[00:07:37]
It's a lot of work, it's a lot of boilerplate and boilerplate is anathema to the Svelte way of doing things. So we have a convenient shorthand. Instead, when this event gets dispatched, we can just forward it to the application by adding on :message. And now, the outer component will dispatch that message when it receives it from the inner component.

[00:08:14]
And of course it works exactly the same way for DOM events. We have a big red button component here and we have a button. We want to get notifications of when the user clicks on that button. We've got our onclick handler wired up already inside App.svelte, I'm gonna call this handle click function, so we just need to add an onclick to that.

[00:08:41]
And now when you press that button. [SOUND]
Okay, that's enough of that.
>> Does forwarding only work with events or callbacks as well?
>> No, it does not work with callbacks, it is purely about events. So if you're using the callback style, then you will have to pass the callback from the parent component through the intermediate component to the child component in the same way that you currently need to add the forwarding syntax for the events.

[00:09:11]
Okay, so we got a question in the chat just now that was basically, how do I know in Outer.svelte that I need to forward this message event? Where is that event coming from? And the answer is, it's coming from us, we added it ourselves. In an App.svelte when we called dispatch, the name of the event that we pass into the dispatch function.

[00:09:32]
That is the name of the event that gets emitted from the component. And so anything that includes Inner.svelte can listen for those events or for them rather by adding that. And that will now cause the outer component to emit a message event that the app can listen to with its own on message handler.

[00:09:57]

>> So a pop-up sound?
>> Yeah, you can think of it that way, yeah.

