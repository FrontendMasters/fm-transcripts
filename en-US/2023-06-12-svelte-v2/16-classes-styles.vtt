WEBVTT

1
00:00:00.140 --> 00:00:02.510
All right, we're gonna learn
some more about bindings.

2
00:00:02.510 --> 00:00:07.372
Before, we used bindings for form elements
like inputs and selects and text areas,

3
00:00:07.372 --> 00:00:09.781
but we can use them in other contexts too.

4
00:00:09.781 --> 00:00:15.473
Here, we're gonna use it in the context
of a content editable element,

5
00:00:15.473 --> 00:00:20.342
so this is element that has
content editable, true, right?

6
00:00:20.342 --> 00:00:24.042
This is just an attribute you
can add to an element, and

7
00:00:24.042 --> 00:00:27.025
it allows you to type stuff into it,
right?

8
00:00:27.025 --> 00:00:30.962
That is not being reflected anywhere
because we're not binding anything.

9
00:00:30.962 --> 00:00:35.018
On this element,
because we're using content editable,

10
00:00:35.018 --> 00:00:38.029
we can bind to the html
inside that element.

11
00:00:41.689 --> 00:00:47.201
Gonna bind the inner HTML
to our HTML value here.

12
00:00:47.201 --> 00:00:52.759
And you'll see that the div is
now populated with the content.

13
00:00:52.759 --> 00:00:55.495
And if we start typing in here,

14
00:00:55.495 --> 00:01:00.249
that is reflected in
the element immediately below.

15
00:01:02.912 --> 00:01:06.140
It is possible to use a binding
inside an each block.

16
00:01:07.310 --> 00:01:15.630
Here, we've got another todo list And
we have some inputs inside that todo list.

17
00:01:16.870 --> 00:01:20.269
And if we change these values to bindings,

18
00:01:24.225 --> 00:01:29.798
Then, when we interact with these inputs,
it will actually mutate the data.

19
00:01:29.798 --> 00:01:36.525
So below, we have got a list of
the number of todos that are remaining,

20
00:01:36.525 --> 00:01:41.086
and that is calculated
from the todos along side

21
00:01:41.086 --> 00:01:45.548
a filter function in
a reactive declaration.

22
00:01:45.548 --> 00:01:47.699
And if I check these items,

23
00:01:47.699 --> 00:01:52.662
you will see that the remaining
value updates automatically.

24
00:01:54.941 --> 00:01:58.089
As I said, it's mutating the array,
that might not be a thing that you want,

25
00:01:58.089 --> 00:02:00.237
you might prefer to use
immutable data structures.

26
00:02:00.237 --> 00:02:03.523
And if that's the case, then you
should avoid using these bindings and

27
00:02:03.523 --> 00:02:05.980
you should use event handlers, instead.

28
00:02:05.980 --> 00:02:09.835
But as I say, mutation is fine as long
as it's local and as long as you're

29
00:02:09.835 --> 00:02:14.405
not mutating objects that you don't own,
so generally, this sort of thing is okay.

30
00:02:18.169 --> 00:02:23.320
We can also bind to the properties of
media elements like audio and video.

31
00:02:24.850 --> 00:02:29.056
Here, we've got some custom UI for
this audio player,

32
00:02:29.056 --> 00:02:32.830
which is defined in this
audio player.sel file.

33
00:02:32.830 --> 00:02:37.427
And we're gonna finish implementing this
by adding the audio element itself along

34
00:02:37.427 --> 00:02:38.619
with some bindings.

35
00:02:45.426 --> 00:02:50.640
So the source attribute is
being passed in from the app.

36
00:02:52.220 --> 00:02:56.794
We're using the spread operator because
each of these tracks has the source

37
00:02:56.794 --> 00:02:57.589
in the data.

38
00:03:07.019 --> 00:03:11.328
And then, we're gonna add some bindings
to the values that we're declaring up

39
00:03:11.328 --> 00:03:13.660
her time, duration, and this paused flag

40
00:03:25.541 --> 00:03:30.366
For duration and time, we just use
shorthand property because this is

41
00:03:30.366 --> 00:03:33.490
kind of unnecessary,
we can get rid of that.

42
00:03:35.710 --> 00:03:39.025
And you'll notice that at least for
the audio elements that have loaded,

43
00:03:39.025 --> 00:03:40.950
one of them seem to fail to load.

44
00:03:40.950 --> 00:03:45.289
It's now showing the duration
of the audio down here,

45
00:03:45.289 --> 00:03:50.854
it's loading the audio, and
once it figures out how long the pieces,

46
00:03:50.854 --> 00:03:55.402
it binds that back to the state and
finally bind, pause.

47
00:03:58.713 --> 00:04:02.873
And so to play the audio, we need to add
an event listener to the button that has

48
00:04:02.873 --> 00:04:05.882
the play icon,
that will just toggle that pause value.

49
00:04:09.043 --> 00:04:13.296
Be very familiar by now, on click,
and then we pass in a function.

50
00:04:16.711 --> 00:04:19.141
And it's just gonna invert
the value of paused.

51
00:04:21.477 --> 00:04:28.382
So if we've done this right, we should be
able to listen to some music now, okay?

52
00:04:31.218 --> 00:04:35.230
So our audio player now has
some basic functionality.

53
00:04:35.230 --> 00:04:39.954
We wanna add the ability to seek
to a specific part of the audio by

54
00:04:39.954 --> 00:04:43.890
dragging these sliders next
to the time indicator.

55
00:04:46.050 --> 00:04:51.892
If we scroll down to the slider element,
we have this pointer down handler,

56
00:04:51.892 --> 00:04:55.087
which lets us seek to
a specific moment and

57
00:04:55.087 --> 00:05:00.330
we just need to finish
implementing that seat function.

58
00:05:00.330 --> 00:05:05.551
We're calculating a value of p, which
is a value between 0 and 1, and we just

59
00:05:05.551 --> 00:05:11.110
need to multiply that by the duration
to get the correct time for the audio.

60
00:05:11.110 --> 00:05:13.350
I mean, just assign that
directly to the time variable.

61
00:05:20.323 --> 00:05:26.082
So this time, when you start playing,
we can drag that to the good bit.

62
00:05:26.082 --> 00:05:29.900
[MUSIC]

63
00:05:29.900 --> 00:05:34.008
And it's updating all
the user interface for us.

64
00:05:37.509 --> 00:05:41.565
We can add another event handler
on the audio element itself so

65
00:05:41.565 --> 00:05:43.603
that when the audio finishes,

66
00:05:50.368 --> 00:05:54.016
We reset the time right
back to the beginning.

67
00:05:59.360 --> 00:06:01.924
So got the last few seconds
of your property here.

68
00:06:01.924 --> 00:06:04.560
And then when it finishes,
you'll see that go back to 0.

69
00:06:06.130 --> 00:06:09.881
So we've covered a few of the bindings
that are available on media elements, but

70
00:06:09.881 --> 00:06:10.664
there are more.

71
00:06:10.664 --> 00:06:14.320
We've got a bunch of read only bindings,
duration, buffered,

72
00:06:14.320 --> 00:06:17.843
seekable, play seeking ended,
and five two-way bindings,

73
00:06:17.843 --> 00:06:21.374
which means that they will update
the state in your component.

74
00:06:21.374 --> 00:06:23.961
But also,
if you update the state in your component,

75
00:06:23.961 --> 00:06:25.640
it will affect the media element.

76
00:06:26.650 --> 00:06:31.394
In addition to these, videos have a video
width and a video height binding,

77
00:06:31.394 --> 00:06:36.074
which you can use to control the
positioning of other elements, and so on.

78
00:06:36.074 --> 00:06:39.176
Do you not have any questions about
the stuff that we've just learned?

79
00:06:41.774 --> 00:06:42.988
Okay.

80
00:06:50.081 --> 00:06:55.385
So every block level element in the DOM
has client width, client height, offset

81
00:06:55.385 --> 00:07:00.700
width, and offset height bindings, and
we can use that in our component state.

82
00:07:01.910 --> 00:07:06.765
Up here, we have width and
height declared and

83
00:07:06.765 --> 00:07:13.614
we can add these bindings to
our &lt;div bind:clientwidth={w}

84
00:07:13.614 --> 00:07:17.610
bind:clientheight equal={h}.

85
00:07:18.740 --> 00:07:22.428
Now, you can see that in the label
below the edit this text box,

86
00:07:22.428 --> 00:07:26.540
is actually showing the current
dimensions of that element.

87
00:07:26.540 --> 00:07:32.080
If we make this larger or smaller,
that updates automatically.

88
00:07:32.080 --> 00:07:36.042
Similarly, if we add more text,

89
00:07:36.042 --> 00:07:40.150
it's updating the width of that.

90
00:07:40.150 --> 00:07:47.310
This works with some crazy hacks that
only work with block level elements.

91
00:07:47.310 --> 00:07:51.440
So if you wanna use this with something
like a canvas, which cannot have children,

92
00:07:51.440 --> 00:07:54.100
then you will need to use
a wrapper element around it.

93
00:07:56.250 --> 00:07:59.274
In the future, we're gonna switch this
to use resize observer binding so

94
00:07:59.274 --> 00:08:00.944
that you will be able to use it anywhere.

95
00:08:04.878 --> 00:08:09.146
All right, you'll remember this
exercise from earlier where we were

96
00:08:09.146 --> 00:08:12.835
manipulating the contents of
a canvas by querying the DOM for

97
00:08:12.835 --> 00:08:15.531
it with document.query selector canvas.

98
00:08:16.580 --> 00:08:21.456
And that works, this call here works, but
it's really not ideal because if you had

99
00:08:21.456 --> 00:08:25.289
more than one of this component on
the page, then every time one of

100
00:08:25.289 --> 00:08:30.570
those components mounted, they would
get a reference to the same canvas.

101
00:08:30.570 --> 00:08:35.004
Using document.query selector is not
really a good way to interact with DOM if

102
00:08:35.004 --> 00:08:37.100
you don't control the entire page.

103
00:08:38.430 --> 00:08:41.432
So instead of using
document.query selector,

104
00:08:41.432 --> 00:08:44.660
we can use an element
binding inside the component.

105
00:08:44.660 --> 00:08:49.980
First of all, we need to declare
a variable, let canvas and then rather

106
00:08:49.980 --> 00:08:55.228
than using that query selector,
we're gonna bind the value of this,

107
00:08:59.777 --> 00:09:05.753
To that value, and
get rid of the query selector,

108
00:09:05.753 --> 00:09:09.462
and the app continues to work.

109
00:09:10.924 --> 00:09:15.431
And we can do the same thing that we
do with elements with components,

110
00:09:15.431 --> 00:09:18.163
we can have bindings on components here.

111
00:09:18.163 --> 00:09:20.869
We have a keypad component, which is,

112
00:09:20.869 --> 00:09:25.543
you can think of in the same way that
you would have an input element or

113
00:09:25.543 --> 00:09:31.310
a text element, you can think of this as
a very custom version of one of those.

114
00:09:31.310 --> 00:09:35.596
And we can bind to the state inside
the keypad in the same way that we bind to

115
00:09:35.596 --> 00:09:37.437
the value of an input element.

116
00:09:40.235 --> 00:09:46.093
So inside app, we'll add the binding and
we're gonna bind the value

117
00:09:46.093 --> 00:09:51.862
of the keypad to the pin value that
is declared inside app.svelte.

118
00:09:55.214 --> 00:10:00.911
Now, if I enter my pin,
they can use that state inside this

119
00:10:00.911 --> 00:10:07.207
view reactive declaration,
which is then used inside the DOM.

120
00:10:09.617 --> 00:10:13.790
So this is handy, but it is something
that you should generally use sparingly.

121
00:10:13.790 --> 00:10:18.242
As we've talked about before, in general,
you want your data to flow down

122
00:10:18.242 --> 00:10:22.001
from the top of the app,
you don't want your data to go back up.

123
00:10:22.001 --> 00:10:27.615
But in some locally confined scenarios,
it's much more convenient to be able

124
00:10:27.615 --> 00:10:33.327
to bind to a value of a component rather
than having to deal with event handlers.

125
00:10:36.037 --> 00:10:39.845
Finally, just as we can bind to
DOM elements, we can also bind

126
00:10:39.845 --> 00:10:44.330
to component instances themselves
using the same bind this directive.

127
00:10:44.330 --> 00:10:47.503
This is useful in the rare
cases that you need to interact

128
00:10:47.503 --> 00:10:52.246
with a component programmatically, as
opposed to by providing it with new state.

129
00:10:52.246 --> 00:10:56.579
So if we take the drawing app that we
looked at a few moments ago, it'd be nice

130
00:10:56.579 --> 00:11:01.730
to add a button to clear the screen and
at the moment, that's quite difficult.

131
00:11:01.730 --> 00:11:06.559
So let's add a clear method
inside the canvas component.

132
00:11:10.216 --> 00:11:14.810
Put that here, export function clear.

133
00:11:16.570 --> 00:11:21.631
When this gets called,
we'll do context.clearRect.

134
00:11:24.802 --> 00:11:26.656
It's to clear the entire canvas.

135
00:11:29.959 --> 00:11:33.117
And then, in app.spelt, we need to
get a reference to this component.

136
00:11:42.254 --> 00:11:46.912
Then, finally, we need to bind that
value to the component instance.

137
00:11:54.983 --> 00:11:59.658
So now, all we need to do in order to
interact with the canvas component

138
00:11:59.658 --> 00:12:04.589
programmatically is called the clear
function inside an event handler.

139
00:12:04.589 --> 00:12:08.737
So down here where we've got the controls,
we have this button here which is that

140
00:12:08.737 --> 00:12:11.055
close button that you
can see in the top left.

141
00:12:11.055 --> 00:12:12.348
We add another button,

142
00:12:22.732 --> 00:12:24.315
Give it a click handler.

143
00:12:26.835 --> 00:12:32.945
And when we click on that element,
we're gonna call canvas.clear.

144
00:12:32.945 --> 00:12:38.359
So now, we can draw something in here, And

145
00:12:38.359 --> 00:12:40.644
we can clear the canvas
if we make a mistake.

