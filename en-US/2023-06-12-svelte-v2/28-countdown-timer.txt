[00:00:00]
>> We're coming to the end of part 2 of the tutorial. This section is a little bit of a mishmash. We've got a bunch of different special elements that Svelte provides to your components and they don't really have anything in common with each other other than the fact that they belong to the Svelte name space.

[00:00:18]
So the first of these is svelte solve and that is something that allows a component to reference itself recursively, and it's useful things like this folder tree view, where a folder can contain another folder. So inside our Folder.svelte component, we would wanna be able to do something like this, where we have the file here, would like to be able to add a folder that references the same component but that's impossible because a module can't import itself.

[00:00:50]
So instead we use svelte:solve here. And now the folder is containing other folders. And we can do that to an arbitrary depth. An interesting fact about this is that if you try and do this at the top level of a component, it will yell at you because that would cause an infinite loop.

[00:01:20]
It's smart enough to know that is not a thing that you should be doing. Now, a component can change its type altogether with the svelte component element. In this exercise, we wanna show red thing.svelte if the value of the selected color is red. And we wanna show a green thing if it's green, and we wanna show blue thing if it's blue, and so on.

[00:01:48]
Now, we could do this with a sequence of if blocks inside that box svelte like we started doing here. And then if we select a different color, it would show the green thing in the blue thing. That's a lot of code to have to write, it's more convenient to make that data driven.

[00:02:06]
So as will create a single dynamic component, get rid of that entire block, ad svelte component. And then the attribute is called this. We're gonna pass in the selector component. So you see up here that the value that is getting passed in is actually the constructor of the component.

[00:02:32]
And now when we change the value of that via the Select, we're rendering a different component And we can do the same thing with elements, right, in the same way we could have, if selected equals h1, we'll have a block of h1 content, distillates equals h2, and so on.

[00:02:56]
But that's just no fun, instead, get rid of all of that. A new spell element, And put some content inside. I'm a less than slated. Greater than, Element, like so. And then now if we change to one of the other options, it recreates the dom automatically. And so the value of this can be any string or it can be a false value in which case no element will be rendered at all.

[00:03:49]
We've already seen how you can add event listeners to DOM elements. We can also add event listeners to the window object using the special spell window element. In this exercise, whenever we focus the window and press a key, we would like to show what key was pressed. We're gonna assign to these key and key code values, and then we're gonna show that inside the app.

[00:04:32]
This is just a more convenient way of using window.addEventListener, it will automatically remove event listeners when this component is unmounted. Just like with DOM elements, you can use event modifiers like prevent default. As well as adding events to Svelte window, we can bind to certain properties of it.

[00:04:55]
So here we've got a nice little piece of artwork generated by Midjourney and we would like to bind the current scroll position to this y value. And we can do that very easily, bind scroll y equals y. And now when we scroll, it reflected, again it's giving us fractional values because my site is zoomed in.

[00:05:24]
So, just change that and it update smoothly, and that's a bidirectional binding if you change the value of Y it will also update the scroll position. So, few different properties that you can bind to, width, height, scroll and also the online binding which is an alias for window.navigator.online.

[00:05:43]
This is useful for displaying a message like you lost the internet, you need to reconnect to Wi-Fi or something like that. As well as the window, we have a way of adding event listeners to the body element which you typically are not rendering yourself because normally you would mount your cell components inside the body, you don't control the actual body.

[00:06:07]
So we have Svelte body to listen to events like mouse enter and mouse leave. And mouse enter we want this, here kitty value to become true. And we'll just copy that line and reverse it on mouseleave it becomes false. And then now if we enter the iframe, kitty comes out to play.

[00:06:49]
Similarly, we have the svelte document element which is useful for the selection change handler in particular which does not fire on the window. So we can add this on selection change event listener. Which is gonna get the current selection and assign it to this selection value there. It can also select itself which kinda gets pretty crazy.

[00:07:31]
I don't recommend it. And then we can also add a Svelte head element. Which is very useful for things like SEO. You can add a document title, you can add descriptions and things like that, that will appear in search results pages. That's what it's mostly useful for, although it's not visible in the context of this tutorial.

[00:07:58]
So we're gonna use something a little bit different. We're gonna use it to load a stylesheet. At the svelte head element, And then, inside the link, rel = stylesheet. And we have a selection of style sheets up here that we can pick from. Beginning with the the Margaritaville theme and you can pick whichever of these you must enjoy Getting into the nuts and bolts of how the compiler works when you invoke the Svelte compiler, which typically you're not doing.

[00:08:58]
Your bundler plugin is doing this for you. But when that happens, you can pass options to the compiler that control how the component is compiled. But those are for all of the components in your app. Sometimes you wanna have some compile options that are component specific, and that's where we use the Svelte options element.

[00:09:17]
There's a few different options that you can pass to the compiler and we'll use the immutable option as our example. So in this app whenever we change the value of one of these todos, all of the todos are updated simultaneously. And that's because we have an after update function here, which causes the element to flash whenever the value is updated.

[00:09:46]
That's not really a problem here, that's fine because it's gonna be fast enough that it's not gonna affect the performance of your application. But you might have some situations where you have some very complex data and you just wanna make sure that a component doesn't update unless you know for sure that its values have changed.

[00:10:04]
So we can tell the to do component that it should only ever update anything when the data that is passed into it changes by reference as opposed to when it is told that its data has changed. This isn't something that you'll use often, but it's a handy thing in some circumstances.

[00:10:34]
So now if I change the value of any of these todos, only the todo in question is being updated, the others being left alone. Few other options that you can set, accesses controls whether or not the instance of a component exposes its props as accesses on the object that you have a reference to.

[00:11:00]
You can pass in a custom namespace, and you can control the tag name if you're compiling your Svelte components as custom elements. If you wanna know more about these, consult the API reference. Earlier, we learned about using slots to pass content into a component. In this exercise, we're making a tic tac toe game.

[00:11:29]
And we have a board component, and inside that board component, we're passing some content which is supposed to appear in each of the grid cells defined by the board. So if you look inside the board component, we are creating a grid which has a certain number of columns and a certain number of rows.

[00:11:54]
But what's happening here is because we have a div with the slot equals game attribute, we're putting all of the buttons inside the first element and it's not being spread out into the rest of the grid. What we want to have is these buttons as direct children of the div class equals board and we can do that by replacing that div with a spelt fragment.

[00:12:35]
All right, so now the buttons that we are declaring now are direct children of the div classic was born.

