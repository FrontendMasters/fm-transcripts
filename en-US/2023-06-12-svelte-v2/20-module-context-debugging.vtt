WEBVTT

1
00:00:00.000 --> 00:00:02.360
Okay, it's time to talk
about the circle of life.

2
00:00:02.360 --> 00:00:07.243
So every component has a life cycle
that starts when it's created and

3
00:00:07.243 --> 00:00:09.190
ends when it is destroyed.

4
00:00:09.190 --> 00:00:12.734
And there's a handful of functions
that allow you to run code inside

5
00:00:12.734 --> 00:00:15.610
your component at key moments
during that life cycle.

6
00:00:15.610 --> 00:00:18.453
The one that you're gonna use most
frequently is called onMount.

7
00:00:18.453 --> 00:00:23.251
And it's a function that allows you to
specify a callback that will get invoked

8
00:00:23.251 --> 00:00:26.171
when the component is
first mounted to the DOM.

9
00:00:26.171 --> 00:00:30.644
So in this exercise we have a canvas
element that we would like to animate

10
00:00:30.644 --> 00:00:34.015
using the paint function
in this gradient.js file.

11
00:00:34.015 --> 00:00:37.917
It's just gonna take an input
canvas context and a value t and

12
00:00:37.917 --> 00:00:42.753
it's gonna do some maths and it's gonna
turn that into a colorful canvas.

13
00:00:42.753 --> 00:00:45.917
So we'll first import
onMount into our component.

14
00:00:56.640 --> 00:00:58.984
And then we'll call onMount,
pass it a callback.

15
00:01:03.346 --> 00:01:04.044
And first up,

16
00:01:04.044 --> 00:01:08.500
we're gonna get a reference to that canvas
element using document querySelector.

17
00:01:08.500 --> 00:01:11.786
And if alarm bells are ringing that we
shouldn't be using document.querySelector,

18
00:01:11.786 --> 00:01:12.870
you're absolutely right.

19
00:01:12.870 --> 00:01:15.010
But we're gonna come to
that in a later exercise.

20
00:01:16.260 --> 00:01:23.368
Begin by doing canvas =
document.querySelector('canvas').

21
00:01:23.368 --> 00:01:27.580
And then if you haven't used the Canvas
API before, once you've got your reference

22
00:01:27.580 --> 00:01:31.631
to the element, you then need to create
a canvas context that you can paint with.

23
00:01:31.631 --> 00:01:39.883
const context = canvas.getContext('2d').

24
00:01:39.883 --> 00:01:43.887
2d is opposed to WebGL.

25
00:01:43.887 --> 00:01:49.320
And then we're gonna do some work in
a loop, gonna call requestAnimationFrame.

26
00:01:51.520 --> 00:01:55.686
And inside here we're gonna have a named
function so that we can refer to it,

27
00:01:55.686 --> 00:01:58.367
that takes a value t,
which is the current time.

28
00:02:00.529 --> 00:02:03.189
Inside the loop,
the first thing we're gonna do is call

29
00:02:03.189 --> 00:02:05.919
the loop again inside another
requestAnimationFrame.

30
00:02:10.699 --> 00:02:15.221
And then we're gonna call our paint
function using the context that we just

31
00:02:15.221 --> 00:02:20.267
created with the t value that got passed
into the requestAnimationFrame handler.

32
00:02:26.768 --> 00:02:30.629
So now, this function is being
called roughly 60 times a second.

33
00:02:34.684 --> 00:02:38.890
Okay, there is a problem with
the code that we just wrote.

34
00:02:38.890 --> 00:02:41.379
And this is kind of an easy
thing to overlook, but

35
00:02:41.379 --> 00:02:44.020
it's important not to make this mistake.

36
00:02:44.020 --> 00:02:46.337
If you're doing some work in onMount,

37
00:02:46.337 --> 00:02:50.494
you need to make sure that you undo
it when the component is unmounted.

38
00:02:50.494 --> 00:02:53.686
And the way that we're gonna do that
is by returning a function that

39
00:02:53.686 --> 00:02:54.940
calls some cleanup code.

40
00:02:57.070 --> 00:03:00.961
Any function that is returned from onMount
will get called when the component is

41
00:03:00.961 --> 00:03:02.580
destroyed.

42
00:03:02.580 --> 00:03:03.256
In our case,

43
00:03:03.256 --> 00:03:07.590
we wanna cancel the AnimationFrame
to stop this loop from running.

44
00:03:07.590 --> 00:03:12.190
In order to do that, we need to
create a frame variable locally.

45
00:03:12.190 --> 00:03:17.513
And we need to assign to that every
time we call requestAnimationFrame.

46
00:03:17.513 --> 00:03:20.858
And then in the return callback,

47
00:03:20.858 --> 00:03:26.483
we just call cancelAnimationFrame and
pass that ID in.

48
00:03:26.483 --> 00:03:29.586
And so, now when this component
is taken off the screen,

49
00:03:29.586 --> 00:03:31.340
we'll stop running that loop.

50
00:03:32.960 --> 00:03:36.744
Now, as you saw, we had that code running,
and it continued to run, and

51
00:03:36.744 --> 00:03:38.670
it was actually kind of fine.

52
00:03:38.670 --> 00:03:42.006
It was just updating a canvas
that you couldn't see anymore,

53
00:03:42.006 --> 00:03:43.490
which is obviously no use.

54
00:03:43.490 --> 00:03:46.812
If you did that too many times in the same
app, you would eventually start to

55
00:03:46.812 --> 00:03:50.319
run into memory leaks, and that's
something that we very much want to avoid.

56
00:03:54.638 --> 00:03:56.780
We have other lifecycle functions.

57
00:03:56.780 --> 00:04:01.491
beforeUpdate and afterUpdate
are lifecycle functions that are called

58
00:04:01.491 --> 00:04:06.840
immediately before the DOM is updated and
immediately after the DOM is updated.

59
00:04:08.620 --> 00:04:13.189
So basically, in Svelte we are dealing
with declarative state, but

60
00:04:13.189 --> 00:04:16.040
occasionally we need to break out of that.

61
00:04:16.040 --> 00:04:19.726
We need to use an escape hatch to
access the DOM directly because some

62
00:04:19.726 --> 00:04:23.510
things are hard to do in
a purely state-driven way.

63
00:04:23.510 --> 00:04:25.945
So this is the Eliza chatbot.

64
00:04:25.945 --> 00:04:32.011
Before there was ChatGPT,
there was Eliza, this comes from the 70s.

65
00:04:32.011 --> 00:04:33.182
And it's pretty cool.

66
00:04:33.182 --> 00:04:39.575
No, actually, everything is great.

67
00:04:39.575 --> 00:04:44.824
We can talk to it,
the only problem is the messages aren't

68
00:04:44.824 --> 00:04:50.944
appearing because we got a scroll,
completely misunderstood me.

69
00:04:50.944 --> 00:04:57.120
No, I'm very positive, right?

70
00:04:57.120 --> 00:04:58.561
[LAUGH] You're being a bit negative.

71
00:04:58.561 --> 00:05:03.251
But we have to do that every time we add
some more content because the DOM doesn't

72
00:05:03.251 --> 00:05:05.010
know that it needs to scroll.

73
00:05:06.270 --> 00:05:08.860
But we can fix that using beforeUpdate and
afterUpdate.

74
00:05:11.150 --> 00:05:15.480
We'll begin by creating
an auto scroll value.

75
00:05:15.480 --> 00:05:22.009
This is gonna track whether or not we
currently should be in auto scroll mode.

76
00:05:22.009 --> 00:05:23.810
I'm gonna default to false.

77
00:05:25.970 --> 00:05:31.226
Now the first time
beforeUpdate gets called,

78
00:05:31.226 --> 00:05:37.032
the dev might not have been
rendered to the DOM yet.

79
00:05:37.032 --> 00:05:41.851
So we're getting a reference to
the development using something

80
00:05:41.851 --> 00:05:46.756
called bind this, which we'll
discover in a later exercise, for

81
00:05:46.756 --> 00:05:49.747
now just pretend that this makes sense.

82
00:05:52.766 --> 00:05:58.909
So if the div has been created,
then we wanna calculate whether or

83
00:05:58.909 --> 00:06:02.382
not we should be in auto scroll mode.

84
00:06:02.382 --> 00:06:08.060
And the way that we're gonna do that
is by figuring out what the distances

85
00:06:08.060 --> 00:06:13.011
between the bottom of the scroll area and
the outer container.

86
00:06:13.011 --> 00:06:16.670
And it took me a few
go's to get this right.

87
00:06:18.940 --> 00:06:21.370
This is the sort of thing
that I struggle with.

88
00:06:21.370 --> 00:06:24.070
So I'm just gonna copy
the code over from the left.

89
00:06:24.070 --> 00:06:27.858
const scrollableDistance =

90
00:06:27.858 --> 00:06:33.620
div.scrollHeight- div.offsetHeight.

91
00:06:36.774 --> 00:06:41.578
And then we're gonna auto scroll
if there's less than 20 pixels

92
00:06:41.578 --> 00:06:46.312
between the bottom of the window and
the bottom of the container.

93
00:06:56.988 --> 00:07:01.145
And then once we've updated the DOM,
once the new chat messages have been

94
00:07:01.145 --> 00:07:04.046
added to the window,
if we are in auto scroll mode,

95
00:07:07.974 --> 00:07:13.494
Then in that case,
we're gonna call div.scrollTo 0,

96
00:07:13.494 --> 00:07:20.400
and then div.scrollHeight will take
us to the very bottom of the chat.

97
00:07:21.881 --> 00:07:24.616
All right, let's see if that worked.

98
00:07:27.392 --> 00:07:30.740
I don't have a problem.

99
00:07:30.740 --> 00:07:33.972
What is your problem?

100
00:07:36.087 --> 00:07:38.290
And you'll see that it's
auto-scrolling nicely.

101
00:07:39.990 --> 00:07:43.113
If, on the other hand,
we were not near the bottom of the chat,

102
00:07:47.498 --> 00:07:49.980
Then auto-scroll will be false.

103
00:07:49.980 --> 00:07:52.677
And so, when the afterUpdate
function gets invoked,

104
00:07:52.677 --> 00:07:55.560
we are not gonna then scroll
back to the bottom of the chat.

105
00:07:59.206 --> 00:08:02.982
All right, you probably won't find
yourself using beforeUpdate and

106
00:08:02.982 --> 00:08:04.585
afterUpdate all that often.

107
00:08:04.585 --> 00:08:10.046
It's really only when you need to interact
with the DOM in this very specific way.

108
00:08:10.046 --> 00:08:15.958
But it's useful when you do need it.

109
00:08:15.958 --> 00:08:20.430
Another lifecycle function that
we're gonna talk about is tick.

110
00:08:21.550 --> 00:08:23.651
Now, onMount, beforeUpdate, and

111
00:08:23.651 --> 00:08:28.170
afterUpdate all have to get called
while the component is initializing.

112
00:08:28.170 --> 00:08:29.720
It doesn't have to be
inside the script tag.

113
00:08:29.720 --> 00:08:32.796
You could be calling out to
a function in another module, but

114
00:08:32.796 --> 00:08:36.779
it does have to get called while the
component is initializing because that's

115
00:08:36.779 --> 00:08:39.398
how the callbacks get
assigned to that component.

116
00:08:39.398 --> 00:08:40.670
Tick is different.

117
00:08:40.670 --> 00:08:45.820
Tick can get called at any point, and
what tick does is it returns a promise

118
00:08:45.820 --> 00:08:50.654
that resolves when any pending state
updates are applied to the DOM.

119
00:08:52.841 --> 00:08:56.751
The reason this works is that when
you update component state in Svelte,

120
00:08:56.751 --> 00:08:59.005
it doesn't update the DOM immediately.

121
00:08:59.005 --> 00:09:03.580
So when we do count plus equals 1, it's
not updating the text inside the button

122
00:09:03.580 --> 00:09:08.090
right there and then, it's actually
waiting to see if there are any more state

123
00:09:08.090 --> 00:09:11.325
updates that it's gonna need
to apply at the same time.

124
00:09:11.325 --> 00:09:15.578
Because it's more efficient to do things
in a batched way than it is to do them

125
00:09:15.578 --> 00:09:16.580
synchronously.

126
00:09:18.240 --> 00:09:23.047
But that can be tricky if you're
updating state in such a way

127
00:09:23.047 --> 00:09:28.060
that causes the DOM to update in
a way that you need to monitor.

128
00:09:30.000 --> 00:09:33.666
For example, a little bit of a contrived
example, but we've got a text area here.

129
00:09:33.666 --> 00:09:38.659
And if I select some text like this,
and I hit the tab key,

130
00:09:38.659 --> 00:09:43.758
then we have a handleKeyDown function,
which is gonna get

131
00:09:43.758 --> 00:09:48.960
the selection range and
it's gonna turn it to shouty case or

132
00:09:48.960 --> 00:09:53.251
quiet case,
depending on what it currently is.

133
00:09:53.251 --> 00:09:56.852
And so if I select that and
I hit tab, it's done that,

134
00:09:56.852 --> 00:09:59.907
it's turned that text into uppercase text.

135
00:09:59.907 --> 00:10:03.843
But it's also moved my cursor
to the end of the text area,

136
00:10:03.843 --> 00:10:05.570
which is not what I want.

137
00:10:05.570 --> 00:10:07.660
I want the selection to stay in place.

138
00:10:08.860 --> 00:10:11.740
And I have some code here
that should be doing that.

139
00:10:11.740 --> 00:10:14.620
It's resetting the selectionStart and
the selectionEnd.

140
00:10:14.620 --> 00:10:18.700
But it's not having any effect
because the DOM hasn't updated yet.

141
00:10:18.700 --> 00:10:21.809
We're waiting to see if there are any
other state updates that we need to take

142
00:10:21.809 --> 00:10:22.350
account of.

143
00:10:23.540 --> 00:10:29.894
So we can fix this by importing
the tick helper from Svelte.

144
00:10:33.404 --> 00:10:38.250
And then immediately before we call
this.selectionStart = selectionStart,

145
00:10:38.250 --> 00:10:40.395
we're just gonna await that tick.

146
00:10:46.072 --> 00:10:50.356
And so now, if we select some text and
we hit tab, it will uppercase it but

147
00:10:50.356 --> 00:10:52.340
it will preserve the selection.

148
00:10:52.340 --> 00:10:53.929
If I hit it again, it will lowercase it.

149
00:10:56.000 --> 00:10:59.230
Again, this isn't a function
that you will use a whole lot.

150
00:10:59.230 --> 00:11:01.419
In the same way that beforeUpdate and

151
00:11:01.419 --> 00:11:04.316
afterUpdate are really
kind of escape hatches,

152
00:11:04.316 --> 00:11:08.781
tick is an escape hatch for when you
need to interact with the DOM manually.

