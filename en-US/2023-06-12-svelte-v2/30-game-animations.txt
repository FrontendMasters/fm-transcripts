[00:00:00]
>> So in all the examples that we've looked at so far, the script block contains code that runs when each component is initialized. And most of the time that is all that you'll need. Very occasionally, you will need to run some code outside of an individual component instance.

[00:00:16]
So if you go back to our audio example from earlier, one thing about this that's not so great is that you can play all of these tracks simultaneously,

[00:00:26]
[MUSIC]

[00:00:27]
Right? This is not what we want in a music player.

[00:00:31]
[MUSIC]

[00:00:32]
It'd be better if we could stop the current audio from playing when a new audio player starts, and we can do that by declaring some module context. Inside AudioPlayer.svelte, we're gonna create a new script block, but this time we're gonna add this context = module attribute. Inside there, we're gonna declare a value current, and all of the instances of AudioPlayer can see that value.

[00:01:12]
And so on our AudioPlayer, we can add an event listener, that when the audio starts playing, We check if there's an existing audio element playing, and if so, we pause it. Right, if this audio element is not current and if the current exists, pause it and change the value of current to be the current audio.

[00:01:55]
Right, and now when we start playing this

[00:01:58]
[MUSIC]

[00:02:00]
Each new AudioPlayer will stop the last one. [SOUND] We can also export things from the module context. So again, back in AudioPlayer.svelte, we have this module context, and we would like to make it possible for a consumer of this component to stop all of the audio. So create a new function, stopAll.

[00:02:34]
And if there is a current audio element, we'll pause it. And then now inside our App.svelte, we can now import the named function that we just declared, just like any other JavaScript module. And we can add a new button below the audio tracks. When we click it, and just call that function.

[00:03:10]
[MUSIC]

[00:03:16]
Works as expected. So you cannot have a default export from your script context = module because the component is the default export, but other than that you can. Yeah, it's basically just a normal JavaScript module and so you have all of the power of a normal JavaScript module.

[00:03:32]
Does anyone have any questions about module context? All right, we're getting very close. Yes, Chris.
>> What was the purpose of instantiating current in a separate script block?
>> So if you were to declare current inside the normal script, this is scope to the component instance. So inside here we can change the value inside the component, but it doesn't impact any of the other components.

[00:04:03]
By having it up here, this is part of the module and all of the instances of this component can read the same variable.
>> Does this affect after update? I mean, does it trigger a rerender across all of their components sharing this context?
>> No it does not, so the values inside the context = module, these are not reactive in the same way that variables inside the components normal script block are reactive.

[00:04:33]
This is just a regular JavaScript variable with no magic applied to it. If you do want components to be able to react to changes in this data, that's when you should use a store instead of a normal variable. Okay, so sometimes it's useful to be able to inspect a piece of data as it's flown through your app.

[00:04:50]
You can use console.log, liberally inside your markup if you want. But if you wanna add a debugger statement inside your component markup, you can do that with the debug tag, with a comma separated list of the values that you want to inspect. So in our App.svelte here, we've got a console.log of user, and when we change the value of that is going to get logged to the console.

[00:05:18]
This is easiest to see if I open this in a separate window. Let's get rid of all of the junk. If we start typing in here, you'll see that it does in fact get logged out. But we can do one better than that, we can get rid of the console.log and replace it with a debug tag.

[00:05:42]
And now you'll see that because we have DevTools open, we've actually paused execution of the component, and we can start to see these local variables and we can interact with them, and understand how the data is flowing through our application. And that concludes parts one and two of the Svelte tutorial.

[00:06:03]
You basically know everything there is to know about Svelte now, all of the features that Svelte itself has to offer. So hopefully you've learned something during this process, whether it's entirely new things or a refresher of things that you are a little bit rusty on, but for now you should take a break, pat yourself on the back and feel good about becoming a Svelte expert.

