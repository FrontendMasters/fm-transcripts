[00:00:00]
>> All right, we're gonna learn some more about bindings. Before, we used bindings for form elements like inputs and selects and text areas, but we can use them in other contexts too. Here, we're gonna use it in the context of a content editable element, so this is element that has content editable, true, right?

[00:00:20]
This is just an attribute you can add to an element, and it allows you to type stuff into it, right? That is not being reflected anywhere because we're not binding anything. On this element, because we're using content editable, we can bind to the html inside that element. Gonna bind the inner HTML to our HTML value here.

[00:00:47]
And you'll see that the div is now populated with the content. And if we start typing in here, that is reflected in the element immediately below. It is possible to use a binding inside an each block. Here, we've got another todo list And we have some inputs inside that todo list.

[00:01:16]
And if we change these values to bindings, Then, when we interact with these inputs, it will actually mutate the data. So below, we have got a list of the number of todos that are remaining, and that is calculated from the todos along side a filter function in a reactive declaration.

[00:01:45]
And if I check these items, you will see that the remaining value updates automatically. As I said, it's mutating the array, that might not be a thing that you want, you might prefer to use immutable data structures. And if that's the case, then you should avoid using these bindings and you should use event handlers, instead.

[00:02:05]
But as I say, mutation is fine as long as it's local and as long as you're not mutating objects that you don't own, so generally, this sort of thing is okay. We can also bind to the properties of media elements like audio and video. Here, we've got some custom UI for this audio player, which is defined in this audio player.sel file.

[00:02:32]
And we're gonna finish implementing this by adding the audio element itself along with some bindings. So the source attribute is being passed in from the app. We're using the spread operator because each of these tracks has the source in the data. And then, we're gonna add some bindings to the values that we're declaring up her time, duration, and this paused flag For duration and time, we just use shorthand property because this is kind of unnecessary, we can get rid of that.

[00:03:35]
And you'll notice that at least for the audio elements that have loaded, one of them seem to fail to load. It's now showing the duration of the audio down here, it's loading the audio, and once it figures out how long the pieces, it binds that back to the state and finally bind, pause.

[00:03:58]
And so to play the audio, we need to add an event listener to the button that has the play icon, that will just toggle that pause value. Be very familiar by now, on click, and then we pass in a function. And it's just gonna invert the value of paused.

[00:04:21]
So if we've done this right, we should be able to listen to some music now, okay? So our audio player now has some basic functionality. We wanna add the ability to seek to a specific part of the audio by dragging these sliders next to the time indicator. If we scroll down to the slider element, we have this pointer down handler, which lets us seek to a specific moment and we just need to finish implementing that seat function.

[00:05:00]
We're calculating a value of p, which is a value between 0 and 1, and we just need to multiply that by the duration to get the correct time for the audio. I mean, just assign that directly to the time variable. So this time, when you start playing, we can drag that to the good bit.

[00:05:26]
[MUSIC]

[00:05:29]
And it's updating all the user interface for us. We can add another event handler on the audio element itself so that when the audio finishes, We reset the time right back to the beginning. So got the last few seconds of your property here. And then when it finishes, you'll see that go back to 0.

[00:06:06]
So we've covered a few of the bindings that are available on media elements, but there are more. We've got a bunch of read only bindings, duration, buffered, seekable, play seeking ended, and five two-way bindings, which means that they will update the state in your component. But also, if you update the state in your component, it will affect the media element.

[00:06:26]
In addition to these, videos have a video width and a video height binding, which you can use to control the positioning of other elements, and so on. Do you not have any questions about the stuff that we've just learned? Okay. So every block level element in the DOM has client width, client height, offset width, and offset height bindings, and we can use that in our component state.

[00:07:01]
Up here, we have width and height declared and we can add these bindings to our <div bind:clientwidth={w} bind:clientheight equal={h}. Now, you can see that in the label below the edit this text box, is actually showing the current dimensions of that element. If we make this larger or smaller, that updates automatically.

[00:07:32]
Similarly, if we add more text, it's updating the width of that. This works with some crazy hacks that only work with block level elements. So if you wanna use this with something like a canvas, which cannot have children, then you will need to use a wrapper element around it.

[00:07:56]
In the future, we're gonna switch this to use resize observer binding so that you will be able to use it anywhere. All right, you'll remember this exercise from earlier where we were manipulating the contents of a canvas by querying the DOM for it with document.query selector canvas. And that works, this call here works, but it's really not ideal because if you had more than one of this component on the page, then every time one of those components mounted, they would get a reference to the same canvas.

[00:08:30]
Using document.query selector is not really a good way to interact with DOM if you don't control the entire page. So instead of using document.query selector, we can use an element binding inside the component. First of all, we need to declare a variable, let canvas and then rather than using that query selector, we're gonna bind the value of this, To that value, and get rid of the query selector, and the app continues to work.

[00:09:10]
And we can do the same thing that we do with elements with components, we can have bindings on components here. We have a keypad component, which is, you can think of in the same way that you would have an input element or a text element, you can think of this as a very custom version of one of those.

[00:09:31]
And we can bind to the state inside the keypad in the same way that we bind to the value of an input element. So inside app, we'll add the binding and we're gonna bind the value of the keypad to the pin value that is declared inside app.svelte. Now, if I enter my pin, they can use that state inside this view reactive declaration, which is then used inside the DOM.

[00:10:09]
So this is handy, but it is something that you should generally use sparingly. As we've talked about before, in general, you want your data to flow down from the top of the app, you don't want your data to go back up. But in some locally confined scenarios, it's much more convenient to be able to bind to a value of a component rather than having to deal with event handlers.

[00:10:36]
Finally, just as we can bind to DOM elements, we can also bind to component instances themselves using the same bind this directive. This is useful in the rare cases that you need to interact with a component programmatically, as opposed to by providing it with new state. So if we take the drawing app that we looked at a few moments ago, it'd be nice to add a button to clear the screen and at the moment, that's quite difficult.

[00:11:01]
So let's add a clear method inside the canvas component. Put that here, export function clear. When this gets called, we'll do context.clearRect. It's to clear the entire canvas. And then, in app.spelt, we need to get a reference to this component. Then, finally, we need to bind that value to the component instance.

[00:11:54]
So now, all we need to do in order to interact with the canvas component programmatically is called the clear function inside an event handler. So down here where we've got the controls, we have this button here which is that close button that you can see in the top left.

[00:12:11]
We add another button, Give it a click handler. And when we click on that element, we're gonna call canvas.clear. So now, we can draw something in here, And we can clear the canvas if we make a mistake.

