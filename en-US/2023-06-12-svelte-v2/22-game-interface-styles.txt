[00:00:00]
>> Okay, so just like elements can have children, like an example here where a div has a paragraph inside it, certain components, but before a component can accept children, it needs to know where it should put them. And for that, we use the slot element. Inside our Card.svelte, we'll add a slot like so, and we can now put things inside the card component in App.svelte.

[00:00:42]
That was what we call a default slot. So anything that goes directly inside the card component goes into the default slot element. But sometimes you need more control over placement. And for those cases, we have something called named slots. And it's like the Card.svelte component, we've got, sorry, inside here we've got a span slot=telephone and a span slot=company and a span slot=address.

[00:01:10]
We need to create corresponding slots for all of that content inside Card.svelte. At the top we'll add this header element. Got one for the telephone, one for the company. And then, below the default slot we'll add a footer, With a slot for the address. Now this card is pretty close to what we want, but we have in the top right, the name of the company has a small element inside it.

[00:02:00]
And the small element is expressed in App.svelte here. And because that's where the element lives, that's where the styles also need to go. All the contents of the Card component inherit styles, that are declared in the style tag of Card.svelte. But ultimately, the styles belong to the component where the elements live.

[00:02:25]
So if you wanna add some styles for that small element, we're gonna need to do it in the style tag of App.svelte. We wanna add a display equals block so that it falls onto its own line. Then we need to give it a smaller font size and we wanna align it to the right.

[00:02:50]
Like so. All right, alternatively we could have used the global modifier and put the styles inside the Card.svelte to target all small elements inside the div with the .card class, it really depends on who you want to be in control of that styling. Now we have two of these cards and one of them we have some content.

[00:03:23]
And then in the other one we haven't yet specified any content. And a component can specify fallbacks for any slots that are left empty by just putting it inside the slot element. So over in Card.svelte, inside the slot we can add, Some fullback content reminding you to put the telephone number on the card.

[00:03:53]
If we make that a little bit bigger, you can see it there in the top left, and we'll do the same thing for, The company name. They have the default slot, And finally for the address. And then of course in App.svelte if we start filling these details out, it will use the values that are passed in instead of the fallback.

[00:04:47]
Right, does anyone have any questions about the component composition APIs? Okay, so in some situations you will need to pass data from a component back into the parent that is passing in the slotted content, which is a little bit of a head scratcher until you see it in action.

[00:05:10]
So here we have a component called filterable list, which given some data allows us to filter the contents of that data based on the field that we've provided. So here we have a whole bunch of CSS named colors. This is every, I believe, CSS named color with its corresponding hex value.

[00:05:36]
And we wanna be able to filter this list, like find all of the orange colors, for example. Which almost works, there are three orange colors, but they're not being rendered correctly. And that's because we're not passing data from the filterable list back in to the app. First thing we need to do is pass the data into the slot.

[00:05:59]
So inside our filterable list, We're gonna pass the item into that just like any component prop. And then on the other side of the equation, where it's being used in App.svelte, We need to add something called the let binding, let item equals row. And what you'll find now is that all of the data is being rendered inside the filterable list and if I type the word orange, we'll see that there are in fact three orange colors, dark orange, orange, and orange red.

[00:06:41]
And finally up here, we began by using Alice Blue for everything, which is the first row in that array of data, we can now get rid of that because it is not being referenced anywhere. So you can do the same thing with name slots, you put the let binding on the element with the slot attribute as opposed to on the component itself.

[00:07:03]
And this allows you to compose components in fairly complex ways. Finally, in some cases you might wanna vary the contents of the component based on whether slotted content has been provided. So for example, in App.svelte, we have this header, which is providing this banner at the top here.

[00:07:27]
If we get rid of that, then it will no longer render, but we're left with this ugly double border effect because inside filterable list, we're rendering div class equals header regardless of whether or not it was provided. And we can fix that using the special dollar dollar slots variable which is available to components.

[00:07:49]
If the header slot was provided, then that will be true. If not, then it is not true and we've got rid of that double border.

