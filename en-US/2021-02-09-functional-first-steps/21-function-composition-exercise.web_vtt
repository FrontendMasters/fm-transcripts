WEBVTT

1
00:00:00.690 --> 00:00:03.175
So this is what we're gonna
do in our next exercise,

2
00:00:03.175 --> 00:00:05.210
which is exercise function composition.

3
00:00:07.490 --> 00:00:11.400
Once again, you can find it by
going to that collection page.

4
00:00:13.080 --> 00:00:14.190
You'll find it in there.

5
00:00:15.460 --> 00:00:19.346
And you can take a look at
the instructions to understand what you're

6
00:00:19.346 --> 00:00:20.780
being asked to do.

7
00:00:20.780 --> 00:00:22.700
But let me run it through run
us through it really quickly.

8
00:00:24.998 --> 00:00:29.471
Pipelining is this type of thing that
we were talking about where we take

9
00:00:29.471 --> 00:00:34.170
the inputs from one function,
pass them into the next function.

10
00:00:34.170 --> 00:00:37.943
Excuse me, we take the inputs from one
function, the outputs from that get passed

11
00:00:37.943 --> 00:00:42.155
into the next function, the outputs from
that get passed into the next function.

12
00:00:42.155 --> 00:00:46.435
And we create kind of a pipeline,
through which the data flows.

13
00:00:46.435 --> 00:00:49.903
So what we're gonna do is
write a pipeline function,

14
00:00:49.903 --> 00:00:54.540
which is gonna make it really easy for
us to do that simply by passing in.

15
00:00:54.540 --> 00:00:58.075
A series of functions
to a pipeline function.

16
00:00:58.075 --> 00:01:02.263
We get to compose them all
together into a single function,

17
00:01:02.263 --> 00:01:05.130
which is going to flow the data through.

18
00:01:06.360 --> 00:01:07.900
So your first task is to implement that.

19
00:01:07.900 --> 00:01:12.657
And there are some tests below, where
you'll wanna look for those little funky

20
00:01:12.657 --> 00:01:17.950
faces to turn into TAs again, to let
you know that your pipeline is working.

21
00:01:17.950 --> 00:01:19.874
And the way we'll be using it,

22
00:01:19.874 --> 00:01:24.388
is by calling it on a series of single
argument functions like this, so,

23
00:01:24.388 --> 00:01:28.459
that we no longer have to worry
about that nested call signature.

24
00:01:28.459 --> 00:01:31.917
It just makes it a little
bit easier to read, and

25
00:01:31.917 --> 00:01:37.590
to understand what order these
functions are gonna be applied in.

26
00:01:37.590 --> 00:01:41.880
And then, if you really wanna challenge
you can try to implement pipeline with

27
00:01:41.880 --> 00:01:43.830
the reduce function from earlier.

28
00:01:46.550 --> 00:01:53.159
The second part of this exercise is that
we're going to try to transform some data.

29
00:01:53.159 --> 00:01:58.826
Using these functional pipelines, so
what we're going to do is take strings

30
00:01:58.826 --> 00:02:04.070
in a certain case, like snake case,
which you might be familiar with.

31
00:02:04.070 --> 00:02:05.230
If you've worked in Python.

32
00:02:05.230 --> 00:02:09.168
This is kind of a convention for
a variable naming in Python and

33
00:02:09.168 --> 00:02:14.092
turn them into more JavaScript IE camel
case strings like to sort of translate

34
00:02:14.092 --> 00:02:19.260
our pythonic variables,
to JavaScript variables or what have you.

35
00:02:19.260 --> 00:02:24.322
And so what you're going to do is try to
write a series of small single arguments,

36
00:02:24.322 --> 00:02:27.748
single operation,
single action sort of functions,

37
00:02:27.748 --> 00:02:32.070
that are going to do just one
transformation at a time.

38
00:02:32.070 --> 00:02:36.584
Then we're going to compose them
together into a program a function

39
00:02:36.584 --> 00:02:42.290
that's going to take in a snake case
string and return a camel case string.

40
00:02:42.290 --> 00:02:45.725
And then there are a few
more challenge exercises for

41
00:02:45.725 --> 00:02:50.190
you as well to do variations on this
on this snake to camel pipeline.

