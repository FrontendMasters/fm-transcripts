WEBVTT

1
00:00:00.000 --> 00:00:02.548
So let's take a look at these exercises.

2
00:00:02.548 --> 00:00:07.430
Did everybody have a chance to get to
the bottom of the notebook as it were?

3
00:00:07.430 --> 00:00:09.112
I'm seeing some nods.

4
00:00:09.112 --> 00:00:10.201
Okay, great.

5
00:00:10.201 --> 00:00:12.644
And obviously for
folks following along at home,

6
00:00:12.644 --> 00:00:14.982
hope you could spend
whatever time you needed.

7
00:00:14.982 --> 00:00:16.391
So all right?

8
00:00:16.391 --> 00:00:19.584
Let's talk about readability.

9
00:00:19.584 --> 00:00:25.062
Now, this is a very subjective question.

10
00:00:25.062 --> 00:00:27.333
Everyone is gonna have
a different answer for it.

11
00:00:27.333 --> 00:00:32.184
But between these two versions,
the iterative factorial and

12
00:00:32.184 --> 00:00:37.594
the recursive factorial, which one
do people find easier to read and

13
00:00:37.594 --> 00:00:42.083
understand what it's doing
just by looking at the code?

14
00:00:42.083 --> 00:00:45.993
Who thinks the iterative
factorial is easier to read?

15
00:00:49.314 --> 00:00:51.196
I don't see any hands being raised.

16
00:00:51.196 --> 00:00:52.990
I don't see anybody nodding.

17
00:00:52.990 --> 00:00:55.437
I see maybe one hand being raised, okay?

18
00:00:55.437 --> 00:00:57.718
Couple people, okay?

19
00:00:57.718 --> 00:00:59.915
What about the recursive version?

20
00:00:59.915 --> 00:01:00.792
Three, four, okay?

21
00:01:00.792 --> 00:01:06.223
A few more people, find this recursive
version a little bit easier to read.

22
00:01:06.223 --> 00:01:07.575
Would anybody like to share?

23
00:01:07.575 --> 00:01:12.433
And again, this is a totally subjective
question because programming is

24
00:01:12.433 --> 00:01:16.992
pretty subjective in the sense that
style and organization of code.

25
00:01:16.992 --> 00:01:20.961
And how easy it is to work with
a particular style or program paradigm is

26
00:01:20.961 --> 00:01:25.621
something that's gonna vary based on
the programmer based on their background.

27
00:01:25.621 --> 00:01:29.234
Based on the languages that they've worked
in before based on the types of programs

28
00:01:29.234 --> 00:01:30.482
that they've read before.

29
00:01:30.482 --> 00:01:34.910
So who would like to share their
perspective on either of these

30
00:01:34.910 --> 00:01:40.031
functions and what they thought
about the difference in readability.

31
00:01:40.031 --> 00:01:45.072
I think that the iterative
one is very clear

32
00:01:45.072 --> 00:01:49.972
in the sense that it does step by step,
but

33
00:01:49.972 --> 00:01:55.448
the recursive fracture
is more like elegant.

34
00:01:55.448 --> 00:01:56.972
I don't know, it seems to me.

35
00:01:56.972 --> 00:02:01.360
&gt;&gt; Okay, so I heard that the iterative
factorial implementation seems very clear,

36
00:02:01.360 --> 00:02:06.014
because we can read step by step what it's
doing, because again, it's imperative.

37
00:02:06.014 --> 00:02:09.357
So it's all these commands,
these kind of steps,

38
00:02:09.357 --> 00:02:13.263
but that the recursive factorial
seems a bit more elegant.

39
00:02:13.263 --> 00:02:17.075
That's something, that's a word that
you often hear people use when they

40
00:02:17.075 --> 00:02:20.784
are describing recursion or
when they are describing functional code.

41
00:02:20.784 --> 00:02:24.453
We'd love to hear more about what makes
this function look elegant to us.

42
00:02:24.453 --> 00:02:26.676
What does elegant mean to us?

43
00:02:26.676 --> 00:02:28.412
Again, it's a subjective question.

44
00:02:28.412 --> 00:02:30.888
Just maybe you want to
expand a little bit.

45
00:02:30.888 --> 00:02:33.417
&gt;&gt; I think that the fate
that the fact that.

46
00:02:33.417 --> 00:02:37.355
&gt;&gt; It doesn't need to hold on state,
it doesn't need state.

47
00:02:37.355 --> 00:02:39.032
It doesn't need to keep state.

48
00:02:39.032 --> 00:02:43.444
We don't have that product
value changing over time.

49
00:02:43.444 --> 00:02:46.225
&gt;&gt; Because we don't have a state,

50
00:02:46.225 --> 00:02:51.172
we don't have to hold on keeping
that state on your mind.

51
00:02:51.172 --> 00:02:55.507
If you are debugging something
that doesn't have a stated way,

52
00:02:55.507 --> 00:02:58.161
it's way more easier to reason about.

53
00:02:58.161 --> 00:03:03.356
But if you don't understand
recursive equations,

54
00:03:03.356 --> 00:03:06.665
then is very hard to understand.

55
00:03:06.665 --> 00:03:11.820
For someone that is
starting on programming or

56
00:03:11.820 --> 00:03:16.708
if you have a lot of
juniors in your company,

57
00:03:16.708 --> 00:03:21.728
it may get to the point
that it starts to become

58
00:03:21.728 --> 00:03:26.110
hard to maintain this recursive code.

59
00:03:26.110 --> 00:03:30.936
&gt;&gt; Okay, so just to recap the absence
of state in the recursive

60
00:03:30.936 --> 00:03:33.929
factorial function and feels nice or

61
00:03:33.929 --> 00:03:39.046
seems like a positive addition,
but for somebody who doesn't

62
00:03:39.046 --> 00:03:44.379
have a lot of experience with
working with recursive functions.

63
00:03:44.379 --> 00:03:49.144
Or perhaps is really new to programming
and especially, and I think a lot of

64
00:03:49.144 --> 00:03:53.845
introductory programming courses
really take an imperative approach.

65
00:03:53.845 --> 00:03:57.551
So if someone is less experienced
with thinking about solving problems

66
00:03:57.551 --> 00:04:00.206
in a recursive way,
the recursive implementation

67
00:04:00.206 --> 00:04:04.486
might be a little harder to wrap your head
around, a little harder to understand.

68
00:04:04.486 --> 00:04:10.171
I totally agree, and I think again,
this is subjective because for example,

69
00:04:10.171 --> 00:04:16.216
if we have been working with an imperative
programming language like C, or C++.

70
00:04:16.216 --> 00:04:21.438
Or one of these languages that
forces us to do everything in kind

71
00:04:21.438 --> 00:04:27.263
of imperative commands, we might be so
used to thinking in that mode.

72
00:04:27.263 --> 00:04:31.973
That might be like really where our
mindset our paradigm, our worldview,

73
00:04:31.973 --> 00:04:36.922
is that mentally and that might make it
easier to take in that imperative code.

74
00:04:36.922 --> 00:04:41.504
But again, that's why it's so
important to get a lot of practice and

75
00:04:41.504 --> 00:04:46.883
spend a lot of time, kind of wrapping
your head around the functional approach.

76
00:04:46.883 --> 00:04:52.282
Because once you've wrapped your head
around the concepts of recursion,

77
00:04:52.282 --> 00:04:57.339
the concepts of solving problems
by breaking them down recursively,

78
00:04:57.339 --> 00:05:01.118
then that will no longer feel so
strange or so weird.

79
00:05:01.118 --> 00:05:06.251
And then, you'll be able to decide for
yourself whether you want to take

80
00:05:06.251 --> 00:05:11.805
a recursive approach because it let's
say allows you to write a much quicker,

81
00:05:11.805 --> 00:05:16.116
shorter function where there's
less than code to check in.

82
00:05:16.116 --> 00:05:20.695
Less code to worry about or
whether you prefer the imperative style.

83
00:05:20.695 --> 00:05:24.192
Because perhaps, you're working on
a team with lots of people who are more

84
00:05:24.192 --> 00:05:27.079
comfortable with imperative code and
that is what's best for

85
00:05:27.079 --> 00:05:29.425
the maintainability of the project and
the team.

86
00:05:29.425 --> 00:05:33.058
So again, there's no hard and
fast answers here.

87
00:05:33.058 --> 00:05:38.204
It's a question of what works best for
you what works best for your team and

88
00:05:38.204 --> 00:05:42.447
what works best for
the journey that you're trying to take.

89
00:05:42.447 --> 00:05:44.787
Are you trying to bend your mind and

90
00:05:44.787 --> 00:05:48.346
solve problems a different
way than you usually do?

91
00:05:48.346 --> 00:05:53.583
Or are you trying to stick with the same
mental models that you've been using?

92
00:05:53.583 --> 00:05:56.872
So this is what I wanted you all to
think about with, with this exercise.

93
00:05:56.872 --> 00:06:01.133
Again is like really,
it's a very individual thing here, okay?

94
00:06:01.133 --> 00:06:04.253
Now, how about writing these functions?

95
00:06:04.253 --> 00:06:06.356
How did this go?

96
00:06:06.356 --> 00:06:10.907
Were people able to implement both
of these versions, the iterative and

97
00:06:10.907 --> 00:06:13.082
recursive Fibonacci functions?

98
00:06:15.680 --> 00:06:17.510
&gt;&gt; Yes.

99
00:06:17.510 --> 00:06:22.371
&gt;&gt; I see some some folks were great.

100
00:06:22.371 --> 00:06:27.205
And I see someone made a comment about
the recursive implementations being

101
00:06:27.205 --> 00:06:30.747
a little bit closer to how we
were taught in math class.

102
00:06:30.747 --> 00:06:35.776
And yes, I agree, I think for certain
of these problems, especially these

103
00:06:35.776 --> 00:06:40.504
operations like the factorial and
the Fibonacci number calculation.

104
00:06:40.504 --> 00:06:45.040
When you learn in math class, when
a human is explaining to another human,

105
00:06:45.040 --> 00:06:48.789
here's how you do it,
you take the factorial of this number.

106
00:06:48.789 --> 00:06:53.509
And that gives you the number of times
the factorial of the next smaller

107
00:06:53.509 --> 00:06:57.590
number that is the way you might
explain it to another human.

108
00:06:57.590 --> 00:07:00.129
Because when we think
about things like that,

109
00:07:00.129 --> 00:07:02.679
that is us thinking in
a kind of recursive way.

110
00:07:02.679 --> 00:07:07.492
So, that also has a big impact on which
of these will be easier to read and

111
00:07:07.492 --> 00:07:08.868
write, all right?

112
00:07:08.868 --> 00:07:13.619
So there are plenty of
ways stylistically and

113
00:07:13.619 --> 00:07:20.382
syntactically in JavaScript to
implement these two versions.

114
00:07:20.382 --> 00:07:26.832
I have one option here in another in a
kind of a solved version of this notebook,

115
00:07:26.832 --> 00:07:31.152
which you can see by going
at the top of the notebook.

116
00:07:31.152 --> 00:07:36.162
It shows there's a fork
iteration versus recursion.

117
00:07:36.162 --> 00:07:39.838
So if you open that up, and
please let me know if anybody is

118
00:07:39.838 --> 00:07:44.065
having trouble again with finding
anything here on observable.

119
00:07:44.065 --> 00:07:50.287
You'll find a version of the notebook
with some of this code filled out.

120
00:07:50.287 --> 00:07:54.923
And so again, once you've got that
implementation done with the correct

121
00:07:54.923 --> 00:07:57.624
output you should see these little tatas.

122
00:07:57.624 --> 00:08:02.594
Now, I'm trusting you all that you're
forcing yourself to use an imperative

123
00:08:02.594 --> 00:08:05.303
style, an iterative style with a loop, or

124
00:08:05.303 --> 00:08:08.410
forcing yourself to use recursion wiki,
wiki.

125
00:08:08.410 --> 00:08:12.026
We're not programmatically
determining that to do these

126
00:08:12.026 --> 00:08:13.879
little test cells down here.

127
00:08:13.879 --> 00:08:18.577
But here's one way you could have
done the Fibonacci Is a sort of with

128
00:08:18.577 --> 00:08:23.537
a couple of just caveats of this is
by definition, that's the answer.

129
00:08:23.537 --> 00:08:25.453
Zero gives zero and one gives one.

130
00:08:25.453 --> 00:08:27.637
And then, you could use a for

131
00:08:27.637 --> 00:08:33.100
loop to kind of keep changing the values
of counters called previous and

132
00:08:33.100 --> 00:08:38.577
current that allow you to keep tracking
where you are at in the process.

133
00:08:38.577 --> 00:08:43.827
So sort of to remember how far
you've come in the sequence,

134
00:08:43.827 --> 00:08:48.141
and then finally return
the most current value.

135
00:08:48.141 --> 00:08:51.180
Folks might have different solutions for

136
00:08:51.180 --> 00:08:55.270
this that are also iterative and
also perfectly valid.

137
00:08:55.270 --> 00:08:57.849
This is just one way you could do it.

138
00:08:57.849 --> 00:09:04.758
So moving on to the recursive version,
this is where there's probably fewer

139
00:09:04.758 --> 00:09:10.085
ways that you would be able to
solve this in a recursive way.

140
00:09:10.085 --> 00:09:11.948
But again, there's some flexibility here.

141
00:09:11.948 --> 00:09:14.211
Everybody might have
a slightly different version.

142
00:09:14.211 --> 00:09:15.368
But here is one way.

143
00:09:15.368 --> 00:09:18.562
So again,
we start out with those kinds of default,

144
00:09:18.562 --> 00:09:23.295
just by definition these are the first
two values of the Fibonacci sequence.

145
00:09:23.295 --> 00:09:27.483
And by the way, I hope everyone was able
to find that link in the exercise to read

146
00:09:27.483 --> 00:09:29.387
up about the Fibonacci sequence and

147
00:09:29.387 --> 00:09:33.407
what Fibonacci numbers are in case
you haven't encountered them before.

148
00:09:33.407 --> 00:09:34.550
Check out the Wikipedia article.

149
00:09:34.550 --> 00:09:36.510
It's pretty good.

150
00:09:36.510 --> 00:09:40.942
[COUGH] And again, we have some test
cases, so we know when it's working.

151
00:09:40.942 --> 00:09:46.022
So in our recursive version,
we start out the same way as we did

152
00:09:46.022 --> 00:09:52.587
in the iterative one with these two
kind of non-recursive return statements.

153
00:09:52.587 --> 00:09:57.611
Does anybody remember which part of
the recursive function this is called?

154
00:09:57.611 --> 00:09:58.551
&gt;&gt; Base case.

155
00:09:58.551 --> 00:10:00.252
&gt;&gt; Base case, thank you, yes.

156
00:10:00.252 --> 00:10:04.192
So in this case, I have two base cases,
or I have a two part base case.

157
00:10:04.192 --> 00:10:06.237
And again, we need that base case so

158
00:10:06.237 --> 00:10:09.857
that we don't end up getting
into an infinite recursive loop.

159
00:10:09.857 --> 00:10:14.674
And then, I have my recursive
case where I am applying

160
00:10:14.674 --> 00:10:19.501
this recursive Fibonacci
function actually twice.

161
00:10:19.501 --> 00:10:26.221
I'm getting the Fibonacci number 2 before,
and the Fibonacci number 1 before,

162
00:10:26.221 --> 00:10:31.899
so that I can add those together and
get the current Fibonacci number.

163
00:10:31.899 --> 00:10:35.886
And this is probably gonna look quite
similar to how again on the Wikipedia

164
00:10:35.886 --> 00:10:38.779
article it describes what
Fibonacci sequences are,

165
00:10:38.779 --> 00:10:42.847
how it's calculated, or maybe what
you would have learned in math class.

166
00:10:42.847 --> 00:10:47.616
And you will see a lot of overlap
between those kind of problems in

167
00:10:47.616 --> 00:10:52.209
math that are solved by these
kind of recursive operations and

168
00:10:52.209 --> 00:10:55.940
functional programming
examples like this one.

169
00:10:55.940 --> 00:10:59.429
So which one was easier to write?

170
00:10:59.429 --> 00:11:03.875
Same question and again,
again, super subjective, but

171
00:11:03.875 --> 00:11:08.604
who found the imperative
iterative version easier to write?

172
00:11:08.604 --> 00:11:14.173
I see a hand, okay?

173
00:11:14.173 --> 00:11:15.993
What about the recursive version?

174
00:11:18.458 --> 00:11:21.356
I see two hands, three hands, okay?

175
00:11:21.356 --> 00:11:24.274
So again, there's no right answer.

176
00:11:24.274 --> 00:11:28.501
It's a function of a lot of
different things, function.

177
00:11:28.501 --> 00:11:33.741
It's a function of how much time you've
spent writing recursive implementations.

178
00:11:33.741 --> 00:11:38.633
Perhaps, whether or not you looked at
the Wikipedia article which would maybe

179
00:11:38.633 --> 00:11:41.236
nudge you in a functional recursive way.

180
00:11:41.236 --> 00:11:45.767
Or whether maybe you are just starting
out in JavaScript after decades

181
00:11:45.767 --> 00:11:49.468
in an imperative language like C or
something like that.

182
00:11:49.468 --> 00:11:52.339
All those things will affect which
one is easier to read and write.

183
00:11:52.339 --> 00:11:56.490
So again, when people say,
recursive programming or

184
00:11:56.490 --> 00:12:00.372
functional programming is
absolutely the best and

185
00:12:00.372 --> 00:12:05.803
absolutely the most elegant and
the most wonderful to write, to read.

186
00:12:05.803 --> 00:12:09.441
That may be true for them, but
it might not be true for everyone.

187
00:12:09.441 --> 00:12:12.609
So keep that in mind
when listening to folks

188
00:12:12.609 --> 00:12:17.260
about how much they love functional
programming and recursion, even me.

