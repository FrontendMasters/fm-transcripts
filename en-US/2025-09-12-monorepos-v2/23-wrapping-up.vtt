WEBVTT

1
00:00:00.240 --> 00:00:04.399
&gt;&gt; Male 1: If I want to build an open
source library composed of multiple

2
00:00:04.399 --> 00:00:08.231
packages like Lib, Course,
Lib, Utils, libreact,

3
00:00:08.231 --> 00:00:11.492
all inside of one monorepo,
using Lerna or nx,

4
00:00:11.492 --> 00:00:16.320
what's the best way to structure it for
long term maintainability?

5
00:00:16.320 --> 00:00:19.069
Should it just be each
feature in its own package or

6
00:00:19.069 --> 00:00:23.280
is it better to keep everything in one
package with an internal structure?

7
00:00:23.280 --> 00:00:25.360
&gt;&gt; Mike: Yeah, that's a great question.

8
00:00:25.360 --> 00:00:32.000
There is a trap of trying to split
things apart too much too early.

9
00:00:32.000 --> 00:00:37.142
And what I would say is look for,
I would rather have a fat

10
00:00:37.142 --> 00:00:41.958
core package that I later
understand I need to factor

11
00:00:41.958 --> 00:00:46.992
some things out than start in
a world where every single

12
00:00:46.992 --> 00:00:52.640
feature is its own package and
then have to worry about.

13
00:00:52.640 --> 00:00:56.398
All right now people are using these
things sort of very difficult to claw

14
00:00:56.398 --> 00:00:57.450
that back, right?

15
00:00:57.450 --> 00:01:01.636
Once people have installed these
things into their apps, you sort of,

16
00:01:01.636 --> 00:01:04.370
I mean you can just stop
publishing packages.

17
00:01:04.370 --> 00:01:09.010
But that loss of continuity of like
a particular piece of functionality

18
00:01:09.010 --> 00:01:11.563
being available in a certain package,

19
00:01:11.563 --> 00:01:16.359
it's much harder to correct the problem
where you fragmented too much and

20
00:01:16.359 --> 00:01:21.463
need to consolidate than like, all right,
you've not fragmented enough and

21
00:01:21.463 --> 00:01:24.943
so you factor something out
into its own package, but

22
00:01:24.943 --> 00:01:30.490
then you can always re export it from the
original package and it still feels okay.

23
00:01:30.490 --> 00:01:35.684
One exception, and
that would be if whatever you're building

24
00:01:35.684 --> 00:01:40.094
is intended to be something
that involves plugins and

25
00:01:40.094 --> 00:01:44.730
in that case maybe your
features are plugins.

26
00:01:44.730 --> 00:01:49.881
That's where I would say, all right,
well invest some of your mental energy

27
00:01:49.881 --> 00:01:54.874
in defining a good plugin interface and
then you will want to have some world

28
00:01:54.874 --> 00:01:59.945
where maybe your internal features,
some of them are modeled as plugins and

29
00:01:59.945 --> 00:02:05.200
then you can also let other people write
libraries that also act as plugins.

30
00:02:05.200 --> 00:02:10.163
That would be the case
where maybe you end up with

31
00:02:10.163 --> 00:02:15.251
a lot of packages earlier
rather than waiting for

32
00:02:15.251 --> 00:02:23.320
a need to introduce more packages to
arise before factoring things out.

33
00:02:23.320 --> 00:02:27.352
&gt;&gt; Male 2: Have you ever had to override
the NX cloud to store the task caches in

34
00:02:27.352 --> 00:02:31.816
your company, whatever company,
cloud provider, cloud storage use,

35
00:02:31.816 --> 00:02:35.640
whether it's like cloud storage or
S3 or anything like that.

36
00:02:37.720 --> 00:02:39.400
&gt;&gt; Mike: Sorry, have I ever done that?

37
00:02:39.400 --> 00:02:42.263
&gt;&gt; Male 2: Yeah.
Have you ever had to override instead of

38
00:02:42.263 --> 00:02:47.290
using NX cloud, their cloud service,
storing the cache in your S3 bucket.

39
00:02:47.290 --> 00:02:50.690
&gt;&gt; Mike: Or something like that,
not while using NX.

40
00:02:52.210 --> 00:02:56.770
So I kind of these days do
two kinds of development.

41
00:02:56.770 --> 00:03:01.299
I do open source stuff,
in which case I am happy to use NX and

42
00:03:01.299 --> 00:03:06.210
I'm fine with everyone being
able to see the build artifacts.

43
00:03:06.210 --> 00:03:10.931
They would be able to see them in
GitHub Action Logs anyway, and

44
00:03:10.931 --> 00:03:16.010
then on the other side,
monorepos that aren't just JavaScript and

45
00:03:16.010 --> 00:03:20.823
that's where we're using Bazel and
we have a similar concept of

46
00:03:20.823 --> 00:03:25.815
being able to take advantage of
distributed build artifacts, but

47
00:03:25.815 --> 00:03:31.020
it's not something we'd use NX for
and that would be like at Stripe.

48
00:03:32.940 --> 00:03:33.700
Does that make sense?

49
00:03:33.700 --> 00:03:36.830
And in that case, absolutely.

50
00:03:36.830 --> 00:03:39.271
We don't want to be tossing our not yet

51
00:03:39.271 --> 00:03:43.710
released build artifacts onto
another person's infrastructure.

52
00:03:43.710 --> 00:03:51.310
I mean like Amazon, sure, but a cloud
provider is who we'd be trusting there.

53
00:03:53.950 --> 00:03:56.001
Not that the NX team is not trustworthy,
but

54
00:03:56.001 --> 00:03:59.150
I think many enterprises would
make a similar decision.

55
00:03:59.150 --> 00:04:03.130
&gt;&gt; Male 2: Yeah, that's why I looked
into it because my company was like.

56
00:04:03.130 --> 00:04:06.955
So I was curious if you've had to
use that any other corporate side.

57
00:04:06.955 --> 00:04:10.640
&gt;&gt; Male 1: Not on the corporate side,
but yeah, sorry,

58
00:04:10.640 --> 00:04:15.470
I can't really provide a better
path forward for you there.

59
00:04:17.310 --> 00:04:20.137
&gt;&gt; Male 3: This isn't necessarily
related to monorepos, but

60
00:04:20.137 --> 00:04:22.910
I was curious if you've
heard of Archetype before.

61
00:04:24.430 --> 00:04:25.270
&gt;&gt; Mike: No, I have not.

62
00:04:25.270 --> 00:04:27.230
No, it's similar to Zod.

63
00:04:27.230 --> 00:04:32.712
&gt;&gt; Male 3: I'm basically trying to get
into some data validation stuff for

64
00:04:32.712 --> 00:04:37.800
TypeScript since we don't really
do any of that right now.

65
00:04:39.080 --> 00:04:43.561
I know Zod is the one you
covered on last one, but

66
00:04:43.561 --> 00:04:47.160
I also looked into Archetype as well.

67
00:04:49.960 --> 00:04:55.436
&gt;&gt; Mike: I mean Zod is used extensively
and I think like I haven't seen Archetype,

68
00:04:55.436 --> 00:05:00.645
but when evaluating libraries like that,
I would look at, you know,

69
00:05:00.645 --> 00:05:06.296
how likely is it that you can hire someone
and they already know how it works,

70
00:05:06.296 --> 00:05:10.091
or how likely is it that
when you run into a problem,

71
00:05:10.091 --> 00:05:14.857
you can go look on Stack Overflow or
let's be real, ask an LLM for

72
00:05:14.857 --> 00:05:20.300
help and like, how many examples
do they have to pull from?

73
00:05:20.300 --> 00:05:25.249
And don't forget this as a TypeScript or
JavaScript developer, there is an enormous

74
00:05:25.249 --> 00:05:29.260
amount of TypeScript and
JavaScript code that LLMs have ingested.

75
00:05:29.260 --> 00:05:33.542
But if you try to get an LLM to
help you with a more esoteric

76
00:05:33.542 --> 00:05:38.103
programming language like Elixir or
something like that,

77
00:05:38.103 --> 00:05:44.380
it's a lot less on target because it just
has a lot fewer examples to pull from.

78
00:05:44.380 --> 00:05:49.681
And similarly with libraries like there
is, if you're using AI coding help,

79
00:05:49.681 --> 00:05:54.760
there is an advantage to going with
an option when you're making choices.

80
00:05:56.360 --> 00:06:00.864
But there's just a ton
of usage out there and

81
00:06:00.864 --> 00:06:05.977
a ton of stuff in GitHub and
GitLab open source that

82
00:06:05.977 --> 00:06:11.091
all helps Build,
I'd say an understanding, but

83
00:06:11.091 --> 00:06:15.964
really a database of
autocomplete results that

84
00:06:15.964 --> 00:06:20.960
will be more likely what
you want to implement.

85
00:06:20.960 --> 00:06:22.400
A more helpful answer,
if that makes sense.

86
00:06:22.400 --> 00:06:26.898
&gt;&gt; Male 3: Archetype seems cool because
it literally uses TypeScript syntax at

87
00:06:26.898 --> 00:06:28.400
runtime.

88
00:06:28.400 --> 00:06:29.120
&gt;&gt; Mike: Interesting.

89
00:06:29.120 --> 00:06:31.200
&gt;&gt; Male 3: Can take TypeScript syntax and

90
00:06:31.200 --> 00:06:35.440
it'll take that to runtime and
then do data validation.

91
00:06:35.440 --> 00:06:39.600
You don't have to learn any new APIs,
which might make it an easier cell.

92
00:06:39.600 --> 00:06:42.020
But also Zod is more proven, I guess.

93
00:06:42.020 --> 00:06:46.488
&gt;&gt; Mike: Well, and in that case maybe what
I just said is less relevant because if

94
00:06:46.488 --> 00:06:50.061
the way you express these
things is in typescript types,

95
00:06:50.061 --> 00:06:54.620
then there is plenty of information
out there on that and it makes sense.

96
00:06:54.620 --> 00:06:58.622
Like there are lots of libraries where
you can extract a JSON schema or

97
00:06:58.622 --> 00:07:02.072
a protobuf or whatever you want
from a TypeScript type, and

98
00:07:02.072 --> 00:07:06.820
it stands to reason you could use that
to compile a validation of some sort.

99
00:07:06.820 --> 00:07:10.900
&gt;&gt; Male 2: I'm gonna piggyback off
of Pepe's question here in the chat.

100
00:07:10.900 --> 00:07:13.740
Do you have any best practices for
building NX generators?

101
00:07:13.740 --> 00:07:17.540
Or do you have any favorite ones that
you or your company have built and use?

102
00:07:18.660 --> 00:07:21.060
&gt;&gt; Mike: Bluntly,
I use the off the shelf stuff.

103
00:07:23.540 --> 00:07:25.380
Sorry.
I do have a best practice.

104
00:07:26.500 --> 00:07:27.660
It's not a best practice.

105
00:07:27.660 --> 00:07:33.562
I can offer my practice for
something like our dev script.

106
00:07:33.562 --> 00:07:36.617
I would just let you know about this more,

107
00:07:36.617 --> 00:07:40.030
don't overlook this as
a possibility thing.

108
00:07:40.030 --> 00:07:45.470
Not that it's the answer to everything,
but a lot of people don't.

109
00:07:46.590 --> 00:07:51.471
Seems obvious when you think about it, but

110
00:07:51.471 --> 00:07:57.300
you can create a package that
NX sees as a package and

111
00:07:57.300 --> 00:08:00.750
it has a Project JSON file.

112
00:08:00.750 --> 00:08:04.052
You could just create a folder with
a project JSON file in it, and

113
00:08:04.052 --> 00:08:05.590
it's kind of a fake package.

114
00:08:05.590 --> 00:08:09.640
Like it has nothing to do with
software that's being imported into

115
00:08:09.640 --> 00:08:11.750
other packages in your monorepo.

116
00:08:11.750 --> 00:08:12.830
But that lets you.

117
00:08:12.830 --> 00:08:17.255
It has the effect of letting you almost
like create commands that are of

118
00:08:17.255 --> 00:08:19.670
the shape that you want to create.

119
00:08:19.670 --> 00:08:24.888
Like if I wanted to create
something that was like

120
00:08:24.888 --> 00:08:29.990
NX dev serve, well,
all I need to do is create.

121
00:08:31.420 --> 00:08:34.338
Really?
That's following the pattern of NX UI

122
00:08:34.338 --> 00:08:34.860
test.

123
00:08:36.140 --> 00:08:37.900
Oops, sorry, I got it backwards.

124
00:08:39.660 --> 00:08:42.860
NXTest UI, yes, terminal,
too small, gotcha.

125
00:08:44.060 --> 00:08:49.077
So really what you're saying
is I want to create a target

126
00:08:49.077 --> 00:08:54.300
that is called dev and
a project that is called serve.

127
00:08:54.300 --> 00:08:59.854
And so this lets you, if you lean
into that, these are just two words.

128
00:08:59.854 --> 00:09:03.686
And so, you can create
a combination of projects and

129
00:09:03.686 --> 00:09:09.210
targets that let you make a very
semantically relevant command.

130
00:09:09.210 --> 00:09:13.885
If you're just like, you're willing to
break this sort of implicit pattern,

131
00:09:13.885 --> 00:09:18.764
but it doesn't have to stay that way of
like, well, the project JSON goes in my

132
00:09:18.764 --> 00:09:24.350
models folder and there are absolutely no
other places I can put this project JSON.

133
00:09:24.350 --> 00:09:29.478
Like, you can make NX aware of projects
that have nothing to do with your

134
00:09:29.478 --> 00:09:35.034
typescript monorepos here it could just
be like another folder in your repo,

135
00:09:35.034 --> 00:09:39.470
like another top level folder
that's not even packages.

136
00:09:39.470 --> 00:09:41.470
Does that make sense?

137
00:09:41.470 --> 00:09:46.313
This could become like noun, verb,
or whatever you want it to be,

138
00:09:46.313 --> 00:09:51.320
because these are really just
task definitions, like targets.

139
00:09:51.320 --> 00:09:56.040
And then this last word is a project.

140
00:09:56.040 --> 00:09:58.280
A project is just a project JSON file.

141
00:09:58.280 --> 00:10:00.920
It does not have to be mapped
one to one with a package JSON.

142
00:10:06.280 --> 00:10:13.000
Usually NX commands are sometimes
not incredibly ergonomic.

143
00:10:13.000 --> 00:10:18.108
And so I will reach for
that when I have something

144
00:10:18.108 --> 00:10:22.962
that's really common
that needs to be run and

145
00:10:22.962 --> 00:10:30.260
I want it to be stupid simple like
NX format manifests or NX lint css.

146
00:10:31.540 --> 00:10:34.460
And you could do that if you
just set it up this way.

147
00:10:34.460 --> 00:10:40.983
And you're not abusing the tool, you're
just cleverly naming the targets and

148
00:10:40.983 --> 00:10:46.241
the projects while benefiting
from the target dependencies and

149
00:10:46.241 --> 00:10:48.010
all of that, right?

150
00:10:48.010 --> 00:10:50.730
Like, of course you could
do PNPM whatever you want.

151
00:10:50.730 --> 00:10:54.210
Like, you could use NPM scripts,
but NX can do that too.

152
00:10:54.210 --> 00:10:56.470
It just requires some more JSON.

153
00:10:56.470 --> 00:10:59.062
&gt;&gt; Male 1: So
this one's tangentially related, but

154
00:10:59.062 --> 00:11:01.610
you seem to be a big advocate for pnpm.

155
00:11:01.610 --> 00:11:05.170
&gt;&gt; Mike: If I were to
go back to my company,

156
00:11:05.170 --> 00:11:09.503
how do I sell PNPM to them to replace npm?

157
00:11:09.503 --> 00:11:15.018
So the most obvious benefit
is really a developer

158
00:11:15.018 --> 00:11:20.939
productivity thing where
every install is faster,

159
00:11:20.939 --> 00:11:27.540
which makes CI faster,
local build startups are faster.

160
00:11:29.700 --> 00:11:36.700
It means less compute
happening on your dev machine.

161
00:11:36.700 --> 00:11:41.742
And so that means, I mean,
I'm sure Stripe is not the only company

162
00:11:41.742 --> 00:11:47.055
where this happens, where developers
get issued at the time they feel

163
00:11:47.055 --> 00:11:52.279
like these really powerful laptops and
then you get to a point a couple

164
00:11:52.279 --> 00:11:58.460
years later where you're like,
I only have 16 gigs of RAM on this thing.

165
00:11:58.460 --> 00:12:01.067
God, I've got two dozen
Chrome tabs open and

166
00:12:01.067 --> 00:12:04.620
I've got an NPM install going
in the background and it.

167
00:12:04.620 --> 00:12:05.900
It sucks.

168
00:12:05.900 --> 00:12:10.119
So, yeah, I would say mostly the developer

169
00:12:10.119 --> 00:12:15.020
productivity angle is
the main thing there.

170
00:12:15.020 --> 00:12:22.180
Alternatively, if the company is
paying for storage of build artifacts,

171
00:12:22.180 --> 00:12:26.620
just size on disk with PNPM is so
much smaller.

172
00:12:26.620 --> 00:12:31.362
I mean, sorry, for
a sizable project it's so

173
00:12:31.362 --> 00:12:37.201
much smaller because of just
the way the linking works and

174
00:12:37.201 --> 00:12:43.250
the flat structure of that
cached set of dependencies.

175
00:12:43.250 --> 00:12:44.250
Gotcha, interesting.

176
00:12:44.250 --> 00:12:44.930
&gt;&gt; Male 1: Thank you.

177
00:12:44.930 --> 00:12:50.210
&gt;&gt; Male 2: How much a lift do you
think it is switching at scale?

178
00:12:51.490 --> 00:12:52.930
&gt;&gt; Mike: What dimension of scale?

179
00:12:52.930 --> 00:12:57.866
&gt;&gt; Male 2: I don't know,
100 packages or something like that.

180
00:12:57.866 --> 00:12:58.463
&gt;&gt; Mike: 100,

181
00:12:58.463 --> 00:13:03.970
I mean that would be a dimension of
scale where I would say doesn't matter.

182
00:13:03.970 --> 00:13:05.170
That should be fine.

183
00:13:05.170 --> 00:13:06.850
You'd start out with pnpm.

184
00:13:06.850 --> 00:13:10.370
You can point it at your package
lock JSON or your yarn lock file.

185
00:13:10.370 --> 00:13:14.810
It'll generate the right PNPM lock file.

186
00:13:14.810 --> 00:13:18.290
That doesn't drift any
of your dependencies.

187
00:13:18.290 --> 00:13:19.410
That's fine.

188
00:13:19.410 --> 00:13:21.650
Here's the other dimensions of scale.

189
00:13:21.650 --> 00:13:24.370
What are developers used to like?

190
00:13:24.370 --> 00:13:27.378
How you kind of have to
train them up a little bit.

191
00:13:27.378 --> 00:13:34.210
You're gonna get people who
are a little curmudgeonly about like,

192
00:13:34.210 --> 00:13:39.922
there was this one feature of
this thing that I really liked,

193
00:13:39.922 --> 00:13:46.082
where there is a little bit of a trap
is if you're using some custom

194
00:13:46.082 --> 00:13:52.100
tooling that relies on a different
layout of node modules.

195
00:13:52.100 --> 00:13:53.860
That's the thing I would look at first.

196
00:13:53.860 --> 00:13:58.464
If you have wacky scripts that kind of
depend on certain things being in the node

197
00:13:58.464 --> 00:14:02.720
modules at the workspace level and
certain things at the package level,

198
00:14:02.720 --> 00:14:05.460
those are the things
that are likely to break.

199
00:14:05.460 --> 00:14:11.540
But the good news is that's
sort of a fail fast task there.

200
00:14:11.540 --> 00:14:15.300
You try it out and
it'll be obvious if it breaks.

201
00:14:15.300 --> 00:14:18.948
You just need to exercise
all those tools and

202
00:14:18.948 --> 00:14:23.490
see if something produces
a wacky result of some sort.

203
00:14:24.690 --> 00:14:29.570
But really the scale that I would
say is what to worry about.

204
00:14:29.570 --> 00:14:33.750
It's not the 100 dependencies,
it's the 100 engineers and

205
00:14:33.750 --> 00:14:36.610
kinda helping them understand.

206
00:14:36.610 --> 00:14:38.530
All right,
here's how to think about these things.

207
00:14:38.530 --> 00:14:41.250
Workspace colon is what you do.

208
00:14:41.250 --> 00:14:44.500
It's more about any tool
requires this kind of thing.

209
00:14:45.850 --> 00:14:47.210
Sort of the cultural rollout.

210
00:14:50.170 --> 00:14:55.293
I mean, these things,
their implementation is not simple,

211
00:14:55.293 --> 00:15:00.216
but they all read a package JSON,
they all have a lock file,

212
00:15:00.216 --> 00:15:05.242
they have differing articulations
of how workspace works,

213
00:15:05.242 --> 00:15:12.660
but that's a relatively small surface for
them to be entangled with your code base.

214
00:15:12.660 --> 00:15:16.660
And so, it depends.

215
00:15:16.660 --> 00:15:20.795
But granted you could have a bunch of
custom stuff that's doing a bunch of NPM

216
00:15:20.795 --> 00:15:24.300
link everywhere and
that's not going to be friendly with pnpm.

217
00:15:24.300 --> 00:15:29.297
So maybe the scale dimension that makes
this really hurt is how much custom

218
00:15:29.297 --> 00:15:34.134
software has been built on top of
the conventional use of these commands

219
00:15:34.134 --> 00:15:38.330
that more tightly integrates
you with one package manager.

220
00:15:38.330 --> 00:15:42.310
So I hope you enjoyed learning
about TypeScript monorepos and

221
00:15:42.310 --> 00:15:46.134
some of the great tools you can
use to make your builds fast,

222
00:15:46.134 --> 00:15:50.188
to make developing on a big project
feel small in a good way, and

223
00:15:50.188 --> 00:15:54.854
how even in a world where you have many
packages inside the same git repo,

224
00:15:54.854 --> 00:15:58.221
you have great ways to trim
down your dependencies,

225
00:15:58.221 --> 00:16:03.654
to enforce consistency standards across
your code base, and generally to make sure

226
00:16:03.654 --> 00:16:08.830
that you get to reap a lot of the benefits
that the concept of a mon repo promises.

