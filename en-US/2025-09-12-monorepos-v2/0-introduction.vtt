WEBVTT

1
00:00:00.400 --> 00:00:03.440
&gt;&gt; Mike North: Welcome to
TypeScript Monorepos V2.

2
00:00:03.440 --> 00:00:07.800
I'm Mike North, I'm a principal staff
engineer and product architect at Stripe

3
00:00:07.800 --> 00:00:12.000
and I've been a front end master's
instructor for over ten years now.

4
00:00:12.000 --> 00:00:14.960
And today I wanna talk
to you about monorepos.

5
00:00:14.960 --> 00:00:18.560
So first off, what is a monorepo?

6
00:00:18.560 --> 00:00:22.548
It is the concept of having a single
git repository that contains multiple

7
00:00:22.548 --> 00:00:23.600
packages.

8
00:00:23.600 --> 00:00:28.554
Sometimes companies will have
like a language level monorepo,

9
00:00:28.554 --> 00:00:30.580
so Stripe is one of these.

10
00:00:30.580 --> 00:00:34.589
We have a monorepo for all of our
Java code, all of our Ruby code is

11
00:00:34.589 --> 00:00:39.140
in a different repo, and then we have
a big JavaScript monorepo as well.

12
00:00:41.140 --> 00:00:44.692
There are also open source projects
like if you've used Babel before,

13
00:00:44.692 --> 00:00:48.596
there are many others where it's kind of
one project, but if you look into it,

14
00:00:48.596 --> 00:00:51.199
you can see there are multiple
distinct packages and

15
00:00:51.199 --> 00:00:55.020
you will find each of these packages
on NPM and they'll each have a version.

16
00:00:55.020 --> 00:00:57.605
Sometimes you're using just
a couple of these things,

17
00:00:57.605 --> 00:01:00.420
not the entire contents of
the repo in order to do something.

18
00:01:02.500 --> 00:01:04.740
What are the benefits of
organizing your code this way?

19
00:01:05.940 --> 00:01:10.404
Why would you aim for a monorepo instead
of the poly repo approach where you

20
00:01:10.404 --> 00:01:13.940
would treat every library you
have as a separate git repo?

21
00:01:13.940 --> 00:01:17.460
Well, first off, there's the issue
of dependency management.

22
00:01:17.460 --> 00:01:22.899
If you've ever worked on something, say
in the open source JavaScript ecosystem,

23
00:01:22.899 --> 00:01:27.033
you'll make a change in the library,
you'll open up your PR and

24
00:01:27.033 --> 00:01:28.349
it'll get merged.

25
00:01:28.349 --> 00:01:32.831
And then you have a whole bunch of
work where you have to go to other

26
00:01:32.831 --> 00:01:37.732
packages that depend on this and
then run NPM install or PNPM install or

27
00:01:37.732 --> 00:01:43.150
whatever it is and float that lock file
pinned version forward a little bit.

28
00:01:43.150 --> 00:01:47.596
And you kind of have to pull it through
all of the things that depend on it and

29
00:01:47.596 --> 00:01:51.360
this has to happen in multiple layers,
right?

30
00:01:51.360 --> 00:01:54.865
You could be several layers
deep in a dependency graph and

31
00:01:54.865 --> 00:01:59.756
a small change could result in you having
to do a lot of work beyond making the code

32
00:01:59.756 --> 00:02:03.440
change just to propagate
through a polyrepo ecosystem.

33
00:02:03.440 --> 00:02:08.660
Well, the idea of monorepos
is you're often locally

34
00:02:08.660 --> 00:02:13.880
referencing other parts of
this software project and

35
00:02:13.880 --> 00:02:18.520
you're kind of evolving
all packages at once.

36
00:02:18.520 --> 00:02:21.942
You could open up a single pull
request that touches three or

37
00:02:21.942 --> 00:02:26.255
four different packages within one
git repository, get that merged, and

38
00:02:26.255 --> 00:02:29.480
there's really no follow on
step that you have to take.

39
00:02:29.480 --> 00:02:32.670
So that's part of what makes
it attractive, especially for

40
00:02:32.670 --> 00:02:35.732
a large company with a lot of
different things going on a lot

41
00:02:35.732 --> 00:02:38.520
of different packages
that they have set up.

42
00:02:38.520 --> 00:02:43.490
It's kind of attractive to say we
don't have to deal with this problem

43
00:02:43.490 --> 00:02:46.187
of somebody made an improvement, but

44
00:02:46.187 --> 00:02:50.736
it's a whole new set of work to
sort of propagate that improved,

45
00:02:50.736 --> 00:02:55.060
whatever it is,
that chunk of value through our ecosystem.

46
00:02:55.060 --> 00:02:58.247
And you end up with people that are sort
of two, three years behind on some

47
00:02:58.247 --> 00:03:01.500
dependency just because they haven't
gotten around to doing that work.

48
00:03:01.500 --> 00:03:06.417
A additional benefit of this, and it's
possible to get this benefit in a polyrepo

49
00:03:06.417 --> 00:03:11.261
ecosystem, is it's that in a monorepo,
it's generally easier to be able to say

50
00:03:11.261 --> 00:03:16.348
I've made a change in a library that's say
three levels deep in a dependency graph.

51
00:03:16.348 --> 00:03:21.135
Say it's some UI that depends on some
library that depends on some other library

52
00:03:21.135 --> 00:03:26.200
that depends on some other library,
and you're right there at the bottom.

53
00:03:26.200 --> 00:03:30.296
Well, it's a lot easier when everything's
in one git repo to sort of run

54
00:03:30.296 --> 00:03:33.987
the entire test suite, not just for
the library you changed, but

55
00:03:33.987 --> 00:03:35.820
everything that depends on it.

56
00:03:35.820 --> 00:03:40.979
And ensure that you're not just validating
against some small set of unit tests,

57
00:03:40.979 --> 00:03:46.760
you're validating the whole project when
composed together, did this actually work?

58
00:03:46.760 --> 00:03:47.927
Am I going to be able to roll this.

