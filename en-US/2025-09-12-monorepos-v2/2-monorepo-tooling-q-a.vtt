WEBVTT

1
00:00:00.160 --> 00:00:01.840
&gt;&gt; Mike North: We have a question online.

2
00:00:01.840 --> 00:00:03.276
&gt;&gt; Speaker 2: Are mono repos and

3
00:00:03.276 --> 00:00:07.503
micro front end architecture
interrelated at all?

4
00:00:07.503 --> 00:00:12.397
&gt;&gt; Mike North: They are, often you'll
have micro front-ends arranged into

5
00:00:12.397 --> 00:00:15.360
packages within a monorepo, right?

6
00:00:15.360 --> 00:00:20.082
So micro front-ends is the concept
of instead of having a UI monolith,

7
00:00:20.082 --> 00:00:23.560
you're sort of composing
together subparts of it.

8
00:00:23.560 --> 00:00:28.312
And that's like a great example of where
you might want to model each of those as

9
00:00:28.312 --> 00:00:29.610
a distinct package.

10
00:00:29.610 --> 00:00:32.223
So there's strong encapsulation or

11
00:00:32.223 --> 00:00:37.362
encapsulation that you have a high
degree of control over as it relates to

12
00:00:37.362 --> 00:00:42.924
the contract between two micro front ends
or their contract with some core part

13
00:00:42.924 --> 00:00:48.170
of the UI that sort of cuts horizontally
across all the micro front ends.

14
00:00:48.170 --> 00:00:51.610
&gt;&gt; Speaker 2: Are monorepos a good
setup for creating a library?

15
00:00:51.610 --> 00:00:55.218
For instance, if I have one
package with multiple projects and

16
00:00:55.218 --> 00:00:57.130
I want to serve that as a library.

17
00:00:59.130 --> 00:01:03.396
&gt;&gt; Mike North: If you have one package
with multiple projects, I would flip that

18
00:01:03.396 --> 00:01:08.530
around and say it's probably if you
have one project with multiple packages.

19
00:01:08.530 --> 00:01:13.967
So say you had a project where it was
consumable as a library, but also you

20
00:01:13.967 --> 00:01:19.870
have a CLI for people that just want to
use it, use some part of it in a terminal.

21
00:01:19.870 --> 00:01:21.790
Say it's for image resizing or something.

22
00:01:21.790 --> 00:01:25.030
Well, you could say, look, there's
this core thing that's the library.

23
00:01:25.030 --> 00:01:28.722
And then on top of that I'm
going to build the cli, but

24
00:01:28.722 --> 00:01:32.910
I want to develop and
evolve these things together.

25
00:01:32.910 --> 00:01:37.536
Like when I add a new feature or I make
some change to the way I represent data,

26
00:01:37.536 --> 00:01:41.657
I want this to all be something where
I can have a single git commit and

27
00:01:41.657 --> 00:01:44.360
kind of keep these synchronized over time.

28
00:01:44.360 --> 00:01:47.560
And in that case, I'd break them up
into two packages within one project.

29
00:01:49.240 --> 00:01:52.120
&gt;&gt; Speaker 2: Your opinions
on turborebo versus nx?

30
00:01:53.560 --> 00:01:56.680
&gt;&gt; Mike North: My opinion
is they both meet.

31
00:01:56.680 --> 00:02:01.240
Like, I like them both, and
they work a similar way.

32
00:02:01.240 --> 00:02:03.000
This concept of having.

33
00:02:05.160 --> 00:02:07.194
Well, like, there are two concepts there,

34
00:02:07.194 --> 00:02:10.040
which we'll get to more deeply
when we start talking about nx.

35
00:02:11.239 --> 00:02:14.359
One is the idea of cached build steps.

36
00:02:14.359 --> 00:02:19.200
You can think of this as almost
like a pure function where

37
00:02:19.200 --> 00:02:22.039
you can state my linting task.

38
00:02:22.039 --> 00:02:27.135
It's the result of running that task
both in terms of did it pass or

39
00:02:27.135 --> 00:02:29.159
did it not pass?

40
00:02:29.159 --> 00:02:31.559
And what was the output to the cli?

41
00:02:31.559 --> 00:02:34.999
What was the output in the terminal or
what was the file it generated?

42
00:02:34.999 --> 00:02:37.702
If you have your linter
piping out to a file,

43
00:02:37.702 --> 00:02:42.159
if that's the output and the input's
the source code and you can state,

44
00:02:42.159 --> 00:02:46.880
yeah, this is like for a given input
the output will always be the same.

45
00:02:46.880 --> 00:02:50.679
Well, then you can cache
that instead of actually

46
00:02:50.679 --> 00:02:54.080
running your linter every single time.

47
00:02:54.080 --> 00:02:58.427
You could say, you know, we haven't really
touched anything since we ran this,

48
00:02:58.427 --> 00:03:01.200
including the version of
eslint that's being run.

49
00:03:02.720 --> 00:03:05.040
So I'm just gonna spit
the same output out.

50
00:03:05.040 --> 00:03:08.629
I'm gonna skip the step where we
run exactly the same thing and

51
00:03:08.629 --> 00:03:10.940
I'm just gonna give you the output.

52
00:03:10.940 --> 00:03:15.420
So that's this concept of like
a cached task, if you will.

53
00:03:15.420 --> 00:03:20.667
And then what turbo repo or
TurboBuild and NX both do is they will

54
00:03:20.667 --> 00:03:26.220
then have a cloud service where
you can push these cached results.

55
00:03:26.220 --> 00:03:31.321
And what that means is even across your
development team, you get the idea of sort

56
00:03:31.321 --> 00:03:36.349
of getting a fingerprint on the inputs and
preserving the same output and you can

57
00:03:36.349 --> 00:03:42.120
sort of benefit from, from that across
your team or in CI across multiple jobs.

58
00:03:42.120 --> 00:03:46.776
So it's sort of like that second step
is more about more than just you

59
00:03:46.776 --> 00:03:51.360
sharing the same cache and
getting the benefits of the same cache.

60
00:03:51.360 --> 00:03:53.560
And we're gonna do that.

61
00:03:53.560 --> 00:03:57.115
We're going to,
as we dive into NX and LERNA as well,

62
00:03:57.115 --> 00:04:00.120
we're going to see the benefits of that.

63
00:04:00.120 --> 00:04:04.572
It's an incredible speed up for
those tasks where

64
00:04:04.572 --> 00:04:09.240
the same inputs will always
yield the same outputs.

65
00:04:09.240 --> 00:04:12.400
And it's up to you to state that
that's the case for a given task.

66
00:04:12.400 --> 00:04:16.800
&gt;&gt; Speaker 3: Given all of these benefits
of monorepos, we're kind of going through.

67
00:04:16.800 --> 00:04:19.882
It almost sounds like you should
always choose a monorepo, but

68
00:04:19.882 --> 00:04:22.000
obviously that's not the case.

69
00:04:22.000 --> 00:04:23.738
What do you kind of look for

70
00:04:23.738 --> 00:04:29.120
when you're trying to decide if a project
should be a monorepo versus poly repo?

71
00:04:29.120 --> 00:04:32.800
Like, what are the indicators
you're kind of looking for there?

72
00:04:32.800 --> 00:04:33.600
&gt;&gt; Mike North: Great question.

73
00:04:34.680 --> 00:04:38.676
For me, the most significant
bit is really about what is

74
00:04:38.676 --> 00:04:44.680
the interrelatedness of the packages
that would be within this project?

75
00:04:44.680 --> 00:04:49.640
The project,
let me answer this in two ways.

76
00:04:49.640 --> 00:04:54.482
If you're thinking about a project
on GitHub, let's take Babel for

77
00:04:54.482 --> 00:04:59.158
example, for taking very modern
JavaScript and transpiling it so

78
00:04:59.158 --> 00:05:03.748
that older runtimes can execute it well,
you can have a nice set of

79
00:05:03.748 --> 00:05:08.088
Babel plugins in there,
you can have the Babel core package,

80
00:05:08.088 --> 00:05:12.780
you can have the Babel cli and
there's a lot of entanglement.

81
00:05:12.780 --> 00:05:15.426
There would be a lot of extra
work if those were each modeled

82
00:05:15.426 --> 00:05:16.780
as a totally separate thing.

83
00:05:18.380 --> 00:05:23.096
Now, at a company level,
where the commonality factor comes in,

84
00:05:23.096 --> 00:05:26.220
the reason for grouping things together.

85
00:05:26.220 --> 00:05:31.243
It's usually about having some
fairly sophisticated tooling and

86
00:05:31.243 --> 00:05:35.280
conventions that are applied
that would be otherwise

87
00:05:35.280 --> 00:05:39.240
very difficult in a poly
repo ecosystem to enforce.

88
00:05:39.240 --> 00:05:40.760
So that's probably number one.

89
00:05:40.760 --> 00:05:45.533
And then number two, if there's
a lot of pain that some community,

90
00:05:45.533 --> 00:05:49.720
be it a company or
people working on an open source project,

91
00:05:49.720 --> 00:05:54.247
if there's pain associated with
keeping everybody upgraded,

92
00:05:54.247 --> 00:05:57.030
were you to go the poly repo path.

93
00:05:57.030 --> 00:05:59.430
Often a monorepo is something to aim for.

94
00:05:59.430 --> 00:06:03.232
But here are examples of things where
I would not necessarily reach for

95
00:06:03.232 --> 00:06:03.950
a monorepo.

96
00:06:03.950 --> 00:06:08.949
Like if you're building a little node
library that's sort of self contained and

97
00:06:08.949 --> 00:06:12.695
it has, you know,
it has like a clear reason for existence,

98
00:06:12.695 --> 00:06:17.270
there's really no convenient place
to sort of start dividing things up.

99
00:06:17.270 --> 00:06:20.206
Or if you were dividing things up,
it would just be for

100
00:06:20.206 --> 00:06:24.370
your own like internal purposes to
get like encapsulation boundaries.

101
00:06:24.370 --> 00:06:26.610
Well, there are other ways to do that.

102
00:06:26.610 --> 00:06:30.810
I think at that point you're going to
see that it takes a little bit to get

103
00:06:30.810 --> 00:06:32.210
these set up.

104
00:06:32.210 --> 00:06:33.262
Now once you are set up,

105
00:06:33.262 --> 00:06:36.850
it's fairly easy to manage them with
some of the tools I'm going to show you.

106
00:06:36.850 --> 00:06:40.850
But at that point it wouldn't
necessarily be worth it to me.

107
00:06:40.850 --> 00:06:46.489
If you have a CLI tool you're building
that's for image manipulation or

108
00:06:46.489 --> 00:06:51.759
something like that, maybe,
maybe it makes sense to just consider

109
00:06:51.759 --> 00:06:56.860
that to be like a monolith tool and
not divided into sub packages.

