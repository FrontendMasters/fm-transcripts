WEBVTT

1
00:00:00.400 --> 00:00:05.411
&gt;&gt; Mike: I'm going to go into models and

2
00:00:05.411 --> 00:00:09.650
I just want to add a trivial

3
00:00:09.650 --> 00:00:14.480
change somewhere like here.

4
00:00:16.160 --> 00:00:17.120
What is this?

5
00:00:17.120 --> 00:00:18.320
Nope, that's in enum.

6
00:00:18.320 --> 00:00:20.880
That's actually going to mess things up.

7
00:00:20.880 --> 00:00:24.640
We've got human toxicity,
pet toxicity, livestock toxicity.

8
00:00:24.640 --> 00:00:27.066
Great.
We're gonna have,

9
00:00:32.510 --> 00:00:35.580
Alien toxicity with affected parts.

10
00:00:36.700 --> 00:00:39.980
We're worried about how our
vegetables will affect aliens.

11
00:00:39.980 --> 00:00:47.325
All right, so I've saved this and
you can see this yellow x,

12
00:00:47.325 --> 00:00:53.830
I've got a code alteration
that's been made.

13
00:00:53.830 --> 00:00:59.214
So what I can do is say pnpm lerna run

14
00:00:59.214 --> 00:01:05.350
test --since=course-progress.

15
00:01:09.109 --> 00:01:13.750
What it's done is it can
identify that I have made.

16
00:01:13.750 --> 00:01:17.990
Gosh, there we go.

17
00:01:17.990 --> 00:01:19.510
That's more satisfying to look at.

18
00:01:20.850 --> 00:01:26.858
Well, I've touched something in the models
folder and I've made a change and

19
00:01:26.858 --> 00:01:32.610
it looks at the delta between my current
working state and any git ref here.

20
00:01:32.610 --> 00:01:33.890
So this could be a sha.

21
00:01:36.930 --> 00:01:40.747
I could have pointed to
origin/course-progress,

22
00:01:40.747 --> 00:01:42.450
whatever you wanna do.

23
00:01:43.970 --> 00:01:49.768
This allows you to run tasks on a subset
of not only what you just touched, but

24
00:01:49.768 --> 00:01:55.460
what is downstream in the dependency
graph from what you just touched.

25
00:01:55.460 --> 00:02:00.095
So it's a lot more sophisticated than
if you've ever used something like lint

26
00:02:00.095 --> 00:02:04.180
staged before, where that's simply
just like looking at git diff.

27
00:02:04.180 --> 00:02:05.940
Which files did you touch?

28
00:02:05.940 --> 00:02:10.340
Let me run things based
on those files here.

29
00:02:10.340 --> 00:02:14.715
We're getting something very
important back that we had at

30
00:02:14.715 --> 00:02:19.950
the beginning of the class when this
was a monolith in a single repo.

31
00:02:19.950 --> 00:02:25.502
And that was we could make a low level
change to our models and then the entire

32
00:02:25.502 --> 00:02:31.230
test suite ran on the server, on the ui,
the tests that run on the models.

33
00:02:31.230 --> 00:02:34.378
And it's very easy when you start
separating things out into a monorepo if

34
00:02:34.378 --> 00:02:36.590
you don't have the right tooling in place.

35
00:02:36.590 --> 00:02:41.605
You can fall into this trap where
it's almost like the unit test trap,

36
00:02:41.605 --> 00:02:45.855
where, gosh, it seemed fine,
we made this code change and

37
00:02:45.855 --> 00:02:51.125
the tests in that package passed, or
the linting on that package passed,

38
00:02:51.125 --> 00:02:55.010
or this small part of
the project type checked.

39
00:02:55.010 --> 00:02:59.095
This lets you get back to that point
where you're saying, all right,

40
00:02:59.095 --> 00:03:03.945
I have the benefits of a monorepo, meaning
I'm not boiling the ocean and saying run

41
00:03:03.945 --> 00:03:08.630
all the tests over again for everything
that exists in this git, git, repo.

42
00:03:08.630 --> 00:03:11.750
But we are getting the benefit
of saying I touched something.

43
00:03:12.870 --> 00:03:16.550
Use your knowledge of,where
was the thing I touched?

44
00:03:16.550 --> 00:03:19.670
What are the downstream
dependencies that it could affect?

45
00:03:19.670 --> 00:03:24.470
And now we can end up running
a subset of the test there.

46
00:03:25.510 --> 00:03:32.150
So let's see if we can show
an example of this actually working.

47
00:03:32.150 --> 00:03:34.310
What I should do now
is revert this change.

48
00:03:38.810 --> 00:03:43.690
Let me touch something just in server,
and the hope is this just runs.

49
00:03:46.010 --> 00:03:47.690
So there we go, trivial change.

50
00:03:54.250 --> 00:03:55.170
Just the server.

51
00:03:55.170 --> 00:03:57.370
Wait, am I in the server folder?

52
00:03:57.370 --> 00:03:59.290
Could have fooled me.

53
00:03:59.290 --> 00:04:00.340
There you go.

54
00:04:00.340 --> 00:04:01.380
That's all that's running.

55
00:04:04.100 --> 00:04:08.300
The only thing that changed since my
head commit was files and server.

56
00:04:08.300 --> 00:04:10.260
So we don't need the models to run again.

57
00:04:10.260 --> 00:04:11.780
We don't need that test suite to pass.

58
00:04:11.780 --> 00:04:13.300
That's upstream.

59
00:04:13.300 --> 00:04:18.660
Presumably those tests pass in master.

60
00:04:18.660 --> 00:04:21.780
I check things out and I haven't
touched it, it's validated already.

61
00:04:21.780 --> 00:04:25.243
So this is a really cool way,
a cool benefit,

62
00:04:25.243 --> 00:04:30.256
a way to reap this benefit of being
able to operate on test on type,

63
00:04:30.256 --> 00:04:34.570
check on lint on small
portions of your project.

64
00:04:34.570 --> 00:04:39.530
And this is where we're starting to
see some of the lightweight promise of

65
00:04:39.530 --> 00:04:42.410
working in a monorepo come to life.

66
00:04:42.410 --> 00:04:45.987
But you need a build tool
that's aware not just of

67
00:04:45.987 --> 00:04:50.176
file structures like file
locations in a directory, but

68
00:04:50.176 --> 00:04:55.840
the dependency graph of how all of
these things are related to each other.

69
00:04:55.840 --> 00:04:58.960
&gt;&gt; Male: When we're doing learn run test,

70
00:04:58.960 --> 00:05:04.240
is that our old like test script
we had that it's running?

71
00:05:04.240 --> 00:05:07.840
&gt;&gt; Mike: Yep, this is the test script.

72
00:05:07.840 --> 00:05:11.654
&gt;&gt; Male: And so how is it able
to break up down to individual

73
00:05:11.654 --> 00:05:14.640
tests if it's just running a script?

74
00:05:14.640 --> 00:05:19.321
&gt;&gt; Mike: Sorry, to be clear,
and I'm gonna prove this,

75
00:05:19.321 --> 00:05:25.570
it is not in our root package
JSON like I'm renaming that.

76
00:05:25.570 --> 00:05:27.010
This should still run.

77
00:05:27.010 --> 00:05:31.801
This is going into each individual
package and running PNPM test,

78
00:05:31.801 --> 00:05:36.508
but it's making a determination
of which packages it does that in

79
00:05:36.508 --> 00:05:41.570
based on what was changed and
its knowledge of the dependency graph.

80
00:05:41.570 --> 00:05:46.520
So this is very much the for
each of testing.

81
00:05:46.520 --> 00:05:48.830
And so what I would do here is I'd say,
great,

82
00:05:48.830 --> 00:05:50.760
we've got like the test thing in CI.

83
00:05:50.760 --> 00:05:52.040
Yeah, we're going to run that.

84
00:05:52.040 --> 00:05:54.760
But we can also have like test changed.

85
00:05:56.360 --> 00:05:59.050
And this is where we would say, look,

86
00:05:59.050 --> 00:06:03.520
PNPM is not quite specific or
sophisticated enough to do this.

87
00:06:03.520 --> 00:06:05.840
And so I'm going to grab this and
I'm going to put it up.

88
00:06:05.840 --> 00:06:06.340
Here.

89
00:06:09.400 --> 00:06:13.787
And we can just have this be like this is
what you would periodically be running

90
00:06:13.787 --> 00:06:15.090
over and over again.

91
00:06:15.090 --> 00:06:16.370
I made some changes.

92
00:06:17.570 --> 00:06:22.549
Lint it for me, lint only the stuff that's
changed, build only the packages that

93
00:06:22.549 --> 00:06:26.530
need to be rebuilt as a result of
the code I have not committed yet.

94
00:06:28.690 --> 00:06:31.250
It's super powerful to be
able to point to any Git ref.

95
00:06:31.250 --> 00:06:35.899
Like, you want to look at is this
an incremental change that is

96
00:06:35.899 --> 00:06:39.290
being added on top of
an existing priority.

97
00:06:39.290 --> 00:06:41.770
And you know that build already passed.

98
00:06:41.770 --> 00:06:45.530
And so you can just look at the last
three commits that you've made.

99
00:06:45.530 --> 00:06:50.890
So let's just do it since Origin,
PR branch or whatever that is.

100
00:06:51.930 --> 00:06:56.164
&gt;&gt; Male: So really the benefit with this
is going to kind of compound as you have

101
00:06:56.164 --> 00:06:59.090
more and more packages,
I guess in a monorepo.

102
00:06:59.090 --> 00:07:03.923
Right, if you just had one package,
this wouldn't really do anything.

103
00:07:03.923 --> 00:07:04.450
Is that correct?

104
00:07:04.450 --> 00:07:10.483
&gt;&gt; Mike: Yeah, it's almost like the more
this benefits you, the more you're able

105
00:07:10.483 --> 00:07:15.940
to break a sizable project up that
already took a long time to build,

106
00:07:15.940 --> 00:07:21.430
to lend to test,
the more you're able to break that up.

107
00:07:21.430 --> 00:07:26.831
This approach is what lets you pay the
cost, the computational cost of performing

108
00:07:26.831 --> 00:07:31.604
these build, lint and test tasks on
the increment of what you touched and

109
00:07:31.604 --> 00:07:36.720
what could be affected by what you
touched as opposed to the whole thing.

110
00:07:36.720 --> 00:07:39.280
So it pays more dividends.

111
00:07:39.280 --> 00:07:44.107
Like if you wanna think of it as
the relative difference between those,

112
00:07:44.107 --> 00:07:47.648
this is more valuable as
your project gets larger and

113
00:07:47.648 --> 00:07:51.840
as productivity starts to look worse and
worse.

114
00:07:51.840 --> 00:07:55.994
When you look at like what would the cost
be of running the entire build from

115
00:07:55.994 --> 00:07:57.920
scratch over and over again?

116
00:07:57.920 --> 00:08:00.960
Like bluntly, I mean,
this took 762 milliseconds.

117
00:08:00.960 --> 00:08:03.360
Let's see, what does the whole thing take?

118
00:08:05.120 --> 00:08:06.960
I mean it's not zero.

119
00:08:06.960 --> 00:08:09.440
Like this was 372.

120
00:08:09.440 --> 00:08:13.120
This was 1.14 11.

121
00:08:13.120 --> 00:08:16.073
Like it's not the end of the world.

122
00:08:16.073 --> 00:08:17.240
But let's try build.

123
00:08:22.757 --> 00:08:25.600
&gt;&gt; Mike: Lerna run build --since.

124
00:08:30.636 --> 00:08:34.490
Pnpm lerna run build.

125
00:08:34.490 --> 00:08:36.490
Great.
So that was 726.

126
00:08:36.490 --> 00:08:40.890
But what if we just said PNPM build.

127
00:08:42.890 --> 00:08:45.290
All right, but remember,
these are in sequence.

128
00:08:45.290 --> 00:08:48.770
So we've got half a second here and
then another 0.7.

129
00:08:48.770 --> 00:08:49.930
So we're over a second.

130
00:08:49.930 --> 00:08:51.690
Like this is.

131
00:08:51.690 --> 00:08:53.980
Call it close to double.

132
00:08:53.980 --> 00:08:54.740
&gt;&gt; Male: It's almost double.

133
00:08:54.740 --> 00:08:56.260
&gt;&gt; Mike: Yeah, close to double.

134
00:08:56.260 --> 00:08:58.420
And this for a teeny tiny little project.

135
00:08:58.420 --> 00:09:03.181
And mainly it's coming from the fact that
I avoided building like spinning up vite

136
00:09:03.181 --> 00:09:07.300
to build this at all, which by
the way is an incredibly fast tool.

137
00:09:07.300 --> 00:09:11.876
Like you're lucky if you're using PNPM and
vite and this latest version of Learna,

138
00:09:11.876 --> 00:09:15.451
we're leaning towards like
the fastest possible things available

139
00:09:15.451 --> 00:09:17.460
that you could be using to build.

140
00:09:17.460 --> 00:09:20.350
And so, where lerna really is useful.

141
00:09:20.350 --> 00:09:26.532
Like say you're using regular NPM and
you've got a lot more files on disk

142
00:09:26.532 --> 00:09:32.030
as a result and you're not using Turbo or
you're not using.

143
00:09:32.030 --> 00:09:34.430
Well, in this case,
you'd be using nx, right?

144
00:09:34.430 --> 00:09:39.070
So it can add up, and it gets
better with where we're going next.

