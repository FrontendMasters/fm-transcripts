WEBVTT

1
00:00:00.020 --> 00:00:01.032
&gt;&gt; Will Sentance: Everybody's thumbs out.

2
00:00:01.032 --> 00:00:01.878
I have a clarification.

3
00:00:01.878 --> 00:00:05.590
I'm surprisingly clear, you lost me.

4
00:00:05.590 --> 00:00:10.130
All right, Victor has a clarification,
Brian has one, Paul has one,

5
00:00:10.130 --> 00:00:12.000
Michelle has one, Mike.

6
00:00:12.000 --> 00:00:15.030
Mike why don't you kick us off, James
has one, Mike why don't you kick us off?

7
00:00:15.030 --> 00:00:16.816
&gt;&gt; Mike: I was just wondering
where the callback queue,

8
00:00:16.816 --> 00:00:18.924
is that you're gonna store
it in a web browser feature?

9
00:00:18.924 --> 00:00:20.081
&gt;&gt; Will Sentance: That's
a JavaScript feature.

10
00:00:20.081 --> 00:00:22.040
No, that's a JavaScript engine feature.

11
00:00:22.040 --> 00:00:23.160
Very, very good question.

12
00:00:23.160 --> 00:00:25.170
That's a JavaScript engine feature.

13
00:00:25.170 --> 00:00:26.030
Brian?

14
00:00:26.030 --> 00:00:29.370
&gt;&gt; Brian: All right,
how does it prioritize those?

15
00:00:29.370 --> 00:00:31.737
Like if you had more
than ones that time out.

16
00:00:31.737 --> 00:00:35.780
They all were going up from 0 to 10 or
something like that.

17
00:00:35.780 --> 00:00:38.220
How would it-
&gt;&gt; Will Sentance: So,

18
00:00:38.220 --> 00:00:41.600
as soon as they complete,
they ascend here.

19
00:00:41.600 --> 00:00:44.574
If they complete at the same time, eh.

20
00:00:47.610 --> 00:00:49.730
&gt;&gt; Will Sentance: It's too subtle to,
I don't know.

21
00:00:49.730 --> 00:00:55.130
I think at the same time,
the scenario's improbable, Alec?

22
00:00:55.130 --> 00:00:57.250
&gt;&gt; Alec: Is that a stack then?

23
00:00:57.250 --> 00:00:58.890
The call back queue?

24
00:00:58.890 --> 00:00:59.398
&gt;&gt; Will Sentance: There's a queue.

25
00:00:59.398 --> 00:01:00.725
&gt;&gt; Alec: Okay, but.

26
00:01:00.725 --> 00:01:05.940
&gt;&gt; Will Sentance: It's a queue in
a sense that we pass in, print hello.

27
00:01:05.940 --> 00:01:08.969
If we were to complete another
web browser feature, and

28
00:01:08.969 --> 00:01:12.139
its web browser feature
can be pass its function.

29
00:01:12.139 --> 00:01:14.450
It's going to be queued up behind,
to start next.

30
00:01:14.450 --> 00:01:17.842
Okay, so it's a first in, first out.

31
00:01:17.842 --> 00:01:19.758
So it's a queue structure.

32
00:01:25.031 --> 00:01:27.867
&gt;&gt; Will Sentance: [LAUGH]
No condescending giggles,

33
00:01:27.867 --> 00:01:34.890
Alec asked a very legitimate question,
whether the word queue is stack.

34
00:01:34.890 --> 00:01:36.290
A very legitimate question.

35
00:01:36.290 --> 00:01:39.710
All right, who else had a,
Victor was next.

36
00:01:39.710 --> 00:01:40.640
&gt;&gt; Speaker 5: What does set interval do?

37
00:01:41.750 --> 00:01:42.940
&gt;&gt; Will Sentance: Let's hold on,
Sandra, we'll do it, yeah,

38
00:01:42.940 --> 00:01:43.790
it's a very interesting one.

39
00:01:43.790 --> 00:01:45.845
But think of it as doing something
very similar in the web browser.

40
00:01:45.845 --> 00:01:48.820
I'll come to that one on one with you,
dude.

41
00:01:48.820 --> 00:01:50.700
There was other James?

42
00:01:50.700 --> 00:01:55.560
&gt;&gt; Speaker 5: Yeah, I can't remember,
does the task queue get

43
00:01:55.560 --> 00:01:59.300
processed at the end of the event loop,
or at the start of, or sorry,

44
00:01:59.300 --> 00:02:01.939
the event loop iteration, or
the start of the next iteration?

45
00:02:02.990 --> 00:02:05.240
&gt;&gt; Will Sentance: Once you've
finished all synchronous tasks.

46
00:02:05.240 --> 00:02:07.090
&gt;&gt; Speaker 5: So
at the end of the itteration.

47
00:02:07.090 --> 00:02:08.210
&gt;&gt; Will Sentance: In that sense, yes.

48
00:02:08.210 --> 00:02:12.430
Let's just make sure we have any
online questions we're answering.

49
00:02:12.430 --> 00:02:12.970
Paul, go ahead.

50
00:02:12.970 --> 00:02:16.270
&gt;&gt; Speaker 6: I think I had one questions,
I just want to make sure I know

51
00:02:16.270 --> 00:02:19.866
the set time out method that was
provided by the browser environment.

52
00:02:19.866 --> 00:02:22.280
&gt;&gt; Will Sentance: Yeah, yeah.
Set time, go ahead please, go ahead man.

53
00:02:22.280 --> 00:02:26.040
&gt;&gt; Speaker 6: So then the event loop and
the call back queue aren't unique to each

54
00:02:26.040 --> 00:02:31.592
individual browser run time but
say other non-browser

55
00:02:31.592 --> 00:02:36.790
run time etc would also have those-
&gt;&gt; Will Sentance: Absolutely,

56
00:02:36.790 --> 00:02:41.080
how Node implements these pieces
that is somewhat up to them, so

57
00:02:41.080 --> 00:02:45.770
we'll come to a piece later on where node
implemented in a somewhat different way.

58
00:02:45.770 --> 00:02:47.640
But we'll see that a little bit later on,
dude.

59
00:02:47.640 --> 00:02:48.850
But that's a great, great question.

60
00:02:50.520 --> 00:02:51.100
Yeah, Ben?

61
00:02:51.100 --> 00:02:52.967
&gt;&gt; Ben: Is there a limit to this
size of the callback queue?

62
00:02:55.923 --> 00:03:00.620
&gt;&gt; Will Sentance: I mean, I assume so
but that's a really good question.

63
00:03:00.620 --> 00:03:03.272
I would say test it out,
and we'll talk about the,

64
00:03:03.272 --> 00:03:06.554
because there was a call stack of course,
the callback queue.

65
00:03:06.554 --> 00:03:09.486
I mean as long as,
don't forget the callback queue,

66
00:03:09.486 --> 00:03:11.774
you're not storing this function here.

67
00:03:11.774 --> 00:03:15.906
You're referencing its position in
JavaScript memories, so the question is

68
00:03:15.906 --> 00:03:19.866
really, is there a limit to JavaScript
memory for function definitions?

69
00:03:19.866 --> 00:03:20.900
Do you see?

70
00:03:20.900 --> 00:03:25.070
You're not limited,
you're not copying this function here, so

71
00:03:25.070 --> 00:03:29.000
to me, the question is, is there
a limited Java Script run time memory?

72
00:03:29.000 --> 00:03:33.052
Well, yes, but that implies for your
callback queue, whatever that limit is,

73
00:03:33.052 --> 00:03:36.706
which is independent to the callback
queue, does that makes sense Ben?

74
00:03:36.706 --> 00:03:37.212
&gt;&gt; Ben: Yes.

75
00:03:37.212 --> 00:03:37.850
&gt;&gt; Will Sentance: Good question though.

76
00:03:39.400 --> 00:03:40.658
Yes Michelle?
&gt;&gt; Michelle: I was just wondering if

77
00:03:40.658 --> 00:03:44.390
the event loop is also part of
the JavaScript engine that you referenced?

78
00:03:44.390 --> 00:03:47.280
&gt;&gt; Will Sentance: Mhmm, absolutely,
but it's going to be even more stuff

79
00:03:47.280 --> 00:03:49.870
than just handle this, but
we'll see those in a moment.

80
00:03:49.870 --> 00:03:51.964
Sean.
&gt;&gt; Sean: What happens when you pass in

81
00:03:51.964 --> 00:03:55.430
an anonymous function to the set time out?

82
00:03:55.430 --> 00:03:56.140
&gt;&gt; Will Sentance: Anonymous functions,

83
00:03:56.140 --> 00:04:01.140
you can almost think of them being stored
in memory as like unlabeled functions.

84
00:04:01.140 --> 00:04:03.830
But they still have a position and
address in memory.

85
00:04:03.830 --> 00:04:07.090
Think of we're not passing
the label to the function really.

86
00:04:07.090 --> 00:04:10.210
Under the hood,
what we're passing is a reference or

87
00:04:10.210 --> 00:04:12.230
particular position in memory.

88
00:04:12.230 --> 00:04:16.920
And so, if we don't have a label for print
hello, we pass a function indirectly.

89
00:04:16.920 --> 00:04:19.820
That function is still being
defined in global memory.

90
00:04:19.820 --> 00:04:23.727
When I run set timeout and pause for
functioning, not a labelled functioning.

91
00:04:23.727 --> 00:04:26.873
But when I define right
there in my parentheses,

92
00:04:26.873 --> 00:04:31.580
that is still being stored in
global memory just without a label.

93
00:04:31.580 --> 00:04:36.210
And it's that referenced function that's
eventually being referenced here.

94
00:04:36.210 --> 00:04:39.160
This doesn't have a label now, but
it's still referencing the position in

95
00:04:39.160 --> 00:04:42.460
Java Script's global memory,
where that function was defined.

96
00:04:42.460 --> 00:04:43.910
Makes sense?
Yes.

97
00:04:43.910 --> 00:04:44.410
&gt;&gt; Mike: Good question.

