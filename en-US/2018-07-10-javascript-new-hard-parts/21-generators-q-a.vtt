WEBVTT

1
00:00:00.130 --> 00:00:02.773
&gt;&gt; Will Sentance: All right,
thumbs on this, you lost me.

2
00:00:02.773 --> 00:00:05.716
[LAUGH] It's okay,
this stuff's super hard.

3
00:00:05.716 --> 00:00:10.370
Very, very clear, these are brand
new features, ES7 clarification.

4
00:00:10.370 --> 00:00:13.826
I didn't need you to put,
I didn't for for a long time,

5
00:00:13.826 --> 00:00:17.299
cuz I don't want to explain const and
let and now we're doing pure ES7.

6
00:00:17.299 --> 00:00:22.700
All right, Brian has a clarification,
Ben has one, Victor and Paul have one.

7
00:00:22.700 --> 00:00:23.540
Josh is in the middle.

8
00:00:23.540 --> 00:00:27.430
Let's start with Victor.
&gt;&gt; Victor: So I guess my question is,

9
00:00:28.720 --> 00:00:31.380
maybe this is one of other ones
that should be left later.

10
00:00:32.730 --> 00:00:34.580
What is this pattern after?

11
00:00:34.580 --> 00:00:38.520
I mean, I feel like it's very new to me.
&gt;&gt; Will Sentance: Other languages have

12
00:00:38.520 --> 00:00:39.400
iterators and generators.

13
00:00:39.400 --> 00:00:43.500
Python has them, they're a pretty
standard, I don't know if it's standard,

14
00:00:43.500 --> 00:00:45.190
but they're pretty nice.

15
00:00:45.190 --> 00:00:48.327
I'm gonna say somewhat more contemporary,

16
00:00:48.327 --> 00:00:52.875
because traditional computer
programming is very imperative.

17
00:00:52.875 --> 00:00:55.858
That is all about saying I'm going
to show you exactly how I do

18
00:00:55.858 --> 00:00:57.960
every last thing I do.

19
00:00:57.960 --> 00:00:59.200
And as we go through time,

20
00:00:59.200 --> 00:01:03.930
we develop a more abstract model where we
talk more about let me do what I wanna do,

21
00:01:03.930 --> 00:01:06.940
as opposed to, for example here,
which I want to do?

22
00:01:06.940 --> 00:01:10.000
I want to do literally get my
next element one after another.

23
00:01:10.000 --> 00:01:12.100
That's a very,
I'm not showing you how I'm getting it.

24
00:01:12.100 --> 00:01:14.608
Well, there's something similar here but

25
00:01:14.608 --> 00:01:20.230
they're in Python at least and so
they're not completely by any means new.

26
00:01:21.370 --> 00:01:22.914
Ben.
&gt;&gt; Ben: So

27
00:01:22.914 --> 00:01:29.025
when we're returning from next to next,
are we also returning don false so

28
00:01:29.025 --> 00:01:32.040
that we know, [CROSSTALK]
&gt;&gt; Will Sentance: Yeah, yeah, yeah.

29
00:01:32.040 --> 00:01:35.230
So I again,
that's a very good clarification.

30
00:01:35.230 --> 00:01:39.375
I simplify this slightly or profoundly
from being the object than the job which

31
00:01:39.375 --> 00:01:42.310
is actually returning
with the value ten and

32
00:01:42.310 --> 00:01:47.420
don false to being the ten but
is very important clarification

33
00:01:47.420 --> 00:01:50.240
here that's gonna help with your
familiarity when you see the actual code,

34
00:01:50.240 --> 00:01:53.090
we actually return now an object
with the two properties.

35
00:01:53.090 --> 00:01:56.940
I mentioned that before, but again,
it's just much more readable here, for

36
00:01:56.940 --> 00:01:59.350
our purposes,
to say we returned the value.

37
00:01:59.350 --> 00:02:02.580
But we actually returned,
value ten, done false.

38
00:02:02.580 --> 00:02:03.850
Okay.

39
00:02:03.850 --> 00:02:04.590
Great question, Ben.

40
00:02:04.590 --> 00:02:06.010
Great, helpful clarification.

41
00:02:06.010 --> 00:02:09.213
Paul?
&gt;&gt; Paul: Note the penultimate yield waits

42
00:02:09.213 --> 00:02:13.946
for five plus newNum to evaluate
before suspending, right?

43
00:02:13.946 --> 00:02:17.121
It doesn't just return five,
it says okay, add newnum, [CROSSTALK]

44
00:02:17.121 --> 00:02:18.309
&gt;&gt; Will Sentance: Right, because the right

45
00:02:18.309 --> 00:02:21.063
hand side is an expression that
can be evaluated before you,

46
00:02:21.063 --> 00:02:24.208
like that's reasonable, like a return so
we'll do the same thing.

47
00:02:24.208 --> 00:02:25.330
&gt;&gt; Paul: So that's my question, yeah,

48
00:02:25.330 --> 00:02:27.920
whether you can put a turner in there,
whether you can put an expression.

49
00:02:27.920 --> 00:02:28.700
&gt;&gt; Will Sentance: You can treat it just

50
00:02:28.700 --> 00:02:31.322
like a return yeah.

51
00:02:31.322 --> 00:02:34.414
Alec?
&gt;&gt; Alec: Does the generator object only

52
00:02:34.414 --> 00:02:35.833
have the next property, or

53
00:02:35.833 --> 00:02:38.290
there are other properties on there?
&gt;&gt; Will Sentance: Go inspect,

54
00:02:38.290 --> 00:02:39.760
go inspect that dude.

55
00:02:39.760 --> 00:02:44.052
I mean you're going to see that actually,
it's got a whole bunch of these built in

56
00:02:44.052 --> 00:02:50.298
generator location, it's not only object,
&gt;&gt; Will Sentance: If we were to build

57
00:02:50.298 --> 00:02:56.420
this out ourselves, we'd probably store it
I suppose we could store it on the object.

58
00:02:56.420 --> 00:03:00.630
We'd want to store the cache of data,
though, probably in the backpack,

59
00:03:00.630 --> 00:03:01.510
in the closure on the function.

60
00:03:01.510 --> 00:03:02.830
And only functions get backpacks.

61
00:03:02.830 --> 00:03:05.790
But the location position, I guess,
could be easily stored on the object.

62
00:03:05.790 --> 00:03:09.942
This is actually a property not on next,
it's a property on the object.

63
00:03:09.942 --> 00:03:12.324
So the whole bunch of properties
on this object that come out,

64
00:03:15.788 --> 00:03:17.552
&gt;&gt; Will Sentance: Generates a location,

65
00:03:17.552 --> 00:03:22.842
actually scope is stored on the objects,
under the hood of it,

66
00:03:22.842 --> 00:03:28.663
it must be still attached to the function
if it's imprinting closure itself,

67
00:03:28.663 --> 00:03:32.542
but it may be an internal
feature of JavaScript, but

68
00:03:32.542 --> 00:03:37.393
it's stored as a square bracket
scope property with that data and

69
00:03:37.393 --> 00:03:43.380
it has a property called status
suspended when it's not executing.

70
00:03:43.380 --> 00:03:44.600
It has a property

71
00:03:47.000 --> 00:03:51.330
generator location itself which refers
to where is the generator defined.

72
00:03:51.330 --> 00:03:51.890
In JavaScript.

73
00:03:51.890 --> 00:03:53.780
That's like five or six properties.
&gt;&gt; Alec: Sure.

74
00:03:53.780 --> 00:03:54.635
&gt;&gt; Will Sentance: Okay.

75
00:03:54.635 --> 00:03:56.969
&gt;&gt; Speaker 6: Does it have too?

76
00:03:56.969 --> 00:03:59.367
[CROSSTALK]
&gt;&gt; Will Sentance: It won't be on

77
00:03:59.367 --> 00:04:03.717
the object itself, but
it could be on the prototype or the,

78
00:04:03.717 --> 00:04:05.989
of the generator object type.

79
00:04:05.989 --> 00:04:07.830
Okay, any other clarifications?

80
00:04:07.830 --> 00:04:12.520
James?
&gt;&gt; James: Number one, I see this as super

81
00:04:12.520 --> 00:04:16.900
powerful because you could certainly have
a generator that's essentially an infinite

82
00:04:16.900 --> 00:04:19.860
loop, as long as it keeps yielding.
&gt;&gt; Will Sentance: Yeah,

83
00:04:19.860 --> 00:04:21.200
that's actually very, very true.

84
00:04:21.200 --> 00:04:23.140
That's one of the most
powerful features of these,

85
00:04:23.140 --> 00:04:23.760
yeah.
&gt;&gt; James: Primes or

86
00:04:23.760 --> 00:04:25.720
Fibonacci calculations.
&gt;&gt; Will Sentance: What a great

87
00:04:25.720 --> 00:04:26.580
insight, yes.

88
00:04:26.580 --> 00:04:30.130
Absolutely, it's one of the most
powerful things about this design.

89
00:04:30.130 --> 00:04:32.400
&gt;&gt; James: And number two,

90
00:04:32.400 --> 00:04:36.290
I assume the shortcoming here, and
which likely leads into the last topic,

91
00:04:36.290 --> 00:04:39.800
is this is synchronous code, however.

92
00:04:39.800 --> 00:04:40.940
Right?
&gt;&gt; Will Sentance: Well let's see in

93
00:04:40.940 --> 00:04:45.210
a moment what happens if we
were to instead yield something

94
00:04:46.230 --> 00:04:48.670
that is an asynchronous task being set up.

95
00:04:48.670 --> 00:04:50.370
And that's our very final peace.

96
00:04:50.370 --> 00:04:53.940
Before we get to that, I think it's
worth doing one more block of pairing.

97
00:04:53.940 --> 00:04:57.110
Just almost to give
ourselves a little breath of

98
00:04:57.110 --> 00:05:01.470
fresh air even in the meantime but
also metaphorically so in other words,

99
00:05:01.470 --> 00:05:06.320
go back to the challenges for a bit just
to test yourself out on this material.

100
00:05:06.320 --> 00:05:09.080
Those last challenge is 789.

101
00:05:09.080 --> 00:05:10.140
Of this material.

102
00:05:10.140 --> 00:05:15.100
But in a moment as we just said, this
returnNextElement is a special object.

103
00:05:15.100 --> 00:05:19.420
There's a next method which starts or
continues running create flow

104
00:05:19.420 --> 00:05:22.260
until it hits yield returns
out the value being yielded.

105
00:05:22.260 --> 00:05:25.450
We end up with a stream flow of values so
we can get one by one.

106
00:05:25.450 --> 00:05:26.870
But we get control and dynamically.

107
00:05:26.870 --> 00:05:30.085
But we're gonna see most importantly for
the first time we get to pause,

108
00:05:30.085 --> 00:05:36.180
pseudo suspend a function being called,
and return to it back into create flow,

109
00:05:36.180 --> 00:05:40.290
using returnNextElement.next, calling it.

110
00:05:40.290 --> 00:05:43.870
Just only a little bit of a preview,
in asynchronous JavaScript,

111
00:05:43.870 --> 00:05:48.840
we want to be able to initiate
a task that takes a long time.

112
00:05:48.840 --> 00:05:51.420
For example,
we're requesting dates from a server.

113
00:05:51.420 --> 00:05:54.360
Move on with regular synchronous code.

114
00:05:54.360 --> 00:05:57.990
And then come back to run
further functionality

115
00:05:57.990 --> 00:06:03.370
on the data that comes back from the slow,
asynchronous task.

116
00:06:03.370 --> 00:06:07.470
What if we were to yield out of
the function at the moment it's setting

117
00:06:07.470 --> 00:06:11.970
off the long-time task, the slow task, and
return to the function only when that task

118
00:06:11.970 --> 00:06:16.496
is complete, we might finally
get a model of thinking about

119
00:06:16.496 --> 00:06:22.040
a synchronicity that
reads logically to us.

120
00:06:22.040 --> 00:06:24.450
We're going to see it after
this pair programming break.

121
00:06:24.450 --> 00:06:26.020
Then I'm gonna wrap it.

122
00:06:26.020 --> 00:06:28.700
We're gonna build it ourselves, manually.

123
00:06:28.700 --> 00:06:33.210
We're then gonna wrap it with a brand
new construct known as Async/await.

124
00:06:33.210 --> 00:06:35.530
All right, people, here we go.

125
00:06:35.530 --> 00:06:40.786
Back to your pair programming,
we'll reconvene in ten, 15 minutes.

