[00:00:00]
>> Ready for question number 10. When animating the following properties, which have the correctly listed rendering costs? Is it width with layout, paint, and composite, opacity with paints and composite, background image with just composite, left with layout, paint, and composite, or transform with paint and composite? Also just remember that you can select multiple if you want.

[00:00:24]
[LAUGH] And also this is just kind of the default. It can be a little different sometimes in browsers, depending on stuff, but yeah, default. All right, let's look at the answer. So the only right ones are A with width, layout, paint, and composite, and D with left, also layout, paint, and composite.

[00:00:46]
So the correct, oops, the correct one would've been the opacity was only composite. background-image should have been paint and composite. I don't know why that wasn't listed. Here it's listed. And transform is only composite. Sorry, so this one's wrong. Background image should also include the paint, but yeah.

[00:01:02]
So first, let's go to the width. So when we're changing the width, maybe on hover, we wanna go from 200 pixels to 300 pixels, the browser first has to calculate kind of geometry of the new sizes of the elements. Cuz it might also affect the other elements on the screen when we're changing the width.

[00:01:21]
So in that case, it has to calculate all the positions again. In that case, it, of course, has to paint it because we just changed the width. And finally, it always has to composite the layers together again. Now, in this animation, it's a bit more dramatic. Browsers are very smart in optimizing to only repaint the parts that are affected by it, not the entire page again.

[00:01:41]
But yeah, changing any sizes will always cause a layout change. And then always a paint and composite as well, cuz it's kinda a pipeline. When we change the opacity, we only have to composite. So opacity is one of those fun GPU accelerated properties where a browser will actually create or kind of promote that element to a separate layer, a separate graphics layer.

[00:02:08]
And when changing the opacity, what it can do is it can just change, I think, it's called the alpha channel on a graphics layer, I'm not into graphics at all. But basically it's what it does, it can just change the layer's opacity. Not the entire layout, not the element itself within that same layout.

[00:02:22]
It can just change the layer's opacity. So it only has to change the opacity during that composite phase. So it doesn't have to do anything. It doesn't have to repaint, it doesn't have to layout, cuz we're not changing width or height or anything. And we're also not changing the pixels.

[00:02:34]
It's just changing the opacity in that browser layer. We'll talk a bit more about the GPU accelerated properties soon to see what other values kind of work the same way. It's also important to remember that in some cases, browsers might not create a separate layer for opacity if we're not animating it, or if they think, okay, it doesn't really make sense, cuz creating a different layer consumes memory, kinda consumes data.

[00:03:00]
So you kinda wanna minimize the amount of layers that you have in an application. But when changing it, when hovering it, it's first grade separate layer, compositive back, and then it can just be on the same layer. So yeah, it's just for the animation. Anyway, moving on to background-image, so this one requires a paint and a composite.

[00:03:16]
So it doesn't need layout because we're not changing width, height, we're not changing anything there. But it does have to repaint the pixels to have that background image. So this does require a paint, and then of course, always a composite to get all those layers back together into one single image.

[00:03:34]
And then we have left, which does affect the layout, like we were changing, not necessarily the geometry, we've changed the position. So it might also alter the position of other elements on the page. So the browser has to ensure that it knows where the other elements go when changing left.

[00:03:49]
So this does require a layout, and then eventually a paint to repaint those pixels. Again, this is a more dramatic one, it does this in a very optimized way, and then compositing the layers back together into the final image. And then finally, transform is also one of those GPU-accelerated ones.

[00:04:05]
So when we transform, for example, we wanna move the elements to the right, I believe, translateX, yeah, to the right 50 pixels. It does so by also promoting it to a separate layer. So it doesn't just repaint every time it forwards to a separate layer. It can just move that layer on top of it and then composite it back together.

[00:04:25]
So it doesn't have to do any layout because we're not changing any of the geometry of the elements that are on that base layout, if that makes sense. It just promotes it and then they can just change that layer and then compositive back, if that makes sense. So this is only composite because transform and translateX is one of those accelerated property.

[00:04:47]
So if you ever wanna move an element to the right or to the left, make sure to use like translateX or translateY, whatever you need, because that makes sure that you're not repainting every, even though it's not every pixel. But if you were just to animate this with a left or with a right, the browser wouldn't promote it to a separate layer, and then it would have to repaint the animation every time, re-layout.

[00:05:08]
This is just super expensive, cuz that all happens on the main thread, right? We saw with the task queue, it also has the UI rendering, all those things. So you don't want that, cuz it's all blocking the main thread. Yeah, that was the last one. Make sense? Questions?

[00:05:24]
[LAUGH] Yeah, what's that?
>> I have a question about the opacity one,
>> Yeah.
>> I mean, I've seen in old code, using opacity to change a color. If it was black, somebody would say opacity, 80%, and make it grayer. That's a really bad way to do it now.

[00:05:40]

>> Yeah, well, I mean, you can do it. If you don't animate it, it's fine. If you just use an opacity, it won't create a separate layer just to show that opacity. This is more about animating the opacity. So during the animation, it will create a new layer.

[00:05:55]
And after the animation, it usually gets rid of that layer again, unless you, yeah, okay, I don't wanna spoil the next part, but you can also use the will change opacity. And in that case, it will always create a new layer just for that elements, but that wouldn't make sense if you're not animating it.

[00:06:13]
Because it could have just eventually be composited back onto the same layer if you're not changing it. So then you're just consuming memory for no reason, but you can still do, I mean, using opacity to make it gray, honestly, I do that as well. [LAUGH] I don't care, it looks gray, so it's fine.

[00:06:30]
But yeah, then it just creates a layer, but only during the very first composite, and you won't see that layer in your browser. So, yeah, FYI, If you open dev tools in Chrome, there is a setting where you can actually see layers. And I think maybe after this, I can also just show you because it's a pretty fun tool and you might be pretty surprised at just how many layers some websites have.

[00:06:53]
I can show Google, yeah, I don't have anything bad there. All right, so you can see Layers, for example, and I'm pretty sure that Google, all right, here, you can see the different layers and you can kind of move around. You see all the different layers created here.

[00:07:09]
[SOUND] These are all the layers, I don't know if you can see that. So here, you can also see why. You see the compositing reasons. You see layer for link, highlight, frame, overlay, all that stuff. You have scrollable stuff. Secondary layer, I don't know, did I always give you reason?

[00:07:26]
iframes also get their own layer. But you also see the memory estimate. So for one layer, this is 7.2 megabytes, and for this one, it's also 7.2. This is 16.4 kilobytes, all that kinda stuff. So this is why it's important to ensure that you don't create too many layers, cuz they all consume memory and you don't always need that.

