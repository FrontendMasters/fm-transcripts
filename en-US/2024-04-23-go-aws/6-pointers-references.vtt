WEBVTT

1
00:00:00.230 --> 00:00:03.615
Cool, I really want to show that address
copy because I thought it was a really

2
00:00:03.615 --> 00:00:06.686
cool feature and in here,
let's just put back our asterisks here, so

3
00:00:06.686 --> 00:00:09.310
that we are going to persist
the changing of our value here.

4
00:00:10.940 --> 00:00:15.702
Now there is another concept
I want to discuss, and

5
00:00:15.702 --> 00:00:21.017
it's basically going to be how
you can declare a variable

6
00:00:21.017 --> 00:00:25.796
as a pointer,
to the memory address of something.

7
00:00:26.826 --> 00:00:27.626
Bear with me.

8
00:00:27.626 --> 00:00:32.316
So let's say we have A,
A is declared as an int/ that's all it is.

9
00:00:32.316 --> 00:00:33.672
We just print A, it's going to give us 7.

10
00:00:35.409 --> 00:00:41.675
Let's create B,
B is going to be a pointer to A.

11
00:00:44.115 --> 00:00:47.482
Okay, nothing too crazy,
let's print this line.

12
00:00:48.562 --> 00:00:52.562
And I wanna actually ask,
what are we gonna get when I print B?

13
00:00:52.562 --> 00:00:57.217
What is B going to be?

14
00:00:57.217 --> 00:00:58.098
&gt;&gt; Address?

15
00:00:58.098 --> 00:01:02.496
&gt;&gt; Yeah, the memory address, so that's
what the ampersand does it doesn't print

16
00:01:02.496 --> 00:01:04.823
the value or what's stored in the memory,

17
00:01:04.823 --> 00:01:09.328
it's a pointer to where that memory was
allocated to where it's pointing to.

18
00:01:09.328 --> 00:01:12.338
So it's gonna point us to
where A is allocated memory.

19
00:01:12.338 --> 00:01:16.471
So if you run this you can see here,
this is B, right?

20
00:01:16.471 --> 00:01:22.801
It's just an address, but what if I wanna
change the value of my pointer, okay?

21
00:01:22.801 --> 00:01:27.615
If I do something like B is now 9,
can I use 9 untyped in

22
00:01:27.615 --> 00:01:33.571
constant as pointer and or
reference INT value in assignment.

23
00:01:33.571 --> 00:01:36.463
So if you want, what we have to
do is called the referencing

24
00:01:36.463 --> 00:01:41.321
the allocated memory to actually change
the value and we can use as it shows here.

25
00:01:41.321 --> 00:01:44.773
So this is kind of that dual
meaning of the asterisk gets

26
00:01:44.773 --> 00:01:49.670
a little murky right now, but what
the asterisk is doing now is it's saying.

27
00:01:49.670 --> 00:01:54.161
I have this new int this 9, the native
type that was allocated when I first

28
00:01:54.161 --> 00:01:57.856
instantiated A, and
instead of giving the memory address or

29
00:01:57.856 --> 00:02:03.508
re-declare the memory address as 9 because
you can't do that, we're basically saying,

30
00:02:03.508 --> 00:02:07.854
hey, dereference the actual value of
where the memory is allocated and

31
00:02:07.854 --> 00:02:10.324
assign it this new int of 9, okay?

32
00:02:10.324 --> 00:02:12.860
So here,
if we keep the same print statement,

33
00:02:12.860 --> 00:02:15.434
I'm actually going to go back up here.

34
00:02:15.434 --> 00:02:19.187
I'm going to comment this out and clear
this just for now, if I actually rerun

35
00:02:19.187 --> 00:02:22.611
this it's still the memory address,
we haven't changed anything.

36
00:02:22.611 --> 00:02:27.300
But if I now dereference it,
and I run it, it's 9.

37
00:02:27.300 --> 00:02:29.343
But question, what is A?

38
00:02:33.260 --> 00:02:34.970
What if I print A what
value is A gonna have?

39
00:02:34.970 --> 00:02:37.760
&gt;&gt; 7 right?

40
00:02:37.760 --> 00:02:40.248
&gt;&gt; 7 or 9, let's find out.

41
00:02:40.248 --> 00:02:45.049
If we change this to A and
we re-assign it, it's 9,

42
00:02:45.049 --> 00:02:48.162
because B is the pointer, right?

43
00:02:48.162 --> 00:02:52.832
It points to the actual allocated member
of A, so if we de-reference it and

44
00:02:52.832 --> 00:02:57.429
re-assign a value, it's going to
impact the D reference B, but also A,

45
00:02:57.429 --> 00:03:00.044
when we first initialize that variable.

46
00:03:02.045 --> 00:03:06.986
Cool, if you've never dealt with pointers
or anything, it can get a little dicey,

47
00:03:06.986 --> 00:03:10.952
but just remember a core kind of
principle is if you want to change and

48
00:03:10.952 --> 00:03:15.479
modify the values of the struct or
the type upon instantiation declaration,

49
00:03:15.479 --> 00:03:18.945
you have to pass it in as
a pointer reference, okay?

50
00:03:18.945 --> 00:03:21.986
But if you are comfortable with
just a copy of this truck for

51
00:03:21.986 --> 00:03:26.924
maybe logging or whatever other purpose
you don't need to put it in as a pointer.

52
00:03:26.924 --> 00:03:29.704
Yes.
&gt;&gt; So your fields are all capitalized?

53
00:03:29.704 --> 00:03:31.338
&gt;&gt; Yes.
&gt;&gt; Even though they're fields.

54
00:03:31.338 --> 00:03:31.924
&gt;&gt; Yeah.

55
00:03:31.924 --> 00:03:34.568
&gt;&gt; And
then also you capitalized that function,

56
00:03:34.568 --> 00:03:37.029
is that because it's returning a struct?

57
00:03:37.029 --> 00:03:42.627
&gt;&gt; No, great question, you're peeking
behind the currents of the next portion,

58
00:03:42.627 --> 00:03:47.400
but I do want to answer it, right now,
this is just like new person.

59
00:03:47.400 --> 00:03:51.056
It's kind of habit the way I wrote
it I'm not gonna lie because

60
00:03:51.056 --> 00:03:55.695
here on function 10 is new person
declaration capital N but for some reason,

61
00:03:55.695 --> 00:04:00.402
this is not capital it's a habit, because
like I said earlier, when I know I'm

62
00:04:00.402 --> 00:04:04.514
gonna have a book person type or
a person struck and I'm gonna use it.

63
00:04:04.514 --> 00:04:08.659
I'm gonna probably import this
function to somewhere else and

64
00:04:08.659 --> 00:04:11.794
declare that function to
get the person right.

65
00:04:13.064 --> 00:04:15.663
And in go making a function public is

66
00:04:15.663 --> 00:04:20.005
only denoted with the capitalization
of the first letter.

67
00:04:20.005 --> 00:04:24.178
So I'm gonna get into that into the next
kind of module like model here or

68
00:04:24.178 --> 00:04:27.075
module, but
that's a tidbit of information.

69
00:04:27.075 --> 00:04:31.099
So everything that's not capitalized is
gonna live in the scope of the package,

70
00:04:31.099 --> 00:04:34.545
everything that's capitalized can
be improved by other packages.

71
00:04:35.545 --> 00:04:40.442
So, I'll show you an example if maybe
that concept is a little wonky okay,

72
00:04:40.442 --> 00:04:42.622
we're almost done.

73
00:04:42.622 --> 00:04:43.861
This goes much deeper.

74
00:04:43.861 --> 00:04:46.244
I wanna go back to our looping here for
a second.

75
00:04:46.244 --> 00:04:52.092
&gt;&gt; Before we get on, can I nested
struct can be copied by assigning?

76
00:04:53.172 --> 00:04:56.207
&gt;&gt; Yes, a nested copy,
if you have a nested struck and

77
00:04:56.207 --> 00:05:00.663
you pass it in, everything will be
copied from the from the nested struck.

78
00:05:00.663 --> 00:05:04.575
Every time it's gonna make a new
copy of whatever you pass it in,

79
00:05:04.575 --> 00:05:09.139
which is another point of there is that
you can kind of get away, like in this

80
00:05:09.139 --> 00:05:13.847
kind of let's say toy example, you can
get away doing passing by reference or

81
00:05:13.847 --> 00:05:17.964
passing by copy cause our struct
has two fields it's whatever.

82
00:05:17.964 --> 00:05:22.872
Our computers can eat that no problem,
if you have a super long struck with

83
00:05:22.872 --> 00:05:29.073
multiple different fields and it has like
a nested STRs passing by copy is costly.

84
00:05:29.073 --> 00:05:32.923
When it gets to that scale, right, that's
where it might be more efficient to pass

85
00:05:32.923 --> 00:05:36.718
the actual reference instead of making
a new copy, passing it down your logic, so

86
00:05:36.718 --> 00:05:39.307
you can do, you can just pass
that struck by reference.

87
00:05:39.307 --> 00:05:43.500
So a lot of the time you would actually
see in more heavier duty code,

88
00:05:43.500 --> 00:05:48.063
that this function here that returns
our person struck is actually always

89
00:05:48.063 --> 00:05:51.540
going to be the reference to
to the struck here, right.

90
00:05:51.540 --> 00:05:56.308
You probably see something like this
happen all the time, cause we wanna return

91
00:05:56.308 --> 00:06:01.220
a struck that's gonna be the actual
reference when it's stantialized and then,

92
00:06:01.220 --> 00:06:05.207
we avoid passing as a copy every
time we call methods on that truck,

93
00:06:05.207 --> 00:06:10.080
changing the property, modifying
the property, aggregating it, whatever.

94
00:06:12.280 --> 00:06:13.100
Any questions on that?

95
00:06:14.690 --> 00:06:16.580
&gt;&gt; When you are dealing with copies and

96
00:06:16.580 --> 00:06:20.241
stuff, is there any kind of track
like cleanup memory you need to do?

97
00:06:20.241 --> 00:06:21.080
&gt;&gt; The garbage.

98
00:06:21.080 --> 00:06:22.670
&gt;&gt; That's too far in the weeds we can.

99
00:06:22.670 --> 00:06:23.940
&gt;&gt; No, no, no, no it's not far.

100
00:06:23.940 --> 00:06:28.637
No not at all, the garbage collector of
go which I briefly mentioned earlier,

101
00:06:28.637 --> 00:06:30.000
does all that for you.

102
00:06:30.000 --> 00:06:34.574
But that isn't excuse to kind of be
negligible in that perspective because you

103
00:06:34.574 --> 00:06:39.216
still run the risk of your heap being to
allocated, if you have a leaky pointer,

104
00:06:39.216 --> 00:06:44.137
right, if you have something it's pointing
to something that's no longer used and

105
00:06:44.137 --> 00:06:48.885
it's massive, you run the risk of like
merging your heap or going over it right.

106
00:06:48.885 --> 00:06:53.554
So there's this concept that a garbage
collector does a lot of things under

107
00:06:53.554 --> 00:06:58.218
the bed kind of under the hood for us,
but you do have to be aware that does has

108
00:06:58.218 --> 00:07:02.841
an underlying cost and it could come
back and bite you, so you have to use.

109
00:07:02.841 --> 00:07:07.329
That's kinda where the engineer in
software program will come into and

110
00:07:07.329 --> 00:07:08.461
make a decision.

111
00:07:09.461 --> 00:07:10.571
Really good question, thank you.

112
00:07:11.751 --> 00:07:16.615
Okay, one more thing about this whole
topic of pointers and everything,

113
00:07:16.615 --> 00:07:19.823
I wanna go back to our
good friend looping.

114
00:07:19.823 --> 00:07:21.813
So I'm gonna make a new slice.

115
00:07:22.873 --> 00:07:30.265
My slice, slice SIO is going to be I don't
know, let's just say it's a slice and

116
00:07:30.265 --> 00:07:35.483
it's int, and we gonna make 1,
2, and 3, okay?

117
00:07:35.483 --> 00:07:39.353
And my task is to increment
these values in the slice.

118
00:07:39.353 --> 00:07:41.350
Pretty easy loop Add 1, okay?

119
00:07:41.350 --> 00:07:45.244
So let's do that, so for index value,

120
00:07:45.244 --> 00:07:49.440
I'm gonna use range myslice, okay?

121
00:07:49.440 --> 00:07:51.770
And here, because we only
are interested in the value,

122
00:07:51.770 --> 00:07:54.370
we can do something that's
pretty interesting to go.

123
00:07:54.370 --> 00:07:57.689
So if there's a return value that you
do not want to use, cuz if we don't use

124
00:07:57.689 --> 00:08:01.339
index, we're not gonna compile
the compiler Is gonna keep yelling at us.

125
00:08:01.339 --> 00:08:02.749
I'm like, man please stop yelling at me.

126
00:08:02.749 --> 00:08:04.079
We can do is just put underscore here.

127
00:08:04.079 --> 00:08:05.579
So now we ignored it.

128
00:08:05.579 --> 00:08:08.123
We essentially ignored the index and
the return type, so

129
00:08:08.123 --> 00:08:10.190
now our compiler doesn't care, it's like,

130
00:08:10.190 --> 00:08:14.229
okay, I see you're ignoring it I'll shop
now, but you still do not use value.

131
00:08:14.229 --> 00:08:16.479
Let's just do value because
we need to increment value++.

132
00:08:16.479 --> 00:08:19.199
We increment the value, okay?

133
00:08:19.199 --> 00:08:24.261
If we do fmt::print, print loin and
we do my slice and we save it.

134
00:08:24.261 --> 00:08:30.504
If we print this,
what do you all think is gonna happen?

135
00:08:31.540 --> 00:08:35.240
Probably you kinda figured out
that's still going to be 123.

136
00:08:35.240 --> 00:08:39.668
So even the built-in range function,
when you increment the value,

137
00:08:39.668 --> 00:08:41.993
it is a copy of the value in the slice,

138
00:08:41.993 --> 00:08:46.407
it is not the allocated reference
to that slice, all right.

139
00:08:46.407 --> 00:08:49.441
If you wanna actually modify
the underlying value of the slice and

140
00:08:49.441 --> 00:08:52.640
persist it and actually allocate
the memory, or change the memory,

141
00:08:52.640 --> 00:08:54.817
that's where we have to
bring back the index.

142
00:08:56.197 --> 00:08:59.781
We can actually ignore this copy and

143
00:08:59.781 --> 00:09:04.801
what we do here is my slice
referenced at the index I

144
00:09:04.801 --> 00:09:09.723
could type that would be
really nice index ++.

145
00:09:09.723 --> 00:09:15.813
And so now, if you run it,
it should say 2, 3, 4 there you go.

146
00:09:16.883 --> 00:09:21.519
So it's another gotcha that if I
introduced iterating over a slice I want

147
00:09:21.519 --> 00:09:23.651
to showcase how you can fix that.

148
00:09:25.831 --> 00:09:29.652
&gt;&gt; How can you return reference of
a struct wouldn't the reference then live

149
00:09:29.652 --> 00:09:31.011
shorter than the struct?

150
00:09:32.681 --> 00:09:34.401
&gt;&gt; How can you return
the reference of the struct?

151
00:09:35.541 --> 00:09:36.921
Well, you could return the reference.

152
00:09:36.921 --> 00:09:40.041
Let's just go back up here.

153
00:09:40.041 --> 00:09:45.258
With this syntax here this is
returning the reference of the struck.

154
00:09:45.258 --> 00:09:49.254
And so every time we use that struck
now we're always going to be passing

155
00:09:49.254 --> 00:09:51.053
the reference of that struck and

156
00:09:51.053 --> 00:09:55.658
never like there's no I don't know the
second portion like the can you repeat it?

157
00:09:57.938 --> 00:10:00.626
&gt;&gt; When the reference live
shorter than the struct

158
00:10:01.942 --> 00:10:07.208
&gt;&gt; I think I understand that question.

159
00:10:07.208 --> 00:10:10.583
So that kinda going back to
what you asked earlier is,

160
00:10:10.583 --> 00:10:15.828
you will still always have a reference
to the memory allocate to that struck.

161
00:10:15.828 --> 00:10:18.564
And if you do remove that struck or
it's unused,

162
00:10:18.564 --> 00:10:23.506
you'll still have that memory allocation
you saw something referencing that memory,

163
00:10:23.506 --> 00:10:27.060
and that's how you can have like
leaking memory usage as well.

164
00:10:28.550 --> 00:10:30.737
So that reference can
exist past the stroke and

165
00:10:30.737 --> 00:10:34.104
you will be kinda referencing allocate
memory that no longer exists and

166
00:10:34.104 --> 00:10:36.250
then that could be pretty
buggy in your code.

