WEBVTT

1
00:00:00.000 --> 00:00:04.871
Just to recap, we begin by setting
some goals and talking about how this

2
00:00:04.871 --> 00:00:09.662
course is designed to help you
understand tricky type information and

3
00:00:09.662 --> 00:00:13.987
to give you tips and tricks that
you can put right into your app.

4
00:00:13.987 --> 00:00:18.266
Copy paste code out of this course,
and it'll save you major headache.

5
00:00:18.266 --> 00:00:22.695
We talked a little bit about how
different kinds of declarations

6
00:00:22.695 --> 00:00:26.304
stack on top of each other and
came to the realization

7
00:00:26.304 --> 00:00:30.909
that classes are actually two things
stacked on top of each other.

8
00:00:30.909 --> 00:00:33.323
It's the factory and
it's the instance, right?

9
00:00:33.323 --> 00:00:35.279
We talked a bit about modules and

10
00:00:35.279 --> 00:00:38.613
CJS interop one of the trickier
things where frankly,

11
00:00:38.613 --> 00:00:43.848
I have helped a TC 39 members, the people
who are on the JavaScript standards body.

12
00:00:43.848 --> 00:00:45.560
They've had trouble with this and

13
00:00:45.560 --> 00:00:49.111
I've had to walk them through this
the same way I walked you through it.

14
00:00:49.111 --> 00:00:54.312
So don't feel bad if if you get stuck
there, and it's a little mysterious.

15
00:00:54.312 --> 00:00:59.323
We extracted type information
from values using type queries,

16
00:00:59.323 --> 00:01:03.508
like type of,
then we moved on to conditional types.

17
00:01:03.508 --> 00:01:08.051
And the built in type script
utility types extract and exclude,

18
00:01:08.051 --> 00:01:11.850
which are just conditional
types behind the scenes.

19
00:01:11.850 --> 00:01:17.986
And we saw how having one branch of
your condition resolve out to never,

20
00:01:17.986 --> 00:01:22.699
that allows you to do some
really interesting things.

21
00:01:22.699 --> 00:01:25.699
We introduced the infer keyword and

22
00:01:25.699 --> 00:01:31.402
we built a utility type to extract
an argument out of a constructor.

23
00:01:31.402 --> 00:01:35.760
And we looked at the example of something
like a Webpack config where it's

24
00:01:35.760 --> 00:01:38.654
a meaningful type that adds
a lot of value to you.

25
00:01:38.654 --> 00:01:41.803
But if you didn't have
access to it directly,

26
00:01:41.803 --> 00:01:46.806
you could kind of suck it up with a vacuum
and put it where you wanna put it and

27
00:01:46.806 --> 00:01:50.230
refer to it just as if it
were an export interface.

28
00:01:50.230 --> 00:01:54.417
Index access types, this was just
a little square bracket notation for

29
00:01:54.417 --> 00:01:56.453
grabbing like a sub part of a type.

30
00:01:56.453 --> 00:02:01.619
And then finally, this was the big
thing we were sort of working our

31
00:02:01.619 --> 00:02:07.810
way up to mapped types and that's the
thing that looks like an index signature.

32
00:02:07.810 --> 00:02:12.454
But we can imagine like we have a lot more
control, hopefully you see now where we

33
00:02:12.454 --> 00:02:16.563
can loop over all of the keys and
a type or all of some other key, right?

34
00:02:16.563 --> 00:02:22.549
Any union type that is based
off of allowable property keys.

35
00:02:22.549 --> 00:02:26.924
And we can combine this with index
access types, with conditional types,

36
00:02:26.924 --> 00:02:29.086
with those template literal types.

37
00:02:29.086 --> 00:02:36.549
And in a very powerful way transform one
piece of type information to another.

38
00:02:36.549 --> 00:02:39.984
So I hope by the end of this you
feel more confident working with

39
00:02:39.984 --> 00:02:42.180
type information how to pick it apart.

40
00:02:42.180 --> 00:02:44.220
You know how to debug it a little bit.

41
00:02:44.220 --> 00:02:47.322
And hopefully this will set
you on a great path for

42
00:02:47.322 --> 00:02:50.280
your continued learning around TypeScript.

