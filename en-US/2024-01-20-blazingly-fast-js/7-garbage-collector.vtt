WEBVTT

1
00:00:00.260 --> 00:00:03.001
All right, I'm gonna let this go all
the way up till about 2000. 2 runs through.

2
00:00:03.001 --> 00:00:03.860
There we go.

3
00:00:03.860 --> 00:00:06.386
I'm gonna kill those two things,
I'm gonna do one more test,

4
00:00:06.386 --> 00:00:07.680
we're gonna go up to 2000.

5
00:00:07.680 --> 00:00:10.232
I'm gonna do 2000, awesome.

6
00:00:10.232 --> 00:00:11.772
Make sure you don't have
an inspect flag on.

7
00:00:11.772 --> 00:00:14.663
If you have the Inspect flag on,
well, that's just gonna suck.

8
00:00:14.663 --> 00:00:15.601
So, [LAUGH] don't do that.

9
00:00:15.601 --> 00:00:20.456
All right, and so I'm gonna take that.

10
00:00:20.456 --> 00:00:25.568
One more, put a two there so we're at
2000 and let's see how bad this one is.

11
00:00:25.568 --> 00:00:30.844
It's looking a lot better than it was last
time but we just got started running so

12
00:00:30.844 --> 00:00:35.831
we'll see what happens as all the games
really get running around in here.

13
00:00:35.831 --> 00:00:40.817
I mean it looks a lot better,
it currently looks a lot better.

14
00:00:40.817 --> 00:00:42.665
I'm not saying it
actually is a lot better.

15
00:00:44.934 --> 00:00:48.263
But it looks a lot better, okay.

16
00:00:49.433 --> 00:00:52.214
I mean,
I don't wanna claim victory yet, but

17
00:00:52.214 --> 00:00:57.343
I'm just saying we're looking a lot
faster, at least in our upper bound.

18
00:00:57.343 --> 00:01:00.499
In our lower bound,
did we really make an improvement?

19
00:01:00.499 --> 00:01:04.431
31 versus pretty much 31.

20
00:01:04.431 --> 00:01:06.036
I mean, that could be error.

21
00:01:06.036 --> 00:01:07.518
That could be a local host.

22
00:01:07.518 --> 00:01:09.512
I would just chalk that up to nothing,
right?

23
00:01:09.512 --> 00:01:11.772
I would just say, that's not a W.

24
00:01:11.772 --> 00:01:16.783
I'd even be pretty hesitant to
call this one a W, a 36 to a 32.

25
00:01:16.783 --> 00:01:20.474
I'm pretty hesitant about that one because
I don't know what the error rate is.

26
00:01:20.474 --> 00:01:23.117
We, again, this isn't a long test.

27
00:01:23.117 --> 00:01:26.328
Again, I have Chrome
inspector window open.

28
00:01:26.328 --> 00:01:27.949
I have LSPs running.

29
00:01:27.949 --> 00:01:31.866
I don't know what percent
different this could make.

30
00:01:31.866 --> 00:01:37.916
As far as this one goes, maybe we got
something there on the upper end.

31
00:01:37.916 --> 00:01:45.492
We're looking a bit healthier, cuz we went
from 43, we went from 62, 63% to about 43.

32
00:01:45.492 --> 00:01:50.279
So probably something there,
I think we can probably safely say that

33
00:01:50.279 --> 00:01:54.226
this optimization actually
made a difference here.

34
00:01:54.226 --> 00:01:58.079
Now, I haven't been following along here
and so I probably missed a bunch of things

35
00:01:58.079 --> 00:02:01.160
that I was supposed to say to you and
these really great ideas such as

36
00:02:01.160 --> 00:02:03.873
you probably should have made
this on a different branch.

37
00:02:03.873 --> 00:02:04.569
All these changes.

38
00:02:04.569 --> 00:02:05.285
So we're gonna do that.

39
00:02:05.285 --> 00:02:07.656
We're gonna check out a different
branch and make all those changes.

40
00:02:08.876 --> 00:02:12.050
You are probably impressed
by my Vim skills by the way,

41
00:02:12.050 --> 00:02:15.293
if you wanna check out a super
cool vim course on frontend

42
00:02:15.293 --> 00:02:19.278
masters.com not slash trial,
this one's not free.

43
00:02:19.278 --> 00:02:20.898
Check it out, it's there.

44
00:02:20.898 --> 00:02:23.008
It's how I approach Vim.

45
00:02:23.008 --> 00:02:24.258
It's still awesome, not free.

46
00:02:25.418 --> 00:02:26.738
We also did this.

47
00:02:26.738 --> 00:02:31.438
I even talk about how I really,
really messed that one up, all right.

48
00:02:31.438 --> 00:02:32.814
And we check the performance tab.

49
00:02:32.814 --> 00:02:33.659
Everything's looking good.

50
00:02:33.659 --> 00:02:34.901
We check the practical one.

51
00:02:34.901 --> 00:02:39.681
We do see a slight win in the practical
one potentially it looks like there's

52
00:02:39.681 --> 00:02:40.811
a there.

53
00:02:40.811 --> 00:02:43.684
Again, we're not in production, but

54
00:02:43.684 --> 00:02:47.960
I'm confident to say that
something probably is better.

55
00:02:47.960 --> 00:02:48.676
So there we go.

56
00:02:48.676 --> 00:02:50.199
Sorry, I forgot I did all this stuff.

57
00:02:50.199 --> 00:02:50.953
What do we do now?

58
00:02:50.953 --> 00:02:52.085
Bathroom break?

59
00:02:52.085 --> 00:02:54.939
I really feel like we gotta keep going for
a moment because we're not quite there

60
00:02:54.939 --> 00:02:57.705
unless, if you guys really have
to use the bathroom break.

61
00:02:57.705 --> 00:02:58.991
No, okay.
We gotta keep going, okay?

62
00:02:58.991 --> 00:03:01.093
I think we need to do more profiling,
okay?

63
00:03:01.093 --> 00:03:02.633
I just feel it in my bones.

64
00:03:02.633 --> 00:03:05.652
So before we do that, I'm gonna jump
over here and I'm gonna go like this.

65
00:03:05.652 --> 00:03:07.486
Get status,
I'm gonna add these things here.

66
00:03:07.486 --> 00:03:11.329
I'm gonna check out fo for
first optimization so

67
00:03:11.329 --> 00:03:15.357
I can kinda store it for
later cuz I want to do the next

68
00:03:15.357 --> 00:03:19.739
optimization again off of
our kinda base project.

69
00:03:19.739 --> 00:03:23.707
And that way we can kind of try putting
them together to see what happens and

70
00:03:23.707 --> 00:03:26.519
see is there some sort
of multiplying effect?

71
00:03:26.519 --> 00:03:28.719
Are we actually perceiving a real win?

72
00:03:28.719 --> 00:03:32.319
Maybe one win causes another
win to be way better.

73
00:03:32.319 --> 00:03:34.319
It just doesn't look better by itself.

74
00:03:34.319 --> 00:03:35.311
So let's find out, all right.

75
00:03:35.311 --> 00:03:37.885
So git status, git commit.

76
00:03:37.885 --> 00:03:40.657
First W of the day, let's go.

77
00:03:40.657 --> 00:03:44.458
All right, git checkout master,
git checkout -b second option,

78
00:03:44.458 --> 00:03:46.599
there we go, we're are looking good.

79
00:03:46.599 --> 00:03:49.609
So now we're branched of master again and
we can go back here and we can do that.

80
00:03:49.609 --> 00:03:52.438
But before we go on I
wanna give you a brief and

81
00:03:52.438 --> 00:03:56.963
entirely too short introduction
into the garbage collector, okay.

82
00:03:56.963 --> 00:03:59.617
This is really important
information that you should know.

83
00:03:59.617 --> 00:04:04.578
There's a really awesome blog
post called Trash Talk on V8 it

84
00:04:04.578 --> 00:04:09.634
goes over what is the name of the GC
in my head I've lost the name

85
00:04:09.634 --> 00:04:15.314
of their they have code names for
all their all their projects.

86
00:04:15.314 --> 00:04:18.086
I know it ends in o n o I just
can't remember the first part.

87
00:04:18.086 --> 00:04:19.756
It starts with an O, ends in an O.

88
00:04:19.756 --> 00:04:22.631
Anyways, so
these are gonna be V8 specific features.

89
00:04:22.631 --> 00:04:26.738
These are not JSC specific features,
which means that if you do this with BUN,

90
00:04:26.738 --> 00:04:29.054
you'll have slightly different results.

91
00:04:29.054 --> 00:04:32.692
I assume they have the same
style of garbage collector, but

92
00:04:32.692 --> 00:04:34.086
I don't really know.

93
00:04:35.166 --> 00:04:37.523
All right, so let's look at
this following code right here.

94
00:04:37.523 --> 00:04:44.563
Which is just let a is an object, b is
an array with a in it, c has a ref to a.

95
00:04:44.563 --> 00:04:48.953
Really what's happening underneath the
hood is that there exists this object a.

96
00:04:48.953 --> 00:04:52.996
And maybe the bookkeeping is attached
in some sort of wrapper class to a,

97
00:04:52.996 --> 00:04:56.893
maybe it's allocated behind a and
how they do their memory stuff.

98
00:04:56.893 --> 00:05:00.739
I'm I don't exactly know how they do it,
but in some sense there is some amount of

99
00:05:00.739 --> 00:05:04.187
bookkeeping to be able to make sure
that when a is created, they know a has

100
00:05:04.187 --> 00:05:08.122
a reference to it, or someone's pointing
to it when they walk through the graph.

101
00:05:08.122 --> 00:05:11.792
It has some sort of determined
location somewhere in the memory,

102
00:05:11.792 --> 00:05:16.213
in the nursery really when it begins with,
and so they're all pointing to it.

103
00:05:16.213 --> 00:05:19.729
Then at some point everyone
should inherently understand this

104
00:05:19.729 --> 00:05:22.507
because we've all done
something like this.

105
00:05:22.507 --> 00:05:26.338
We've set a property on a and
it's reflected in b's first element in

106
00:05:26.338 --> 00:05:31.026
the array, in c's child item inside the
object, you kind of understand inherently

107
00:05:31.026 --> 00:05:36.157
that there's pointers somewhere in
here that everything is pointing to.

108
00:05:36.157 --> 00:05:39.569
So now, but what happens when we do this?

109
00:05:39.569 --> 00:05:41.089
a becomes undefined.

110
00:05:41.089 --> 00:05:42.929
b, we execute pop.

111
00:05:42.929 --> 00:05:44.629
c, we delete a ref.

112
00:05:44.629 --> 00:05:45.699
What happens?

113
00:05:45.699 --> 00:05:50.353
Well, our dead b, our original addressed
object, has been completely abandoned.

114
00:05:50.353 --> 00:05:52.429
Nothing is pointing to it.

115
00:05:52.429 --> 00:05:54.837
Well, GC needs to happen.

116
00:05:54.837 --> 00:05:56.312
So there's two types of GCs.

117
00:05:56.312 --> 00:05:58.611
First, there is something called a major,

118
00:05:58.611 --> 00:06:02.470
which walks all of everything inside
the heap, starting from the roots.

119
00:06:02.470 --> 00:06:04.255
It's typically considered slow.

120
00:06:04.255 --> 00:06:05.787
It's gonna check exhaustively.

121
00:06:05.787 --> 00:06:09.431
It also performs compaction in
case pages get too fragmented.

122
00:06:09.431 --> 00:06:10.790
It does a lot of stuff.

123
00:06:10.790 --> 00:06:12.046
Then there's minors.

124
00:06:12.046 --> 00:06:16.964
Minors only walk from special
roots to check for new objects,

125
00:06:16.964 --> 00:06:21.327
and so V8 has what is referred
to as a generational GC.

126
00:06:22.877 --> 00:06:27.117
Typically, the major one is
called marking and sweeping.

127
00:06:27.117 --> 00:06:29.357
And so
you can kinda think of it in this example.

128
00:06:29.357 --> 00:06:32.183
Say we have this little
piece of HTML here,

129
00:06:32.183 --> 00:06:36.577
greatest programming language ever,
and we create a and b.

130
00:06:36.577 --> 00:06:40.604
Those are actually attached the window
object you may have forgot this.

131
00:06:40.604 --> 00:06:44.721
A lot of people probably have forgot this
but if you just raw dog a script in HTML,

132
00:06:44.721 --> 00:06:48.601
whatever variable you create actually
get attached to the window object.

133
00:06:48.601 --> 00:06:51.638
It's kind of one of those things you
forget when you've been working in this

134
00:06:51.638 --> 00:06:53.685
module system for so long,
but this just happens.

135
00:06:53.685 --> 00:06:59.254
So a and b are on the window and
at some point we said to b to undefined.

136
00:06:59.254 --> 00:07:04.613
All right, so that means window
has a reference to b and a.

137
00:07:04.613 --> 00:07:06.927
When a GC happens,
before we set b to undefined,

138
00:07:06.927 --> 00:07:10.765
it will start at the window object, and
it's gonna crawl all of its references,

139
00:07:10.765 --> 00:07:13.710
which means it eventually will say,
hey, I'm gonna mark b.

140
00:07:13.710 --> 00:07:14.486
I found b.

141
00:07:14.486 --> 00:07:15.566
Hey, I'm gonna mark a.

142
00:07:15.566 --> 00:07:17.304
I have found a.

143
00:07:17.304 --> 00:07:19.164
Okay, nothing I need to clean up.

144
00:07:19.164 --> 00:07:22.555
We set b to undefined and
so now we start another GC.

145
00:07:22.555 --> 00:07:23.817
It goes to the window object.

146
00:07:23.817 --> 00:07:26.091
It's able to reach a,
but b has been unmarked.

147
00:07:26.091 --> 00:07:27.790
It is able to be cleaned up.

148
00:07:27.790 --> 00:07:29.879
It's able to be added to the free list.

149
00:07:29.879 --> 00:07:32.435
That's how they kinda keep track of all
the little holes is they have something

150
00:07:32.435 --> 00:07:34.266
called a free list,
which we will actually get back to.

151
00:07:34.266 --> 00:07:37.002
There's a really cool
technique I haven't tried but

152
00:07:37.002 --> 00:07:39.322
I really want to try on
making things faster.

153
00:07:40.422 --> 00:07:44.482
All right, lastly, so
that's kinda the basics of a major GC.

154
00:07:44.482 --> 00:07:47.542
Crawls finds objects that
are still there and marks them.

155
00:07:47.542 --> 00:07:49.242
Everything else gets the sweep.

156
00:07:49.242 --> 00:07:51.532
Compaction, this is
directly from the blog.

157
00:07:51.532 --> 00:07:56.028
A major GC also chooses to evacuate slash
compact some pages based on fragmentation

158
00:07:56.028 --> 00:07:57.157
heuristics.

159
00:07:57.157 --> 00:08:01.237
You can think of compaction like hard
disk defragmentation of an old PC.

160
00:08:01.237 --> 00:08:02.767
Zoomers confused right now.

161
00:08:02.767 --> 00:08:03.687
I get it.

162
00:08:03.687 --> 00:08:07.512
We copy surviving objects into pages that
are not currently being compacted using

163
00:08:07.512 --> 00:08:08.417
a free list.

164
00:08:08.417 --> 00:08:10.695
And that way we can make
use of the small and

165
00:08:10.695 --> 00:08:14.917
scattered gaps within memory
left behind by dead objects.

166
00:08:14.917 --> 00:08:16.516
Okay, so that's just directly from them.

167
00:08:16.516 --> 00:08:19.747
If you don't know what that means,
it just means that at some point,

168
00:08:19.747 --> 00:08:22.477
some pages are gonna have a bunch
of just holes in them and so

169
00:08:22.477 --> 00:08:24.256
probably need to be cleaned up.

170
00:08:24.256 --> 00:08:27.172
So we can move all those objects out,
put them into other pages so

171
00:08:27.172 --> 00:08:29.278
that way they start filling all the holes,
and

172
00:08:29.278 --> 00:08:32.896
then now we have a clean page in which we
can just start freshly allocating from.

173
00:08:33.896 --> 00:08:36.993
All right, a minor GC,
this one also called a scavenge.

174
00:08:36.993 --> 00:08:40.884
This is a second form of GC, and
it follows the generational hypothesis,

175
00:08:40.884 --> 00:08:43.727
which basically states that
most objects die young.

176
00:08:43.727 --> 00:08:47.616
In other words, JavaScript
programmers create a lot of garbage.

177
00:08:47.616 --> 00:08:49.648
And most objects are allocated and

178
00:08:49.648 --> 00:08:54.215
then almost immediately become unreachable
from the perspective of the GC.

179
00:08:54.215 --> 00:08:56.477
This is, again, a direct quote from V8's

180
00:08:56.477 --> 00:09:01.047
trash talk, again, an amazing article
to go read it goes quite detailed.

181
00:09:01.047 --> 00:09:02.694
There's also a YouTube video,

182
00:09:02.694 --> 00:09:06.608
which is really really good from EU
2018 I believe or no to you 2018.

183
00:09:06.608 --> 00:09:10.249
Very, very good talk about
how the GC effectively works.

184
00:09:10.249 --> 00:09:13.170
And so a minor GCs are pretty
complicated in some sense,

185
00:09:13.170 --> 00:09:16.354
because they use a couple of
techniques that are different.

186
00:09:16.354 --> 00:09:20.956
And so, one thing they do is they have
a different set of roots to calculate, but

187
00:09:20.956 --> 00:09:23.511
only half of the memory
is used in a minor GC.

188
00:09:23.511 --> 00:09:27.150
So they have something called a from
space and something called a to space.

189
00:09:27.150 --> 00:09:30.746
And so, what they do is every object
they can reach in the from space or

190
00:09:30.746 --> 00:09:34.095
the place that they currently
have been allocating objects in,

191
00:09:34.095 --> 00:09:36.637
they copy them over one at
a time to the to space and

192
00:09:36.637 --> 00:09:40.535
update any pointers that refine
the same object with a back ref to it.

193
00:09:40.535 --> 00:09:44.120
It's pretty complicated and now the to
space has all the live objects and

194
00:09:44.120 --> 00:09:47.705
all the ones that were unreachable
are simply just deleted.

195
00:09:47.705 --> 00:09:50.268
Or really they just probably
are just not referenced anymore and

196
00:09:50.268 --> 00:09:52.355
they get overwritten as
new objects come in.

197
00:09:52.355 --> 00:09:57.006
And so they just do this thing back and
forth where half the memory is used,

198
00:09:57.006 --> 00:09:58.956
half of it is for the next GC, so

199
00:09:58.956 --> 00:10:03.333
all live objects just keep on getting
half between these two things.

200
00:10:04.483 --> 00:10:08.643
So to recap GC is to stop the world one,
crawl everything.

201
00:10:08.643 --> 00:10:10.023
They're typically more rare.

202
00:10:10.023 --> 00:10:13.452
They usually take significantly
longer than a minor GC.

203
00:10:13.452 --> 00:10:15.259
They may have to do some compacting and

204
00:10:15.259 --> 00:10:18.768
other kind of memory management's
stuff minors typically pretty fast.

205
00:10:18.768 --> 00:10:20.304
There's something called a nursery or

206
00:10:20.304 --> 00:10:22.454
young generation and
they happen pretty frequently.

207
00:10:22.454 --> 00:10:25.894
Like if we do a dash dash trace
dash GC on our node process,

208
00:10:25.894 --> 00:10:29.854
you'll actually see it spit out
scavenged GC pretty regularly.

209
00:10:30.924 --> 00:10:33.164
And so how does the generational one work?

210
00:10:33.164 --> 00:10:36.203
Effectively, when you have a bunch
of objects in your from space and

211
00:10:36.203 --> 00:10:39.401
they get copied over to the to space
they get marked with something and so

212
00:10:39.401 --> 00:10:41.772
they're considered
an intermediate aged object.

213
00:10:41.772 --> 00:10:45.463
When it does it again if they contain
a mark they'll be moved into the old

214
00:10:45.463 --> 00:10:46.210
generation.

215
00:10:46.210 --> 00:10:49.031
The old generation is the one
that's cleaned up by the major GC,

216
00:10:49.031 --> 00:10:51.709
the minor ones are all cleaned
up with the young generation.

217
00:10:51.709 --> 00:10:55.681
And there's a whole bunch of
multi-threading parallelism that is added

218
00:10:55.681 --> 00:10:58.639
to both minor and
major that make it really fast.

219
00:10:58.639 --> 00:11:02.806
So really think about what that means
because if you have a garbage collector

220
00:11:02.806 --> 00:11:07.037
that is very, very multi-threaded and
you're running on a two core machine

221
00:11:07.037 --> 00:11:10.032
that's also accepting
a bunch of internet requests,

222
00:11:10.032 --> 00:11:13.509
you're probably gonna have
some competition going on.

223
00:11:13.509 --> 00:11:17.500
You may not be able to achieve as good of
performance cuz on my machine there's six

224
00:11:17.500 --> 00:11:18.635
cores, right?

225
00:11:18.635 --> 00:11:20.805
On the EC2 instance that you're using,

226
00:11:20.805 --> 00:11:25.148
there might not be six cores and really
amazing silicon and the latest technology.

227
00:11:25.148 --> 00:11:28.094
It might be pretty commodity-based and
it may not run nearly as fast.

228
00:11:28.094 --> 00:11:32.707
So GCs can have a disproportional
effect if you don't have as much freely

229
00:11:32.707 --> 00:11:34.380
available compute time.

230
00:11:34.380 --> 00:11:38.203
That's why clients tend to experience
little stutter from GCs, but you can see

231
00:11:38.203 --> 00:11:42.380
GCs disproportionately affecting servers,
especially when you run in production.

232
00:11:42.380 --> 00:11:45.677
Some of the best changes I've ever made
have been just less GCs on a server

233
00:11:45.677 --> 00:11:49.410
because it's just that the instance was
small enough that it greatly affected how

234
00:11:49.410 --> 00:11:52.083
the network and
everything interplayed with each other.

235
00:11:52.083 --> 00:11:54.372
Here's a cool picture from
the talk that's linked.

236
00:11:54.372 --> 00:11:59.012
You can actually see that it just spawns a
whole bunch of background, marking threads

237
00:11:59.012 --> 00:12:03.535
before it does any of these activities so
it can do them all in super parallel.

238
00:12:03.535 --> 00:12:04.103
So again,

239
00:12:04.103 --> 00:12:09.185
less availability you have probably
the longer these things are gonna take.

240
00:12:09.185 --> 00:12:10.111
All right, so there you go.

241
00:12:10.111 --> 00:12:11.274
That's like a brief introduction.

242
00:12:11.274 --> 00:12:16.205
So when you make two squiggly braces when
you make a simple object hopefully that

243
00:12:16.205 --> 00:12:17.392
makes you go okay.

244
00:12:17.392 --> 00:12:22.102
I am having impact on my program,
maybe not right where I'm doing it.

245
00:12:22.102 --> 00:12:24.631
It can be impacted somewhere
completely different.

