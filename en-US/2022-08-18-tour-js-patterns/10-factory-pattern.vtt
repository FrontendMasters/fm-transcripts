WEBVTT

1
00:00:00.210 --> 00:00:04.610
So the factory pattern is a pattern
that uses a special function.

2
00:00:04.610 --> 00:00:07.460
And this function is called
the factory function.

3
00:00:07.460 --> 00:00:09.587
And we can use this function which
in JavaScript is pretty easy.

4
00:00:09.587 --> 00:00:13.331
It's just like an arrow function to
create many of the same objects.

5
00:00:13.331 --> 00:00:15.879
We know all the properties
that is going to have and

6
00:00:15.879 --> 00:00:17.516
then based on what we pass to it,

7
00:00:17.516 --> 00:00:22.000
maybe we add some more properties, maybe
we I change them a little bit, and so on.

8
00:00:22.000 --> 00:00:24.650
So like here we're creating
two users like John and Sarah.

9
00:00:24.650 --> 00:00:26.620
Now, we only pass the first name and
last name.

10
00:00:26.620 --> 00:00:30.970
But the object that we create also
contains the ID, created ads, and

11
00:00:30.970 --> 00:00:34.354
the full name based on
the properties that we passed.

12
00:00:34.354 --> 00:00:38.150
Yeah, like I said, it's pretty simple in
JavaScript to create a factory function.

13
00:00:38.150 --> 00:00:41.331
This pattern is really more for languages
that don't really have built in objects.

14
00:00:41.331 --> 00:00:44.777
So it's more difficult to create
many objects of the same type, but

15
00:00:44.777 --> 00:00:47.800
luckily in JavaScript,
we can just use an arrow function or

16
00:00:47.800 --> 00:00:50.043
a regular function that returns an object.

17
00:00:53.045 --> 00:00:57.823
Okay, so the trade offs for the factory
pattern is that we don't have to recreate

18
00:00:57.823 --> 00:01:01.073
the same object or
type the same object out every time.

19
00:01:01.073 --> 00:01:04.200
We will also see this in
the exercise later on.

20
00:01:04.200 --> 00:01:07.790
So we can just easily create many of
the same objects with just a one liner.

21
00:01:07.790 --> 00:01:10.012
We just have to say create user,
create your user,

22
00:01:10.012 --> 00:01:13.380
create user instead of having
that user object every time.

23
00:01:13.380 --> 00:01:15.500
But yeah, like I said, in JavaScript,
it's not really a pattern.

24
00:01:15.500 --> 00:01:18.568
I see there's an overflow here.

25
00:01:18.568 --> 00:01:22.010
Now, we will go into the prototype
pattern a bit later,

26
00:01:22.010 --> 00:01:26.919
which actually shows that this pattern
is not very memory efficient, maybe you

27
00:01:26.919 --> 00:01:32.217
should try to avoid it if you're actually
creating a really large amount of objects.

28
00:01:32.217 --> 00:01:35.258
But we will cover that in
the prototype pattern.

29
00:01:35.258 --> 00:01:35.763
So yeah,

30
00:01:35.763 --> 00:01:39.680
just to recap all it does is we just
have a function that returns an object,

31
00:01:39.680 --> 00:01:44.180
that's the vector pattern, and that
function is called a factory function.

32
00:01:44.180 --> 00:01:47.332
So when we look at the exercise here,
you see that we have many books.

33
00:01:47.332 --> 00:01:51.380
We have Harry Potter,
a Great Gatsby and all this stuff.

34
00:01:51.380 --> 00:01:55.440
And in index, I guess, yeah,
we're logging all of those books.

35
00:01:55.440 --> 00:02:01.087
But in this case, so we create it,
explicitly created all of these objects.

36
00:02:01.087 --> 00:02:05.228
So the exercise here is to create
a factory function instead that

37
00:02:05.228 --> 00:02:09.530
returns a book, instead of having
to write those books like this.

