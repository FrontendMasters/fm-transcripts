WEBVTT

1
00:00:00.000 --> 00:00:02.982
&gt;&gt; Mike: We also got something
called destructured assignment, and

2
00:00:02.982 --> 00:00:06.791
this is a rather complex example just
to show, like, the power of this idea.

3
00:00:06.791 --> 00:00:11.580
But say we have a value here, person,
which is a pretty deeply nested object and

4
00:00:11.580 --> 00:00:14.728
sorry for
the unconventional formatting here, but

5
00:00:14.728 --> 00:00:17.469
hopefully you get the idea
of the outlining.

6
00:00:17.469 --> 00:00:19.058
And then on the bottom,

7
00:00:19.058 --> 00:00:24.551
we are basically trying to capture values
that exist deep within this structure.

8
00:00:24.551 --> 00:00:29.292
And, we can capture one or more values at

9
00:00:29.292 --> 00:00:34.037
the same time in one statement, right?

10
00:00:34.037 --> 00:00:40.340
So, in this case, just reading
the second let here, we're saying first,

11
00:00:40.340 --> 00:00:46.248
well sorry, we're saying to begin I
wish to go into this name object and

12
00:00:46.248 --> 00:00:51.587
go and grab me whatever value is
there under the property first.

13
00:00:51.587 --> 00:00:55.565
And then go into the languages object and

14
00:00:55.565 --> 00:01:01.302
into the backend object, and
get me that backend object.

15
00:01:01.302 --> 00:01:07.266
And I want to assign that to
a variable called serverSkills.

16
00:01:07.266 --> 00:01:11.494
So we do that all in one statement here.

17
00:01:11.494 --> 00:01:13.809
So effectively, we'd be able to
log out something like this.

18
00:01:13.809 --> 00:01:19.279
So we're logging out the thing we
got under the value of name first.

19
00:01:19.279 --> 00:01:24.935
And then,
the keys available on language's backend,

20
00:01:24.935 --> 00:01:28.795
and that's where we get elixir from.

21
00:01:28.795 --> 00:01:31.376
But that's the idea of
destructured assignment, and

22
00:01:31.376 --> 00:01:34.926
if you've used a language that had
something like pattern matching in it.

23
00:01:34.926 --> 00:01:38.980
You could think of it just as,
during assignment,

24
00:01:38.980 --> 00:01:44.449
we basically try to make, try to look
at the structure on the right and

25
00:01:44.449 --> 00:01:49.824
the left and figure out a way that
assignments can be made such that,

26
00:01:49.824 --> 00:01:55.613
we can have the stuff on the left
captures values from stuff on the right.

27
00:01:55.613 --> 00:01:58.628
Yes?
&gt;&gt; Speaker 2: So name and languages would

28
00:01:58.628 --> 00:02:02.024
not be accessible as variables?
&gt;&gt; Mike: Correct.

29
00:02:02.024 --> 00:02:04.749
Name and languages would not
be accessible as variables.

30
00:02:04.749 --> 00:02:10.338
They are simply there to define
structure of where I'm looking to go and

31
00:02:10.338 --> 00:02:11.744
grab variables.

32
00:02:11.744 --> 00:02:16.360
And the reason you know that
is because it's a key, right?

33
00:02:16.360 --> 00:02:18.361
There's a colon to the right of it,

34
00:02:18.361 --> 00:02:22.248
as opposed to places where I'm
capturing things, or there isn't.

35
00:02:22.248 --> 00:02:27.416
The exception being backend
where I'm basically aliasing it.

36
00:02:27.416 --> 00:02:31.259
If I didn't have serverSkills and
I deleted the column to the right of

37
00:02:31.259 --> 00:02:34.587
backend, I'd have a variable
that I could use as backend.

38
00:02:34.587 --> 00:02:36.600
So that's just the optional
renaming at work.

