WEBVTT

1
00:00:00.420 --> 00:00:03.630
&gt;&gt; Maximiliano Firtman: Arrow functions,
there are people that right now

2
00:00:03.630 --> 00:00:06.688
are actually really fans
of arrow functions and

3
00:00:06.688 --> 00:00:11.505
they're using arrow functions as much
as they can because they feel like,

4
00:00:11.505 --> 00:00:15.730
they're cool guys, okay,
if they're using arrow functions.

5
00:00:15.730 --> 00:00:20.303
But you shouldn't be using arrow functions
always because arrow functions works

6
00:00:20.303 --> 00:00:21.603
differently.

7
00:00:21.603 --> 00:00:25.486
So you should understand the difference
between a normal function and

8
00:00:25.486 --> 00:00:29.333
an arrow function, and
use it whenever you feel it should work.

9
00:00:29.333 --> 00:00:34.013
So the idea is that here you have a couple
of examples just to render quickly.

10
00:00:34.013 --> 00:00:37.920
So let's analyze first the first one,
it's multiply variable.

11
00:00:37.920 --> 00:00:41.743
Yeah, that's fine,
you can do that with a function A and B.

12
00:00:41.743 --> 00:00:46.821
So instead of using the function I can
get out of the function keyword and

13
00:00:46.821 --> 00:00:50.726
replace that with this with the arrow,
the fat arrow.

14
00:00:50.726 --> 00:00:57.431
That's the name of this operator, the fat
arrow, because this is the thin arrow and

15
00:00:57.431 --> 00:01:03.038
this is the fat arrow, and
then we pass a block which is okay.

16
00:01:03.038 --> 00:01:05.668
But there are other advantages
of using arrow functions.

17
00:01:05.668 --> 00:01:09.395
For example, one advantage is
that if you have only one line,

18
00:01:09.395 --> 00:01:11.338
you don't need the code block.

19
00:01:12.818 --> 00:01:15.368
Okay, you don't need it.

20
00:01:15.368 --> 00:01:20.091
And also, when you don't have a code
block, when you don't have curly braces,

21
00:01:20.091 --> 00:01:22.638
you have an implicit return.

22
00:01:22.638 --> 00:01:24.958
So I don't need the return keyword.

23
00:01:24.958 --> 00:01:26.368
I can write this like this.

24
00:01:28.748 --> 00:01:31.988
Which for this particular example,
it's pretty cool.

25
00:01:31.988 --> 00:01:33.538
I'm still seeing the 12 here.

26
00:01:33.538 --> 00:01:40.729
So we can see here this is multiply output
so we can see that, okay, this one.

27
00:01:40.729 --> 00:01:44.244
And it works, okay, nothing fancy.

28
00:01:44.244 --> 00:01:45.900
I'm pretty sure that you have seen this.

29
00:01:45.900 --> 00:01:50.431
I have a same example here with dividing,
okay?

30
00:01:50.431 --> 00:01:54.633
So that's the first part
of the arrow functions.

31
00:01:54.633 --> 00:01:59.801
If you don't have any arguments, which is
not the case here, but if I have here.

32
00:01:59.801 --> 00:02:06.541
So another function without arguments,
you just use empty parentheses.

33
00:02:06.541 --> 00:02:12.556
And if you have only one argument, for
example, I will say, I will add 1 to x.

34
00:02:12.556 --> 00:02:17.212
If you have only one arguments,
you don't need the parentheses,

35
00:02:17.212 --> 00:02:19.467
only with one argument, okay?

36
00:02:19.467 --> 00:02:23.970
It's just the only syntax issue here.

37
00:02:23.970 --> 00:02:29.295
And something that is typically important
when talking about arrow functions,

38
00:02:29.295 --> 00:02:31.663
there are many differences.

39
00:02:31.663 --> 00:02:35.073
As I mentioned before,
the arguments object is different.

40
00:02:36.363 --> 00:02:41.535
In a traditional function, you have
an argument that is actually this one.

41
00:02:41.535 --> 00:02:48.735
Okay, so show arguments is stringifying
the arguments output that we have here.

42
00:02:48.735 --> 00:02:51.800
And when you have arrow functions,
the arguments,

43
00:02:51.800 --> 00:02:54.315
objects it's not actually there, okay?

44
00:02:54.315 --> 00:02:57.515
So it's not working, but that this
is kind of an advanced situation.

45
00:02:57.515 --> 00:02:59.374
I'm not sure if you have used it before.

46
00:02:59.374 --> 00:03:01.482
So without getting into that,

47
00:03:01.482 --> 00:03:06.519
let's talk about something that is
really important, that is the this.

48
00:03:06.519 --> 00:03:08.468
The this object.

49
00:03:08.468 --> 00:03:11.284
Okay, and
probably you have seen this before.

50
00:03:11.284 --> 00:03:17.971
The this in JavaScript is not
always what you think it is, okay?

51
00:03:17.971 --> 00:03:22.828
So actually,
when we are executing this, okay?

52
00:03:22.828 --> 00:03:28.537
Who is this dot count, by the way,
you're expecting to be this code.

53
00:03:28.537 --> 00:03:31.243
By the way, is ECMAScript compatible?

54
00:03:31.243 --> 00:03:32.559
What do you think?

55
00:03:32.559 --> 00:03:34.177
This is a function.

56
00:03:34.177 --> 00:03:37.897
So it's not a class, so
it is ECMAScript compatible.

57
00:03:37.897 --> 00:03:41.173
So some of you are reading this
as a class for some reason, but

58
00:03:41.173 --> 00:03:42.791
that's not the case, okay?

59
00:03:42.791 --> 00:03:45.541
But I know that it happens,
so that's what I'm saying.

60
00:03:45.541 --> 00:03:50.697
So it's a function, so yeah,
it starts at count 0, but who is this?

61
00:03:52.215 --> 00:03:53.276
&gt;&gt; Student: It's the function definition.

62
00:03:53.276 --> 00:03:55.246
&gt;&gt; Maximiliano Firtman: It's the function,

63
00:03:55.246 --> 00:03:59.302
does the function have
its own this object?

64
00:03:59.302 --> 00:04:05.971
So that's not a
class declaration.

65
00:04:05.971 --> 00:04:10.251
Actually, the real answer,
who is this right now?

66
00:04:10.251 --> 00:04:15.299
Is that we don't know because it
depends on who is executing and

67
00:04:15.299 --> 00:04:18.596
how is executing this function.

68
00:04:18.596 --> 00:04:23.366
As we are executing like this,
I also I'm creating a new counter here.

69
00:04:23.366 --> 00:04:24.476
And what is this?

70
00:04:24.476 --> 00:04:27.536
I'm creating a new counter,
but counter is a function.

71
00:04:27.536 --> 00:04:31.596
&gt;&gt; Student: The new keyword returns
the instance when it's a class,

72
00:04:31.596 --> 00:04:34.567
I don't know about when it's a function.

73
00:04:34.567 --> 00:04:37.236
&gt;&gt; Maximiliano Firtman: Well,
this is ECMAScript compatible.

74
00:04:37.236 --> 00:04:38.586
This is perfect ES5.

75
00:04:41.146 --> 00:04:44.386
Before ES6,
we didn't have the class syntax.

76
00:04:44.386 --> 00:04:45.576
We didn't have it.

77
00:04:45.576 --> 00:04:49.736
The way to create classes, as we know it
today, was with the function keyword.

78
00:04:51.266 --> 00:04:56.001
So if I execute the function like this,
this is gonna be window,

79
00:04:56.001 --> 00:04:57.503
the global option.

80
00:04:58.854 --> 00:05:03.344
If I execute the function like this,
I'm creating a new instance of counter.

81
00:05:04.364 --> 00:05:08.234
And then this is that
object that I'm creating.

82
00:05:10.274 --> 00:05:16.774
Okay, but when we are in a set interval,
that might not be the case.

83
00:05:16.774 --> 00:05:21.328
It depends if you have a function here or
an arrow function.

84
00:05:21.328 --> 00:05:25.429
So it gets complicated, and
there are plenty of other

85
00:05:25.429 --> 00:05:30.260
courses at frontier masters you
get more insight on this okay,

86
00:05:30.260 --> 00:05:36.020
to spend more time playing with this
object with JavaScript foundations.

87
00:05:36.020 --> 00:05:40.953
But let's say for now that If
you wanna make sure that we can

88
00:05:40.953 --> 00:05:45.895
change this to a class if you
feel like it's better, okay?

89
00:05:45.895 --> 00:05:49.239
For now,
because we haven't seen modern syntax,

90
00:05:49.239 --> 00:05:53.066
let's create the constructor
that set the count to zero.

91
00:05:53.066 --> 00:05:56.199
So I think that you will be
happier with this version.

92
00:05:57.389 --> 00:06:00.371
So we have a constructor
that says the count of zero.

93
00:06:00.371 --> 00:06:05.219
And then we should create a method, or
we can do this in the constructor as

94
00:06:05.219 --> 00:06:09.652
well,
&gt;&gt; Maximiliano Firtman: That every one

95
00:06:09.652 --> 00:06:14.891
second should be,
&gt;&gt; Maximiliano Firtman: Adding

96
00:06:14.891 --> 00:06:17.392
one to the counter, okay?

97
00:06:17.392 --> 00:06:21.507
So If you wanna make sure
that this is this variable.

98
00:06:21.507 --> 00:06:26.057
If you wanna make sure,
you need to use arrow functions.

99
00:06:26.057 --> 00:06:30.847
If you don't use arrow functions,
the this object can change.

100
00:06:32.737 --> 00:06:38.198
Also, again, I don't wanna get into too
much detail here on this because we have.

101
00:06:38.198 --> 00:06:41.118
We need time for a lot of other stuff,

102
00:06:41.118 --> 00:06:45.831
I'm not sure if you have seen
that when you have a function,

103
00:06:45.831 --> 00:06:51.128
you combine that function to
something else with the bind method.

104
00:06:52.528 --> 00:06:53.058
Have you seen that?

105
00:06:54.378 --> 00:06:57.338
With bind, you can change the this.

106
00:06:57.338 --> 00:07:00.587
You can change who is this for
that execution.

107
00:07:00.587 --> 00:07:05.344
But anyway, I don't wanna spend too
much time on the this object here,

108
00:07:05.344 --> 00:07:08.516
but have in mind that arrow
functions are changing

109
00:07:08.516 --> 00:07:12.583
the nature of the this object
when you are using JavaScript.

