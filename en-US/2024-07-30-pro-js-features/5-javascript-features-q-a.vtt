WEBVTT

1
00:00:00.000 --> 00:00:04.216
&gt;&gt; Audience: How long after ECMA
introduces a new feature does it take for

2
00:00:04.216 --> 00:00:06.671
TypeScript to also implement it?

3
00:00:06.671 --> 00:00:10.188
&gt;&gt; Maximiliano Firtman: So,
typically they are fast enough, and

4
00:00:10.188 --> 00:00:15.024
to be honest, there are some features,
at least today.

5
00:00:15.024 --> 00:00:20.039
Some ECMAScript new features
that are actually sometimes

6
00:00:20.039 --> 00:00:25.776
coming from TypeScript, or
they are very similar in TypeScript.

7
00:00:25.776 --> 00:00:30.262
That also adds sometimes
a challenge on the TypeScript team,

8
00:00:30.262 --> 00:00:34.404
because sometimes the ECMA,
the technical committee,

9
00:00:34.404 --> 00:00:39.073
they make a different decision
on how to implement the feature.

10
00:00:39.073 --> 00:00:43.899
So then TypeScript has a challenge
of how to support both,

11
00:00:43.899 --> 00:00:48.045
now the ECMAScript and
their own version of that.

12
00:00:48.045 --> 00:00:52.508
But typically, they are fast enough,
I don't have the explicit answer

13
00:00:52.508 --> 00:00:56.111
to say it's always like six months,
or things like that.

14
00:00:56.111 --> 00:01:00.050
But they are keeping up
to date to ECMAScript,

15
00:01:00.050 --> 00:01:04.602
most of the time,
because they tend to be a superset.

16
00:01:04.602 --> 00:01:07.818
And when you are a superset,
it's not that different language,

17
00:01:07.818 --> 00:01:10.756
it's something on top of, so
it's like a plugin on top of.

18
00:01:10.756 --> 00:01:17.111
So that's why they're typically
fast to apply these new changes.

19
00:01:17.111 --> 00:01:22.923
Also remember that when you transpile
TypeScript, you transpile into ECMAScript.

20
00:01:22.923 --> 00:01:25.749
We don't have TypeScript runtimes.

21
00:01:25.749 --> 00:01:29.898
So at the end,
the browser will be ECMAScript,

22
00:01:29.898 --> 00:01:34.895
will run ECMAScript, or
Node.js will run ECMAScript.

23
00:01:34.895 --> 00:01:36.375
Another question, yeah.

24
00:01:36.375 --> 00:01:41.465
&gt;&gt; Audience: Do you think TypeScript or
something like it will become standard?

25
00:01:41.465 --> 00:01:43.348
&gt;&gt; Maximiliano Firtman: That's
an interesting question.

26
00:01:46.179 --> 00:01:50.272
&gt;&gt; Maximiliano Firtman: So, TypeScript
becoming the standard for the web, I don't

27
00:01:50.272 --> 00:01:55.422
think it's going to happen, I think
there are a lot of people pushing that.

28
00:01:55.422 --> 00:02:00.011
I don't think it's going to happen because
we have a lot of people that thinks that

29
00:02:00.011 --> 00:02:02.605
adding types to JavaScript is a good idea,
but

30
00:02:02.605 --> 00:02:06.146
also there are a lot of people
saying that it's not a good idea.

31
00:02:06.146 --> 00:02:12.984
So it's not that 100% of the communities
is with, let's add types to JavaScript.

32
00:02:12.984 --> 00:02:17.511
So, actually Google tried
to push a new language,

33
00:02:17.511 --> 00:02:22.685
also typed language,
strict typed language for the web.

34
00:02:22.685 --> 00:02:24.251
Once, and it didn't work.

35
00:02:24.251 --> 00:02:29.612
Microsoft did that with VBScript,
it didn't work, in the 90s.

36
00:02:29.612 --> 00:02:33.955
In 2008, something around that,

37
00:02:33.955 --> 00:02:41.462
Google tried to push Dart to
replace JavaScript, it didn't work.

38
00:02:41.462 --> 00:02:46.321
So, I don't think TypeScript
will win that fight anyway.

39
00:02:46.321 --> 00:02:50.304
So I don't think it's going to happen,

40
00:02:50.304 --> 00:02:56.877
I think we will still work with
this transpiling thing for a while.

41
00:02:56.877 --> 00:03:01.708
Maybe in the future,
because now with WebAssembly, the web and

42
00:03:01.708 --> 00:03:06.641
ECMAScript or JavaScript in general,
it's more flexible now.

43
00:03:06.641 --> 00:03:10.781
So you can run Python client-side these
days, I'm not sure if you know that.

44
00:03:10.781 --> 00:03:17.384
Because you can ship your own
Python interpreter in WebAssembly.

45
00:03:17.384 --> 00:03:24.029
So then you can run,
it's kind of native Python client-side.

46
00:03:24.029 --> 00:03:28.579
And with that in mind,
you can run anything client-side,

47
00:03:28.579 --> 00:03:30.492
including TypeScript.

48
00:03:30.492 --> 00:03:35.007
So I think that maybe in the future,
that's one future,

49
00:03:35.007 --> 00:03:40.650
a way to use the language you want,
and then you just ship WebAssembly,

50
00:03:40.650 --> 00:03:44.433
or a WebAssembly interpreter,
for your code.

51
00:03:44.433 --> 00:03:47.667
Now, for example, Dart,
that's with Flutter as well,

52
00:03:47.667 --> 00:03:52.023
when you're doing Flutter apps, and
you compile to a progressive web app, so

53
00:03:52.023 --> 00:03:55.197
a web app, that web app is
using WebAssembly by default.

54
00:03:55.197 --> 00:04:00.199
So, it's not even shipping JavaScript
anymore, it's shipping WebAssembly,

55
00:04:00.199 --> 00:04:04.778
and so I think that for the future,
I think that might answer the question.

56
00:04:04.778 --> 00:04:08.562
Maybe you will be able to natively run

57
00:04:08.562 --> 00:04:13.333
TypeScript by shipping
a TypeScript engine.

58
00:04:13.333 --> 00:04:16.934
I'm not sure if that's gonna happen,
but that's a possible future.

59
00:04:16.934 --> 00:04:21.826
I don't think it's going to
become a standard, we'll see.

60
00:04:21.826 --> 00:04:26.873
&gt;&gt; Audience: I always have trouble picking
which version to transpile down to.

61
00:04:26.873 --> 00:04:28.056
How do you make that decision?

62
00:04:28.056 --> 00:04:31.059
&gt;&gt; Maximiliano Firtman: That's
a good question.

63
00:04:31.059 --> 00:04:37.036
So, which version of ECMAScript we
should be using as a target for

64
00:04:37.036 --> 00:04:38.893
shipping our code?

65
00:04:38.893 --> 00:04:42.971
I think I do have a slide for
that later, but

66
00:04:42.971 --> 00:04:47.049
let's say, five years ago, the normal,

67
00:04:47.049 --> 00:04:51.824
the standard was actually to ship to ES5,
okay?

68
00:04:51.824 --> 00:04:57.711
ES5, it's 2009, okay,
we're talking about 15 years ago.

69
00:04:57.711 --> 00:05:03.124
I think that's going
too much to be honest,

70
00:05:03.124 --> 00:05:11.038
the only browser that has
0.8% still there, it's IE11.

71
00:05:11.038 --> 00:05:16.492
Old corporate users maybe working
on some old banks somewhere,

72
00:05:16.492 --> 00:05:20.133
they're still in Windows XP with IE11.

73
00:05:20.133 --> 00:05:24.588
If you need to target those,
you will serve, unfortunately,

74
00:05:24.588 --> 00:05:26.446
ES5 is still the answer.

75
00:05:26.446 --> 00:05:29.847
For the rest, ES6 is safe.

76
00:05:29.847 --> 00:05:32.110
And I could argue that, and

77
00:05:32.110 --> 00:05:37.230
we will see that later that
these days if you target 2020,

78
00:05:37.230 --> 00:05:42.266
for example,
you're probably a 97% of the population.

79
00:05:42.266 --> 00:05:45.845
So, yeah, the problem is what
happened with the 3%, okay?

80
00:05:45.845 --> 00:05:52.616
Well, first, maybe you have to check in
your analytics, and checking your website,

81
00:05:52.616 --> 00:05:57.652
based on your audience,
which browsers they're using to see.

82
00:05:57.652 --> 00:06:02.448
Because maybe you can start working
with modern ECMAScript without

83
00:06:02.448 --> 00:06:05.483
transpilation and that's not a problem.

84
00:06:05.483 --> 00:06:10.445
Maybe, it depends on the audience
that you have, okay?

85
00:06:10.445 --> 00:06:15.427
So these days,
I will say that the three answers are,

86
00:06:15.427 --> 00:06:20.188
ES5 in the rare case that
you still need to cover all

87
00:06:20.188 --> 00:06:25.426
those enterprise users using
still CD based browsers.

88
00:06:25.426 --> 00:06:28.960
And we have ES6 if you wanna be safe,

89
00:06:28.960 --> 00:06:34.090
100% of users, normal users, or ES2020 for

90
00:06:34.090 --> 00:06:38.652
the rest if you wanna be more on the edge,
okay?

91
00:06:38.652 --> 00:06:41.176
That's if you are going
to use a transpiler,

92
00:06:41.176 --> 00:06:44.438
those are the three possibilities
that works these days.

