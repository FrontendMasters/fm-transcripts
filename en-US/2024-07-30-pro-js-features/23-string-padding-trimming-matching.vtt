WEBVTT

1
00:00:00.190 --> 00:00:02.780
&gt;&gt; Maximiliano Firtman: A string
methods is actually pretty cool,

2
00:00:02.780 --> 00:00:07.350
probably you have seen some of those or
you have used some of those.

3
00:00:07.350 --> 00:00:13.700
We have now startsWith, this is ES6 by
the way, startsWith, endsWith, includes.

4
00:00:15.350 --> 00:00:17.710
Okay, they are pretty straightforward.

5
00:00:17.710 --> 00:00:22.391
The one will check if a string starts
with an another string if it ends with

6
00:00:22.391 --> 00:00:26.013
another string, or
if it includes another substring.

7
00:00:26.013 --> 00:00:30.351
If you have been playing with
JavaScript for years, like myself,

8
00:00:30.351 --> 00:00:33.449
probably you have been
playing with index of and

9
00:00:33.449 --> 00:00:37.563
then checking if it's minus one
that minus one was giving you.

10
00:00:37.563 --> 00:00:39.573
Well, now includes it's more semantic.

11
00:00:39.573 --> 00:00:43.297
It will tell tell you if
a substring is in there.

12
00:00:43.297 --> 00:00:45.583
And also we have a repeat,
that I have it here and

13
00:00:45.583 --> 00:00:47.717
also I have it separated, I think.

14
00:00:47.717 --> 00:00:54.347
But repeat will just repeat the string
n times, again, straightforward.

15
00:00:54.347 --> 00:01:00.068
Just remember they are there, but
padding, this is new from 2017.

16
00:01:01.804 --> 00:01:06.114
We have now ways we can
take that string and

17
00:01:06.114 --> 00:01:09.808
apply, for example, padStart and

18
00:01:09.808 --> 00:01:14.611
padStart will receive a value,
a length, for

19
00:01:14.611 --> 00:01:20.187
example, I can say 5 or
I can say padEnd with 5.

20
00:01:20.187 --> 00:01:21.677
What's the difference?

21
00:01:21.677 --> 00:01:28.657
Well, here you can see I have
5 spaces before or after.

22
00:01:29.857 --> 00:01:34.507
But as you may be expecting,
just using spaces.

23
00:01:34.507 --> 00:01:37.533
I mean, it's okay, but
it's not always what you want.

24
00:01:37.533 --> 00:01:41.375
So that's why, when if you go to the
solution here, it's not a big deal anyway.

25
00:01:41.375 --> 00:01:46.022
There is a second argument
where you can specify

26
00:01:46.022 --> 00:01:49.981
the character that you want to pad with.

27
00:01:49.981 --> 00:01:55.520
So a 0, okay, dash,
&gt;&gt; Maximiliano Firtman: Or

28
00:01:55.520 --> 00:02:00.379
something like that, of course,
it can be any value here.

29
00:02:00.379 --> 00:02:02.799
Two things, two important things.

30
00:02:02.799 --> 00:02:07.111
First, the ECMAScript team
here I think they made

31
00:02:07.111 --> 00:02:10.919
a mistake with the names because padStart.

32
00:02:12.099 --> 00:02:19.548
It's actually not padStart, but padLeft,
and padEnd is actually padRight.

33
00:02:19.548 --> 00:02:24.691
What's the difference when you
are working with languages right to left,

34
00:02:24.691 --> 00:02:26.005
Hebrew, Arabic?

35
00:02:26.005 --> 00:02:32.235
Start should be from the right and
that's not how it works,

36
00:02:32.235 --> 00:02:38.725
start here is always from the left,
okay, so first warning.

37
00:02:38.725 --> 00:02:43.777
So, it should be called padLeft and
padRight, not start and end.

38
00:02:43.777 --> 00:02:45.867
But anyway, it is what it is.

39
00:02:45.867 --> 00:02:46.524
And also,

40
00:02:46.524 --> 00:02:51.207
another important thing is that what
happens if I add more characters here?

41
00:02:53.837 --> 00:02:57.869
It's not just one character,
I can add more things, and

42
00:02:57.869 --> 00:03:00.667
this is what he's going to do.

43
00:03:00.667 --> 00:03:06.127
It's padding with that pattern,
repeating the pattern, okay?

44
00:03:06.127 --> 00:03:11.483
So it's not just one character,
you can match a mix on one space for

45
00:03:11.483 --> 00:03:14.677
example,
&gt;&gt; Maximiliano Firtman: Or a dot or

46
00:03:14.677 --> 00:03:18.744
wherever, of course,
it can be any amount of characters here.

47
00:03:20.162 --> 00:03:24.945
&gt;&gt; Maximiliano Firtman: It would just
repeat that pattern in the empty space

48
00:03:24.945 --> 00:03:29.403
untill it fills the whole
width that we define.

49
00:03:29.403 --> 00:03:33.448
So trimming,
will trim the spaces at the start or

50
00:03:33.448 --> 00:03:37.394
at the end but
as we mentioned before, start and

51
00:03:37.394 --> 00:03:43.909
end here is not really taking in
consideration right to left, languages?

52
00:03:43.909 --> 00:03:49.806
And this is just the first one,
is trimming the first characters,

53
00:03:49.806 --> 00:03:52.753
actually we should one by one, so

54
00:03:52.753 --> 00:03:58.646
you can see that these spaces
are still there at the end.

55
00:03:58.646 --> 00:04:03.956
And if we do a console.log of that one,
we have this space.

56
00:04:06.456 --> 00:04:11.736
It's just that matchAll, this is bigger.

57
00:04:11.736 --> 00:04:16.539
Okay, I was actually in
the middle of adding this

58
00:04:16.539 --> 00:04:21.354
under strings, or
under regular expressions?

59
00:04:21.354 --> 00:04:25.874
Because it's a string method, but
it belongs to more the regular expression.

60
00:04:27.194 --> 00:04:30.434
I'm not sure if you have played with
regular expressions in JavaScript.

61
00:04:30.434 --> 00:04:32.925
I know that regular
expression sounds scary for

62
00:04:32.925 --> 00:04:35.194
a lot of developers on any language.

63
00:04:35.194 --> 00:04:42.658
[LAUGH] But anyway, ECMAScript already
have a match method on strings where

64
00:04:42.658 --> 00:04:48.594
you can pass the regular expression and
it will match that.

65
00:04:48.594 --> 00:04:51.688
It will try to find a substring,
or it will tell you yes or no,

66
00:04:51.688 --> 00:04:53.770
it depends on what you're looking for.

67
00:04:53.770 --> 00:04:58.182
But it was limited,
the first thing is that,

68
00:04:58.182 --> 00:05:03.058
if you wanna search you can
use regular special for

69
00:05:03.058 --> 00:05:06.791
searching patterns within a string.

70
00:05:06.791 --> 00:05:09.105
It was just returning you the first one.

71
00:05:10.205 --> 00:05:15.293
Okay, matchAll will return
a collection of all the elements that

72
00:05:15.293 --> 00:05:21.246
were found on that particular string
matching your regular expression.

73
00:05:22.416 --> 00:05:28.736
And also, now you can include
capture groups, what is that?

74
00:05:28.736 --> 00:05:31.536
Let's see with that example,
I think it will be clear.

75
00:05:31.536 --> 00:05:34.316
So let's see,
we have this string here, okay?

76
00:05:34.316 --> 00:05:38.827
So, within the string, of course,
we can use ChatGPT for this now but

77
00:05:38.827 --> 00:05:41.440
we are JavaScript developers, right?

78
00:05:41.440 --> 00:05:45.224
We want to do it ourself,
I wanna extract dates with this format.

79
00:05:45.224 --> 00:05:51.528
So, this text contains dates, so
I wanna extract them from the string.

80
00:05:51.528 --> 00:05:56.887
So then I create a regular expression
to match that particular thing.

81
00:05:56.887 --> 00:06:01.551
In this case, quickly,
it says d is a digit, so number, and

82
00:06:01.551 --> 00:06:03.384
4 means four numbers.

83
00:06:03.384 --> 00:06:07.823
So this is one group,
four numbers, another group,

84
00:06:07.823 --> 00:06:12.768
two numbers, two digits, and
another two digits, okay?

85
00:06:12.768 --> 00:06:17.190
Every parenthesis here is
creating a capture group,

86
00:06:17.190 --> 00:06:20.541
that's a regular expression concept.

87
00:06:21.591 --> 00:06:25.327
So now, I can take a text,
the text, the string, and

88
00:06:25.327 --> 00:06:28.331
matchAll using that regular expression.

89
00:06:28.331 --> 00:06:33.867
Remember in JavaScript regular
expression goes within these characters,

90
00:06:33.867 --> 00:06:39.907
okay, that's a regular expression and
actually we receive an array of matches.

91
00:06:39.907 --> 00:06:46.111
If I run this,
it's going to give me all the dates and

92
00:06:46.111 --> 00:06:49.797
also every group separately.

93
00:06:49.797 --> 00:06:52.231
The year, and by the way,

94
00:06:52.231 --> 00:06:57.672
here we can use ES6 to say
something like we wanna get.

95
00:06:57.672 --> 00:07:02.804
It from match, [fullDate,

96
00:07:02.804 --> 00:07:09.212
year, month, day] for match.

97
00:07:09.212 --> 00:07:13.853
So we can extract the data,
because it's an array,

98
00:07:13.853 --> 00:07:17.756
in case you wanna create variables, okay,

99
00:07:17.756 --> 00:07:21.778
instead of using match sub 1, match sub 2.

100
00:07:21.778 --> 00:07:29.018
So, I can extract the whole date and
each group separately, yeah.

101
00:07:30.068 --> 00:07:34.019
&gt;&gt; Speaker 2: Now could you put that
destructuring and replace it with,

102
00:07:34.019 --> 00:07:37.173
could you replace
the const match with const?

103
00:07:37.173 --> 00:07:38.333
And then the full [CROSSTALK].

104
00:07:38.333 --> 00:07:40.495
&gt;&gt; Maximiliano Firtman: So
the question is can I just do this?

105
00:07:42.188 --> 00:07:43.118
&gt;&gt; Maximiliano Firtman: Well first,

106
00:07:43.118 --> 00:07:47.102
the problem is that now I need
to adjust all my references.

107
00:07:47.102 --> 00:07:52.085
So I have the full date, year, month,

108
00:07:52.085 --> 00:07:56.020
go to a new line here, and day.

109
00:07:56.020 --> 00:08:00.944
Okay, I'm okay, so, yes, I can.

110
00:08:00.944 --> 00:08:04.951
So, I can destructure directly
within the four of declaration?

111
00:08:04.951 --> 00:08:08.700
Yes, you can, in this case,
I'm destructuring an array.

112
00:08:08.700 --> 00:08:12.364
But remember, it can also be an object or
a complex destructuring.

113
00:08:12.364 --> 00:08:17.617
Objects and arrays with objects inside,
that's possible.

114
00:08:17.617 --> 00:08:19.888
Okay, make sense?

115
00:08:21.088 --> 00:08:26.448
Well, this was not possible before
matchAll was available, okay?

116
00:08:26.448 --> 00:08:30.566
So, that's new in ECMAScript 2020,
which is kind of cool for

117
00:08:30.566 --> 00:08:32.412
doing these kinds of things.

