WEBVTT

1
00:00:00.000 --> 00:00:04.093
&gt;&gt; Maximiliano Firtman: Symbol this is the
one of the things that have appear in ESX

2
00:00:04.093 --> 00:00:09.733
that it's actually difficult to finally
understand what is a symbol, Okay?

3
00:00:09.733 --> 00:00:15.630
So a symbol first is a constructor and
it's a type in JavaScript,

4
00:00:15.630 --> 00:00:20.134
so it's a new type that
appear in ECMAScript six,

5
00:00:20.134 --> 00:00:24.656
they are unique and
immutable primitive values.

6
00:00:24.656 --> 00:00:27.568
So they're not objects,they're
primitive values.

7
00:00:27.568 --> 00:00:34.241
So for example, I cannot put a symbol in
a weak set that accepts only objects.

8
00:00:34.241 --> 00:00:38.575
They're often used to create
unique property keys for objects.

9
00:00:38.575 --> 00:00:41.035
For example, I create a new symbol.

10
00:00:41.035 --> 00:00:45.268
The symbol has a property
key that is kind of a label.

11
00:00:45.268 --> 00:00:48.805
It's for kind of debugging purposes only.

12
00:00:48.805 --> 00:00:52.609
And then I use that symbol, okay?

13
00:00:52.609 --> 00:00:56.516
Like that, and
that when we create the symbol,

14
00:00:56.516 --> 00:01:00.824
that symbol goes to a global
collection of symbols.

15
00:01:00.824 --> 00:01:05.749
That you can query with symbol for
so I can check okay?

16
00:01:05.749 --> 00:01:11.678
If I do have a symbol for description,
something important is that if you create

17
00:01:11.678 --> 00:01:18.059
another symbol with the same description,
it's a different one, not the same one.

18
00:01:18.059 --> 00:01:23.056
Everyone is unique okay,
so even if they have

19
00:01:23.056 --> 00:01:27.928
the same property, so it doesn't matter.

20
00:01:27.928 --> 00:01:32.790
And you use that, for example,
as a key in an object,

21
00:01:32.790 --> 00:01:35.612
or as a key for something else.

22
00:01:35.612 --> 00:01:40.271
Sometimes it's being used
to send us an argument.

23
00:01:40.271 --> 00:01:44.929
When you want something unique and
you wanna,

24
00:01:44.929 --> 00:01:49.237
it's kind of an ID of the current process.

25
00:01:49.237 --> 00:01:53.041
So when the software starts,
you create a symbol and

26
00:01:53.041 --> 00:01:55.733
then you pass that symbol anywhere.

27
00:01:55.733 --> 00:02:00.466
That means if you refresh,
you will get the different symbol.

28
00:02:00.466 --> 00:02:02.646
So it's a different one, things like that.

29
00:02:02.646 --> 00:02:07.745
So it's not completely clear initially,
yeah.

30
00:02:07.745 --> 00:02:11.916
&gt;&gt; Student: If I remember correctly I
know in like Ruby which also has strings

31
00:02:11.916 --> 00:02:15.481
as keys for hashes, objects and
then symbols as well.

32
00:02:15.481 --> 00:02:19.638
Symbols are often preferred because
they're like supposedly faster for

33
00:02:19.638 --> 00:02:20.718
lookups, etc..

34
00:02:20.718 --> 00:02:25.519
Do you know if JS is fast enough
that that's not a consideration

35
00:02:25.519 --> 00:02:28.289
here or is it like-
&gt;&gt; Maximiliano Firtman: Symbols should be

36
00:02:28.289 --> 00:02:33.981
faster but I don't think you will pick
symbols over strings because of that.

37
00:02:33.981 --> 00:02:39.307
Because looking into
strings is always slower.

38
00:02:39.307 --> 00:02:45.202
Think about the symbol like If it's
a binary ID or something like that.

39
00:02:45.202 --> 00:02:48.047
But I don't think anyone
is thinking about that.

40
00:02:48.047 --> 00:02:53.805
So I think it's a big issue okay but
yeah, you can use symbols and

41
00:02:53.805 --> 00:02:58.189
because it's immutable,
no one can change it.

42
00:02:58.189 --> 00:03:04.354
So it's immutable, which means that
That it's more secure if you want.

