WEBVTT

1
00:00:00.000 --> 00:00:03.032
&gt;&gt; Maximiliano Firtman: Okay,
so on recaps on arrays,

2
00:00:03.032 --> 00:00:08.295
remember that we have values and
entries on objects.

3
00:00:08.295 --> 00:00:10.766
Now we have something similar on arrays.

4
00:00:10.766 --> 00:00:12.340
For example, I can take an array.

5
00:00:12.340 --> 00:00:13.587
By the way, let's go and see here.

6
00:00:13.587 --> 00:00:17.725
This is my array, a, b, c, I can get keys.

7
00:00:17.725 --> 00:00:21.156
So keys will give you 0, 1, 2.

8
00:00:21.156 --> 00:00:23.674
I can get all the values.

9
00:00:23.674 --> 00:00:28.650
And this is giving me, actually,
an iterator that I can use in a for.

10
00:00:28.650 --> 00:00:31.354
We'll get into iterator in a second.

11
00:00:31.354 --> 00:00:34.861
So I can get all the keys that actually,

12
00:00:34.861 --> 00:00:39.856
in a normal array,
it's just numbers, the values, or

13
00:00:39.856 --> 00:00:44.446
entries that will give you
an array of index value.

14
00:00:44.446 --> 00:00:45.496
Does it make sense?

15
00:00:45.496 --> 00:00:50.147
So you have an array, and
now you get another array,

16
00:00:50.147 --> 00:00:54.079
which in each position, you have an array.

17
00:00:54.079 --> 00:00:57.168
One with the index, one with the value.

18
00:00:57.168 --> 00:01:00.800
CopyWithin will copy elements or

19
00:01:00.800 --> 00:01:04.955
part of the array into another array.

20
00:01:04.955 --> 00:01:07.023
Actually, not into another array,

21
00:01:07.023 --> 00:01:09.900
it's into the same array
in a different position.

22
00:01:09.900 --> 00:01:14.999
So I can take the first two elements and
put it at the end, okay?

23
00:01:14.999 --> 00:01:20.992
I'm just moving elements within the array.

24
00:01:20.992 --> 00:01:27.287
Fill, we shall fill
the array with one element.

25
00:01:27.287 --> 00:01:31.923
Okay, so for example, in this case,
we'll fill with 0 from index 2 to index 4,

26
00:01:31.923 --> 00:01:32.673
exclusive.

27
00:01:32.673 --> 00:01:35.906
So it's not including 4.

28
00:01:35.906 --> 00:01:37.966
So that's why we have two zeros here.

29
00:01:40.682 --> 00:01:43.876
&gt;&gt; Maximiliano Firtman: A small
utility available in array, okay?

30
00:01:43.876 --> 00:01:45.784
Nothing that is so important.

31
00:01:45.784 --> 00:01:49.139
Typed arrays,
we are not going to cover them.

32
00:01:49.139 --> 00:01:54.448
Typed arrays is a way that we have
to typically work with WebGL,

33
00:01:54.448 --> 00:02:00.768
with binary data on the network,
with web sockets and binary web sockets.

34
00:02:00.768 --> 00:02:07.317
If you wanna deal with WebAssembly, and
we wanna work directly with binary data.

35
00:02:07.317 --> 00:02:11.505
Typically, it's array of bytes,
array of integers, array of floats.

36
00:02:11.505 --> 00:02:17.306
So now we can create, we have,
for example, in this case,

37
00:02:17.306 --> 00:02:21.831
it's int 16 bits, so 2 bytes per integer,

38
00:02:21.831 --> 00:02:25.791
is an array of int 16 or unsigned int 8.

39
00:02:25.791 --> 00:02:32.907
This is like a byte for
an integer from 0 to 255, and so on.

40
00:02:32.907 --> 00:02:35.994
Again, if you are getting into that,
Typed Arrays.

41
00:02:35.994 --> 00:02:42.809
Iterators, so in this case, I have
a countdown, which is just a for of, but

42
00:02:42.809 --> 00:02:47.829
I'm using a for
of of an object that I have just created.

43
00:02:47.829 --> 00:02:52.425
It's not an array, that's the new part.

44
00:02:52.425 --> 00:02:54.399
You can create iterators.

45
00:02:54.399 --> 00:03:00.899
An iterator, is any object of any kind,
it can be an object literal,

46
00:03:00.899 --> 00:03:06.952
or it can be an instance of a class,
that contains one particular

47
00:03:06.952 --> 00:03:12.468
property with this particular key,
symbol.iterator.

48
00:03:12.468 --> 00:03:16.720
And remember, we we have this
new syntax of square brackets.

49
00:03:16.720 --> 00:03:23.131
So it's an iterator where that
iterator should return an object,

50
00:03:23.131 --> 00:03:30.814
is kind of weird, it returns an object
that should have a next function inside.

51
00:03:30.814 --> 00:03:36.168
With this, you can make any,
any class that you are creating,

52
00:03:36.168 --> 00:03:40.219
something that you can
iterate with the for of.

53
00:03:40.219 --> 00:03:44.866
Typically, it is a collection
behind the scenes, okay?

54
00:03:44.866 --> 00:03:47.904
But it's not necessarily a connection,
it can be anything.

55
00:03:47.904 --> 00:03:49.451
Any questions?

56
00:03:49.451 --> 00:03:54.033
For all of the iterators,
this is a recap, so it's not really new.

57
00:03:54.033 --> 00:03:55.619
It's from ES6.

58
00:03:55.619 --> 00:03:59.230
And the last weird part
from ES6 is generators.

59
00:03:59.230 --> 00:04:03.224
I'm not sure if you have
seen generators before, but

60
00:04:03.224 --> 00:04:08.193
it's like when you have a function
with a star, with an asterisk,

61
00:04:08.193 --> 00:04:12.483
that function will not return data,
it will yield data.

62
00:04:12.483 --> 00:04:16.469
So when you execute the function,
for example here,

63
00:04:16.469 --> 00:04:21.088
I have a question for the class,
how do we call the generator?

64
00:04:21.088 --> 00:04:22.971
Like, generate.

65
00:04:22.971 --> 00:04:26.579
So, should I create something like this?

66
00:04:26.579 --> 00:04:28.805
Well, actually, no.

67
00:04:28.805 --> 00:04:34.127
Or actually, if I execute this,
this is a generator.

68
00:04:34.127 --> 00:04:39.066
Okay, so it's not really 1 or 2.

69
00:04:39.066 --> 00:04:42.792
So then you need to talk
with the generator, and

70
00:04:42.792 --> 00:04:45.876
you execute the generator many times.

71
00:04:45.876 --> 00:04:50.373
And every time you execute, for
example, you will execute this.

72
00:04:50.373 --> 00:04:58.939
If I run this, it will execute
your code until the first yield.

73
00:04:58.939 --> 00:05:02.132
So when it reaches the first yield,
it will stop.

74
00:05:02.132 --> 00:05:04.253
So it's like, this is not there.

75
00:05:04.253 --> 00:05:07.102
And it will remember the position.

76
00:05:07.102 --> 00:05:10.638
Next time you execute the generator,

77
00:05:10.638 --> 00:05:15.843
it will continue until the next yield,
and so on, okay?

78
00:05:15.843 --> 00:05:20.105
Again, it's more complicated than that,
and

79
00:05:20.105 --> 00:05:23.735
you can mix generators with iterators.

80
00:05:23.735 --> 00:05:28.517
Here, to make the previous
example even better or simpler,

81
00:05:28.517 --> 00:05:35.477
where I'm also doing a countdown, but with
a generator, which is better than before.

82
00:05:35.477 --> 00:05:40.002
So it's a for starting from a variable,

83
00:05:40.002 --> 00:05:43.871
this case 5, and then going on to 0.

84
00:05:43.871 --> 00:05:50.219
And every time I'm yielding the values,
I'm yielding the values that you see here,

85
00:05:50.219 --> 00:05:54.116
5, then 4, then 3, then 2, then 1, then 0.

86
00:05:54.116 --> 00:05:56.566
If you don't get into generators,
it's fine.

87
00:05:56.566 --> 00:06:00.526
You're not going to use them a lot actually,
for web apps, at least, but

88
00:06:00.526 --> 00:06:02.376
just have in mind they are there.

