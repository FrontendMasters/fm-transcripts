WEBVTT

1
00:00:00.050 --> 00:00:01.913
&gt;&gt; Will Sentance: Folks,
so we have now set up.

2
00:00:01.913 --> 00:00:07.927
[SOUND] We're ready to go to start
getting data from out of our file system,

3
00:00:07.927 --> 00:00:11.427
our file storage, what we saved earlier.

4
00:00:11.427 --> 00:00:12.230
We did this manually.

5
00:00:12.230 --> 00:00:15.970
We literally just, I don't know, dragged
and dropped this big old file of data

6
00:00:15.970 --> 00:00:20.062
that we want to then use
JavaScript labels for

7
00:00:20.062 --> 00:00:24.790
Node C++ feature that's written

8
00:00:24.790 --> 00:00:29.330
in C++ that does have
access to our file system.

9
00:00:29.330 --> 00:00:30.040
Perfect.

10
00:00:30.040 --> 00:00:33.000
What is the JavaScript label?

11
00:00:33.000 --> 00:00:34.930
Can anyone spot on here, Zep,

12
00:00:34.930 --> 00:00:39.430
what's the JavaScript label we're
going to use to give us access

13
00:00:39.430 --> 00:00:44.310
to our Node plus C++ built feature that
gives us access to the file system?

14
00:00:44.310 --> 00:00:44.885
&gt;&gt; Zep: FS?

15
00:00:44.885 --> 00:00:49.639
&gt;&gt; Will Sentance: FS is the label, FS
dot read file is the specific label bill

16
00:00:49.639 --> 00:00:53.242
into JavaScript that gives access to Node.

17
00:00:53.242 --> 00:00:56.860
Now remember we have to require it in.

18
00:00:56.860 --> 00:00:59.330
But it's as good as built in as a label to

19
00:00:59.330 --> 00:01:03.740
trigger Node C++ base functionality,
all right.

20
00:01:03.740 --> 00:01:04.630
Let's get going.

21
00:01:04.630 --> 00:01:05.696
By the looks of it,

22
00:01:05.696 --> 00:01:09.319
it's gonna take an actual position
of a file on our file system.

23
00:01:09.319 --> 00:01:11.908
I guess we're gonna rely on
Node to know how to go and

24
00:01:11.908 --> 00:01:16.070
look into the file system grab that
file and start bringing it back here.

25
00:01:16.070 --> 00:01:17.060
Andrew line 1.

26
00:01:17.060 --> 00:01:18.783
What are we doing?

27
00:01:18.783 --> 00:01:22.340
&gt;&gt; Andrew: D clear a label
called Clean tweets.

28
00:01:22.340 --> 00:01:25.130
And that stores the entire
function of Clean tweets.

29
00:01:25.130 --> 00:01:27.930
&gt;&gt; Will Sentance: Very nicely put exactly
we're not gonna say how it works we just

30
00:01:27.930 --> 00:01:29.420
know it's like a black box.

31
00:01:29.420 --> 00:01:34.820
We just know that if it takes in data
it'll return out clean data of bad words.

32
00:01:34.820 --> 00:01:35.970
Okay, next line.

33
00:01:35.970 --> 00:01:36.470
Matt.

34
00:01:37.560 --> 00:01:42.760
&gt;&gt; Matt: The next line is read Declare
Function called use imported tweets.

35
00:01:42.760 --> 00:01:47.100
&gt;&gt; Will Sentance: Use imported tweets,
there it is my friends.

36
00:01:47.100 --> 00:01:47.900
Excellent, thank you.

37
00:01:47.900 --> 00:01:51.270
And now we get triggering
Node functionality.

38
00:01:51.270 --> 00:01:52.822
Sarah Rose.

39
00:01:52.822 --> 00:01:57.370
Where is FS.read file going
to have the majority or

40
00:01:57.370 --> 00:02:01.820
is important consequences in JavaScript.

41
00:02:01.820 --> 00:02:05.280
&gt;&gt; Sarah Rose: No in the Nodes C++.

42
00:02:05.280 --> 00:02:05.980
&gt;&gt; Will Sentance: Exactly.

43
00:02:05.980 --> 00:02:09.690
So I'm bringing out my purple pen.

44
00:02:09.690 --> 00:02:15.104
My Node purple pen parts in slash
tweets dot JSON which is just

45
00:02:15.104 --> 00:02:22.330
to be really clear folks, to JavaScript
that is just a string of characters.

46
00:02:22.330 --> 00:02:24.400
It has no idea what that means.

47
00:02:24.400 --> 00:02:26.210
That doesn't mean it follows a path to it.

48
00:02:26.210 --> 00:02:27.470
It's got no idea.

49
00:02:27.470 --> 00:02:31.710
Node is going to look at it and say,
okay, it's asking specifically for

50
00:02:31.710 --> 00:02:34.669
this location in the computer's memory,
that computer's hard drive.

51
00:02:35.870 --> 00:02:37.900
The first input we always pass through,

52
00:02:37.900 --> 00:02:41.000
where do we find out about how
FS.readfile works, everyone?

53
00:02:41.000 --> 00:02:41.630
&gt;&gt; Speaker 6: Documentation?

54
00:02:41.630 --> 00:02:42.750
&gt;&gt; Will Sentance: The node documentation.

55
00:02:42.750 --> 00:02:45.790
And it will tell us,
first input is the path,

56
00:02:45.790 --> 00:02:48.300
the location of a file on your computer.

57
00:02:48.300 --> 00:02:51.975
Second input is the function
that we want to have what?

58
00:02:51.975 --> 00:02:54.660
&gt;&gt; [INAUDIBLE]
&gt;&gt; Will Sentance: Autorun,

59
00:02:54.660 --> 00:02:56.460
there's the word I wanna hear.

60
00:02:56.460 --> 00:02:59.150
Auto, Automatically run.

61
00:02:59.150 --> 00:03:00.250
Thank you Mohammed, exactly.

62
00:03:01.580 --> 00:03:09.710
Use imported tweets is the function
we want Node to auto run.

63
00:03:09.710 --> 00:03:13.199
So this here is a command
to our dear friend.

64
00:03:14.380 --> 00:03:18.650
Node and
it's saying take this path, use it.

65
00:03:18.650 --> 00:03:22.830
Take this function have it
auto run at the right moment.

66
00:03:22.830 --> 00:03:24.935
When do you think that
function is going to auto run?

67
00:03:24.935 --> 00:03:27.714
Sam?

68
00:03:27.714 --> 00:03:29.422
When would it make sense to have it?

69
00:03:29.422 --> 00:03:32.645
It takes a bit of time to grab that
tweet data into Node and JavaScript.

70
00:03:32.645 --> 00:03:36.009
So when do we think that
function is gonna auto run?

71
00:03:36.009 --> 00:03:39.250
When would it make sense to
have it auto run, Michael?

72
00:03:39.250 --> 00:03:41.009
&gt;&gt; Michael: When it completes
getting the tweets.

73
00:03:41.009 --> 00:03:43.421
&gt;&gt; Will Sentance: Getting tweets, exactly.

74
00:03:43.421 --> 00:03:46.640
Getting the JSON data into Node and
into JavaScript accent.

75
00:03:47.790 --> 00:03:53.291
All right, so
we're going to set up FS in Node.

76
00:03:53.291 --> 00:03:56.394
There it is Fs, that's just its name for

77
00:03:56.394 --> 00:04:02.161
connecting to the file system via live
up to what information does it need?

78
00:04:02.161 --> 00:04:08.320
It needs this path.

79
00:04:08.320 --> 00:04:12.670
There it is and it needs a function
to auto run, which is what?

80
00:04:12.670 --> 00:04:15.762
Roman, what function is going to auto run?

81
00:04:15.762 --> 00:04:17.190
&gt;&gt; Roman: Use imported tweets.

82
00:04:17.190 --> 00:04:19.150
&gt;&gt; Will Sentance: Use imported
tweets thank you, man.

83
00:04:22.160 --> 00:04:23.645
Use imported tweets.

84
00:04:23.645 --> 00:04:25.825
There they are.

85
00:04:25.825 --> 00:04:29.845
I have a feeling the auto-created and
inserted data the argument might

86
00:04:29.845 --> 00:04:33.820
just be the data from tweets.JSON,
that'd be nice, right?

87
00:04:33.820 --> 00:04:37.650
Okay, good, setup done.

88
00:04:37.650 --> 00:04:40.210
Setup done immediately.

89
00:04:40.210 --> 00:04:44.548
It's going to start from Node sending.

90
00:04:44.548 --> 00:04:47.780
It's gonna first figure
out what this path is.

91
00:04:47.780 --> 00:04:50.800
Dot means current folder in
which you are running Node.

92
00:04:50.800 --> 00:04:54.940
Which happens to be fortunately
where we saved tweets.JSON.

93
00:04:54.940 --> 00:04:57.590
Slash says look in that folder.

94
00:04:57.590 --> 00:04:58.570
Find the tweets.JSON.

95
00:04:58.570 --> 00:05:01.320
There it is and
make a connection through to it.

96
00:05:02.800 --> 00:05:06.040
No does too much detail but
just so you know.

97
00:05:06.040 --> 00:05:11.081
Unlike for when we speak to
the network where we Node and

98
00:05:11.081 --> 00:05:16.343
libuv does not handle the actual
opening of the socket and

99
00:05:16.343 --> 00:05:21.285
the focusing of a thread
on waiting inbound message.

100
00:05:21.285 --> 00:05:26.000
A thread is the computer's ability to do
a task and focus on a single task at once.

101
00:05:26.000 --> 00:05:29.155
We are not responsible and
in either Node or libuv for

102
00:05:29.155 --> 00:05:32.752
having a thread dedicated to
awaiting an inbound message.

103
00:05:32.752 --> 00:05:36.870
That is handled by the computer's
internals, the operating system itself.

104
00:05:36.870 --> 00:05:41.950
A thread is just the processing power of
the computer to focus on a single task

105
00:05:41.950 --> 00:05:43.890
in this case listening for
an inbound message.

106
00:05:43.890 --> 00:05:45.530
We don't do that in Node or libuv.

107
00:05:47.050 --> 00:05:49.440
It's done by the operating system itself.

108
00:05:49.440 --> 00:05:52.742
However, because there's too much,

109
00:05:52.742 --> 00:05:57.798
this is my understanding, too much variety
in how different computers implement.

110
00:05:57.798 --> 00:06:01.756
Access to file storage and
file system libuv,

111
00:06:01.756 --> 00:06:06.931
said we are gonna handle the setting
up of a persistent thread

112
00:06:06.931 --> 00:06:11.613
that's going to focus on
pulling that data into Node.

113
00:06:11.613 --> 00:06:16.405
And we're gonna be in charge of that, on
any computer operating system you use this

114
00:06:16.405 --> 00:06:19.222
is one of those big senior
dev questions in node.

115
00:06:19.222 --> 00:06:25.030
Which I/O, this is known as I/O,
input/output from the computer system.

116
00:06:25.030 --> 00:06:30.380
Which I/O in Node sets up
a thread dedicated within Node,

117
00:06:30.380 --> 00:06:34.330
handled by libuv for doing that task,
and which one doesn't.

118
00:06:34.330 --> 00:06:36.724
File system access sets up a thread.

119
00:06:36.724 --> 00:06:38.257
I/O through a network or

120
00:06:38.257 --> 00:06:43.760
a socket rely on the computer to do the
focusing on awaiting that inbound message.

121
00:06:43.760 --> 00:06:46.065
Okay, all right.

122
00:06:46.065 --> 00:06:48.680
Good, so it's true.

123
00:06:48.680 --> 00:06:49.514
I do stamp my foot,

124
00:06:49.514 --> 00:06:52.450
John told me I stamp my foot when
I'm trying to start a new section.

125
00:06:52.450 --> 00:06:53.310
Do I always do this?

126
00:06:54.516 --> 00:06:55.540
That's very interesting.

127
00:06:55.540 --> 00:06:56.140
Good point, John.

128
00:06:58.040 --> 00:06:59.974
Excellent, all right.

129
00:06:59.974 --> 00:07:02.040
I'm going to do it like I'm doing now.

130
00:07:02.040 --> 00:07:04.450
All right, so there you go.

131
00:07:04.450 --> 00:07:07.850
Now this we got to wait a while people.

132
00:07:07.850 --> 00:07:09.090
It's a big old file.

133
00:07:09.090 --> 00:07:12.240
That is a huge file.

134
00:07:12.240 --> 00:07:13.650
Time is passing.

135
00:07:13.650 --> 00:07:15.074
What is it it's like.

136
00:07:15.074 --> 00:07:17.450
It would be 15 seconds.

137
00:07:17.450 --> 00:07:25.003
I mean roughly 15 seconds, but it's a long
time, while this data is flowing in.

138
00:07:25.003 --> 00:07:27.170
15 seconds later, people.

139
00:07:27.170 --> 00:07:29.060
I want you to know,
that's not a short time.

140
00:07:29.060 --> 00:07:33.390
To save stuff to memory here
takes 100 nanoseconds, or

141
00:07:33.390 --> 00:07:37.120
a nanosecond, 100 nanoseconds,
very, very, very short.

142
00:07:37.120 --> 00:07:40.580
That means that 15 seconds is millions,
it's orders of magnitude,

143
00:07:40.580 --> 00:07:42.350
millions times longer.

144
00:07:42.350 --> 00:07:45.650
The time it would take to do
something locally in JavaScript.

145
00:07:45.650 --> 00:07:49.200
This is like a big, big, big,
long time in computer time,

146
00:07:49.200 --> 00:07:52.182
long, longer than often
going to a data center and

147
00:07:52.182 --> 00:07:56.655
bringing data back for another
machine that's ready, there available,

148
00:07:56.655 --> 00:08:00.917
accessible in RAM on the other machine,
is really, really slow task.

149
00:08:00.917 --> 00:08:04.245
I just want to really flag that to
everybody who's gonna mean before you want

150
00:08:04.245 --> 00:08:05.390
to break it down later on.

151
00:08:05.390 --> 00:08:09.721
So anyway, income to the data and
15 seconds.

152
00:08:09.721 --> 00:08:10.790
Good news.

153
00:08:10.790 --> 00:08:11.870
It's done.

154
00:08:11.870 --> 00:08:15.630
What functions gonna auto run
when the data comes in Zip?

155
00:08:15.630 --> 00:08:16.670
&gt;&gt; Zep: Using point tweet.

156
00:08:16.670 --> 00:08:17.650
&gt;&gt; Will Sentance: Using point tweet.

157
00:08:17.650 --> 00:08:20.200
Let's throw it up and
let's start executing it.

158
00:08:20.200 --> 00:08:22.897
Use imported Tweets.

159
00:08:22.897 --> 00:08:25.351
I should have probably done it in purple,
but

160
00:08:25.351 --> 00:08:27.943
I'll talk about the execution
of it in purple.

161
00:08:27.943 --> 00:08:29.035
Here it is.

162
00:08:29.035 --> 00:08:32.910
Huge execution context for this,
cuz I wanna do a bunch of stuff in it.

163
00:08:32.910 --> 00:08:35.595
So here it is, the execution context for
it to run its code.

164
00:08:37.650 --> 00:08:38.818
&gt;&gt; Will Sentance: Okay, into it we go.

165
00:08:38.818 --> 00:08:41.890
What's the auto-created and inserted data?

166
00:08:41.890 --> 00:08:48.340
Folk, it's that JSON formatted
stringified version of an object.

167
00:08:48.340 --> 00:08:50.010
So it's gonna look something like this,

168
00:08:50.010 --> 00:08:55.680
JSON data you have to put double
quotes around every damn thing.

169
00:08:55.680 --> 00:08:57.130
So Toneiger.

170
00:08:57.130 --> 00:09:00.610
Those who are regulars using it know
that if you get one double quote

171
00:09:00.610 --> 00:09:02.200
out either the whole thing gets corrupted.

172
00:09:02.200 --> 00:09:04.590
You gotta figure out where the error is.

173
00:09:04.590 --> 00:09:06.124
By the way the helpful thing for

174
00:09:06.124 --> 00:09:10.086
that is there's a bunch of online tools
that will help you spot your JSON error.

175
00:09:10.086 --> 00:09:14.812
There's always one, you try to edit it
manually you move the comma in the wrong

176
00:09:14.812 --> 00:09:17.388
place and
that is infamously a very very and

177
00:09:17.388 --> 00:09:21.825
the pass function is going to turn it
into an object in here isn't like some

178
00:09:21.825 --> 00:09:25.270
sophisticated parts that
can go past finally go.

179
00:09:25.270 --> 00:09:26.160
They missed a quote that.

180
00:09:26.160 --> 00:09:27.010
No problem.

181
00:09:27.010 --> 00:09:28.050
I'll figure it out.

182
00:09:28.050 --> 00:09:30.990
Here is a simple simple function
that's going to do only one

183
00:09:30.990 --> 00:09:35.680
thing which is convert perfectly formatted
JSON data into a job as an object.

184
00:09:35.680 --> 00:09:36.380
That's all it can do.

185
00:09:36.380 --> 00:09:40.050
It's not like a sophisticated algorithm
for figuring out your errors.

186
00:09:40.050 --> 00:09:44.890
Okay, ao anyway the date comes in
the first tweet is always hello.

187
00:09:44.890 --> 00:09:45.930
There we go.

188
00:09:45.930 --> 00:09:49.120
And then there'll be another one tweet.

189
00:09:49.120 --> 00:09:50.010
So forth.

190
00:09:50.010 --> 00:09:55.120
Huge it's 1.5 billion
characters long long long long.

191
00:09:55.120 --> 00:09:57.727
It's like tons of tweets by the way
still nowhere near all the tweets but

192
00:09:57.727 --> 00:09:59.060
like a lot of tweets.

193
00:09:59.060 --> 00:10:02.170
Okay, this is gonna be
auto inserted into here.

194
00:10:02.170 --> 00:10:03.085
Does it get a name?

195
00:10:03.085 --> 00:10:06.389
Not by Node, do we give it a name?

196
00:10:06.389 --> 00:10:07.920
&gt;&gt; Speaker 10: Yeah.
&gt;&gt; Will Sentance: Yes, yeah.

197
00:10:07.920 --> 00:10:08.690
There you go.

198
00:10:08.690 --> 00:10:09.970
We give it a name.

199
00:10:09.970 --> 00:10:12.800
Two auto inserted inputs.

200
00:10:12.800 --> 00:10:14.300
Damn it.
Two was inserted.

201
00:10:14.300 --> 00:10:15.510
This is the second one.

202
00:10:16.560 --> 00:10:19.620
Was the first auto inserted input?

203
00:10:19.620 --> 00:10:22.890
This is called the error
first pattern in Node.

204
00:10:22.890 --> 00:10:25.510
A lot of Node features,

205
00:10:25.510 --> 00:10:30.410
their auto triggered function, the auto
run function will take two inputs.

206
00:10:30.410 --> 00:10:36.810
The first one, I don't know, damn, the
first one will represent any error data.

207
00:10:36.810 --> 00:10:38.810
Let's put it up here above so
it's really clear.

208
00:10:38.810 --> 00:10:41.360
The first one will also
represent any error data.

209
00:10:41.360 --> 00:10:43.679
The second one,
with the actual data we care about.

210
00:10:43.679 --> 00:10:45.695
It's there's no-error data,
this state is clean, it's fine.

211
00:10:45.695 --> 00:10:48.663
No-error data,
the first one would default to?

212
00:10:48.663 --> 00:10:49.296
&gt;&gt; Speaker 11: Undefined?

213
00:10:49.296 --> 00:10:51.710
&gt;&gt; Will Sentance: Undefined is
a really reasonable thing to think.

214
00:10:51.710 --> 00:10:52.910
Actually, here, it defaults to?

215
00:10:52.910 --> 00:10:54.810
&gt;&gt; Speaker 12: Initialized data.

216
00:10:54.810 --> 00:10:55.660
&gt;&gt; Speaker 13: No.
&gt;&gt; Will Sentance: No.

217
00:10:55.660 --> 00:11:00.380
It's spawned from, Virginia,
there it is, null.

218
00:11:00.380 --> 00:11:02.270
So, the first input will be null.

219
00:11:02.270 --> 00:11:07.590
The second input will be all our
JSON stringified data, okay.

220
00:11:07.590 --> 00:11:11.802
Let's go into the execution context,
let me try to give enough space.

221
00:11:11.802 --> 00:11:16.964
Yeah, [SOUND], probably about here.

222
00:11:16.964 --> 00:11:20.463
Okay, in the local memory, this is a more
complex function than I'd like, but

223
00:11:20.463 --> 00:11:21.780
I want to show you something.

