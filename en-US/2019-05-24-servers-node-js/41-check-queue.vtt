WEBVTT

1
00:00:00.160 --> 00:00:03.318
&gt;&gt; Will Sentance: The third prioritized
queue is called the Check Queue.

2
00:00:05.714 --> 00:00:08.440
&gt;&gt; Will Sentance: Let's just
squeeze it in a bit here.

3
00:00:08.440 --> 00:00:08.940
The check queue.

4
00:00:12.406 --> 00:00:17.490
&gt;&gt; Will Sentance: Check queue, how do
I get a function in the check queue?

5
00:00:19.400 --> 00:00:22.160
I use set immediate.

6
00:00:22.160 --> 00:00:24.530
Whatever function I pass is set immediate,

7
00:00:24.530 --> 00:00:27.330
that function will be absolute
opposite of running immediately.

8
00:00:27.330 --> 00:00:30.094
It is the worst named
function in all of history.

9
00:00:30.094 --> 00:00:33.960
That's about ten years, and it's
the worst named method in all history.

10
00:00:33.960 --> 00:00:38.470
It absolutely, you're so glad is, that it
certainly is not gonna run immediately.

11
00:00:38.470 --> 00:00:41.092
It's literally certainly gonna
be the last queue to be checked.

12
00:00:41.092 --> 00:00:44.570
&gt;&gt; Speaker 2: [LAUGH] why?

13
00:00:44.570 --> 00:00:49.430
&gt;&gt; Will Sentance: It is the worst,
it is a misnomer beyond.

14
00:00:49.430 --> 00:00:54.390
But, there are times when we want
to make sure that all IO work,

15
00:00:54.390 --> 00:00:56.690
at that point, has been done.

16
00:00:56.690 --> 00:00:59.120
All completed input, output,
auto run functions have run.

17
00:00:59.120 --> 00:01:04.450
And we wanna be sure that they've all run,
before we run this other function.

18
00:01:04.450 --> 00:01:05.900
Another way we can do that,

19
00:01:05.900 --> 00:01:10.896
is by using a set immediate that will put
the associated function in the last queue.

20
00:01:10.896 --> 00:01:14.600
As opposed we've added something from
one of these into a global variable,

21
00:01:14.600 --> 00:01:16.310
we wanna be sure it's already there, and

22
00:01:16.310 --> 00:01:21.120
it's gonna give as a right to
control the order of our execution.

23
00:01:22.140 --> 00:01:23.664
Of functions that we auto-delay,

24
00:01:23.664 --> 00:01:26.204
it's kinda nice that we can
actually insert something from

25
00:01:26.204 --> 00:01:29.379
the running of this function that will
set immediate that will go in here.

26
00:01:29.379 --> 00:01:34.179
That we can then know all of
this would've finished, and

27
00:01:34.179 --> 00:01:37.090
we can then check this queue lost.

28
00:01:37.090 --> 00:01:41.403
And when that queue is checked,
that function, we know that all IO related

29
00:01:41.403 --> 00:01:46.530
delayed functions that have been
auto-run have been run at that point.

30
00:01:46.530 --> 00:01:51.078
Not all ever, just all have
it done at that moment, okay.

31
00:01:53.528 --> 00:01:58.016
&gt;&gt; Will Sentance: All of that in cycle of
checking through the associated queues,

32
00:01:58.016 --> 00:02:02.060
which happens again, and again, and again.

33
00:02:02.060 --> 00:02:04.080
In that cycle of checking,

34
00:02:04.080 --> 00:02:08.660
all currently finished call backs in
the queue have finished at that moment.

35
00:02:08.660 --> 00:02:10.200
Then we enter the check queue.

36
00:02:10.200 --> 00:02:15.612
And so, at five and into five minutes,
three minutes seconds,

37
00:02:15.612 --> 00:02:21.626
roughly I guess, this again is not
real milliseconds, just ordinal,

38
00:02:21.626 --> 00:02:28.160
ordinal means the order of numbers, so
that was the next thing that's done.

39
00:02:28.160 --> 00:02:29.974
At 503 milliseconds, we run set immediate,
we run set immediate.

40
00:02:29.974 --> 00:02:32.250
Pass it, what function?

41
00:02:32.250 --> 00:02:32.960
Sam.

42
00:02:32.960 --> 00:02:34.443
&gt;&gt; Sam: Immediately.
&gt;&gt; Will Sentance: Immediately,

43
00:02:34.443 --> 00:02:37.050
the whole definition of it.

44
00:02:37.050 --> 00:02:38.520
I should've call it not immediately,
right?

45
00:02:38.520 --> 00:02:40.050
That would've been much clearer.

46
00:02:40.050 --> 00:02:43.561
Immediately, and that also speaks to node.

47
00:02:48.030 --> 00:02:50.470
&gt;&gt; Will Sentance: That is not true,
it has gone the other way round.

48
00:02:50.470 --> 00:02:52.700
There it is that speaks in a that can go
the other way around others, clearly.

49
00:02:52.700 --> 00:02:56.736
And that's going to set up down here,

50
00:02:56.736 --> 00:03:02.809
a,
&gt;&gt; Will Sentance: Well,

51
00:03:02.809 --> 00:03:05.168
we can represented here,
what is represented here directly.

52
00:03:05.168 --> 00:03:10.039
You know what, it does have any
manifest difference between

53
00:03:10.039 --> 00:03:14.850
whether we put it down here,
I mean just to be consistent.

54
00:03:14.850 --> 00:03:18.550
It's setting up a C++ background feature,
so let's put it in here.

55
00:03:18.550 --> 00:03:23.215
The immediate slash checks because they

56
00:03:23.215 --> 00:03:28.344
going to check queue,
&gt;&gt; Will Sentance: The function

57
00:03:28.344 --> 00:03:29.500
immediately.

58
00:03:31.530 --> 00:03:37.083
But, it's instantly grabbed and put in
the check queue at 503 milliseconds.

59
00:03:41.537 --> 00:03:47.269
&gt;&gt; Will Sentance: 503 milliseconds.

60
00:03:48.650 --> 00:03:50.860
And you might be thinking,
hold on, how these still in there?

61
00:03:50.860 --> 00:03:53.540
Because we still were running
through the whole way through this

62
00:03:53.540 --> 00:03:55.400
regular jobs synchronous code.

63
00:03:55.400 --> 00:03:57.971
So we won't even allow, the event it
wasn't even checking any of these queues.

64
00:03:57.971 --> 00:04:02.080
Even those very last thing we had to say
immediate, is gonna be added in here.

65
00:04:02.080 --> 00:04:03.710
We still haven't grabbed
anything else from our queues and

66
00:04:03.710 --> 00:04:05.010
this is our third priority cues.

67
00:04:05.010 --> 00:04:06.694
I feel like it might be
the last thing to be checked.

68
00:04:06.694 --> 00:04:13.525
All right, so, now,
is there any global code left?

69
00:04:13.525 --> 00:04:16.361
This was popped off the call
stack a long time ago.

70
00:04:16.361 --> 00:04:17.916
Is there any global code left?

71
00:04:17.916 --> 00:04:19.346
&gt;&gt; Speaker 4: No.

72
00:04:19.346 --> 00:04:21.375
&gt;&gt; Will Sentance: Is there
any thing when I call stack.

73
00:04:21.375 --> 00:04:22.432
&gt;&gt; Speaker 5: No.

74
00:04:22.432 --> 00:04:24.380
&gt;&gt; Will Sentance: Exactly.

75
00:04:24.380 --> 00:04:29.650
So, event loop goes,
we're good to check the queues.

76
00:04:29.650 --> 00:04:33.220
And we check the queues at,
I guess, again, metaphorically,

77
00:04:33.220 --> 00:04:36.470
504 milliseconds we start checking queues.

78
00:04:36.470 --> 00:04:39.080
And what's the first queue we check?

79
00:04:39.080 --> 00:04:39.580
&gt;&gt; Speaker 2: Timer queue.
&gt;&gt; Will Sentance: Timer queue.

80
00:04:39.580 --> 00:04:42.214
It's actually technically what's called

81
00:04:42.214 --> 00:04:43.740
a timer minheap.

82
00:04:43.740 --> 00:04:44.664
The way it's represented is,

83
00:04:44.664 --> 00:04:48.970
the way of organizing data where
you take the smallest counter

84
00:04:50.090 --> 00:04:53.330
is invested number of seconds, it's
been delayed and check that one first.

85
00:04:53.330 --> 00:04:56.150
And if it's below
the amount of current time,

86
00:04:56.150 --> 00:04:58.850
then it grabs that associated
function inserted on the cool side.

87
00:04:58.850 --> 00:05:01.048
But we can metaphorically
think of it as a acute.

88
00:05:01.048 --> 00:05:04.737
Just, shoot lasers better organizes and
what's called a minheap,

89
00:05:04.737 --> 00:05:07.418
which is a better way of
organizing certain data.

90
00:05:07.418 --> 00:05:10.382
But we'll call it, it's a queue
effectively, and we do indeed at.

91
00:05:10.382 --> 00:05:14.518
504 milliseconds, put print hello,

92
00:05:14.518 --> 00:05:19.480
on the call stack,
my goodness, print hello is

93
00:05:19.480 --> 00:05:24.442
executed and
what did it do in our console people,

94
00:05:24.442 --> 00:05:29.970
in console logs,
hello at 504 milliseconds.

95
00:05:29.970 --> 00:05:31.293
Hello, thank you, Sam for
great enthusiasm.

96
00:05:31.293 --> 00:05:35.880
They're so enthusiastic to get a drink of
water after the strength of the hello.

97
00:05:35.880 --> 00:05:37.183
All right, and it's the cube.

98
00:05:37.183 --> 00:05:41.507
And the event that goes,
check the next queue,

99
00:05:41.507 --> 00:05:47.816
which is where 95% of our delayed
functions to be auto run will be in here.

100
00:05:47.816 --> 00:05:50.700
Because that's what will be interesting
stuff is time isn't all that interesting.

101
00:05:50.700 --> 00:05:54.161
Sammy there's a lot I enjoy while
they're quite cool actually.

102
00:05:54.161 --> 00:05:57.762
But you know that's not a go to thing all,
stuff is interacting.

103
00:05:57.762 --> 00:06:00.844
IO, note it is most fun when it's
interacting with the computer's

104
00:06:00.844 --> 00:06:04.428
internals is what they first 70 percent
is taught wall which it was, right?

105
00:06:04.428 --> 00:06:09.600
They all go in here as why this last
bit here is almost like an appendix.

106
00:06:09.600 --> 00:06:11.678
It's like most of the time.

107
00:06:11.678 --> 00:06:16.413
You're not gonna worry too much about this
is great for interviews, and for really,

108
00:06:16.413 --> 00:06:18.732
really interesting and deep debugging.

109
00:06:18.732 --> 00:06:22.120
And that's why we're gonna cover it and
we're almost there.

110
00:06:22.120 --> 00:06:24.130
But it's not like the cool fun, but

111
00:06:24.130 --> 00:06:28.890
it's using the features of
the computer via C++ in JavaScript.

112
00:06:28.890 --> 00:06:33.290
Here and now, you doing weird stuff
like delaying functions, timer,

113
00:06:33.290 --> 00:06:36.680
zero minute to make the point
of exactly how the queues

114
00:06:36.680 --> 00:06:39.440
allow stuff back in on the event
loop via the live event loop.

