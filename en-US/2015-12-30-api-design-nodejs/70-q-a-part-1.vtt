WEBVTT

1
00:00:00.008 --> 00:00:02.275
&gt;&gt; [MUSIC]

2
00:00:02.275 --> 00:00:06.500
&gt;&gt; Scott Moss: All right, so
now is the time for us to open up and

3
00:00:06.500 --> 00:00:11.370
ask questions about anything we've
been exploring the last three days, or

4
00:00:11.370 --> 00:00:15.482
ask me anything about node, APIs,
express, mongodb, mongoose, or

5
00:00:15.482 --> 00:00:19.656
anything internal.

6
00:00:19.656 --> 00:00:20.710
Yo.

7
00:00:20.710 --> 00:00:24.140
&gt;&gt; Speaker 2: As far as API design goes,

8
00:00:24.140 --> 00:00:28.740
I've heard some people say like,
let say you have, let say you're on, like,

9
00:00:28.740 --> 00:00:32.010
the Netflix home page and
has all those movie tiles.

10
00:00:32.010 --> 00:00:35.680
They say, like, if you do a request for
each one of those tiles,

11
00:00:35.680 --> 00:00:37.430
it's gonna be a lot of requests.

12
00:00:37.430 --> 00:00:40.790
So, there are like add
parameters at the end.

13
00:00:40.790 --> 00:00:42.510
I want a group of six.

14
00:00:42.510 --> 00:00:43.330
&gt;&gt; Scott Moss: Yeah.
&gt;&gt; Speaker 2: Stuff like that,

15
00:00:43.330 --> 00:00:48.150
so what I'm wondering is like how should
you balance how many parameters and

16
00:00:48.150 --> 00:00:51.772
stuff you should put on, and
how restful you want to design the API?

17
00:00:51.772 --> 00:00:53.820
&gt;&gt; Scott Moss: There ares
common patterns like ordering,

18
00:00:53.820 --> 00:00:56.590
sorting, filtering those
are common limits.

19
00:00:56.590 --> 00:00:59.410
And then if you're doing something
like consignation you have like

20
00:00:59.410 --> 00:01:02.940
a cursor where it says start, and
you can figure out what page you are on.

21
00:01:02.940 --> 00:01:04.360
So those are common ones.

22
00:01:04.360 --> 00:01:08.945
As far as the properties, it depends on
what type of properties you want people

23
00:01:08.945 --> 00:01:13.599
to be able to search by, for instance, if
the user, all we have is a user name and

24
00:01:13.599 --> 00:01:17.437
a password here, but what if we
had multiple properties on here.

25
00:01:17.437 --> 00:01:22.827
It also depends on what did you index
right, so if you indexed the user name it

26
00:01:22.827 --> 00:01:28.302
might behoove you allow people to search
by the user name do a query string, so

27
00:01:28.302 --> 00:01:34.061
you can get that benefit of that constant
time look up speed of the indexed field.

28
00:01:34.061 --> 00:01:37.533
So, I guess it all depends, but
there are the common ones like I said, and

29
00:01:37.533 --> 00:01:40.950
then it's gonna be up to you to pin on
what you want the users to search by.

30
00:01:40.950 --> 00:01:44.530
Maybe you don't want the users searching
by their Facebook access token.

31
00:01:44.530 --> 00:01:45.970
So, you don't want to put that there.

32
00:01:45.970 --> 00:01:50.210
But really what would happen is
you would build like an agnostic

33
00:01:50.210 --> 00:01:53.980
query builder that doesn't know about
what the query perimeters are and

34
00:01:53.980 --> 00:01:56.940
actually it doesn't care, and
that's where Mongo kind of shines.

35
00:01:56.940 --> 00:01:58.655
We didn't get into
the advance query of Mongo,

36
00:01:58.655 --> 00:02:01.770
because I told you that's a whole
other thing by itself, but

37
00:02:01.770 --> 00:02:07.340
Mongo will allow you to like pass in
different query params like that.

38
00:02:07.340 --> 00:02:11.960
And if you match them up exactly to
rec.query.params, and pass in and

39
00:02:11.960 --> 00:02:16.400
out to Mongo query, you can pretty
much get whatever they pass in right.

40
00:02:16.400 --> 00:02:19.270
And then you can leave it up
to Mongo to decide if that

41
00:02:19.270 --> 00:02:20.480
is a valid parameter or not.

42
00:02:20.480 --> 00:02:22.520
So, you don't have to do
the checking yourself right.

43
00:02:22.520 --> 00:02:25.740
Like for instance, on my user Hold on.

44
00:02:25.740 --> 00:02:26.840
Where's my user.

45
00:02:26.840 --> 00:02:27.340
Let's go to user.

46
00:02:27.340 --> 00:02:30.630
I only have her user name and
password, but

47
00:02:30.630 --> 00:02:33.200
somebody typed in a parameter looking for
an age.

48
00:02:34.380 --> 00:02:36.140
Mongo's not going to find
anything with that on it.

49
00:02:36.140 --> 00:02:37.910
So, I don't have to check for
it, although I could.

50
00:02:37.910 --> 00:02:39.290
You see what I mean?

51
00:02:39.290 --> 00:02:40.830
I could leave it up to
Mongo to figure out,

52
00:02:40.830 --> 00:02:42.650
if it's going to find something
with an age property on it.

53
00:02:42.650 --> 00:02:45.370
Which it's obviously not,
cause no users have an age property on it.

54
00:02:45.370 --> 00:02:46.610
&gt;&gt; Speaker 2: Yeah.

55
00:02:46.610 --> 00:02:47.809
&gt;&gt; Scott Moss: Yeah, so
like you can totally do that.

56
00:02:47.809 --> 00:02:49.317
Like, that would look something like this.

57
00:02:49.317 --> 00:02:55.950
So for like, for instance, I want to get
users, but I wanna limit to 20, right.

58
00:02:55.950 --> 00:03:00.220
And you know, I want their age to be like

59
00:03:01.520 --> 00:03:03.990
equals and then like,
you might do like some encoding here.

60
00:03:03.990 --> 00:03:06.010
It's like, this obviously isn't valid.

61
00:03:06.010 --> 00:03:07.560
You do like greater than.

62
00:03:09.450 --> 00:03:10.170
Something like that.

63
00:03:10.170 --> 00:03:11.570
You can do all types of things in here.

64
00:03:11.570 --> 00:03:14.200
You can even pass them like a JSON string.

65
00:03:14.200 --> 00:03:14.940
So it's up to you.

66
00:03:14.940 --> 00:03:18.850
There is no limit on what you can
do as far as the query parameters.

67
00:03:18.850 --> 00:03:21.310
It's just like what type of-
what does your client need?

68
00:03:21.310 --> 00:03:22.198
What type of data do they need?

69
00:03:22.198 --> 00:03:27.030
So, it's very much up to you.

70
00:03:27.030 --> 00:03:29.650
A good example, if you want to
check it out is parts, parts api,

71
00:03:29.650 --> 00:03:33.210
they have one of the best apis I've seen,
so I'd check that out.

72
00:03:33.210 --> 00:03:34.100
Yes?

73
00:03:34.100 --> 00:03:35.360
&gt;&gt; Speaker 3: Some questions
are rolling in here.

74
00:03:35.360 --> 00:03:38.250
What's the most effective way
to identify the right module, or

75
00:03:38.250 --> 00:03:40.630
library when there's so many.

76
00:03:40.630 --> 00:03:43.570
Are there sites, or
anything that help you?

77
00:03:43.570 --> 00:03:46.900
&gt;&gt; Scott Moss: So,
the way I do it, there is no,

78
00:03:46.900 --> 00:03:49.230
if it's really really good there
will be blog posts about it.

79
00:03:49.230 --> 00:03:51.570
You just won't be able to,
if there was something really good and

80
00:03:51.570 --> 00:03:54.560
you google how do I do this in node,
it'll be the first thing to come up.

81
00:03:54.560 --> 00:03:55.730
If that's not the case,

82
00:03:55.730 --> 00:03:59.510
if it's not obvious, then what you do is
you find something you think is good.

83
00:03:59.510 --> 00:04:03.200
The first thing I do is,
I go to node, I click on the GitHub.

84
00:04:03.200 --> 00:04:04.230
That 404ed.

85
00:04:04.230 --> 00:04:05.830
Totally not gonna use that, right?

86
00:04:05.830 --> 00:04:07.280
So then I go, I stay in npm.

87
00:04:07.280 --> 00:04:10.630
I'll start Googling stuff, and

88
00:04:10.630 --> 00:04:13.750
a big indicator if something is
great is when it was last updated.

89
00:04:15.220 --> 00:04:16.600
So, if I click on this.

90
00:04:16.600 --> 00:04:20.760
The thing's got 246 stars,
relatively okay.

91
00:04:20.760 --> 00:04:23.310
It's got a link to a website
that's being hosted somewhere.

92
00:04:23.310 --> 00:04:26.430
That means they probably put some work
into it or they're just trying to market.

93
00:04:26.430 --> 00:04:26.930
I don't know.

94
00:04:28.520 --> 00:04:30.310
The readme looks pretty sophisticated.

95
00:04:30.310 --> 00:04:32.060
It looks like it's kept up to date.

96
00:04:32.060 --> 00:04:36.130
So I mean I guess it all depends on
how well done is the re-meet, or

97
00:04:36.130 --> 00:04:37.770
the re-pull looks like.

98
00:04:37.770 --> 00:04:39.790
It was updated 17 days ago.

99
00:04:39.790 --> 00:04:41.330
That's pretty current.

100
00:04:41.330 --> 00:04:43.160
So, that's a good indicator
that it's being used.

101
00:04:43.160 --> 00:04:47.539
So, obviously a combination of the stars
on GitHub, the last time it was updated.

102
00:04:48.980 --> 00:04:52.110
If you can find any blog post,
if you can find anybody talking about it.

103
00:04:52.110 --> 00:04:56.860
But if it's just something where it's just
like, two stars, updated four months ago.

104
00:04:56.860 --> 00:05:00.850
The read me has like two lines in it, but
you think it's exactly what you need?

105
00:05:00.850 --> 00:05:02.470
Probably not the thing.

106
00:05:02.470 --> 00:05:04.340
I would rather make my
own thing than use that.

107
00:05:05.580 --> 00:05:09.270
So yeah, and it would be pretty obvious
if somebody was, if this was proper.

108
00:05:09.270 --> 00:05:16.480
Just look at the activity, stars, watches,
update times, and how nice is the readme.

109
00:05:16.480 --> 00:05:17.790
This is a pretty good readme.

110
00:05:17.790 --> 00:05:19.810
This person put a lot of time into it.

111
00:05:19.810 --> 00:05:20.570
So, yep.

112
00:05:25.240 --> 00:05:28.730
&gt;&gt; Speaker 3: How does MongoDB performance
compare with enterprise level databases

113
00:05:28.730 --> 00:05:29.510
like Oracle?

114
00:05:31.230 --> 00:05:32.640
&gt;&gt; Scott Moss: Man.

115
00:05:32.640 --> 00:05:36.440
I don't know anything about Oracle,
so I cannot compare the two.

116
00:05:36.440 --> 00:05:41.020
I've never had to use Oracle in my entire
life, but I do know if you had Oracle,

117
00:05:41.020 --> 00:05:43.500
it comes with a db administrator
that handles it for you, right.

118
00:05:43.500 --> 00:05:44.505
Doesn't it come with a person?

119
00:05:44.505 --> 00:05:45.670
&gt;&gt; Speaker 2: [LAUGH]
&gt;&gt; Scott Moss: Right?

120
00:05:45.670 --> 00:05:49.600
Don't you think of Oracle, it comes
with a person who handles that for you?

121
00:05:49.600 --> 00:05:54.061
But I can say that Mongo
is very performant,

122
00:05:54.061 --> 00:05:57.450
because it's based off of an eventing
system kind of like Note.

123
00:05:57.450 --> 00:06:00.720
So as far as performance,
it's actually pretty fast, but

124
00:06:00.720 --> 00:06:02.150
it doesn't mean it's the best.

125
00:06:02.150 --> 00:06:05.990
Speed is not everything
when it comes to database.

126
00:06:05.990 --> 00:06:07.560
It's all about all types of other stuff.

127
00:06:07.560 --> 00:06:09.320
Is it ACID-compliant?

128
00:06:09.320 --> 00:06:10.520
What are the reads, what are the writes?

129
00:06:10.520 --> 00:06:12.570
What is it good for,
is it better for reads or the writes?

130
00:06:12.570 --> 00:06:13.781
There's a lot of the stuff
goes in day-to-day support.

131
00:06:13.781 --> 00:06:16.070
&gt;&gt; Speaker 2: Is the API usable?

132
00:06:16.070 --> 00:06:19.429
&gt;&gt; Scott Moss: Yeah,
is the api usable, can it [CROSSTALK]

133
00:06:19.429 --> 00:06:20.833
&gt;&gt; Speaker 2: Mongo will allow it,

134
00:06:20.833 --> 00:06:23.260
because it's like a hybrid of
&gt;&gt; Scott Moss: Exactly.

135
00:06:23.260 --> 00:06:25.180
&gt;&gt; Speaker 2: A lot of things
are easier to get started with.

136
00:06:25.180 --> 00:06:27.690
&gt;&gt; Scott Moss: Yeah,
Mongo's very easy to get started with.

137
00:06:27.690 --> 00:06:31.720
Where it's like if you've never
studied relational databases, and

138
00:06:31.720 --> 00:06:35.250
the first time you used a database was
like I'm gonna use Postgre or SQL.

139
00:06:35.250 --> 00:06:38.760
You might have a hard time
understanding why this stuff is.

140
00:06:38.760 --> 00:06:39.410
Like, what is a?

141
00:06:39.410 --> 00:06:40.790
What is a migration?

142
00:06:40.790 --> 00:06:41.730
What is this?

143
00:06:41.730 --> 00:06:42.300
What is that?

144
00:06:42.300 --> 00:06:44.740
Like, if you never studied databases,
that stuff doesn't make sense to you,

145
00:06:44.740 --> 00:06:48.010
whereas Mongo is like just connect,
and you're okay.

146
00:06:48.010 --> 00:06:48.780
Give me JavaScript.

147
00:06:48.780 --> 00:06:51.080
So it's like a lead,
a lot of easier setup.

148
00:06:51.080 --> 00:06:53.710
So, yeah it's pretty fast because it
doesn't have to do things like join tables

149
00:06:53.710 --> 00:06:55.040
and stuff like that.

150
00:06:55.040 --> 00:06:57.240
But again, it's not the best thing for
everything.

151
00:06:59.630 --> 00:07:02.470
&gt;&gt; Speaker 3: So I guess what they're
asking, following up, if you're shipping

152
00:07:02.470 --> 00:07:05.380
an app in production with a huge amount
of users, can Mongo support that?

153
00:07:06.480 --> 00:07:08.610
&gt;&gt; Scott Moss: I don't know
what a huge amount of users is,

154
00:07:08.610 --> 00:07:12.420
like I said at the end I don't think
it comes down to how much it's storing.

155
00:07:12.420 --> 00:07:15.020
It's coming down to like what
you're doing with the data,

156
00:07:15.020 --> 00:07:17.050
are you gonna be reading
more than writing?

157
00:07:17.050 --> 00:07:18.086
What are you gonna be writing?

158
00:07:18.086 --> 00:07:18.630
How many concurrent users?

159
00:07:18.630 --> 00:07:22.210
How many concurrent writes
are you gonna have, right?

160
00:07:22.210 --> 00:07:25.020
And I think that's more important than
an amount of shared data that it's

161
00:07:25.020 --> 00:07:26.080
gonna store.

162
00:07:26.080 --> 00:07:27.760
I've heard problems with Mongo,

163
00:07:27.760 --> 00:07:30.830
where people are saying that
sometimes things wouldn't write.

164
00:07:30.830 --> 00:07:32.890
I've never entered that
problem personally.

165
00:07:32.890 --> 00:07:35.290
But again, I've never built
a big data platform either.

166
00:07:35.290 --> 00:07:36.720
I'm not a big data person.

167
00:07:36.720 --> 00:07:38.220
So, I can not comment on that.

168
00:07:38.220 --> 00:07:40.280
But I've also heard other
things about SQL and stuff.

169
00:07:40.280 --> 00:07:43.940
So, I mean, the the pros and
cons are Mongo is easy to get started.

170
00:07:43.940 --> 00:07:45.360
It's really good for prototyping.

171
00:07:45.360 --> 00:07:47.040
You could probably get
away using the production.

172
00:07:47.040 --> 00:07:48.750
Cuz it's really good.

173
00:07:48.750 --> 00:07:52.860
But then again, SQL is probably overall
is gonna have better performance,

174
00:07:52.860 --> 00:07:54.210
Postgre SQL.

175
00:07:54.210 --> 00:07:56.700
But you actually need
to know how to use it,

176
00:07:56.700 --> 00:07:59.800
it's only going to be good,
if you know what you're doing.

177
00:07:59.800 --> 00:08:02.884
If you don't know how to
administer a relational database,

178
00:08:02.884 --> 00:08:05.200
then you're not going to have fun with it.

179
00:08:05.200 --> 00:08:08.360
&gt;&gt; Speaker 2: I think people
tend to over think scalability,

180
00:08:08.360 --> 00:08:10.210
because they think my
apps going to be huge.

181
00:08:10.210 --> 00:08:11.950
&gt;&gt; Scott Moss: Right.
&gt;&gt; Speaker 2: Right, but when they

182
00:08:11.950 --> 00:08:13.039
actually run into issues

183
00:08:14.971 --> 00:08:17.805
in a company that's worth millions-
&gt;&gt; Scott Moss: Yeah.

184
00:08:17.805 --> 00:08:18.730
You got funny and you can fix it.

185
00:08:18.730 --> 00:08:19.880
Yeah.
So, it's like,

186
00:08:19.880 --> 00:08:22.530
it's not even your problem now,
like, just use it.

187
00:08:22.530 --> 00:08:23.860
I've never had a problem mongodb.

188
00:08:23.860 --> 00:08:25.420
I've built client work of mongodb.

189
00:08:25.420 --> 00:08:26.860
I've never had a problem.

190
00:08:26.860 --> 00:08:29.536
I have know people who have
had that problems with, but

191
00:08:29.536 --> 00:08:31.233
I've never had problems with it.

192
00:08:32.934 --> 00:08:35.010
&gt;&gt; Speaker 3: More stuff
rolling in on that.

193
00:08:35.010 --> 00:08:37.270
So, when building a backend API like this,

194
00:08:37.270 --> 00:08:40.990
why use NoSQL database or
relational database?

195
00:08:40.990 --> 00:08:44.260
Mongo seems pretty much trying to
replicate much of the functionality of

196
00:08:44.260 --> 00:08:45.760
a relational database.

197
00:08:45.760 --> 00:08:47.450
But I think you kind of just covered that.

198
00:08:47.450 --> 00:08:48.715
&gt;&gt; Scott Moss: Yeah,
Mongoose is trying to,

199
00:08:48.715 --> 00:08:51.300
because the argument
was Mongo doesn't care.

200
00:08:51.300 --> 00:08:52.390
You're right.

201
00:08:52.390 --> 00:08:53.780
Mongo doesn't care about the database.

202
00:08:53.780 --> 00:08:58.630
Mongoose is like, but we want that same
thing as we did, relational databases,

203
00:08:58.630 --> 00:08:59.430
without the overhead.

204
00:08:59.430 --> 00:09:01.620
So, we're just gonna attach the Mongo.

205
00:09:01.620 --> 00:09:04.520
So yeah, but
it's not exactly the same though, right.

206
00:09:04.520 --> 00:09:09.090
Like on Mongoose you have
a schema that's guaranteed

207
00:09:09.090 --> 00:09:11.820
you that the data is going to be saved
this way, whereas a relational database,

208
00:09:11.820 --> 00:09:13.790
it has nothing to do with the ORM.

209
00:09:13.790 --> 00:09:16.260
It's the database that's saying
this is how it's gonna be saved.

210
00:09:16.260 --> 00:09:18.630
Relational database is that
fix with columns, right.

211
00:09:18.630 --> 00:09:20.600
So like it's the database that's saying,

212
00:09:20.600 --> 00:09:24.360
this is how it's gonna be whereas like,
Mongo, it's still just doesn't care.

213
00:09:24.360 --> 00:09:25.940
You just have this driver on top of it.

214
00:09:25.940 --> 00:09:29.310
This ODM,
this ORM that's doing all that validation.

215
00:09:29.310 --> 00:09:31.440
So, it's really not the same thing.

216
00:09:31.440 --> 00:09:33.300
It's more so on a higher level.

217
00:09:33.300 --> 00:09:35.230
It's just very abstracted away.

218
00:09:35.230 --> 00:09:38.850
So it looks, you get the same result but
the same thing is not happening.

219
00:09:38.850 --> 00:09:43.450
But there are pros and cons,
Postgress users json now so

220
00:09:43.450 --> 00:09:47.160
you can throw json in Postgress, whereas
you couldn't before so there's tons

221
00:09:47.160 --> 00:09:50.390
of support for that, and it also depends
on what you're doing with your data.

222
00:09:50.390 --> 00:09:54.190
Like for a time series sort of data,
I don't know, Mongo is probably good, but

223
00:09:54.190 --> 00:09:57.160
you probably want a better database for
time series, but

224
00:09:57.160 --> 00:09:58.350
it also depends on the type of data.

225
00:09:58.350 --> 00:10:01.090
So and then there's like,
you know, geospatial support.

226
00:10:01.090 --> 00:10:03.190
Mongo has pretty good geospatial support,
but

227
00:10:03.190 --> 00:10:05.060
definitely not as good as like Postgress.

228
00:10:05.060 --> 00:10:07.380
Postgress has some of
the best geospatial support.

229
00:10:07.380 --> 00:10:11.124
So, it all depends on the type
of data you're having.

230
00:10:13.203 --> 00:10:15.380
&gt;&gt; Speaker 4: Can you elaborate
more on the time series data?

231
00:10:15.380 --> 00:10:17.050
If you're working on something like that?

232
00:10:17.050 --> 00:10:18.740
What do you recommend the most?

233
00:10:18.740 --> 00:10:20.448
&gt;&gt; Scott Moss: I can't recommend anything,

234
00:10:20.448 --> 00:10:24.860
because I've never worked on time series
data, but I can show you the best one.

235
00:10:24.860 --> 00:10:25.795
It's super easy.

236
00:10:25.795 --> 00:10:29.368
Best time series database.

237
00:10:29.368 --> 00:10:36.350
Okay that didn't turn- that didn't come
back and do what it was supposed to do.

238
00:10:36.350 --> 00:10:39.400
I can't think about time,
not influence, that's not the one.

239
00:10:40.790 --> 00:10:41.990
I can't, I can't recommend that.

240
00:10:41.990 --> 00:10:44.400
I have never had to deal with
time series databases, so.

241
00:10:44.400 --> 00:10:46.440
But there are some,
some good ones out there.

242
00:10:50.052 --> 00:10:51.789
&gt;&gt; Scott Moss: I wouldn't recommend
something like Postgress or

243
00:10:51.789 --> 00:10:52.560
something like that.

244
00:10:52.560 --> 00:10:54.600
I wouldn't recommend
a relational database like that.

245
00:10:54.600 --> 00:10:57.050
&gt;&gt; Speaker 4: How about something
like Firebase or Mombo DB?

246
00:10:57.050 --> 00:10:57.700
&gt;&gt; Scott Moss: Firebase.

247
00:10:57.700 --> 00:10:58.680
&gt;&gt; Speaker 4: Or Mombo DB?

248
00:10:58.680 --> 00:10:59.634
&gt;&gt; Scott Moss: I wouldn't
recommend Firebase.

249
00:10:59.634 --> 00:11:02.870
No, I like Firebase,
because they're realtime.

250
00:11:02.870 --> 00:11:05.120
I wouldn't recommend them
as like my data store,

251
00:11:05.120 --> 00:11:07.620
like this is where I'm gonna store
all the data for my applications.

252
00:11:07.620 --> 00:11:08.310
Time series data?

253
00:11:08.310 --> 00:11:09.640
No.
You can't even query it,

254
00:11:09.640 --> 00:11:11.700
so you'd be screwed.

255
00:11:11.700 --> 00:11:14.670
&gt;&gt; Speaker 4: If you had somewhere
where you process all the work, but

256
00:11:14.670 --> 00:11:18.787
if you want to present data once the
processing is done in time series maybe

257
00:11:18.787 --> 00:11:20.199
Firebase is good for that?

258
00:11:22.540 --> 00:11:24.920
&gt;&gt; Scott Moss: When you can't process,
you can't process correctly.

259
00:11:25.960 --> 00:11:27.080
&gt;&gt; Speaker 4: But just to present the ones

260
00:11:28.330 --> 00:11:32.580
you like once your done processing in some
other place to able to present it out and.

261
00:11:32.580 --> 00:11:35.440
&gt;&gt; Scott Moss: I don't know I
wouldn't use firebase for that.

262
00:11:35.440 --> 00:11:37.020
Your limited to what you can query.

263
00:11:37.020 --> 00:11:40.820
Like you can't say give me this
specific thing and this specific time.

264
00:11:40.820 --> 00:11:43.750
You can't do that it's just
like give me all the things.

265
00:11:43.750 --> 00:11:46.740
If you want to do that filtering for
the client, you can do it.

266
00:11:46.740 --> 00:11:48.920
If that's what you're talking about.

267
00:11:48.920 --> 00:11:51.180
Yeah, you could totally do that.

268
00:11:51.180 --> 00:11:53.620
You're just like, dump me the thing and
I'll do it over here.

269
00:11:53.620 --> 00:11:54.790
Yeah, you could do that.

270
00:11:54.790 --> 00:11:56.290
But for more fine-grained control,

271
00:11:56.290 --> 00:11:59.500
I want the database to do the sorting and
filtering for me.

272
00:11:59.500 --> 00:12:01.030
You're not gonna,
Firebase isn't meant for that.

273
00:12:01.030 --> 00:12:02.240
It's not what it's meant for.

274
00:12:02.240 --> 00:12:04.200
&gt;&gt; Speaker 4: So
then Mongo is better at that?

275
00:12:04.200 --> 00:12:06.020
&gt;&gt; Scott Moss: Mongo is definitely
better at that than Firebase,

276
00:12:06.020 --> 00:12:08.470
but there are still better
things out there than Mongo

277
00:12:08.470 --> 00:12:10.470
as far as time series database goes.

278
00:12:10.470 --> 00:12:12.110
I just can't think of any,
because I've never used them.

