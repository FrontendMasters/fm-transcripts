WEBVTT

1
00:00:00.510 --> 00:00:04.360
&gt;&gt; Kyle Simpson: I think one of the most
important answers to the why functional

2
00:00:04.360 --> 00:00:07.210
programming is this
concept of provability.

3
00:00:08.500 --> 00:00:14.188
What functional programming seeks
to do at least from my perspective,

4
00:00:14.188 --> 00:00:19.588
what it seeks to do is to use patterns
that have already been tried and

5
00:00:19.588 --> 00:00:23.214
tested and proven and
not for like two years.

6
00:00:23.214 --> 00:00:24.690
You know how we get all excited.

7
00:00:24.690 --> 00:00:27.230
Cuz two years ago,
somebody invented Reactor.

8
00:00:27.230 --> 00:00:31.570
3.5 years ago, they invented Angular and
we're all hyperexcited about that.

9
00:00:31.570 --> 00:00:34.164
In a year from now,
we're gonna be excited about Vue.

10
00:00:34.164 --> 00:00:37.266
And then a year after that, we're gonna
be excited about whatever that thing

11
00:00:37.266 --> 00:00:39.580
is that somebody in here is inventing.

12
00:00:39.580 --> 00:00:45.410
Because we have this very small,
almost myopic view of innovation and

13
00:00:45.410 --> 00:00:50.180
of the deep thought processes that
go into building this stuff that

14
00:00:50.180 --> 00:00:53.240
we use the foundations that we walk upon.

15
00:00:55.060 --> 00:00:58.298
These are ideas that have been around for
like 50 years or more.

16
00:00:58.298 --> 00:01:02.267
As a matter of fact,
the mathematical principles underneath

17
00:01:02.267 --> 00:01:06.769
them had have been around for hundreds
of years not a couple of years and

18
00:01:06.769 --> 00:01:11.680
they don't just have a couple thousand
people starring the repo on GitHub.

19
00:01:13.150 --> 00:01:17.570
We've got tens and hundreds of thousands
of mathematicians, and computer

20
00:01:17.570 --> 00:01:22.200
scientists that have vetted these ideas,
and they've proven these ideas work.

21
00:01:23.410 --> 00:01:27.383
And what they've said is here's
this crazy term monoid and

22
00:01:27.383 --> 00:01:32.160
it describes this thing, which is
proven to do a thing you wanted to do.

23
00:01:32.160 --> 00:01:38.480
So use it, so that your code in
that part has a proof to it.

24
00:01:39.910 --> 00:01:42.400
Many of you probably know

25
00:01:42.400 --> 00:01:47.280
that it's important to have tests around
your code and I certainly agree with that.

26
00:01:47.280 --> 00:01:48.045
You should have unit tests.

27
00:01:48.045 --> 00:01:49.285
You should have integration tests.

28
00:01:49.285 --> 00:01:54.412
But there's a hint here that in a sense,
the aspiration should

29
00:01:54.412 --> 00:01:59.248
be that we should write a piece
of code and know verifiably,

30
00:01:59.248 --> 00:02:04.594
provably what it's gonna do without
even needing the unit test.

31
00:02:04.594 --> 00:02:09.442
Like I already know the unit test is gonna
pass, cuz I used a mathematically proven

32
00:02:09.442 --> 00:02:12.900
concept to model it and
you're not gonna argue with math.

33
00:02:14.310 --> 00:02:16.330
If you get a bug and
the unit test doesn't pass,

34
00:02:16.330 --> 00:02:17.960
it's cuz you didn't
implement it correctly.

35
00:02:20.020 --> 00:02:22.300
So I think the functional programmer says,

36
00:02:23.370 --> 00:02:27.680
let me try to use
mechanisms that are proven.

37
00:02:28.890 --> 00:02:32.852
And you might wonder, okay,
is that just like an academic exercise?

38
00:02:32.852 --> 00:02:36.289
Do you just make yourself feel clever,
because your code is more provable or

39
00:02:36.289 --> 00:02:37.320
something like that.

40
00:02:37.320 --> 00:02:38.620
There's something much deeper here.

41
00:02:39.630 --> 00:02:45.200
Not only does provable code make it so
that you can understand that code better,

42
00:02:45.200 --> 00:02:47.910
because I've said this before and
I'll say it a million more times.

43
00:02:49.540 --> 00:02:54.340
Code that you do not stand is
code that you cannot trust and

44
00:02:54.340 --> 00:02:56.547
the reverse is also true.

45
00:02:56.547 --> 00:03:00.160
Code that you cannot trust is
code that you cannot understand.

46
00:03:01.980 --> 00:03:06.500
If you cannot trust that it will
do exactly what you want it to do,

47
00:03:06.500 --> 00:03:07.940
you don't fully understand it yet.

48
00:03:09.580 --> 00:03:13.559
Let me ask you this way, how many of
you ever had a piece of code break and

49
00:03:13.559 --> 00:03:15.396
you weren't sure why it broke?

50
00:03:15.396 --> 00:03:16.442
Anybody?

51
00:03:16.442 --> 00:03:19.066
We're all mostly raising our hands.

52
00:03:19.066 --> 00:03:20.469
We're in good company.

53
00:03:20.469 --> 00:03:22.474
Let me ask a more profound question,

54
00:03:22.474 --> 00:03:26.690
how many of you have had a piece of code
work and you didn't know why it worked?

55
00:03:28.340 --> 00:03:32.520
It's a little closer to the heart,
doesn't it?

56
00:03:32.520 --> 00:03:34.371
So we have to admit that, but it's true.

57
00:03:34.371 --> 00:03:36.877
We all do this and I include myself.

58
00:03:36.877 --> 00:03:41.669
I wrote code a few days ago on the plane
ride here, I don't know how it works.

59
00:03:41.669 --> 00:03:43.298
Literally, I don't know how it works.

60
00:03:43.298 --> 00:03:45.740
I don't fully understand what I did.

61
00:03:45.740 --> 00:03:51.640
So, code that you can't trust is code
that you can't fully understand.

62
00:03:51.640 --> 00:03:54.652
In a functional program, it says,
one way to trust my code better is to

63
00:03:54.652 --> 00:03:57.271
use a pattern that's already
been mathematically proven.

64
00:03:57.271 --> 00:03:59.624
I don't need to go figure
that part out again.

65
00:03:59.624 --> 00:04:03.409
I just need to understand it and then
understand how to put it together, and

66
00:04:03.409 --> 00:04:06.473
then understand this other Lego piece and
how it fits in, and

67
00:04:06.473 --> 00:04:08.356
what their effect together will do.

68
00:04:08.356 --> 00:04:11.519
And I just build my program as
a series of those assertions.

69
00:04:13.040 --> 00:04:19.100
Removing large swaths of the program
from the sphere of concern.

70
00:04:20.780 --> 00:04:23.870
There are parts of your program that
you're always gonna have to wonder about,

71
00:04:23.870 --> 00:04:27.380
your business logic,
your validation rules.

72
00:04:27.380 --> 00:04:31.410
But there's also large swaths
of the program that represent

73
00:04:31.410 --> 00:04:36.040
verifiable transformations on data that
you shouldn't have to worry about.

74
00:04:36.040 --> 00:04:37.590
You should be able to fully trust it.

75
00:04:38.950 --> 00:04:44.090
It should be provable and your own
intuition about how to prove stuff with

76
00:04:44.090 --> 00:04:50.220
a unit test is not as good as the stuff
that's been proven by mathematicians for

77
00:04:50.220 --> 00:04:53.780
hundreds of years, and
by computer scientists for decades.

78
00:04:55.110 --> 00:04:55.610
It's just not.

79
00:04:57.400 --> 00:05:01.690
So in a sense, I think a functional
programmer admits that.

80
00:05:01.690 --> 00:05:03.610
Says, I need some help.

81
00:05:03.610 --> 00:05:07.420
So, I'm gonna use this domain called
functional programming to find patterns

82
00:05:07.420 --> 00:05:09.920
that I can use in my code that
have already been proven.

83
00:05:11.430 --> 00:05:16.100
But there is something deeper and
this is I think the ultimate motivation,

84
00:05:16.100 --> 00:05:16.930
the ultimate question.

85
00:05:18.380 --> 00:05:24.588
Code that's already been proven and
code that's already recognizable as such.

86
00:05:24.588 --> 00:05:29.112
Meaning, if you structure it in
such a way that it is easily at

87
00:05:29.112 --> 00:05:34.172
a glance recognizable as
an implementation of that proven theory,

88
00:05:34.172 --> 00:05:37.898
also means that,
that code does not have to take up

89
00:05:37.898 --> 00:05:42.460
the neuron processing time in
you brain as you read the code.

90
00:05:44.750 --> 00:05:47.980
What I really think the deepest
motivation for functional programming is,

91
00:05:47.980 --> 00:05:53.450
it's not just to help you, the author
of the code have a confidence and

92
00:05:53.450 --> 00:05:57.130
a level of provability and
trustability to what you've written.

93
00:05:57.130 --> 00:06:01.317
But it is also to help the reader
of your code be able to trust that

94
00:06:01.317 --> 00:06:04.886
they don't have to worry
about how these parts work.

95
00:06:04.886 --> 00:06:06.330
They know what they do.

96
00:06:06.330 --> 00:06:08.310
They know that you're using them.

97
00:06:08.310 --> 00:06:12.460
There's a part of the code
I don't need to read and

98
00:06:12.460 --> 00:06:15.790
I'll make the almost silly assertion.

99
00:06:15.790 --> 00:06:18.720
The most readable code is the code
that doesn't have to be read at all,

100
00:06:20.930 --> 00:06:26.156
because our brand should be focused
on the stuff that really matters.

101
00:06:26.156 --> 00:06:29.142
The high-level, macro-level,
business logic,

102
00:06:29.142 --> 00:06:33.069
validation rules kinds of stuff use
on our action rules, all of that.

103
00:06:33.069 --> 00:06:35.503
That's what we should focus on,
but we get so

104
00:06:35.503 --> 00:06:38.140
distracted by focusing
on all this other stuff.

105
00:06:39.900 --> 00:06:42.750
And a function department says, why don't
we just do all that other stuff in our

106
00:06:42.750 --> 00:06:46.280
provable trusted way, a recognizable way?

107
00:06:46.280 --> 00:06:48.810
That way, the reader of the code doesn't
need to worry about that part anymore.

108
00:06:50.220 --> 00:06:51.270
If they recognize it,

109
00:06:51.270 --> 00:06:55.020
if they've learned what it does,
I don't need to think about it.

110
00:06:55.020 --> 00:06:58.393
Imagine the mountain climber having
to think at every single moment.

111
00:06:58.393 --> 00:07:01.690
Now, how does this carabiner work and
what is this rope doing?

112
00:07:01.690 --> 00:07:05.063
I don't even know what rock climbing
equipment is, so I'm just pretending.

113
00:07:05.063 --> 00:07:05.850
I've just Googled stuff.

114
00:07:07.580 --> 00:07:10.610
Imagine him having,
while on the face of a mountain,

115
00:07:10.610 --> 00:07:13.070
having to think about all those
individual little things.

116
00:07:14.120 --> 00:07:16.270
Would that be an effective
way to climb a mountain?

117
00:07:17.620 --> 00:07:18.120
I don't think so.

118
00:07:20.390 --> 00:07:23.250
A mountain climber trusts his tools.

119
00:07:23.250 --> 00:07:26.801
The mountain climber knows what the rope
does and knows what the carabiner does and

120
00:07:26.801 --> 00:07:27.830
knows that if he falls,

121
00:07:27.830 --> 00:07:32.415
it's gonna catch him.
&gt;&gt; Kyle Simpson: A functional program

122
00:07:32.415 --> 00:07:34.700
are trust as tools.

123
00:07:34.700 --> 00:07:35.949
Knows what it's gonna do.

124
00:07:35.949 --> 00:07:39.286
Functional program are trusted
tools used by others.

125
00:07:39.286 --> 00:07:42.410
And when they read their code, they don't
have to go second guess that stuff.

126
00:07:44.370 --> 00:07:45.580
That helps code be more readable.

127
00:07:47.670 --> 00:07:50.260
And ultimately,
the reason I think code readability is so

128
00:07:50.260 --> 00:07:56.040
important is because the most important
thing that we can be doing as programmers

129
00:07:56.040 --> 00:07:58.440
is communicating with other human beings.

130
00:07:58.440 --> 00:08:02.070
That's not a unique thought to me,
but I believe it deeply.

131
00:08:02.070 --> 00:08:03.230
Almost at a religious level

132
00:08:04.370 --> 00:08:07.510
that our goal should be to better
communicate with other people.

133
00:08:08.780 --> 00:08:11.758
The computer is already figuring
out from what you write,

134
00:08:11.758 --> 00:08:14.625
whatever amazing code you
think you've architected.

135
00:08:14.625 --> 00:08:17.920
The computer already looks at it and says,
thanks very much for that suggestion.

136
00:08:17.920 --> 00:08:19.565
But I'm gonna do it in
an entirely different way.

137
00:08:19.565 --> 00:08:20.651
Thanks very much.

138
00:08:20.651 --> 00:08:21.690
Why do we get so

139
00:08:21.690 --> 00:08:26.649
obsessed about what we write as if
the computer cares what we write?

140
00:08:28.160 --> 00:08:33.810
Why don't we focus a little bit more and

141
00:08:33.810 --> 00:08:38.480
a lot more on structuring the code,
so that other readers

142
00:08:38.480 --> 00:08:42.840
including your future selves have an
easier time understanding what's going on.

143
00:08:44.810 --> 00:08:48.550
That to me,
at least at this point in my journey,

144
00:08:48.550 --> 00:08:52.290
I'm a little bit further up the cliff
face climbing than you are.

145
00:08:52.290 --> 00:08:54.470
That to me is the why we're
climbing the mountain.

146
00:08:55.910 --> 00:08:57.230
That's why functional programming.

147
00:08:58.570 --> 00:09:00.931
Use mechanisms that have
been proven not only so

148
00:09:00.931 --> 00:09:04.296
that you have a confidence over your
code and you understand it, but

149
00:09:04.296 --> 00:09:07.424
that the reader of your code has
the same level of confidence and

150
00:09:07.424 --> 00:09:12.071
understanding.
&gt;&gt; Kyle Simpson: So,

151
00:09:12.071 --> 00:09:14.076
let me pause there for a moment.

152
00:09:14.076 --> 00:09:19.134
Any thoughts or questions about
those assertions before I move on?

153
00:09:19.134 --> 00:09:21.327
Yes.
&gt;&gt; Speaker 2: Just one question

154
00:09:21.327 --> 00:09:22.093
from online.

155
00:09:22.093 --> 00:09:27.431
Craig asked, when you move from
imperative to declarative, are you

156
00:09:27.431 --> 00:09:32.313
increasing the level of abstraction?
&gt;&gt; Kyle Simpson: Abstraction is a funny

157
00:09:32.313 --> 00:09:36.885
thing and we're gonna talk
more about abstraction, but

158
00:09:36.885 --> 00:09:39.372
it's one of our fundamental.

159
00:09:39.372 --> 00:09:42.340
It's one of our most important
concepts in programming.

160
00:09:43.940 --> 00:09:48.270
And yet, I think a lot of people have
the wrong intuition about what abstraction

161
00:09:48.270 --> 00:09:49.860
really is.

162
00:09:49.860 --> 00:09:54.306
I bet if I were to poll each of you and
those of you online and I were to say,

163
00:09:54.306 --> 00:09:57.123
tell me what,
if we were in a job interview and

164
00:09:57.123 --> 00:10:01.443
I gave you the job interview question,
tell me what abstraction is.

165
00:10:01.443 --> 00:10:02.602
Define abstraction.

166
00:10:02.602 --> 00:10:04.201
Give me examples of abstraction.

167
00:10:04.201 --> 00:10:09.742
I bet what I would hear from most of you
is something along the lines of well,

168
00:10:09.742 --> 00:10:11.830
abstraction hides details.

169
00:10:13.340 --> 00:10:14.397
Something to that effect.

170
00:10:14.397 --> 00:10:18.475
We think about class-oriented coding or
hiding details inside of the class

171
00:10:18.475 --> 00:10:21.160
implementation and
we call that an abstraction.

172
00:10:23.190 --> 00:10:25.190
That's not really what abstraction is or

173
00:10:25.190 --> 00:10:30.420
at least it's not what abstraction
was originally designed to describe.

174
00:10:31.520 --> 00:10:35.250
That concept, hiding details in
particular has a different term and

175
00:10:35.250 --> 00:10:36.449
that's called encapsulation.

176
00:10:38.700 --> 00:10:40.480
Abstraction is a little different.

177
00:10:42.310 --> 00:10:47.030
Abstraction actually comes
to us from a very old root.

178
00:10:47.030 --> 00:10:51.320
If you think about the word complex,
that comes to us from the Latin root for

179
00:10:51.320 --> 00:10:56.530
complect or complected and
that comes to us from this idea of

180
00:10:56.530 --> 00:11:00.260
the strands of a rope being
tightly braided together.

181
00:11:00.260 --> 00:11:02.970
And we know a rope that when it's
braided together, it's much stronger.

182
00:11:04.130 --> 00:11:08.450
But we also know that if you have
a tightly braided strands of rope and then

183
00:11:08.450 --> 00:11:12.680
you wanted to take just one of the strands
out, that would be virtually impossible.

184
00:11:14.660 --> 00:11:19.280
So, complected comes to us from this idea
of having things tightly wound together.

185
00:11:20.410 --> 00:11:24.460
And actually, we get simple as
the opposite of that where things

186
00:11:24.460 --> 00:11:29.713
are completely separate and that's really
what abstraction was actually about.

187
00:11:29.713 --> 00:11:32.701
It was not about taking some detail and
hiding it away, so

188
00:11:32.701 --> 00:11:34.452
we don't have to think about it.

189
00:11:34.452 --> 00:11:39.913
Rather, it was taking two or more
things that were tightly wound together

190
00:11:39.913 --> 00:11:45.108
like the strands of a rope and
teasing them apart, separating them and

191
00:11:45.108 --> 00:11:49.530
putting intentionally between
them a semantic boundary.

192
00:11:51.230 --> 00:11:54.280
Not so that we don't have to think
about one or the other, but so

193
00:11:54.280 --> 00:11:59.020
that we can comfortably sit on either
side of that semantic boundary.

194
00:11:59.020 --> 00:12:01.810
Understand what that
thing is in its full and

195
00:12:01.810 --> 00:12:05.380
completeness without worrying about the
stuff on the other side of the boundary.

196
00:12:06.630 --> 00:12:09.910
Abstraction is about creating
semantic boundaries between things.

197
00:12:11.080 --> 00:12:16.945
So in a sense, the question that was
asked is imperative to declarative.

198
00:12:16.945 --> 00:12:21.180
Is that move towards declarative about
adding extra, extra, abstractions?

199
00:12:21.180 --> 00:12:23.480
In its pure essence, yes.

200
00:12:23.480 --> 00:12:25.790
But it's not about hiding things.

201
00:12:25.790 --> 00:12:27.220
That's not what we wanna do.

202
00:12:28.410 --> 00:12:31.845
It's about creating the appropriate
layers of separation.

203
00:12:31.845 --> 00:12:36.845
The appropriate boundaries of separation,
so that we can independently think about,

204
00:12:36.845 --> 00:12:39.730
reason about and prove each piece.

205
00:12:39.730 --> 00:12:41.044
That's what it's really about.

206
00:12:41.044 --> 00:12:42.918
We're gonna see many more
examples about this, so

207
00:12:42.918 --> 00:12:45.458
I'm not gonna get any further into
that discussion of abstraction.

208
00:12:45.458 --> 00:12:48.083
But I wanted to provide some
more color to that question.

209
00:12:48.083 --> 00:12:51.100
In the basic sense, yes, it is.

210
00:12:51.100 --> 00:12:54.769
But it's about adding
the right kind of abstraction.

211
00:12:56.940 --> 00:12:59.030
There's lots of abstraction you can do.

212
00:12:59.030 --> 00:13:00.210
There's lots of things you can do and

213
00:13:00.210 --> 00:13:03.710
call them abstraction that aren't
going to aid us in that goal.

