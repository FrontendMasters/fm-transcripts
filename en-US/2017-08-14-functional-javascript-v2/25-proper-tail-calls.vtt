WEBVTT

1
00:00:00.660 --> 00:00:05.180
&gt;&gt; Kyle Simpson: So back to our summation
recur that we've been working on

2
00:00:05.180 --> 00:00:07.310
before we did the exercise.

3
00:00:07.310 --> 00:00:12.460
This was representation of that function
and you notice we did that peek ahead.

4
00:00:12.460 --> 00:00:20.212
But there's something that we all have to
come to grips with around this recursion,

5
00:00:20.212 --> 00:00:27.550
which is that recursion is one of those
things that in theory works great.

6
00:00:27.550 --> 00:00:31.460
But there are some practical limitations
that computer scientists have always

7
00:00:31.460 --> 00:00:32.070
had to deal with.

8
00:00:33.190 --> 00:00:38.741
To understand those practical limitations,
we do have to think a little bit.

9
00:00:38.741 --> 00:00:42.279
We have to go a little bit
deeper under the covers,

10
00:00:42.279 --> 00:00:44.730
if you will to how function calls.

11
00:00:44.730 --> 00:00:47.210
And how something like recursion
would actually get implemented,

12
00:00:47.210 --> 00:00:50.030
how it would get processed,
by an engine that was running this code.

13
00:00:50.030 --> 00:00:53.530
And what I'm about to say really doesn't
have anything specific to do with

14
00:00:53.530 --> 00:00:54.720
JavaScript.

15
00:00:54.720 --> 00:00:58.890
It really is just about the idea
of how a computer could express

16
00:00:58.890 --> 00:01:02.000
something like recursion for
languages that support that.

17
00:01:02.000 --> 00:01:06.120
It really goes all the way back to some
of the original, earliest languages,

18
00:01:06.120 --> 00:01:09.870
the lists,
they had recursion very early on and

19
00:01:09.870 --> 00:01:11.950
they had to deal with
this particular problem.

20
00:01:13.470 --> 00:01:15.490
So we want to try to

21
00:01:17.090 --> 00:01:20.230
understand what that is gonna imply
about our usage of recursion.

22
00:01:21.230 --> 00:01:25.390
You'll notice that we make a call
to sumRecur here on line three,

23
00:01:25.390 --> 00:01:28.620
we make this call to sumRecur.

24
00:01:28.620 --> 00:01:32.340
And that is actually no different
than calling any other function.

25
00:01:32.340 --> 00:01:35.750
It's not like it's special because
it happens to be calling itself.

26
00:01:35.750 --> 00:01:37.120
It's calling any other function.

27
00:01:37.120 --> 00:01:41.590
So we could really generalize this to
saying that could have just been a called

28
00:01:41.590 --> 00:01:43.580
a foo or a bar or something.

29
00:01:43.580 --> 00:01:47.099
But any time one function makes
a call to another function.

30
00:01:48.210 --> 00:01:53.961
All right, question has to get asked which
is, what is the current state of things,

31
00:01:53.961 --> 00:01:58.173
the current set of variables,
the current position within,

32
00:01:58.173 --> 00:02:02.308
the statements and
expressions when that call dispatches.

33
00:02:02.308 --> 00:02:04.911
Because we need to save all
of that information, so

34
00:02:04.911 --> 00:02:08.980
that we can restore it when we're done
with that function call and we come back.

35
00:02:10.210 --> 00:02:11.290
So we could ask ourselves,

36
00:02:11.290 --> 00:02:16.540
what is gonna happen after the call
to sumRecur on line three?

37
00:02:16.540 --> 00:02:20.160
Say it's gone off and done its work and
now it's given us a value back,

38
00:02:20.160 --> 00:02:22.990
what's gonna happen after it?

39
00:02:22.990 --> 00:02:26.060
Well, clearly what's gonna happen
after it is that it's gonna get added.

40
00:02:26.060 --> 00:02:30.410
Its results are gonna get added to
the sum variable and then returned.

41
00:02:30.410 --> 00:02:32.390
So there's a little bit
of work left to do,

42
00:02:32.390 --> 00:02:35.190
we're not fully done with this function.

43
00:02:35.190 --> 00:02:40.180
Because we're not fully done,
preserving that state is super important.

44
00:02:40.180 --> 00:02:44.650
So the way computers generally
implement this idea of a function

45
00:02:44.650 --> 00:02:47.230
that could call another function
that could call another.

46
00:02:47.230 --> 00:02:50.960
In memory they reserve an area
of memory that's given the name

47
00:02:50.960 --> 00:02:53.090
a stack frame, generally.

48
00:02:53.090 --> 00:02:56.536
It's a small area of memory that
keeps track of all the variables,

49
00:02:56.536 --> 00:03:00.500
sometimes referred to as
the variables that are on the stack.

50
00:03:00.500 --> 00:03:03.500
It keeps track of all of the variables
that it knows about, keeps track of

51
00:03:03.500 --> 00:03:08.440
the program counter, the position it is
in the program, things of that nature.

52
00:03:08.440 --> 00:03:10.370
So there's some state that
it has to keep track of.

53
00:03:10.370 --> 00:03:15.350
And if you've ever heard of
the call stack, we use that word

54
00:03:15.350 --> 00:03:19.980
stack because, as a data structure we
talk about an item that comes here and

55
00:03:19.980 --> 00:03:23.060
then a stack, another item on, and
another item, and another item.

56
00:03:23.060 --> 00:03:26.580
And when we're done, we pop that off
the stack, and pop that one, and

57
00:03:26.580 --> 00:03:27.820
pop the next one.

58
00:03:27.820 --> 00:03:30.070
So calls are kinda modeled the same way.

59
00:03:30.070 --> 00:03:34.280
We have a call to the current function,
and then when we need to make a new call

60
00:03:34.280 --> 00:03:37.480
to another function,
it's gonna need its own area of memory.

61
00:03:37.480 --> 00:03:40.940
So we make another stack frame and
put it on the call stack.

62
00:03:40.940 --> 00:03:44.120
And then if it calls to another function,
we make another stack frame and

63
00:03:44.120 --> 00:03:46.930
put it on, and they stack up and
they stack up.

64
00:03:46.930 --> 00:03:49.260
Now this is not a lot of
memory being used, but

65
00:03:49.260 --> 00:03:52.550
it is a small amount of memory being used.

66
00:03:52.550 --> 00:03:55.340
Maybe couple dozen bytes, 100, 200 bytes.

67
00:03:55.340 --> 00:03:56.500
Something like that.

68
00:03:56.500 --> 00:03:58.640
It's a not a ton of memory,
but it is getting used.

69
00:03:59.650 --> 00:04:04.990
And we know that machines run with, have a
fixed amount of memory that they can use.

70
00:04:06.500 --> 00:04:11.190
So it probably doesn't take too much
of a leap of understanding to realize

71
00:04:11.190 --> 00:04:15.150
that that means that a call
stack only has a fixed number of

72
00:04:15.150 --> 00:04:18.760
depth that it can go before we're gonna
exhaust all the memory in the system.

73
00:04:20.220 --> 00:04:22.850
And when you think back
to the 50s when lists and

74
00:04:22.850 --> 00:04:26.960
recursions were kinda being
wrestled with the first time.

75
00:04:26.960 --> 00:04:30.770
[COUGH]
They had the exact same problem, but

76
00:04:30.770 --> 00:04:32.210
they had a lot less memory than we did.

77
00:04:32.210 --> 00:04:36.330
They had a lot less memory in
their computers than we did.

78
00:04:36.330 --> 00:04:38.550
So it was a very pronounced problem for
them.

79
00:04:39.560 --> 00:04:44.580
And so what we observed back

80
00:04:44.580 --> 00:04:50.230
then was recursion works if I'm going
to just like a callstack would work.

81
00:04:50.230 --> 00:04:53.690
Recursion works if I'm
gonna do a small data set.

82
00:04:53.690 --> 00:04:58.440
But if I'm gonna end up, for example,
summing up a list of 10,000 numbers,

83
00:04:58.440 --> 00:05:00.670
now I'm gonna have 10,000 stack frames.

84
00:05:00.670 --> 00:05:02.253
What about 100,000 numbers?

85
00:05:02.253 --> 00:05:03.350
That's 100,000 stack frames.

86
00:05:03.350 --> 00:05:06.900
At some point,
there's a physical limit to the system.

87
00:05:08.320 --> 00:05:09.740
At some point we've run out.

88
00:05:09.740 --> 00:05:11.310
Now when you weren't doing recursion.

89
00:05:11.310 --> 00:05:13.540
If you just did foo calls, bar calls,

90
00:05:13.540 --> 00:05:18.370
bass, you're almost never gonna run out
of call stack space because you're never

91
00:05:18.370 --> 00:05:23.180
gonna have a million separate functions
most likely in your application.

92
00:05:23.180 --> 00:05:26.000
And you're certainly not gonna
wire up a million different

93
00:05:26.000 --> 00:05:27.680
function calls like that.

94
00:05:27.680 --> 00:05:30.800
You probably at most have,
I don't know 10,

95
00:05:30.800 --> 00:05:35.180
maybe 15 calls stacked up
whenever recursion isn't in play.

96
00:05:35.180 --> 00:05:38.950
So a lot of people think this problem
is specifically related to recursion.

97
00:05:38.950 --> 00:05:42.610
It's really related to any function calls,
but

98
00:05:42.610 --> 00:05:46.069
you almost never would observe it
unless recursion was involved.

99
00:05:48.840 --> 00:05:50.370
So, what are we gonna do?

100
00:05:50.370 --> 00:05:55.858
Because we're developers, we like to
extrapolate things to their extremes.

101
00:05:55.858 --> 00:06:00.803
This is all well and good if I know I'm
only gonna have 5 or 10 or 100 numbers.

102
00:06:00.803 --> 00:06:03.466
But what somebody in production
gives me a million numbers?

103
00:06:03.466 --> 00:06:07.160
Am I gonna run out of space,
how many can I go?

104
00:06:07.160 --> 00:06:08.750
How do I even know how far I can go?

105
00:06:08.750 --> 00:06:13.500
Cuz I don't know how much memory is on
somebody's mobile phone or on the device,

106
00:06:13.500 --> 00:06:15.220
how do I even know?

107
00:06:15.220 --> 00:06:18.860
Well when we talk about JavaScript,
there's a specific answer to the question.

108
00:06:18.860 --> 00:06:23.202
But in the general case they didn't really
have a generalized solution to that

109
00:06:23.202 --> 00:06:23.806
problem.

110
00:06:23.806 --> 00:06:28.720
So you just kind of ran
until you ran out of memory.

111
00:06:28.720 --> 00:06:30.660
You crossed your fingers that
you didn't run out of memory.

112
00:06:31.920 --> 00:06:34.550
That obviously was an untenable
solution for them.

113
00:06:34.550 --> 00:06:36.830
So the early days of
the computer scientist, he said,

114
00:06:36.830 --> 00:06:39.480
we have to come up with some
solution to this problem.

115
00:06:39.480 --> 00:06:41.160
That's not gonna work in general.

116
00:06:41.160 --> 00:06:43.520
If that's the way
recursion's gonna happen,

117
00:06:43.520 --> 00:06:48.480
we're never gonna really be able to use
recursion practically in any applications.

118
00:06:48.480 --> 00:06:53.180
So they said, okay, what could we do

119
00:06:53.180 --> 00:06:57.500
to reduce the amount of memory that
was having to get created every time.

120
00:06:58.890 --> 00:07:03.720
And maybe not just reduce it, but is there
some way that we could eliminate needing

121
00:07:03.720 --> 00:07:09.330
to create new memory allocation for each
function call in a recursive call stack.

122
00:07:09.330 --> 00:07:13.370
In other words,
could we run in fixed memory,

123
00:07:13.370 --> 00:07:18.140
a fixed amount of memory, instead of
an infinitely growing amount of memory?

124
00:07:18.140 --> 00:07:19.330
Whatever that fixed memory is,

125
00:07:19.330 --> 00:07:22.840
we know we can fit that within the device,
whatever device it's running on.

126
00:07:24.590 --> 00:07:28.680
So I began to think, why is it that we
need a stack frame to be kept around?

127
00:07:28.680 --> 00:07:32.150
It's because we need to restore in case

128
00:07:32.150 --> 00:07:34.140
we're gonna do anything
after the function call.

129
00:07:35.870 --> 00:07:38.850
And so they begin to think well,
what if we could arrange it, so

130
00:07:38.850 --> 00:07:41.670
there wasn't any work to
do after the function call?

131
00:07:43.170 --> 00:07:46.200
If we could arrange it so
that the function call was the last

132
00:07:46.200 --> 00:07:51.680
thing to happen, then we don't need
to actually keep that memory around.

133
00:07:51.680 --> 00:07:53.740
And so when we go to make the next call,

134
00:07:53.740 --> 00:07:58.390
we could just reuse the same stack frame,
we could just override it with.

135
00:07:58.390 --> 00:08:01.540
The memory, we could reuse that memory for
the next stack frame.

136
00:08:01.540 --> 00:08:05.684
Or a different implementation,
an alternate implementation is to create

137
00:08:05.684 --> 00:08:08.658
a new stack frame and
then just throw away the old one.

138
00:08:08.658 --> 00:08:11.331
Either way,
we could run essentially forever and

139
00:08:11.331 --> 00:08:14.206
only have one stack frame in
memory at any given time.

140
00:08:14.206 --> 00:08:18.306
That only works if we can
somehow arrange our algorithm so

141
00:08:18.306 --> 00:08:22.332
that we don't have any work
to do at the end afterwards.

142
00:08:22.332 --> 00:08:25.472
So it's this part right here, on line 3,

143
00:08:25.472 --> 00:08:30.723
it's the sum plus part that's
creating this problem for JavaScript.

144
00:08:30.723 --> 00:08:35.762
We are [COUGH] arranging this, so that
there is work to do after the recursive

145
00:08:35.762 --> 00:08:40.004
bit and that's what's gonna
keep those stack frames around.

146
00:08:40.004 --> 00:08:44.146
As via 6, the spec requires
the JavaScript engine to be

147
00:08:44.146 --> 00:08:49.083
smart enough that if you orient it,
so there's no more work to do,

148
00:08:49.083 --> 00:08:53.783
then it should be able to run
your programs without the limits.

149
00:08:53.783 --> 00:08:55.703
But when there are limits in place,

150
00:08:55.703 --> 00:08:59.233
either because you're in a browser
that doesn't support that.

151
00:08:59.233 --> 00:09:01.962
Or because you don't
arrange yourself in that

152
00:09:01.962 --> 00:09:05.044
form which we gonna talk
about that form in a second.

153
00:09:05.044 --> 00:09:10.037
Then JavaScript is gonna not allow to just
run out all the memory on the device,

154
00:09:10.037 --> 00:09:11.939
they're gonna have a limit.

155
00:09:11.939 --> 00:09:15.601
And you've probably seen that
error that's been thrown before.

156
00:09:15.601 --> 00:09:18.481
You may have run some code and
either on purpose or

157
00:09:18.481 --> 00:09:21.372
accidentally created
a really long call stack.

158
00:09:21.372 --> 00:09:26.056
And then, they got the range error
maximum call stack size exceeded.

159
00:09:26.056 --> 00:09:29.938
Now that error used to be really low,

160
00:09:29.938 --> 00:09:36.585
like I remember back in IE 4,
5, 6 that that limit was 13.

161
00:09:36.585 --> 00:09:41.779
Literally you could not call,
you could do a chain of 13 function calls,

162
00:09:41.779 --> 00:09:47.156
but when you went to the 14th one it
would throw a range error which was nuts.

163
00:09:47.156 --> 00:09:52.650
At the time I was writing a compiler, and
the compilers were recursive descent.

164
00:09:52.650 --> 00:09:57.401
And I very quickly said, well, there's a
whole bunch of programs I can't implement

165
00:09:57.401 --> 00:10:01.043
because the syntax of the language
is more than 14 levels deep.

166
00:10:01.043 --> 00:10:04.094
And so I can't compile that language.

167
00:10:04.094 --> 00:10:10.590
[COUGH] So modern days, thankfully,
we don't have a limit of 13.

168
00:10:10.590 --> 00:10:14.959
And it seems, although I'm not sure cuz
I don't work on the browser engines.

169
00:10:14.959 --> 00:10:17.726
This is all left entirely up to
the implementation to decide.

170
00:10:17.726 --> 00:10:22.396
But it seems like the engines nowadays
have an adaptive limit, where they just

171
00:10:22.396 --> 00:10:26.599
say, I am gonna stop you at some
arbitrary point that they determine.

172
00:10:26.599 --> 00:10:29.761
And they might determine that
differently depending on the device.

173
00:10:29.761 --> 00:10:33.383
But on my laptop,
when I run in a modern day Chrome,

174
00:10:33.383 --> 00:10:37.351
that limit seems to be
somewhere around 20,000.

175
00:10:37.351 --> 00:10:42.812
Somewhere between 20 and 25,000 it
will spit out a range error on me.

176
00:10:42.812 --> 00:10:45.698
But if I do less 20,000,
that's a good size.

177
00:10:45.698 --> 00:10:48.009
And theres are a lot of data sets
that that will work against.

178
00:10:48.009 --> 00:10:52.348
But, as a good computer scientist, I don't
want to write something if it's gonna

179
00:10:52.348 --> 00:10:56.511
accidentally throw an error in production,
given data that I can't predict.

180
00:10:56.511 --> 00:11:02.010
So that's an unacceptable limitation, even
though it's better than it used to be.

181
00:11:02.010 --> 00:11:06.773
And I think it's for that reason that
JavaScript developers have essentially not

182
00:11:06.773 --> 00:11:11.550
used recursion very much for the majority
of the time JavaScript's been around.

183
00:11:11.550 --> 00:11:13.453
Because we have this limitation and

184
00:11:13.453 --> 00:11:17.838
we don't have an engine that's even smart
enough to do it, even if we rearrange.

185
00:11:17.838 --> 00:11:21.414
So that's why it was such a big
deal when ES 6 came along and

186
00:11:21.414 --> 00:11:24.854
said, we're finally gonna
put in this optimization.

187
00:11:24.854 --> 00:11:29.649
Or we're gonna put in this characteristic,
that if you write your code in what is so

188
00:11:29.649 --> 00:11:32.816
called PTC, which stands for
Proper Tail Calls form.

189
00:11:32.816 --> 00:11:35.716
If you write your code in
Proper Tail Call form,

190
00:11:35.716 --> 00:11:38.398
then what we will do is
ensure as the engine,

191
00:11:38.398 --> 00:11:42.980
the engine will ensure that you will
never run into that range error limit.

192
00:11:42.980 --> 00:11:44.199
You'll never run out of memory.

193
00:11:44.199 --> 00:11:49.166
So I'm guaranteeing that it will
somehow run in a fixed space of memory.

194
00:11:49.166 --> 00:11:53.035
Now there was a lot of early
writing on this topic and

195
00:11:53.035 --> 00:11:58.438
I was one of them that referred to
this as TCO, Tail Call Optimization.

196
00:11:58.438 --> 00:12:06.086
Since then I've realized that these are
actually adjacent topics but not the same.

197
00:12:06.086 --> 00:12:14.375
Proper Tail Calls is specifically that the
code can run in a fixed amount of memory.

198
00:12:14.375 --> 00:12:16.413
In other words,
never run the device out of memory.

199
00:12:16.413 --> 00:12:17.792
It could run infinitely and

200
00:12:17.792 --> 00:12:21.459
not run the device out of memory,
if you arrange it as a Proper Tail Call.

201
00:12:21.459 --> 00:12:24.195
Tail Call Optimization
says within that space,

202
00:12:24.195 --> 00:12:27.740
there's lots of different ways
that we might implement that.

203
00:12:27.740 --> 00:12:29.367
Some of them are faster than others.

204
00:12:29.367 --> 00:12:34.308
So Tail Call Optimization is a set of
additional things that can be done,

205
00:12:34.308 --> 00:12:38.042
like reusing the stack frame or
other sorts of tricks.

206
00:12:38.042 --> 00:12:43.041
So it's kind of like PTC is the umbrella
and TCO is the way that an engine might

207
00:12:43.041 --> 00:12:47.748
choose to do different sorts of
optimizations, make things not slow.

208
00:12:47.748 --> 00:12:51.924
As it turns out in the general sense,
creating a new stack frame and

209
00:12:51.924 --> 00:12:54.170
throwing an old stack frame array.

210
00:12:54.170 --> 00:12:59.073
If the engine just started doing that,
that would actually make every function

211
00:12:59.073 --> 00:13:02.889
in your program,
every single time recursive or not slower.

212
00:13:02.889 --> 00:13:07.568
So just implementing that feature that
they could run in the recursive case in

213
00:13:07.568 --> 00:13:12.539
fixed memory would make all functions,
even non-recursive ones, run slower.

214
00:13:12.539 --> 00:13:14.990
So they wanted to leave
the door open to say,

215
00:13:14.990 --> 00:13:18.256
there's lots of tricks you
can perform to optimize that.

216
00:13:18.256 --> 00:13:21.675
And there's a whole series of tricks,
we won't really get into that, but

217
00:13:21.675 --> 00:13:23.811
there's a whole series
of tricks called TCO.

218
00:13:23.811 --> 00:13:26.612
So when you refer to this feature,
refer to it as PTC.

219
00:13:26.612 --> 00:13:29.961
Because that's the part
that's required by the spec.

220
00:13:29.961 --> 00:13:34.471
TCO is not required by the spec,
but it's allowed.

221
00:13:34.471 --> 00:13:38.452
The engines are allowed to figure out
how to optimized it however they want.

222
00:13:38.452 --> 00:13:44.927
So here's what Proper Tail Calls looks
like, in JavaScript specifically.

223
00:13:44.927 --> 00:13:48.321
Here I have this foo function
that calls this bar function and

224
00:13:48.321 --> 00:13:53.117
you'll notice something right off the bat
that I've inserted that you haven't seen

225
00:13:53.117 --> 00:13:56.931
in my previous code snippets I've
switched this into strict mode.

226
00:13:56.931 --> 00:13:59.506
PTC requires strict mode.

227
00:13:59.506 --> 00:14:03.245
If you don't have strict mode on,
PTC is not gonna be in effect and

228
00:14:03.245 --> 00:14:06.514
therefore, those limits
are gonna be in effect for you.

229
00:14:06.514 --> 00:14:09.446
So you have to make sure to
remember to switch to strict mode.

230
00:14:09.446 --> 00:14:13.352
If you're not already using strict mode,
this is just one more of the plethora of

231
00:14:13.352 --> 00:14:15.600
reasons that you should
be using strict mode.

232
00:14:15.600 --> 00:14:18.899
So you're gonna make sure to remember
that and I always forget that.

233
00:14:18.899 --> 00:14:22.700
And for some reason I always forget it and
I try a little test and

234
00:14:22.700 --> 00:14:26.376
it doesn't work and, dang it,
I forgot strict mode.

235
00:14:26.376 --> 00:14:29.391
Still getting myself into the habit
of remember to writing, even for

236
00:14:29.391 --> 00:14:32.411
small, little test snippets,
you're gonna have to have it there.

237
00:14:32.411 --> 00:14:35.097
As a matter of fact,
I literally have some files on my desktop.

238
00:14:35.097 --> 00:14:39.613
I have JavaScript file and
an HTML file on my desktop of my system.

239
00:14:39.613 --> 00:14:44.594
Test PTC, and anytime I'm doing anything
around recursion, I just drop it in

240
00:14:44.594 --> 00:14:49.664
there so I don't forget that that's the
environment I need to set myself up in.

241
00:14:49.664 --> 00:14:54.633
But now, we ask obviously bar on line 8,
that doesn't make any call.

242
00:14:54.633 --> 00:14:57.323
So it's already gonna run in fixed space.

243
00:14:57.323 --> 00:15:00.306
But the foo function does dispatch to bar.

244
00:15:00.306 --> 00:15:03.570
But does it do any work after it returns?

245
00:15:03.570 --> 00:15:08.178
And the answer is no,
it just simply returns its value back.

246
00:15:08.178 --> 00:15:12.058
So this is what we call PTC form.

247
00:15:12.058 --> 00:15:17.026
That all of the calls that are made from
that function to another function are in

248
00:15:17.026 --> 00:15:21.936
a position where they are at the very end
of the flow control of that function.

249
00:15:21.936 --> 00:15:27.055
And specifically, the return
keyword has to be part of the call,

250
00:15:27.055 --> 00:15:30.321
even if it's not gonna return anything.

251
00:15:30.321 --> 00:15:33.524
It should, because, hey,
we're functional programmers and

252
00:15:33.524 --> 00:15:35.792
real functions should be returning things.

253
00:15:35.792 --> 00:15:38.721
But even if technically you
weren't returning things,

254
00:15:38.721 --> 00:15:42.757
to take advantage of PTC, you're gonna
have to have it in this specific form.

255
00:15:42.757 --> 00:15:52.557
You're gonna have to say return bar
&gt;&gt; Kyle Simpson: There's one exception

256
00:15:52.557 --> 00:15:59.510
to that, which is, you're allowed to
have a ternary in the return clause.

257
00:15:59.510 --> 00:16:02.580
And as long as the function
call is in a position

258
00:16:02.580 --> 00:16:06.280
in that clause where it's the last
thing to run, then that's okay.

259
00:16:06.280 --> 00:16:11.130
So the, because the ternary is gonna
get run first before the function

260
00:16:11.130 --> 00:16:11.810
call happens.

261
00:16:12.870 --> 00:16:16.620
But generally speaking you PTCs
are gonna look like return bar.

262
00:16:16.620 --> 00:16:18.540
Now that's a non-recursive scenario.

263
00:16:18.540 --> 00:16:22.480
If we switched to a recursive
scenario Here foo was calling itself.

264
00:16:22.480 --> 00:16:25.840
So, I have the return foo position.

265
00:16:25.840 --> 00:16:28.620
The return foo any position,
where it's the last thing.

266
00:16:28.620 --> 00:16:31.720
Does have to be the last line of the
function, it just has to be that in every

267
00:16:31.720 --> 00:16:37.390
path that we can dispatch to a function,
that path has to be in PTC form.

268
00:16:39.060 --> 00:16:43.910
So we come back then to this example,
and we say well, this is not PTC.

269
00:16:45.300 --> 00:16:52.150
It's not PTC because of that sum that
happens after the function call finishes.

270
00:16:52.150 --> 00:16:55.240
So this code would unfortunately,
even with strict mode on,

271
00:16:55.240 --> 00:16:59.720
would unfortunately not be
able to take advantage of PTC.

272
00:16:59.720 --> 00:17:03.600
It would run within the limits and then
pro arrange here if we ran it too far.

273
00:17:05.710 --> 00:17:10.280
So we wanna talk about some
strategies that we could use

274
00:17:10.280 --> 00:17:14.450
for optimizing or

275
00:17:14.450 --> 00:17:18.586
rearranging or our codes so that they
would be able to take advantage of PTC.

276
00:17:18.586 --> 00:17:24.970
That sum + sum + sum part is the problem,

277
00:17:24.970 --> 00:17:30.450
so we have to ask ourselves what could we
do to get rid of the sum + sum + sum part,

278
00:17:30.450 --> 00:17:33.310
it's the plus part really,
what would we do to get rid of that part?

279
00:17:35.040 --> 00:17:39.810
And to be completely honest with you,
it is not, even to

280
00:17:39.810 --> 00:17:45.340
this moment with my experience with this,
It is not terribly self obvious to me.

281
00:17:45.340 --> 00:17:49.320
Until somebody explained it
to me a few hundred times,

282
00:17:49.320 --> 00:17:51.320
that I started to kinda get
it through my thick head.

283
00:17:51.320 --> 00:17:54.630
So don't feel bad if this
feels a little unnatural.

284
00:17:54.630 --> 00:18:01.930
But the question to ask yourself is,
what is being kept on the stack frame.

285
00:18:01.930 --> 00:18:06.233
It is specifically the sum variable
that's being kept on the stack frame and

286
00:18:06.233 --> 00:18:11.130
if I want to get rid of this stack frame
then what can I do with that variable?

287
00:18:11.130 --> 00:18:15.060
If I can't keep it in a stack
frame then what can I do with it?

288
00:18:16.490 --> 00:18:21.820
And the answer is I can pass it along
as an argument to the next call.

289
00:18:25.120 --> 00:18:29.290
Instead of holding onto it now,
I can calculate

290
00:18:29.290 --> 00:18:34.380
right away what the addition is and
pass that partial total along.

291
00:18:34.380 --> 00:18:39.700
So essentially if I reserved the first
argument for my sum recur function,

292
00:18:39.700 --> 00:18:44.830
if I just reserved an argument that
was kind of the accumulator, and

293
00:18:44.830 --> 00:18:49.740
whenever you called it you could start
with that accumulator position 0 and then

294
00:18:49.740 --> 00:18:53.880
have your list of numbers then I could
just always update the accumulator and

295
00:18:53.880 --> 00:18:56.760
forward pass it along and
then there would be no need for

296
00:18:56.760 --> 00:19:00.860
the stack and I would be able to say
directly just return sumRecur and

297
00:19:00.860 --> 00:19:05.866
then pass along that argument.

298
00:19:05.866 --> 00:19:11.770
So because that function might have
a signature that is awkward for

299
00:19:11.770 --> 00:19:12.900
the user to use.

300
00:19:12.900 --> 00:19:17.050
I wanna hide that awkward
signature from the outside world.

301
00:19:17.050 --> 00:19:22.950
So here's that awkward signature where
I've got that item in the first position.

302
00:19:22.950 --> 00:19:26.130
That you would normally
have to pass a 0 in.

303
00:19:26.130 --> 00:19:31.580
And what I'm then doing is calling
the recur function inside of it.

304
00:19:31.580 --> 00:19:33.820
So you'll notice there I'm calling recur,
and

305
00:19:33.820 --> 00:19:36.490
I'm passing along that list of numbers.

306
00:19:36.490 --> 00:19:40.690
And I could pass along the 0 there in
that first position if I wanted to.

307
00:19:42.060 --> 00:19:45.550
Now this means that
from the outside world,

308
00:19:45.550 --> 00:19:48.340
I still get to use my function
like I'm doing on line 14.

309
00:19:48.340 --> 00:19:50.700
I still get to use it exactly
the same way I'm used to,

310
00:19:50.700 --> 00:19:54.610
which is just passing 3, 4, 5, 6, 7, 8, 9.

311
00:19:54.610 --> 00:19:58.940
Under the covers, it's an implementation
detail that it chooses to do so

312
00:19:58.940 --> 00:20:00.060
recursively.

313
00:20:00.060 --> 00:20:03.280
And it's a further implementation
detail that it chooses.

314
00:20:03.280 --> 00:20:04.710
To do so in a PTC form.

315
00:20:04.710 --> 00:20:08.050
Cuz you'll notice there's
now a PTC form in both of

316
00:20:08.050 --> 00:20:10.650
the places where function
calls are happening.

317
00:20:10.650 --> 00:20:12.850
It's return function call.

318
00:20:12.850 --> 00:20:17.510
And what I do here on line 10 is I
pass along sum in that first position,

319
00:20:17.510 --> 00:20:18.220
there on line 10.

320
00:20:18.220 --> 00:20:21.640
That's because I've already
calculated on line 8,

321
00:20:21.640 --> 00:20:26.320
I've gone ahead and pre-calculated
the current iterations partial sum.

322
00:20:26.320 --> 00:20:31.510
I took whatever sum was, I added the first
numb to it, I've recalculated that partial

323
00:20:31.510 --> 00:20:36.290
sum, I either returned that partial
sum on num 9 because I'm done or

324
00:20:36.290 --> 00:20:41.710
I forward pass that partial sum along
to the next iteration of the recursion.

325
00:20:43.510 --> 00:20:47.410
So as long as I have that first item
in that position that I'm allowed to

326
00:20:47.410 --> 00:20:49.470
kind of do with it, whatever I need to.

327
00:20:49.470 --> 00:20:52.510
I can just use that as my stack.

328
00:20:52.510 --> 00:20:57.000
Now because this is simple addition, all I
need to do is add a number, but your case

329
00:20:57.000 --> 00:21:01.210
might be that that first position needs to
be an array, and you need to stick stuff

330
00:21:01.210 --> 00:21:05.540
in an array, and so you're gonna
kinda use the array as a heap almost.

331
00:21:05.540 --> 00:21:09.250
A set of memory that you could grow and
contract or stick stuff in or

332
00:21:09.250 --> 00:21:13.670
whatever, but you're reserving essentially
that first position as your memory

333
00:21:13.670 --> 00:21:15.460
instead of the stack frame.

334
00:21:15.460 --> 00:21:19.000
And now it's just gonna be able
run unbounded according to

335
00:21:19.000 --> 00:21:20.470
the JavaScript engine.

336
00:21:20.470 --> 00:21:24.560
Of course if you grow that, if you use
an array there and you grow that array

337
00:21:24.560 --> 00:21:29.090
infinitely You're eventually gonna crash
your device and run out of memory, too.

338
00:21:29.090 --> 00:21:30.630
So you have to be careful about that, but

339
00:21:30.630 --> 00:21:34.200
at least you won't be limited
artificially by the engine.

340
00:21:34.200 --> 00:21:34.880
You have the freedom.

341
00:21:34.880 --> 00:21:38.650
And here, we're not gonna grow any memory
cuz we can just do a numeric addition.

342
00:21:38.650 --> 00:21:40.120
That's all we need to do to accumulate.

343
00:21:41.630 --> 00:21:46.030
I've done recursion where that first
position is a function that gets more and

344
00:21:46.030 --> 00:21:48.820
more composed That's a way of doing it.

345
00:21:48.820 --> 00:21:51.930
I've done it where it's an array and
I stick a few values in the array and

346
00:21:51.930 --> 00:21:55.590
then I collapse those down and a few more
into the array and collapse those down.

347
00:21:55.590 --> 00:21:59.720
I've done them with numbers, with strings,
but essentially that first position or

348
00:21:59.720 --> 00:22:03.960
maybe a couple positions can be used as
your accumulator instead of your stack

349
00:22:06.020 --> 00:22:07.480
frame.

350
00:22:07.480 --> 00:22:10.000
But, there's a different
problem that we've created.

351
00:22:10.000 --> 00:22:14.240
Other than the fact that this
is now a bit more verbose,

352
00:22:14.240 --> 00:22:16.410
there's some more overhead here.

353
00:22:16.410 --> 00:22:20.650
And, we've lost a little bit of the
graceful nature of the recursive notation.

354
00:22:20.650 --> 00:22:22.480
It's still pretty good.

355
00:22:22.480 --> 00:22:25.270
Lines seven through eleven are still
pretty straight forward to our

356
00:22:25.270 --> 00:22:26.460
implementation.

357
00:22:26.460 --> 00:22:30.340
But this extra boiler plate of having
to wrap it around is unfortunate but

358
00:22:30.340 --> 00:22:32.350
there is a deeper problem.

359
00:22:32.350 --> 00:22:35.370
Not a huge one but
a deeper problem we should be aware of.

360
00:22:35.370 --> 00:22:39.050
Which is every time I call the outer
function sumRecur, that is every time I

361
00:22:39.050 --> 00:22:45.730
ran line 14 I would actually be
recreating the inner function on line 7.

362
00:22:45.730 --> 00:22:50.100
So if I only use the utility once no
big deal, I just create it once and

363
00:22:50.100 --> 00:22:51.470
use it a bunch of times.

364
00:22:51.470 --> 00:22:55.390
But if I was doing line 14 thousands and
thousands of times,

365
00:22:55.390 --> 00:22:58.330
I'd be unnecessarily recreating
that inner function over and over.

366
00:23:00.240 --> 00:23:05.220
So that's an unfortunate detail,
cuz I'm kinda shooting myself in the foot

367
00:23:05.220 --> 00:23:08.320
creating a much of memory
turn that I don't want.

368
00:23:08.320 --> 00:23:12.840
Now why am I putting
that recur on line seven?

369
00:23:12.840 --> 00:23:15.010
Why am I putting it inside anyway?

370
00:23:15.010 --> 00:23:16.890
The reason generally is,

371
00:23:16.890 --> 00:23:19.780
because it's not a function I want
to expose to the outside world.

372
00:23:21.250 --> 00:23:24.200
I normally would name it with
an underscore or something.

373
00:23:24.200 --> 00:23:26.340
It's an implementation detail.

374
00:23:26.340 --> 00:23:29.400
So generally,
encapsulation says keep that thing hidden.

375
00:23:29.400 --> 00:23:33.480
Your library might give you a place
to put your private functions,

376
00:23:33.480 --> 00:23:35.160
and then that would've been
fine to stick it there.

377
00:23:35.160 --> 00:23:39.470
But given that we wanna just implement
our own self-recursive function,

378
00:23:40.500 --> 00:23:43.740
we wanted to hide it, and that's why
we stuck it inside of that scope.

379
00:23:43.740 --> 00:23:46.690
That's not the only way to hide
something in a scope, though.

380
00:23:48.460 --> 00:23:52.210
Instead of making our sumRecur
be a function that does that,

381
00:23:52.210 --> 00:23:56.810
we can instead make the outer
scope be a one time use iffy

382
00:23:57.810 --> 00:24:00.770
that creates the scope and it hides it.

383
00:24:00.770 --> 00:24:02.850
And the if field returns our function.

384
00:24:04.160 --> 00:24:08.620
And that's the way of getting around this
that the inner recur can get recreated.

385
00:24:08.620 --> 00:24:12.512
So, I'm just gonna rewrite it slightly and

386
00:24:12.512 --> 00:24:17.361
now some recur is pointing
at that returned function.

387
00:24:17.361 --> 00:24:21.850
And that return function is
inside of a scope where it has

388
00:24:21.850 --> 00:24:26.541
accessed to the inner
implementation recur on line nine.

389
00:24:26.541 --> 00:24:31.142
So I only create those two
inner functions once ever,

390
00:24:31.142 --> 00:24:37.900
free to call some recur as many times as
I want without doing unnecessary work.

391
00:24:39.760 --> 00:24:44.810
Now at this point, we've certainly
created a pretty fair bit of overhead.

392
00:24:46.570 --> 00:24:49.297
And if you're in the position that I am,

393
00:24:49.297 --> 00:24:52.908
where you're trying to make
code more declarative,

394
00:24:52.908 --> 00:24:58.623
you kind of wince at the fact that, sure,
I feel more clever about using recursion.

395
00:24:58.623 --> 00:25:03.270
But man, this is not nearly as
graceful maybe this wasn't worth it.

396
00:25:03.270 --> 00:25:06.800
I'm not ultimate pragmatist,
I'm always asking yeah,

397
00:25:06.800 --> 00:25:11.061
so great I use recursion but at the end
of the day, this is a lot uglier.

398
00:25:11.061 --> 00:25:12.810
It's not really what I want.

399
00:25:12.810 --> 00:25:15.474
Sometimes, the performance aspect of it,

400
00:25:15.474 --> 00:25:20.010
sometimes you're doing an algorithm
that really needs recursion because

401
00:25:20.010 --> 00:25:23.334
the iterative form of expression
is much harder to do.

402
00:25:23.334 --> 00:25:25.210
Summation of nums is
not one of those cases.

403
00:25:25.210 --> 00:25:28.420
But if you were doing recursive
descent to the binary tree,

404
00:25:28.420 --> 00:25:30.690
that's a lot harder to write iteratively.

405
00:25:30.690 --> 00:25:33.880
You probably wanna do it recursively and
then if performance matters,

406
00:25:33.880 --> 00:25:37.176
you kinda just have to do
the uglier form of it.

407
00:25:37.176 --> 00:25:41.881
But [COUGH] when I was preparing
this material sometime ago,

408
00:25:41.881 --> 00:25:47.432
this was kind of my final slide in
this discussion when I landed here and

409
00:25:47.432 --> 00:25:52.821
I said, just so you know this is
the one of the techniques we can use.

410
00:25:52.821 --> 00:25:57.678
But sometimes this is just the unfortunate
trade off, the code has to get

411
00:25:57.678 --> 00:26:03.290
a little bit uglier so that it will
perform aka not crash in production.

412
00:26:03.290 --> 00:26:10.540
Sometimes that's what we have
to make that concession.

413
00:26:10.540 --> 00:26:14.070
But something about this
code caught my eye one time,

414
00:26:14.070 --> 00:26:16.560
when I was looking through it.

415
00:26:16.560 --> 00:26:20.770
And I think it's because of the discussion
around the point free coding.

416
00:26:20.770 --> 00:26:23.220
And something caught my eye
when I looked up at line four.

417
00:26:24.890 --> 00:26:28.450
And I said, I'm creating this function
that will call my inner function and

418
00:26:28.450 --> 00:26:33.090
you'll notice that the signature of
those two is compatible, it's identical.

419
00:26:35.730 --> 00:26:40.490
In other words, as point free coding
told us earlier in the course,

420
00:26:40.490 --> 00:26:43.110
I don't really need that
wrapper function on line four.

421
00:26:44.250 --> 00:26:46.910
Couldn't I just return recur itself?

422
00:26:46.910 --> 00:26:49.324
And as soon as I got to that
point I was like wait a minute,

423
00:26:49.324 --> 00:26:52.640
I don't need this whole
wrapping scope thing anyway.

424
00:26:52.640 --> 00:26:57.240
The way I originally expressed recur,
as the signature,

425
00:26:57.240 --> 00:26:59.800
where I had those two separate parameters,

426
00:26:59.800 --> 00:27:04.860
it's already compatible with
this forward passing concept.

427
00:27:05.930 --> 00:27:09.050
So, I don't need to hide that
as an implementation detail,

428
00:27:09.050 --> 00:27:12.040
I can just simply expose recur as is.

429
00:27:13.710 --> 00:27:18.525
That signature is compatible to
expose to the outside world, so

430
00:27:18.525 --> 00:27:22.729
now my PTC form recursive
edition just looks like that.

431
00:27:22.729 --> 00:27:26.135
Now that's different
than what it was six or

432
00:27:26.135 --> 00:27:31.658
seven slides ago because now on line
four where pre calulating the sum,

433
00:27:31.658 --> 00:27:36.450
the partial sum and
we're forward passing it on line six.

434
00:27:36.450 --> 00:27:39.080
That's a bit different than
what we were doing before but

435
00:27:39.080 --> 00:27:43.530
now that is sufficient to get
our algorithm into the PTC form,

436
00:27:43.530 --> 00:27:49.702
to take advantage of tail calls.
&gt;&gt; Kyle Simpson: In my own coding,

437
00:27:49.702 --> 00:27:55.800
I've had mixed success with this
kind of refactored into PTC form.

438
00:27:57.050 --> 00:28:01.320
The general strategy is usually,
try to figure out what the stack needs and

439
00:28:01.320 --> 00:28:04.250
then figure out how to pass
it in the first argument.

440
00:28:04.250 --> 00:28:05.830
Sometimes that works well,

441
00:28:05.830 --> 00:28:08.990
sometimes it ends up creating
something really super awkward.

442
00:28:08.990 --> 00:28:12.640
Hard to debug or whatever and
I just give up, and I don't do recursive.

443
00:28:12.640 --> 00:28:15.870
So I've had some mixed success with it but
at least there are times where I

444
00:28:15.870 --> 00:28:19.430
can implement something recursively and
take advantage of PTC.

445
00:28:21.700 --> 00:28:27.206
Well, I could take advantage of PTC if the
browser engines would implement this spec.

446
00:28:29.480 --> 00:28:32.480
So, the final point I'm gonna
make before we take a break here,

447
00:28:32.480 --> 00:28:37.370
is unfortunately, as things stand, there's

448
00:28:37.370 --> 00:28:42.030
only one browser that has faithfully
implemented this part of the spec.

449
00:28:42.030 --> 00:28:47.024
There are a number of browser which have
claimed that they have implemented 100%

450
00:28:47.024 --> 00:28:47.580
of ES6.

451
00:28:47.580 --> 00:28:52.540
And they have not because they have not
implemented this requirement for PTC.

452
00:28:52.540 --> 00:28:56.430
Safari, which has generally of late been

453
00:28:56.430 --> 00:28:59.840
sort of trailing behind a lot
of the web in a lot of features.

454
00:28:59.840 --> 00:29:04.090
Is the only browser, as things stand
today, that has actually implemented and

455
00:29:04.090 --> 00:29:06.370
rolled into production PTC support.

456
00:29:08.240 --> 00:29:16.111
As a side note, this is just a little
rabbit trail that I sometimes go on.

457
00:29:16.111 --> 00:29:20.334
The folks at Apple that drive Safari,
they don't put features into their

458
00:29:20.334 --> 00:29:24.560
browser unless there is a really
good reason why they want to.

459
00:29:24.560 --> 00:29:28.500
So my suspicion is that either
something that's already shipped or

460
00:29:28.500 --> 00:29:33.340
something that's shipping soon on
their road map, distinctly and

461
00:29:33.340 --> 00:29:35.980
directly requires them
to have PTC support.

462
00:29:35.980 --> 00:29:41.280
And so they elevated this implementation
to be something they spent the time on.

463
00:29:41.280 --> 00:29:44.300
They don't generally just do things like
that out of the goodness of their heart.

464
00:29:44.300 --> 00:29:48.170
There's usually a reason why
a feature gets prioritized and

465
00:29:48.170 --> 00:29:53.360
especially a feature like this which to
some extent has been a bit controversial.

466
00:29:53.360 --> 00:29:57.280
The reason it's not in the other engines
is not because it's too hard for them.

467
00:29:57.280 --> 00:29:59.620
They don't want to implement it.

468
00:29:59.620 --> 00:30:03.060
They've decided that implementing this
feature, even though they voted to put it

469
00:30:03.060 --> 00:30:06.920
in the spec, they've decided that
implementing this feature is gonna

470
00:30:06.920 --> 00:30:11.550
unnecessarily hamper other performance
things that they wanna do.

471
00:30:11.550 --> 00:30:14.304
And so, they're pushing back
on the TC39 committee saying,

472
00:30:14.304 --> 00:30:16.720
we wanna take that out of this spec.

473
00:30:16.720 --> 00:30:22.220
And the WebKit folks are like, well,
we already shipped it like six months ago.

474
00:30:22.220 --> 00:30:24.830
So, we don't wanna take it out of
the spec, we like it, we think it's good.

475
00:30:25.950 --> 00:30:29.200
So, there's an open
debate at TC39 right now,

476
00:30:29.200 --> 00:30:34.430
where the engines have basically then
in opened defiance of the spec or

477
00:30:34.430 --> 00:30:37.460
just really dragging their
feet to note implement it.

478
00:30:37.460 --> 00:30:42.830
Because they want to either take it out or
change it in some way.

479
00:30:42.830 --> 00:30:45.610
Here is a number of proposals that
they've got on the board for it.

480
00:30:45.610 --> 00:30:49.520
So as things currently
stand unfortunately,

481
00:30:49.520 --> 00:30:53.660
you can only take advantage of PTC
if your code's gonna run in Safari.

482
00:30:53.660 --> 00:30:54.930
And you've put it in strict mode.

483
00:30:56.430 --> 00:31:02.070
I hope that that changes soon because
I think it's an untenable position for

484
00:31:02.070 --> 00:31:07.090
all these major browsers to
be in defiance of the spec or

485
00:31:07.090 --> 00:31:08.404
not in agreement with each other.

486
00:31:08.404 --> 00:31:13.319
Somebody is gotta give in this process and
we don't have an infinite timeline here

487
00:31:13.319 --> 00:31:18.396
for them to make that decision, I think it
unhealthy in terms of the state of things.

488
00:31:18.396 --> 00:31:21.385
So I genuinely hope that they
get over their objections and

489
00:31:21.385 --> 00:31:25.045
figure out how to do it, how the way
WebKit did and then we just get PTC and

490
00:31:25.045 --> 00:31:27.127
it lands, and then we're done with it.

491
00:31:27.127 --> 00:31:30.448
But as things currently stand,
it's important for

492
00:31:30.448 --> 00:31:33.325
you to know that caveat
is still a bit in flux.

