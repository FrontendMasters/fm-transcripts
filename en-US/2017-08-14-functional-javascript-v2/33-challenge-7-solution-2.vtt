WEBVTT

1
00:00:00.450 --> 00:00:02.482
&gt;&gt; Kyle Simpson: Okay, so
that's our iterative approach.

2
00:00:02.482 --> 00:00:06.388
And that algorithm should have come
through because what we're basically

3
00:00:06.388 --> 00:00:09.800
saying is take the list and
make it a little bit smaller each time.

4
00:00:10.820 --> 00:00:15.192
That actually leads us to the idea of
what the algorithm would be if we did it

5
00:00:15.192 --> 00:00:16.119
recursively.

6
00:00:16.119 --> 00:00:19.762
We could do the same thing just
make a smaller and smaller list and

7
00:00:19.762 --> 00:00:23.660
make the recursive call,
not do it with a while loop.

8
00:00:23.660 --> 00:00:27.410
And we won't need to do the block scoping
destructuring part because that part can

9
00:00:27.410 --> 00:00:30.670
be taken care of with the recursive call.

10
00:00:30.670 --> 00:00:35.477
So what I'll do is comment this out and

11
00:00:35.477 --> 00:00:40.592
then re-implement addn recursively.

12
00:00:40.592 --> 00:00:43.511
And what I'm gonna do is take advantage

13
00:00:43.511 --> 00:00:50.701
of,
&gt;&gt; Kyle Simpson: The signature

14
00:00:50.701 --> 00:00:53.666
to go ahead and do that for me.

15
00:00:53.666 --> 00:00:58.723
And then I want to say, if, so
my base case is if fnslength = 0,

16
00:00:58.723 --> 00:01:06.605
actually let me say, if it's greater than
0, meaning that there's still stuff to do.

17
00:01:06.605 --> 00:01:13.563
Then we need to go ahead and,
&gt;&gt; Kyle Simpson: Do a recursive call.

18
00:01:16.556 --> 00:01:22.087
&gt;&gt; Kyle Simpson: And the array, sorry this
is not, let me do the destructuring here.

19
00:01:24.970 --> 00:01:30.381
&gt;&gt; Kyle Simpson: The array that we wanna
pass in is gonna look exactly the same.

20
00:01:30.381 --> 00:01:34.088
It's gonna have a function
that includes fn0 and fn1.

21
00:01:43.101 --> 00:01:46.193
&gt;&gt; Kyle Simpson: And then it's gonna
include the rest of the fns in it.

22
00:01:48.488 --> 00:01:51.530
&gt;&gt; Kyle Simpson: So that's the array
being passed to our recursive call.

23
00:01:53.520 --> 00:01:58.180
And if we're not in that base
condition then we know that fn0 and

24
00:01:58.180 --> 00:02:01.190
fn1 are the last two to deal with.

25
00:02:01.190 --> 00:02:08.040
So we can just simply call
add2 with fn0 and fn1.

26
00:02:10.170 --> 00:02:11.972
Same algorithm as what we did before, but

27
00:02:11.972 --> 00:02:14.760
now we're expressing it recursively
instead of iteratively.

28
00:02:16.810 --> 00:02:22.941
So if I didn't make another huge mistake,
let's try that out and see if it works.

29
00:02:25.795 --> 00:02:28.519
&gt;&gt; Kyle Simpson: And there we get 35.

