WEBVTT

1
00:00:00.000 --> 00:00:05.484
I wanted to give a brief TL didn't watch,
too long didn't watch.

2
00:00:05.484 --> 00:00:09.565
This is a quick summary of kinda
the takeaways that I'm going to illustrate

3
00:00:09.565 --> 00:00:11.462
throughout the entire workshop.

4
00:00:11.462 --> 00:00:14.741
These are principles that you
might take at face value or

5
00:00:14.741 --> 00:00:19.066
you might not fully appreciate, but
hopefully by the end of this course,

6
00:00:19.066 --> 00:00:22.439
you appreciate that these
things are really important.

7
00:00:22.439 --> 00:00:26.771
The first one that I wanna highlight
is asking better clarifying questions.

8
00:00:26.771 --> 00:00:29.085
Anytime you're presented with a problem,

9
00:00:29.085 --> 00:00:33.777
whether it's somebody stating a problem to
you, or it's just there's an issue filed,

10
00:00:33.777 --> 00:00:37.737
or there's a feature that you don't
know how to implement, or whatever.

11
00:00:37.737 --> 00:00:40.812
Anytime there's a problem present to you,

12
00:00:40.812 --> 00:00:44.892
your first job is to understand
that problem completely.

13
00:00:44.892 --> 00:00:47.327
Your first job is not to write code.

14
00:00:47.327 --> 00:00:50.797
That's the last thing you do and
that's optional.

15
00:00:50.797 --> 00:00:54.442
The first thing you have to
do is understand the problem.

16
00:00:54.442 --> 00:00:57.045
And we cannot get that
with one single question.

17
00:00:57.045 --> 00:01:02.068
That is a progressive thing, it's
a cyclical thing we have to come back to.

18
00:01:02.068 --> 00:01:06.980
We have reapproach a problem and realize
later, I should have asked this before.

19
00:01:06.980 --> 00:01:12.097
If you can get better at having
that almost uncanny ability to ask

20
00:01:12.097 --> 00:01:17.120
the right questions up front,
that really is probably the best

21
00:01:17.120 --> 00:01:22.997
approximation of seniority and
maturity and experience as an engineer,

22
00:01:22.997 --> 00:01:27.573
is just the instinct to ask
the right questions earlier.

23
00:01:27.573 --> 00:01:29.870
There's no magic trick to it.

24
00:01:29.870 --> 00:01:33.205
In fact, I tell people that's really
the only difference between me and

25
00:01:33.205 --> 00:01:36.923
any other JavaScript developer, even
somebody who just started in a boot camp,

26
00:01:36.923 --> 00:01:39.602
is that I've just asked more
questions of the language and

27
00:01:39.602 --> 00:01:42.523
I didn't stop when I got an answer,
I asked another question.

28
00:01:42.523 --> 00:01:47.366
That's it, so just, if I have
a superpower, it's asking questions, and

29
00:01:47.366 --> 00:01:50.408
so I wanna encourage you
to adopt that mindset.

30
00:01:50.408 --> 00:01:54.999
It does not show weakness, it does not
show that we're not good enough or

31
00:01:54.999 --> 00:01:56.363
anything like that.

32
00:01:56.363 --> 00:01:58.438
In fact, it's a superpower.

33
00:01:58.438 --> 00:02:02.449
If you can be the one who asks the best
questions in the room, you'll be the one

34
00:02:02.449 --> 00:02:06.061
who's providing value long after
everybody else has left the room.

35
00:02:06.061 --> 00:02:07.936
So I strongly encourage that.

36
00:02:07.936 --> 00:02:10.001
So when you're faced with a problem,

37
00:02:10.001 --> 00:02:13.355
you have to ask the right questions
to constrain the problem,

38
00:02:13.355 --> 00:02:17.631
because the answers to those questions,
sometimes you won't get an answer.

39
00:02:17.631 --> 00:02:19.527
They'll say, I don't know, depends, right?

40
00:02:19.527 --> 00:02:23.608
But sometimes you'll get a concrete
answer and that very much may guide you

41
00:02:23.608 --> 00:02:26.670
to an entirely different path for
solving the problem.

42
00:02:26.670 --> 00:02:31.517
So don't forsake by getting those
sort of clarifying questions as early

43
00:02:31.517 --> 00:02:35.495
as possible and
then revisiting that as often as possible.

44
00:02:35.495 --> 00:02:38.766
Second one I already mentioned or
referred to,

45
00:02:38.766 --> 00:02:42.855
we definitely want to balance
what we do with the processing

46
00:02:42.855 --> 00:02:47.128
optimizations versus what we
do with memory optimizations.

47
00:02:47.128 --> 00:02:52.046
Most of the time, people only care
about performance, the speed,

48
00:02:52.046 --> 00:02:56.720
the CPU processing speed, and
they tend to neglect the memory.

49
00:02:56.720 --> 00:03:00.167
And in a language like JavaScript,
it makes it even easier for

50
00:03:00.167 --> 00:03:04.345
you to neglect the memory and even easier
to shoot yourself in the foot where

51
00:03:04.345 --> 00:03:08.591
something is running super fast until
it completely stops for two seconds,

52
00:03:08.591 --> 00:03:11.268
while it cleans up all
of your memory mistakes.

53
00:03:11.268 --> 00:03:13.215
So don't make that mistake.

54
00:03:13.215 --> 00:03:17.111
Do be aware at all times
of the trade-offs.

55
00:03:17.111 --> 00:03:19.521
There are not always trade-offs,
by the way.

56
00:03:19.521 --> 00:03:21.419
I used to think this earlier in my career.

57
00:03:21.419 --> 00:03:25.674
I used to think there's no such thing
as a performance and memory optimized,

58
00:03:25.674 --> 00:03:26.991
it's one or the other.

59
00:03:26.991 --> 00:03:29.078
And in a lot of cases, it feels like that.

60
00:03:29.078 --> 00:03:31.780
A lot of cases, the trade-offs
that we make do feel like that.

61
00:03:31.780 --> 00:03:34.446
But there are times, and
you will see in this workshop,

62
00:03:34.446 --> 00:03:37.681
we will come up with a solution that
is both better in performance and

63
00:03:37.681 --> 00:03:40.380
better in memory management,
and that's a win-win.

64
00:03:40.380 --> 00:03:45.742
So look for those, but when you can't
find those, be aware of the differences.

65
00:03:45.742 --> 00:03:48.917
That means asking,
where is this application gonna run?

66
00:03:48.917 --> 00:03:54.221
If it's gonna run on low-end smartphone
devices in Third World countries or

67
00:03:54.221 --> 00:03:59.035
other parts of the world that don't
have the same privileged access to

68
00:03:59.035 --> 00:04:01.170
high-end devices that we do.

69
00:04:01.170 --> 00:04:02.542
If that's what that means,

70
00:04:02.542 --> 00:04:05.979
then you might need to actually make
a totally different choice there.

71
00:04:05.979 --> 00:04:11.213
Versus the only people that are ever
gonna run this are high-end Mac pros or

72
00:04:11.213 --> 00:04:12.804
something like that.

73
00:04:12.804 --> 00:04:16.626
So that goes back to number 1,
asking better questions,

74
00:04:16.626 --> 00:04:20.608
understanding the context of
where this stuff is gonna run.

75
00:04:20.608 --> 00:04:23.256
Number 3,
this is kind of a big pet peeve of mine,

76
00:04:23.256 --> 00:04:27.546
I don't hear enough people say this, but
I think most of the people who teach this

77
00:04:27.546 --> 00:04:30.217
really believe it,
they just don't call it out.

78
00:04:30.217 --> 00:04:35.263
So I'm gonna call it out, that you
really actually need to get good at

79
00:04:35.263 --> 00:04:40.657
understanding the problem and then
shaping what data structure you use or

80
00:04:40.657 --> 00:04:44.671
how you use it to that problem
rather than the reverse.

81
00:04:44.671 --> 00:04:49.535
Rather than trying to say all I've got
is a queue, and I've got to figure out

82
00:04:49.535 --> 00:04:53.501
some way to express my problem as
if I can solve it with a queue.

83
00:04:53.501 --> 00:04:58.633
Oftentimes you can solve most problems
with many different data structures,

84
00:04:58.633 --> 00:05:01.442
but most of those are not
the best way to go.

85
00:05:01.442 --> 00:05:06.360
So what you want to do is develop a
broader understanding of the various ways

86
00:05:06.360 --> 00:05:11.836
to use data structures, to combine them,
to mix and match them just more broadly.

87
00:05:11.836 --> 00:05:15.570
I mean, there's dozens and
hundreds of different data structures,

88
00:05:15.570 --> 00:05:18.873
some of them general,
some of them very highly specialized.

89
00:05:18.873 --> 00:05:23.907
And none of us can keep all of that in our
head, but the more of that that you have

90
00:05:23.907 --> 00:05:28.633
in your head, the easier it will be for
you to identify this is more likely

91
00:05:28.633 --> 00:05:33.920
the school or the group of those problems
that are gonna help me solve my problem.

92
00:05:33.920 --> 00:05:36.368
These data structures
are more well-aligned.

93
00:05:36.368 --> 00:05:41.305
So literally aligning the data structure
choice with the problem is one

94
00:05:41.305 --> 00:05:44.602
of the biggest hurdles
that we have to get over.

95
00:05:44.602 --> 00:05:47.913
Cuz our job as an algorithmist,
our job as an engineer,

96
00:05:47.913 --> 00:05:52.146
is to turn what we have in our heads
into instructions for the computer.

97
00:05:52.146 --> 00:05:57.099
And if those two are misaligned, our code
is going to be non-performant, buggy,

98
00:05:57.099 --> 00:06:01.019
hard to maintain, and ultimately,
it's gonna get rewritten.

99
00:06:01.019 --> 00:06:04.969
That's the ultimate cycle,
is that every line of code that we write

100
00:06:04.969 --> 00:06:08.297
suffers that same fate that
somebody comes along later,

101
00:06:08.297 --> 00:06:11.157
doesn't understand it,
and just rewrites it.

102
00:06:11.157 --> 00:06:15.509
And as an algorithmist, we should be
trying to ask those questions and

103
00:06:15.509 --> 00:06:20.377
think about it more carefully, so that
hopefully the code that we write is more

104
00:06:20.377 --> 00:06:24.464
robust, it's gonna survive those
inevitable rewrite cycles.

105
00:06:24.464 --> 00:06:27.622
Somebody comes along and says, well,
I don't know about all this other stuff,

106
00:06:27.622 --> 00:06:30.270
but this thing is solid, this code
does what it's supposed to do and

107
00:06:30.270 --> 00:06:31.732
it's as good as we're gonna get it.

108
00:06:31.732 --> 00:06:36.884
That's sort of the ideal, if you will,
that you could shoot for.

109
00:06:36.884 --> 00:06:43.964
Final point that I'll make, many of you
have probably heard the famous quote.

110
00:06:43.964 --> 00:06:48.877
I did a little bit of digging, and
actually, I'm not sure that it was

111
00:06:48.877 --> 00:06:53.984
even Knuth original idea, maybe he
cribbed it from a few other people.

112
00:06:53.984 --> 00:06:59.754
But many of you have heard this common
quote about premature optimization

113
00:06:59.754 --> 00:07:04.607
is the root of all evil don't
prematurely optimize, right?

114
00:07:04.607 --> 00:07:08.900
This concept that anytime somebody
sees an engineer working on

115
00:07:08.900 --> 00:07:11.087
an optimization of something,

116
00:07:11.087 --> 00:07:17.005
it seems there's almost an automatic doubt
that what they're doing is even worth it.

117
00:07:17.005 --> 00:07:20.633
There's this presumption that
if you're optimizing something,

118
00:07:20.633 --> 00:07:23.188
you're probably prematurely optimizing it.

119
00:07:23.188 --> 00:07:27.822
And what I will say is that, and
we're gonna teach this as a practice.

120
00:07:27.822 --> 00:07:29.934
I could have put this as
a fifth point up here.

121
00:07:29.934 --> 00:07:34.850
We're gonna teach it as a practice that
when you tackle an algorithmic problem,

122
00:07:34.850 --> 00:07:39.274
the first solution that you do should
be the dumbest and worst solution.

123
00:07:39.274 --> 00:07:44.765
It should be the quickest thing that you
can get that is accurate, in my opinion.

124
00:07:44.765 --> 00:07:48.656
It should work, but
you should not have to spend days or

125
00:07:48.656 --> 00:07:51.796
weeks trying to conceive of that solution.

126
00:07:51.796 --> 00:07:53.959
Even if it's horribly non-performant,

127
00:07:53.959 --> 00:07:57.204
even if it's completely impractical
to launch to production,

128
00:07:57.204 --> 00:08:01.469
you actually need a reference solution, so
that the optimizations that you can do,

129
00:08:01.469 --> 00:08:04.495
you can check to make sure that
you're doing it correctly.

130
00:08:04.495 --> 00:08:08.858
Most people will skip over that step,
they'll try to second guess things.

131
00:08:08.858 --> 00:08:13.207
I absolutely do this, I know for
a fact that an n squared algorithm, for

132
00:08:13.207 --> 00:08:17.648
example, is gonna not work, so
I'll just avoid even writing the code.

133
00:08:17.648 --> 00:08:21.647
And as a discipline, I'm gonna teach
you that it's really important

134
00:08:21.647 --> 00:08:25.442
to have that reference implementation
that was quick to write, so

135
00:08:25.442 --> 00:08:29.531
that you can benchmark, and so
that you can check your answers, okay?

136
00:08:29.531 --> 00:08:32.986
Testing to make sure that you didn't
create some regression because

137
00:08:32.986 --> 00:08:35.022
you were trying to optimize something.

138
00:08:35.022 --> 00:08:39.203
So what I would say is that premature
optimization is not really the problem,

139
00:08:39.203 --> 00:08:40.952
it's immature optimization.

140
00:08:40.952 --> 00:08:44.924
There are things that you should be
optimizing from the very first moment that

141
00:08:44.924 --> 00:08:48.360
you write some code, and
there are things that will never matter.

142
00:08:48.360 --> 00:08:51.504
You think you're optimizing them,
but they will never matter.

143
00:08:51.504 --> 00:08:53.848
I'll pick on one, for example,

144
00:08:53.848 --> 00:08:59.041
that I sometimes see floating around
in the world, is that people claim,

145
00:08:59.041 --> 00:09:04.151
for example, that if you use the const
keyword, that somehow magically

146
00:09:04.151 --> 00:09:09.207
underneath JavaScript engine covers,
that it's gonna do less work.

147
00:09:09.207 --> 00:09:11.891
Cuz it knows it's never gonna
get mutated or something.

148
00:09:11.891 --> 00:09:14.771
And I don't actually know
whether that's true, but

149
00:09:14.771 --> 00:09:18.492
I'm just gonna go out on a limb and
say it's completely irrelevant.

150
00:09:18.492 --> 00:09:22.738
There is never going to be a case where
the choice between a var, let, and

151
00:09:22.738 --> 00:09:25.665
const was the difference
between performance and

152
00:09:25.665 --> 00:09:29.450
non-performing code,
that's just nonsense, it is, okay?

153
00:09:29.450 --> 00:09:34.271
So immature optimization, one of
the things that I put under that umbrella,

154
00:09:34.271 --> 00:09:39.254
is trying to micro-optimize or trying
to look at some implementation detail.

155
00:09:39.254 --> 00:09:44.042
And say I know that V8 uses hidden
classes and blah, blah, blah, and

156
00:09:44.042 --> 00:09:48.686
then tomorrow, V8 ships a new version and
all that's different.

157
00:09:48.686 --> 00:09:51.910
My advice is don't bet against the future.

158
00:09:51.910 --> 00:09:56.720
That practice of saying, I know now better
than the engine, better than the compiler,

159
00:09:56.720 --> 00:10:00.425
better than the computer,
I know these things better than they do,

160
00:10:00.425 --> 00:10:03.675
is you betting against the future
of all of those incredibly

161
00:10:03.675 --> 00:10:06.675
smart folks who are working
on optimizing that stuff.

162
00:10:06.675 --> 00:10:09.869
That's one of the reasons
that I like JavaScript,

163
00:10:09.869 --> 00:10:13.371
is I like to be able to let it
do what it's really good at.

164
00:10:13.371 --> 00:10:16.038
[LAUGH] They're really good
at optimizing JavaScript, and

165
00:10:16.038 --> 00:10:19.833
I don't wanna fight against that and try
to convince JavaScript that I know better.

166
00:10:19.833 --> 00:10:23.297
I certainly wouldn't wanna write a code,
I would never endorse writing

167
00:10:23.297 --> 00:10:27.470
a piece of code that's gonna work great in
V8 and suck in SpiderMonkey, for example.

168
00:10:27.470 --> 00:10:31.569
And that happens all the time, because
people actually feel almost an ego boost

169
00:10:31.569 --> 00:10:35.749
when they learn some internal detail and
then they optimize their code for that.

170
00:10:35.749 --> 00:10:38.750
And then it turns out they didn't
even care about testing it in

171
00:10:38.750 --> 00:10:40.319
some other JavaScript engine.

172
00:10:40.319 --> 00:10:43.658
So I would say that the real thing that
we should be worried about is immature

173
00:10:43.658 --> 00:10:44.407
optimization.

174
00:10:44.407 --> 00:10:46.200
How do you get more mature at it?

175
00:10:46.200 --> 00:10:48.630
Practice, experience.

176
00:10:48.630 --> 00:10:52.849
But don't follow the bandwagon of,
I'm not allowed to optimize now, or

177
00:10:52.849 --> 00:10:56.933
I'm only allowed to optimize in this
specific way, because this guy,

178
00:10:56.933 --> 00:11:00.215
this person said this or
whatever, don't follow that.

179
00:11:00.215 --> 00:11:05.050
Look at the problem, follow these steps,
and that's the path, cyclically,

180
00:11:05.050 --> 00:11:07.938
experience over experience
over experience,

181
00:11:07.938 --> 00:11:10.481
is the path to more mature optimization.

182
00:11:10.481 --> 00:11:13.657
And optimization is good, it's useful.

183
00:11:13.657 --> 00:11:17.757
You need to understand actually
the full context of Knuth's quote,

184
00:11:17.757 --> 00:11:21.503
which was not just that all
premature optimization is bad, but

185
00:11:21.503 --> 00:11:26.307
what he was saying is that many times,
people focus on the non-critical parts of

186
00:11:26.307 --> 00:11:30.710
their application and they optimize
stuff that won't actually matter.

187
00:11:30.710 --> 00:11:33.855
So that's really speaking to what
I'm talking about about being more

188
00:11:33.855 --> 00:11:34.950
mature with it.

189
00:11:34.950 --> 00:11:39.707
If you can figure out what the critical
path is, that's the $64 million question,

190
00:11:39.707 --> 00:11:42.110
what is the critical path?

191
00:11:42.110 --> 00:11:46.130
It turns out that's not a binary,
it is or is not critical path.

192
00:11:46.130 --> 00:11:48.338
It's extremely context-dependent.

193
00:11:48.338 --> 00:11:50.034
So we have to get more mature and

194
00:11:50.034 --> 00:11:54.476
we have to get better at asking questions
about our systems, our requirements,

195
00:11:54.476 --> 00:11:58.719
our problems, the contexts that our code
will run in before we can ever hope to

196
00:11:58.719 --> 00:12:01.961
figure out where's the 3%
that my attention should go.

