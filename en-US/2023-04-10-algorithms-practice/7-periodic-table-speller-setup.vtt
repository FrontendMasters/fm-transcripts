WEBVTT

1
00:00:00.000 --> 00:00:05.122
In the slides, which you should all
have access to, as we go along, there'll

2
00:00:05.122 --> 00:00:10.410
be links to GitHub repositories, that
we'll be going over with our exercises.

3
00:00:10.410 --> 00:00:14.094
So you'll see those links and it'll say
repo down in the bottom right corner.

4
00:00:14.094 --> 00:00:16.593
They'll come to repos like this.

5
00:00:16.593 --> 00:00:18.857
This will be the first one we're
actually gonna go through.

6
00:00:18.857 --> 00:00:24.002
And I just wanna to point out real
quickly the mechanics of these repos.

7
00:00:24.002 --> 00:00:28.748
The main branch on the repo has
the readme that describes the project so

8
00:00:28.748 --> 00:00:34.070
it's got all your instructions on kind
of how to orient and that kind of thing.

9
00:00:34.070 --> 00:00:38.573
And then we've got you can do this from
the command line you can do it from the UI

10
00:00:38.573 --> 00:00:43.076
and whatever your is your favorite way of
interacting with it I like to just get

11
00:00:43.076 --> 00:00:45.318
clone and do it from the command line.

12
00:00:45.318 --> 00:00:49.476
But there are branches in here and
there's a start here branch and

13
00:00:49.476 --> 00:00:54.177
that's where you wanna start,
when you're gonna work on the workshop.

14
00:00:54.177 --> 00:00:58.991
So the start here branch will have
the basic files already created for you.

15
00:00:58.991 --> 00:01:03.535
And then for each of these workshops,
you'll see option one, option two, three,

16
00:01:03.535 --> 00:01:06.418
four, etc., for
each of the different workshops.

17
00:01:06.418 --> 00:01:08.572
Those are progressively more and more or

18
00:01:08.572 --> 00:01:11.433
different ways of doing
the solution to the problem.

19
00:01:11.433 --> 00:01:15.727
The reason I did them as branches is it's
real easy in the UI to do a diff between

20
00:01:15.727 --> 00:01:18.848
two branches you can also do
that from the command line.

21
00:01:18.848 --> 00:01:21.409
So you can check and
see I missed something or

22
00:01:21.409 --> 00:01:24.180
something he did didn't
work quite the same way.

23
00:01:24.180 --> 00:01:28.775
Just diff the, if we're on option two diff
one to option two or start here to option

24
00:01:28.775 --> 00:01:32.589
one or whatever and you can see
anything that you might have missed.

25
00:01:32.589 --> 00:01:36.813
So hopefully those diffs are helpful for
you just as you're keeping up.

26
00:01:36.813 --> 00:01:41.081
I'd also mentioned that if for whatever
reason we're gonna be doing a lot of live

27
00:01:41.081 --> 00:01:44.658
coding in the workshop, but if for
whatever reason you get behind or

28
00:01:44.658 --> 00:01:47.762
something isn't working for
you exactly, quite right.

29
00:01:47.762 --> 00:01:50.273
You're welcome to ask questions and

30
00:01:50.273 --> 00:01:54.485
we can try to do a little
troubleshooting or tips or whatever.

31
00:01:54.485 --> 00:01:59.072
But if for some reason you are behind,
you don't have to stay behind just simply

32
00:01:59.072 --> 00:02:02.037
stash your work and
switch to the new to the branch.

33
00:02:02.037 --> 00:02:06.044
So again, if we're getting ready to do
the option two solution you switch to

34
00:02:06.044 --> 00:02:08.182
the option one branch which is the base.

35
00:02:08.182 --> 00:02:12.499
Just, stash your changes, switch to option
one, and then you're good to go for

36
00:02:12.499 --> 00:02:13.522
the next portion.

37
00:02:13.522 --> 00:02:17.993
One other little note is that each one of
the exercises that we're gonna work on

38
00:02:17.993 --> 00:02:20.239
are designed to be run in a web context.

39
00:02:20.239 --> 00:02:23.926
Which means from the root
directory of that repo checkout,

40
00:02:23.926 --> 00:02:26.365
you wanna run some sort of a web server.

41
00:02:26.365 --> 00:02:29.299
Some people like to do that from
inside of their code editor or IDE.

42
00:02:29.299 --> 00:02:32.686
Some people like to do it
from the command line.

43
00:02:32.686 --> 00:02:37.045
I always do like NPX, HTTP server, but
whatever your favorite way of running just

44
00:02:37.045 --> 00:02:40.916
a local host web server, you don't
need anything else fancy than that.

45
00:02:40.916 --> 00:02:45.484
But we make fetch for a JSON file and
you can't do that on the file system so.

46
00:02:45.484 --> 00:02:50.398
You wanna make sure you
run a local web server so

47
00:02:50.398 --> 00:02:54.060
that you can run it in the browser.

48
00:02:54.060 --> 00:02:58.531
So I'm gonna pull up for example, I've
got a web server running for localhost,

49
00:02:58.531 --> 00:03:00.920
localhost port 8080 is what I choose.

50
00:03:00.920 --> 00:03:04.548
And here's that first exercise pull
up in a browser, nothing fancy, but

51
00:03:04.548 --> 00:03:06.430
that's what you wanna be able to see.

52
00:03:06.430 --> 00:03:11.841
In a browser, when you go to localhost and
whatever port you choose,

53
00:03:11.841 --> 00:03:18.003
we're ready for our first laboratory
exercise our first official exercise,

54
00:03:18.003 --> 00:03:22.321
you notice the link there
to the workshop repository.

55
00:03:22.321 --> 00:03:27.504
This is periodic table speller
is the name of this problem.

56
00:03:27.504 --> 00:03:30.584
So we're gonna dive into
the periodic table speller.

57
00:03:30.584 --> 00:03:35.078
Go ahead and make sure you have that
repository cloned in your local system.

58
00:03:35.078 --> 00:03:37.892
You're gonna want to be
on the Start Here branch,

59
00:03:37.892 --> 00:03:41.309
you're gonna want to have your
local web server running, so

60
00:03:41.309 --> 00:03:45.877
that you can pull up the index html file
in a web page, Port 8080 or whatever.

61
00:03:45.877 --> 00:03:47.840
What is this exercise all about?

62
00:03:47.840 --> 00:03:53.872
Well, don't be scared if you're not
like me, not one of the science folks.

63
00:03:53.872 --> 00:03:58.077
When I look at a periodic table,
I'm like, I know, like, oxygen.

64
00:03:58.077 --> 00:03:58.766
That's about it.

65
00:03:58.766 --> 00:04:03.578
I don't know what all this stuff is my
kids actually have more than half of this

66
00:04:03.578 --> 00:04:05.367
periodic table memorized.

67
00:04:05.367 --> 00:04:10.131
I'm we didn't do that when I was a kid
they didn't ask us to learn the periodic

68
00:04:10.131 --> 00:04:10.658
table.

69
00:04:10.658 --> 00:04:15.055
My kids have a song that they sing all the
periodic table elements it's incredible.

70
00:04:15.055 --> 00:04:18.939
Anyway, I got inspired because my
daughter had a little assignment.

71
00:04:18.939 --> 00:04:24.565
Where they asked her to spell out
some words that were meaningful

72
00:04:24.565 --> 00:04:29.364
to her using only the symbols
from the periodic table.

73
00:04:29.364 --> 00:04:31.236
And I thought that was
a cool little assignment.

74
00:04:31.236 --> 00:04:33.790
And so she had come up with
a couple of different words.

75
00:04:33.790 --> 00:04:38.256
And I was trying to think of words to help
her with and then of course, my programmer

76
00:04:38.256 --> 00:04:42.554
brain went to, this got to be a thing that
solved or a thing that can be written.

77
00:04:42.554 --> 00:04:46.778
And it turns out there is a website that
does this you can find that website you

78
00:04:46.778 --> 00:04:47.640
can type it in.

79
00:04:47.640 --> 00:04:51.390
But it was a little bit annoying to me
that they use not only the periodic table

80
00:04:51.390 --> 00:04:53.221
elements which was her assignment.

81
00:04:53.221 --> 00:04:56.916
But they also use like a Physics
characters, like epsilon and

82
00:04:56.916 --> 00:05:01.405
stuff like that from other parts of
science, not just the periodic table.

83
00:05:01.405 --> 00:05:04.980
And that wasn't part of her assignment,
so I got annoyed by that and

84
00:05:04.980 --> 00:05:08.701
I was I'm gonna write the code to do
this just from the periodic table.

85
00:05:08.701 --> 00:05:13.364
And so that's the little code the tool
that we're gonna build a periodic

86
00:05:13.364 --> 00:05:14.441
table speller.

87
00:05:14.441 --> 00:05:18.958
So the word because can be spelled
out with these I don't even have to

88
00:05:18.958 --> 00:05:23.809
pronounce it as a beryllium anybody
know calcium uranium and selenium.

89
00:05:23.809 --> 00:05:26.263
It spells outwards so
you can't spell all words but

90
00:05:26.263 --> 00:05:27.927
many words that you can spell out.

91
00:05:27.927 --> 00:05:31.240
And we're gonna write the code
do that immediately I want

92
00:05:31.240 --> 00:05:35.598
your brains is you're listening to this,
to go to, how am I gonna do that?

93
00:05:35.598 --> 00:05:37.335
Where would I start?

94
00:05:37.335 --> 00:05:41.508
What is the first questions
that we need to ask about this?

95
00:05:41.508 --> 00:05:46.170
Remember, I'm trying to help you learn
the discipline of approaching problems

96
00:05:46.170 --> 00:05:49.120
thinking as an algorithmic
thinking in algorithms

97
00:05:49.120 --> 00:05:52.217
before you start to write the code for
the algorithm.

98
00:05:52.217 --> 00:05:55.247
So as an algorithmic,
what should you be thinking?

99
00:05:55.247 --> 00:05:58.176
What should you be asking yourself?

100
00:05:58.176 --> 00:06:02.622
Anyone have any suggestions for
questions that we should be asked if

101
00:06:02.622 --> 00:06:06.843
given this assignment,
given this task at work, for example.

102
00:06:06.843 --> 00:06:09.037
What are the clarifying question
that we ought to be asking?

103
00:06:11.939 --> 00:06:14.950
Yeah.
&gt;&gt; Are we allowed partial matches or

104
00:06:14.950 --> 00:06:18.261
are we required to spell the entire word?

105
00:06:18.261 --> 00:06:22.274
&gt;&gt; Are we allowed to leave off letters or
spell only part of the word?

106
00:06:22.274 --> 00:06:27.386
Great question I think we're gonna assume
that you either spelled the whole word and

107
00:06:27.386 --> 00:06:28.759
nothing but the word.

108
00:06:28.759 --> 00:06:30.297
But that's a great question.

109
00:06:30.297 --> 00:06:34.250
Maybe we ought to allow it to leave
off the trailing characters, or

110
00:06:34.250 --> 00:06:36.730
the leading characters, or something.

111
00:06:36.730 --> 00:06:42.008
But for this exercise, we will either
match the whole word or none of the word.

112
00:06:42.008 --> 00:06:45.443
Good question, what else?

113
00:06:45.443 --> 00:06:47.258
There's a real obvious
one on the screen here.

114
00:06:47.258 --> 00:06:49.224
I just wondered if anybody
would pick up on it.

115
00:06:49.224 --> 00:06:50.686
Yeah.

116
00:06:50.686 --> 00:06:54.813
&gt;&gt; It doesn't seem like
capitalization matters.

117
00:06:54.813 --> 00:06:55.430
&gt;&gt; See?

118
00:06:55.430 --> 00:06:56.779
Casing, right?

119
00:06:56.779 --> 00:07:00.190
Do we want to require
the capitalization of the first letter?

120
00:07:00.190 --> 00:07:02.585
Do we want to allow any casing?

121
00:07:02.585 --> 00:07:05.415
Here we're gonna assume that
we've got whatever we input.

122
00:07:05.415 --> 00:07:10.011
We'll make sure that's all lowercase and
we'll match the symbols case insensitive.

123
00:07:10.011 --> 00:07:12.811
That'll make our problems
significantly easier.

124
00:07:12.811 --> 00:07:16.803
But you absolutely could identify that so
you're already asking exactly the right

125
00:07:16.803 --> 00:07:20.524
kinds of questions is going to lead to
a very different algorithmic outcome.

126
00:07:20.524 --> 00:07:25.452
These are not minor details afterwards
these are very important things that

127
00:07:25.452 --> 00:07:30.072
we have to catch up front because they
may take us on a very different path

128
00:07:30.072 --> 00:07:31.543
any other questions?

129
00:07:31.543 --> 00:07:32.745
&gt;&gt; There's some from chat.

130
00:07:32.745 --> 00:07:34.196
&gt;&gt; Yeah, what do we got?

131
00:07:34.196 --> 00:07:36.386
&gt;&gt; Can we repeat using an element?

132
00:07:36.386 --> 00:07:38.606
&gt;&gt; Very good question.

133
00:07:38.606 --> 00:07:43.499
Answer for this one definitely we want
to allow repeating an element because

134
00:07:43.499 --> 00:07:48.698
the same series of characters might end
up appearing multiple times in the word,

135
00:07:48.698 --> 00:07:52.559
absolutely
&gt;&gt; Do all the element names have one or

136
00:07:52.559 --> 00:07:53.842
two letters?

137
00:07:53.842 --> 00:07:58.978
&gt;&gt; Very good question which leads to
a question may not have yet been obvious

138
00:07:58.978 --> 00:08:04.463
to any of you all of the periodic table
elements do have one or two characters.

139
00:08:04.463 --> 00:08:09.217
But how are we gonna decide whether we
want words that are the longest possible

140
00:08:09.217 --> 00:08:11.569
meaning the most number of elements?

141
00:08:11.569 --> 00:08:16.109
That would be one where we prefer
single letter elements versus

142
00:08:16.109 --> 00:08:18.003
the two letter elements?

143
00:08:18.003 --> 00:08:21.517
Or do we wanna spell the words
with the fewest number of symbols?

144
00:08:21.517 --> 00:08:23.683
So we're gonna prefer the two character.

145
00:08:23.683 --> 00:08:26.321
Those would lead to potentially
very different outcomes.

146
00:08:26.321 --> 00:08:28.259
In some cases, the same outcome.

147
00:08:28.259 --> 00:08:32.355
But in some words,
you would get a very different spelling of

148
00:08:32.355 --> 00:08:36.064
it if you optimized for
more symbols or fewer symbols.

149
00:08:36.064 --> 00:08:39.141
All very good questions,
there's probably more to it.

150
00:08:39.141 --> 00:08:42.111
Here's one of the most practical
ones that I started with.

151
00:08:42.111 --> 00:08:43.847
Where am I gonna get the data from?

152
00:08:43.847 --> 00:08:45.238
I don't know the periodic table.

153
00:08:45.238 --> 00:08:46.642
Where am I going to get it from?

154
00:08:46.642 --> 00:08:48.582
I Googled around, and

155
00:08:48.582 --> 00:08:54.509
I happened to find a JSON file that
had the whole periodic table in it.

156
00:08:54.509 --> 00:08:58.753
And I did a little bit of processing on
it to filter out some of the data that I

157
00:08:58.753 --> 00:09:01.787
didn't care about and
keep only the data that I did.

158
00:09:01.787 --> 00:09:04.669
And that's included with our project,
so you don't need to go find that.

159
00:09:04.669 --> 00:09:09.760
But sometimes it's as simple as,
where do I find my dataset to start with?

160
00:09:09.760 --> 00:09:12.860
And in this case, thankfully,
it wasn't that difficult.

161
00:09:12.860 --> 00:09:16.993
All right, let me switch over
to the actual Speller here.

162
00:09:16.993 --> 00:09:18.441
I've got this loaded and running.

163
00:09:18.441 --> 00:09:20.067
I've got a web server
again in the background.

164
00:09:20.067 --> 00:09:22.177
I've got this loaded and running.

165
00:09:22.177 --> 00:09:26.817
You'll notice that when I type in
the word because and I click spell,

166
00:09:26.817 --> 00:09:31.537
it couldn't spell it because we
haven't written the algorithm yet.

167
00:09:31.537 --> 00:09:35.449
So that's what we get on
the Start Here Branch is a functional but

168
00:09:35.449 --> 00:09:36.904
not complete project.

169
00:09:36.904 --> 00:09:39.930
I wanna orient you a little
bit to the code, but

170
00:09:39.930 --> 00:09:44.523
this basically is the same as
the instructions that are in the readme.

171
00:09:44.523 --> 00:09:48.704
So remember that there's a readme on the
main branch that has these instructions

172
00:09:48.704 --> 00:09:51.976
and I'm just gonna kinda walk
you through the same stuff here.

173
00:09:51.976 --> 00:09:57.575
So if you need to refer back or miss any
thing that's what we're going through so

174
00:09:57.575 --> 00:10:00.595
I'm gonna switch over to the code editor.

175
00:10:00.595 --> 00:10:02.899
And I'll just orient you and

176
00:10:02.899 --> 00:10:08.861
start here branch we start with index
study HTML file pretty basic stuff.

177
00:10:08.861 --> 00:10:13.210
We're not gonna make any changes
to the HTML in this project.

178
00:10:13.210 --> 00:10:15.788
But just so
you're aware of what it's doing,

179
00:10:15.788 --> 00:10:19.886
it's got an input box to enter in
the word, it's got a button to spell it,

180
00:10:19.886 --> 00:10:23.074
and then there's a div for
us to place the word spelling.

181
00:10:23.074 --> 00:10:28.425
We load up our app module which again
all of this code is already written for

182
00:10:28.425 --> 00:10:32.587
you, you don't need to touch
any of the code in app.js.

183
00:10:32.587 --> 00:10:37.808
But just to familiarize ourselves with
it we grab some references to those

184
00:10:37.808 --> 00:10:42.874
functions and we set up a couple of
click handler and key down handlers.

185
00:10:45.293 --> 00:10:47.745
We do a little bit of validation here,

186
00:10:47.745 --> 00:10:52.051
which is that you have to have
provided at least three characters.

187
00:10:52.051 --> 00:10:53.939
We could have allowed two characters, but

188
00:10:53.939 --> 00:10:56.620
it just doesn't seem that
interesting to have a single one.

189
00:10:56.620 --> 00:10:59.166
So you got to have at
least three letters long.

190
00:10:59.166 --> 00:11:03.431
And then we invoke the speller.check
that's in another module, and

191
00:11:03.431 --> 00:11:05.755
that's the code we're gonna write.

192
00:11:05.755 --> 00:11:10.680
And then to spell the word we,
once we get back a list of symbols and

193
00:11:10.680 --> 00:11:12.123
array of symbols.

194
00:11:12.123 --> 00:11:16.744
If it matched to spell the word we
need to be able to call the lookup

195
00:11:16.744 --> 00:11:20.525
method on that same module
to pull out the elements.

196
00:11:20.525 --> 00:11:23.953
So we have the symbol, but
I want the whole elements I want its name,

197
00:11:23.953 --> 00:11:26.068
its atomic number and it's symbol back.

198
00:11:26.068 --> 00:11:28.376
So we need to have a lookup.

199
00:11:28.376 --> 00:11:32.302
So we see those two methods,
we see the check and the lookup method.

200
00:11:32.302 --> 00:11:37.522
And if we switch over to the speller,
module speller.js.

201
00:11:37.522 --> 00:11:41.122
You'll note here that it automatically
does the work of loading up our

202
00:11:41.122 --> 00:11:41.801
JSON for us.

203
00:11:41.801 --> 00:11:47.518
So that file is already in your
project and already loads for us.

204
00:11:47.518 --> 00:11:51.744
And all we need to do is
handle these to do comments.

205
00:11:51.744 --> 00:11:53.519
There's the check function and

206
00:11:53.519 --> 00:11:57.865
the lookup function should be fairly
straightforward and self explanatory.

207
00:11:57.865 --> 00:12:01.033
Again, refer to the readme if
you're curious about it, but

208
00:12:01.033 --> 00:12:05.087
the check function should always return
an array empty if it's got nothing.

209
00:12:05.087 --> 00:12:12.222
And full of the symbols as strings,
if it was able to spell the input word.

210
00:12:12.222 --> 00:12:16.357
The lookup takes one of those strings and
returns the object.

211
00:12:16.357 --> 00:12:23.920
If open up our JSON file you'll note that
each entry has a name, number, and symbol.

212
00:12:23.920 --> 00:12:28.086
So given the symbol in lowercase,
we need to return this whole object.

213
00:12:28.086 --> 00:12:29.398
That's what the lookup function does.

