WEBVTT

1
00:00:00.400 --> 00:00:04.301
All right, I wanted to start
with a quick primer on DSA,

2
00:00:04.301 --> 00:00:07.090
data structures and algorithms.

3
00:00:07.090 --> 00:00:14.399
This is the few minute version of what
is full courses for other people, right?

4
00:00:14.399 --> 00:00:17.440
So, I'm definitely not
going deep into detail.

5
00:00:17.440 --> 00:00:21.421
We will get into many of these topics and
come back to them as we code along, but

6
00:00:21.421 --> 00:00:25.589
I just wanted to present for those of you
that maybe don't know some of the terms,

7
00:00:25.589 --> 00:00:28.961
just so you have a little bit of
basic familiarity with the terms,

8
00:00:28.961 --> 00:00:30.910
how they relate to each other.

9
00:00:30.910 --> 00:00:33.379
These are the sorts of terms
that you go and google and

10
00:00:33.379 --> 00:00:34.851
find the Wikipedia pages for.

11
00:00:34.851 --> 00:00:38.670
And just read the first three paragraphs
of any Wikipedia page because beyond that,

12
00:00:38.670 --> 00:00:40.840
it's probably too much depth for you.

13
00:00:40.840 --> 00:00:44.788
But the first three paragraphs of any
one of these Wikipedia pages is probably

14
00:00:44.788 --> 00:00:47.094
enough to get you a familiarity like,
okay,

15
00:00:47.094 --> 00:00:50.450
I know where that's gonna fit into
the overall scheme of things.

16
00:00:52.060 --> 00:00:57.299
Some common data structures to be aware
of, these may be familiar to many of you,

17
00:00:57.299 --> 00:01:02.461
maybe not familiar to some of you, I just
picked a few of them that you definitely

18
00:01:02.461 --> 00:01:08.380
wanna have on your radar screen and have
done some at least minimal research on.

19
00:01:08.380 --> 00:01:08.950
Arrays.

20
00:01:08.950 --> 00:01:13.524
We talked about that, the concept of
sequentially ordering a list of values,

21
00:01:13.524 --> 00:01:17.889
they go by lots of different names,
lists, and arrays, and vectors and,

22
00:01:17.889 --> 00:01:22.880
there's all kinds of subnuances and
caveats underneath each one of these.

23
00:01:22.880 --> 00:01:26.324
But arrays are sequentially,
generally indexed order,

24
00:01:26.324 --> 00:01:30.010
numerically indexed collections of values.

25
00:01:30.010 --> 00:01:34.560
Stacks are most always built on top of
arrays, although they don't have to be

26
00:01:34.560 --> 00:01:40.000
built on top of arrays, they can be built
on top of other primitive data structures.

27
00:01:40.000 --> 00:01:42.740
But a stack is kind of like
an array with an additional

28
00:01:42.740 --> 00:01:47.400
property which is that we only put on to
the end and we only take off of the end.

29
00:01:47.400 --> 00:01:50.569
So if I start out with two
values in a stack, and

30
00:01:50.569 --> 00:01:54.795
I want to take one value off,
I don't take the first item off,

31
00:01:54.795 --> 00:02:00.370
I take the last item off cuz it's
last in first out, so called LIFO.

32
00:02:00.370 --> 00:02:02.790
Last In First Out is
what we have with stacks.

33
00:02:02.790 --> 00:02:06.030
Stacks are immensely
important to understand.

34
00:02:06.030 --> 00:02:10.078
We use terminology like pushing and
popping, we push on to a stack,

35
00:02:10.078 --> 00:02:13.710
my favorite visualization of
that is the stack of pancakes.

36
00:02:14.790 --> 00:02:17.270
I got four pancakes, that's not enough.

37
00:02:17.270 --> 00:02:21.452
Give me a fifth pancake,
you put a fifth pancake on top, okay?

38
00:02:21.452 --> 00:02:24.271
And then I eat a pancake, and
then we've popped it off the stack, and

39
00:02:24.271 --> 00:02:26.520
now I'm back to four, and
now I need a fifth one again.

40
00:02:27.820 --> 00:02:30.120
Just tell the waiter,
always keep five pancakes on top.

41
00:02:31.150 --> 00:02:32.880
Okay, so there's your stack, right?

42
00:02:32.880 --> 00:02:37.030
And this is immensely
common in programming.

43
00:02:37.030 --> 00:02:38.914
We'll see this over and
over and over again,

44
00:02:38.914 --> 00:02:42.203
you'll hear that word stack over and
over again used, so be familiar with it.

45
00:02:42.203 --> 00:02:47.835
Queues, similar to stack, but it's a first
in first out instead of last in first out.

46
00:02:47.835 --> 00:02:51.161
In the queue world, again,
often implemented with an array,

47
00:02:51.161 --> 00:02:55.120
can be implemented with other things
like linked lists and so forth.

48
00:02:55.120 --> 00:02:58.432
But in a queue, the first thing that we
put in, no matter how much else we put in,

49
00:02:58.432 --> 00:03:01.120
the first thing that we put in is
the thing we're gonna take out.

50
00:03:02.200 --> 00:03:03.670
Queue being like a line.

51
00:03:03.670 --> 00:03:07.400
Just think of it like a line at the,
waiting to get on a roller coaster.

52
00:03:07.400 --> 00:03:09.439
Generally, we don't let
people cut in line, so

53
00:03:09.439 --> 00:03:13.260
the next person in line is the one that
gets to get on the roller coaster.

54
00:03:13.260 --> 00:03:14.050
Just think of it like that.

55
00:03:14.050 --> 00:03:15.703
And again, we use those a lot,

56
00:03:15.703 --> 00:03:18.770
we'll see queues today in use
in some of our algorithms.

57
00:03:18.770 --> 00:03:22.910
These are kinda like Lego pieces that
you end up putting algorithms on top of.

58
00:03:22.910 --> 00:03:28.740
So data structures are the mechanisms by
which we implement our various algorithms.

59
00:03:28.740 --> 00:03:31.730
A couple of others,
we've got sets, so what is a set?

60
00:03:31.730 --> 00:03:34.331
Again, often implemented as an array, but

61
00:03:34.331 --> 00:03:37.847
can be implemented with other
primitive data structures,

62
00:03:37.847 --> 00:03:43.030
sets are basically like, I want
an unordered collection that is unique.

63
00:03:43.030 --> 00:03:44.433
unordered is important.

64
00:03:44.433 --> 00:03:46.680
In arrays they're ordered.

65
00:03:46.680 --> 00:03:51.189
So if you were implementing a set with
an array, you would actually have to go

66
00:03:51.189 --> 00:03:55.556
to a little bit of extra trouble to make
it seem as if the array was set like,

67
00:03:55.556 --> 00:04:00.820
because two sets with the same values in
a different order should be equivalent.

68
00:04:00.820 --> 00:04:03.612
And two arrays with the values in
different orders would definitely be

69
00:04:03.612 --> 00:04:04.470
different, right?

70
00:04:04.470 --> 00:04:06.610
So you have to go to a little
bit of extra trouble, and

71
00:04:06.610 --> 00:04:09.450
that might be why you didn't actually
implement a set with an array.

72
00:04:09.450 --> 00:04:11.570
Maybe you implemented
it with something else.

73
00:04:11.570 --> 00:04:12.690
Again, lots of choices there.

74
00:04:13.840 --> 00:04:17.520
But sets are an unordered
collection of unique values.

75
00:04:17.520 --> 00:04:19.330
Extremely helpful.

76
00:04:19.330 --> 00:04:25.604
We will implement traversal algorithms and
talk about traversal algorithms,

77
00:04:25.604 --> 00:04:30.940
where we need to remember that
we visited something before.

78
00:04:30.940 --> 00:04:36.080
You throw it into a set and then you ask
the set, have I seen this thing before?

79
00:04:36.080 --> 00:04:37.580
Extremely useful.

80
00:04:37.580 --> 00:04:38.690
Could you do that with an array?

81
00:04:38.690 --> 00:04:39.310
Of course you could.

82
00:04:39.310 --> 00:04:42.711
We've got array, we've got array includes,
or index have or whatever, but

83
00:04:42.711 --> 00:04:46.040
that's not the right tool for the job,
the right tool for the job is set.

84
00:04:46.040 --> 00:04:46.700
Why?

85
00:04:46.700 --> 00:04:50.044
Because you would not wanna just keep
throwing the same value into that array

86
00:04:50.044 --> 00:04:52.721
over and over and have it grow and
grow and waste your memory.

87
00:04:52.721 --> 00:04:55.740
A set's gonna make sure we only
have one copy of the thing.

88
00:04:55.740 --> 00:04:59.072
I'll talk about map in a moment and
then we can answer the question about,

89
00:04:59.072 --> 00:05:02.533
there's a question being asked about,
when would you use a map versus set?

90
00:05:02.533 --> 00:05:05.131
They're very different data structures so,

91
00:05:05.131 --> 00:05:08.740
you would almost never use one
interchangeably with the other.

92
00:05:08.740 --> 00:05:10.909
They're for
very different types of problems.

93
00:05:11.940 --> 00:05:12.501
Objects.

94
00:05:12.501 --> 00:05:17.114
I throw that up here because it's a nice,
simple,

95
00:05:17.114 --> 00:05:21.633
recognizable word for
key value data structure.

96
00:05:21.633 --> 00:05:25.051
And by key, in JavaScript in particular,
we mean something like a string key.

97
00:05:25.051 --> 00:05:28.752
So that's contrasted with
something like an array,

98
00:05:28.752 --> 00:05:33.193
which is that the location of
the data is numerically indexed and

99
00:05:33.193 --> 00:05:38.129
it's generally contiguous,
here in an object you can have string keys

100
00:05:38.129 --> 00:05:43.085
that are not contiguous,
that aren't related in any way, whatever.

101
00:05:43.085 --> 00:05:48.816
And so, you're probably familiar with
these sorts of things, JSON, objects,

102
00:05:48.816 --> 00:05:54.046
or how most people kind of visualize this,
but an object is simply a place to

103
00:05:54.046 --> 00:06:00.070
store some data in a collection and
give it a unique name, generally a string.

104
00:06:00.070 --> 00:06:04.359
You technically can use numbers cuz
they just, string of I is the number for

105
00:06:04.359 --> 00:06:07.967
the key but, usually you stick
to numeric indexing on arrays,

106
00:06:07.967 --> 00:06:10.270
and string indexing on objects.

107
00:06:10.270 --> 00:06:10.990
Now what's a map?

108
00:06:10.990 --> 00:06:13.650
A lot of people get
confused object versus map.

109
00:06:13.650 --> 00:06:18.546
Maps are very similar, but maps under
the covers fundamentally say we can use

110
00:06:18.546 --> 00:06:21.120
any value as our key not simply a string.

111
00:06:22.350 --> 00:06:26.967
And that is why there it gives rise
to the more formal concept which is

112
00:06:26.967 --> 00:06:29.728
called a HashMap, what does that mean?

113
00:06:29.728 --> 00:06:34.838
There's other terms that you'll find as
you google around for this but, a map has

114
00:06:34.838 --> 00:06:39.891
to take any value, and if it's a string or
a number, it's really easy, right?

115
00:06:39.891 --> 00:06:43.575
We just know where to store stuff if
we've got strings and numbers, or

116
00:06:43.575 --> 00:06:47.757
at least we can think in our minds, I know
where I would probably store something

117
00:06:47.757 --> 00:06:49.585
if the key was a number or a string.

118
00:06:49.585 --> 00:06:52.168
But what if the key is a function?

119
00:06:52.168 --> 00:06:54.398
Function's a weird value, what would I do?

120
00:06:54.398 --> 00:06:56.406
Would I string of I the function or
whatever?

121
00:06:56.406 --> 00:06:58.756
So there's this notion
of hashing something.

122
00:06:58.756 --> 00:07:03.142
A hash is a one way mathematical
transform on a value,

123
00:07:03.142 --> 00:07:06.368
that produces ideally a unique value.

124
00:07:08.602 --> 00:07:11.278
Unfortunately, there's no perfect hashing,
so

125
00:07:11.278 --> 00:07:14.420
we always have what's called collisions.

126
00:07:14.420 --> 00:07:18.398
And the job of an implementer
of something like a HashMap is,

127
00:07:18.398 --> 00:07:23.000
what do I do If two different values
I push through some transform, and

128
00:07:23.000 --> 00:07:27.530
I get a hash to use as the key, and
both values end up with the same key?

129
00:07:27.530 --> 00:07:29.760
They say end up with the same hash,
what do I do?

130
00:07:31.390 --> 00:07:34.676
And so there's lots of different
strategies for how to deal with that.

131
00:07:34.676 --> 00:07:38.222
You have these kind of
exotic data structures where

132
00:07:38.222 --> 00:07:43.088
there's a hash key mechanism used to
do the single slot and that in it,

133
00:07:43.088 --> 00:07:46.633
and at any given slot,
then it's simply an array,

134
00:07:46.633 --> 00:07:51.520
a list of all the values that had
a collision in their key or something.

135
00:07:51.520 --> 00:07:55.822
So, it's lots of different
complexities they're not relevant to

136
00:07:55.822 --> 00:08:00.425
our discussion in this workshop, but
now understanding maps and sets,

137
00:08:00.425 --> 00:08:04.283
you can see that in a set,
its key is completely irrelevant.

138
00:08:04.283 --> 00:08:09.246
It's simply the inclusion in the data
structure, that's the only question

139
00:08:09.246 --> 00:08:13.960
we want to ask of the data structure is,
does it have it or not?

140
00:08:13.960 --> 00:08:15.954
I don't care where it is,
I don't care how you stored it,

141
00:08:15.954 --> 00:08:19.230
I don't care how you implemented it,
just tell me, do you have it or not?

142
00:08:19.230 --> 00:08:24.530
And ideally, also there needs
to only be one of it, right?

143
00:08:24.530 --> 00:08:26.950
Don't ever let there be
more than one of it.

144
00:08:26.950 --> 00:08:29.787
So the kinds of questions we'd ask,
like inclusion or

145
00:08:29.787 --> 00:08:32.929
exclusion, is it there or
is it not, we'd ask that of a set,

146
00:08:32.929 --> 00:08:36.382
you technically could ask that of a map,
like does it have the key,

147
00:08:36.382 --> 00:08:41.080
but again, that's not the right data
structure for that kind of question.

148
00:08:41.080 --> 00:08:45.053
So you often would not,
it's not to say that you couldn't and

149
00:08:45.053 --> 00:08:49.870
sometimes we do stick a key into an object
to represent that we've seen it or

150
00:08:49.870 --> 00:08:54.227
not seen it or whatever but,
usually only use something like a map or

151
00:08:54.227 --> 00:08:57.910
a HashMap when you're going
to retrieve it by its index.

152
00:08:58.920 --> 00:09:03.509
In a set you don't need to retrieve it
because you already have the value,

153
00:09:03.509 --> 00:09:06.779
and you're asking,
is the value already in there?

154
00:09:06.779 --> 00:09:10.652
But with, something like a map or
a HashMap, you wouldn't have the value but

155
00:09:10.652 --> 00:09:14.943
you would have the key, you would have the
index, the property name, whatever, you

156
00:09:14.943 --> 00:09:19.590
would have that, and you would be saying,
tell me what the value is for this thing.

157
00:09:19.590 --> 00:09:23.500
So it's more of a lookup, as opposed
to an inclusion exclusion question.

158
00:09:23.500 --> 00:09:26.528
Just different kinds of problems
that we solve they're both useful,

159
00:09:26.528 --> 00:09:28.280
we do use them for different things.

160
00:09:28.280 --> 00:09:30.966
Moving on, we've got trees and graphs,

161
00:09:30.966 --> 00:09:34.810
trees are extremely common
we use them quite a bit.

162
00:09:34.810 --> 00:09:36.370
And many people if pressed,

163
00:09:36.370 --> 00:09:40.700
can't actually tell you what's
the difference between a tree and a graph.

164
00:09:40.700 --> 00:09:44.935
They are very different, and some of
you listening probably are like, yeah,

165
00:09:44.935 --> 00:09:49.512
they're used for very, very different
things, they have different properties.

166
00:09:49.512 --> 00:09:53.693
What's interesting about the algorithms
that we are gonna look at, and

167
00:09:53.693 --> 00:09:56.639
the algorithms that you're
likely to run across,

168
00:09:56.639 --> 00:09:59.859
is that many times there is
a version of the algorithm for

169
00:09:59.859 --> 00:10:03.720
kind of each of these different
classes of data structure.

170
00:10:03.720 --> 00:10:07.085
So there are algorithms that work
on trees, that have an adaptation,

171
00:10:07.085 --> 00:10:10.221
sometimes just a one-for-one,
and sometimes a slight tweak,

172
00:10:10.221 --> 00:10:12.420
an adaptation that works on a graph.

173
00:10:12.420 --> 00:10:15.632
But graphs are gonna throw more
complexity in, so the algorithm has to

174
00:10:15.632 --> 00:10:19.016
generally be a little bit smarter to
handle, what am I doing with a graph?

175
00:10:19.016 --> 00:10:23.000
And there's lots of different kinds of
graphs, there's directed and undirected,

176
00:10:23.000 --> 00:10:26.240
there's cyclic and acyclic,
there's all kinds of stuff.

177
00:10:26.240 --> 00:10:31.035
But generally, if you learn an algorithm
in a tree algorithm, there's at least some

178
00:10:31.035 --> 00:10:35.520
way to apply that or translate that
concept over into the graph world.

179
00:10:35.520 --> 00:10:38.410
So, what's the difference
between a graph and a tree?

180
00:10:38.410 --> 00:10:43.600
A graph is going to allow all of
those sorts of multiple connections.

181
00:10:43.600 --> 00:10:48.020
So, you can have multiple parents, one
node can have multiple inbound arrows if

182
00:10:48.020 --> 00:10:51.820
you were drawing it out in your mind,
that's a graph.

183
00:10:51.820 --> 00:10:56.410
In a tree,
the relationship is always unidirectional.

184
00:10:56.410 --> 00:11:00.080
A child only has one parent,
it never has two parents.

185
00:11:00.080 --> 00:11:05.046
So there's no such thing as cycles,
trees are inherently directed from parent

186
00:11:05.046 --> 00:11:09.790
to child relationship, graphs are not
inherently directed, meaning that

187
00:11:09.790 --> 00:11:14.704
the arrows have a certain way that they
go, but you can create directed trees.

188
00:11:14.704 --> 00:11:19.898
I mean directed graphs, or
you can create kind of undirected,

189
00:11:19.898 --> 00:11:24.980
uniconnected, universally
connected graphs.

190
00:11:24.980 --> 00:11:29.200
So, some words that I've been spouting
out, words that you see here in the slide,

191
00:11:29.200 --> 00:11:32.033
these are things,
if any of them are unfamiliar to you,

192
00:11:32.033 --> 00:11:35.771
just make yourself a note, I should go and
read the first few paragraphs on

193
00:11:35.771 --> 00:11:39.610
a Wikipedia page just to kinda get
a little bit more comfortable with them.

194
00:11:39.610 --> 00:11:41.170
We'll see them in practice as we go.

195
00:11:41.170 --> 00:11:42.740
There was a question here, yes?

196
00:11:42.740 --> 00:11:47.520
&gt;&gt; Yeah, so if we look at the categories,
the array, set, queue, set,

197
00:11:47.520 --> 00:11:49.671
object, map, and tree graph,

198
00:11:49.671 --> 00:11:54.790
it's another way of thinking about
the differences between those groups.

199
00:11:54.790 --> 00:12:01.600
You have a change in the permissiveness,
say, of ordering and indexing.

200
00:12:01.600 --> 00:12:09.203
So, Array, stacks, queues, they're pretty
friendly to what you throw at them.

201
00:12:09.203 --> 00:12:10.413
Sets, objects, and

202
00:12:10.413 --> 00:12:14.449
maps are going to be much more reactive
to what you've tried to put in and

203
00:12:14.449 --> 00:12:19.560
you have to know kinda how they're going
to behave and what you want out of them.

204
00:12:19.560 --> 00:12:23.401
And trees and graphs are an absolute
mess if you don't go in with a plan.

205
00:12:23.401 --> 00:12:28.175
Because they'll do anything you want and
the tree will turn into a graph,

206
00:12:28.175 --> 00:12:30.793
so we have to have a way of accessing the,

207
00:12:30.793 --> 00:12:35.644
we have to kind of an expectation for
ourselves to access the information,

208
00:12:35.644 --> 00:12:40.580
cuz the data structures provide less
rules as you move from one to the next.

209
00:12:40.580 --> 00:12:42.440
Is that a fair interpretation here?

210
00:12:42.440 --> 00:12:44.981
&gt;&gt; I don't disagree with
any of what you said,

211
00:12:44.981 --> 00:12:48.940
I think it's a pretty reasonable
way of summarizing things.

212
00:12:48.940 --> 00:12:53.218
I won't take credit that I had any
deep thought exactly in exactly how

213
00:12:53.218 --> 00:12:56.834
I categorized these or whatever,
but there is definitely

214
00:12:56.834 --> 00:13:01.460
a difference between whether order
matters in the data structure or not.

215
00:13:01.460 --> 00:13:05.865
That's one of the big characteristics that
will differentiate data structures, and

216
00:13:05.865 --> 00:13:09.665
you see that array, stacks, and
queues order absolutely matters in set,

217
00:13:09.665 --> 00:13:12.497
object, and
map order does not matter at all, in fact,

218
00:13:12.497 --> 00:13:14.820
the concept of order
is somewhat undefined.

219
00:13:14.820 --> 00:13:20.480
In trees, order absolutely matters and
in graphs It depends.

220
00:13:20.480 --> 00:13:22.150
It depends on the kind of graph.

221
00:13:22.150 --> 00:13:26.045
So ordering is certainly one of the
characteristics that we could distinguish

222
00:13:26.045 --> 00:13:27.310
data structures with.

223
00:13:27.310 --> 00:13:32.140
I think there are various other ones, but
I agree with your general interpretation

224
00:13:32.140 --> 00:13:35.390
that that's a primary
characteristic to keep in mind.

