WEBVTT

1
00:00:00.110 --> 00:00:02.034
So, now introduce the virtual DOM.

2
00:00:02.034 --> 00:00:07.134
I think the most misunderstood concept
in UI development because I don't know,

3
00:00:07.134 --> 00:00:10.270
it sounds kinda good, doesn't it, right?

4
00:00:10.270 --> 00:00:12.660
I don't know what it is,
but it sounds kinda good.

5
00:00:12.660 --> 00:00:17.620
We're going to build out a y for
it, hopefully.

6
00:00:17.620 --> 00:00:21.274
And that's gonna enable us
to have a more visual or

7
00:00:21.274 --> 00:00:26.060
declarative version of JavaScript for
coding user interfaces,

8
00:00:26.060 --> 00:00:30.870
knowing that JavaScript is
incredibly non-declarative.

9
00:00:30.870 --> 00:00:32.497
Doesn't matter where,

10
00:00:32.497 --> 00:00:37.538
if your output of your code in UI is
physical element or not physical, right?

11
00:00:37.538 --> 00:00:42.111
Your elements on this green in
an order you would perhaps imagine,

12
00:00:42.111 --> 00:00:47.920
hopefully, that your code would look
somewhat shaped like what shows up.

13
00:00:47.920 --> 00:00:51.586
If you're adding an element here,
here, and here,

14
00:00:51.586 --> 00:00:55.550
the display will display
them in that order.

15
00:00:55.550 --> 00:00:59.872
If you're thinking about declaring,
I want these elements in this order,

16
00:00:59.872 --> 00:01:03.518
what's the most intuitive way
of doing that was HTML's listing

17
00:01:03.518 --> 00:01:06.010
them down in that order down the page.

18
00:01:06.010 --> 00:01:11.979
That is what declaring, that is what
descriptive code would look like for

19
00:01:11.979 --> 00:01:16.340
producing the output,
not of data but of pixels.

20
00:01:16.340 --> 00:01:18.230
Pixels are a visual structure.

21
00:01:18.230 --> 00:01:22.609
Therefore, the declarative style of
UI engineering would be a visual,

22
00:01:22.609 --> 00:01:27.660
somewhat, representation in our code
of what's to show up on the page.

23
00:01:27.660 --> 00:01:29.813
Well, JavaScript does not give us that,

24
00:01:29.813 --> 00:01:32.344
by default we're going
to give ourselves that.

25
00:01:32.344 --> 00:01:35.864
But it's gonna require some
significant optimizations, diffing,

26
00:01:35.864 --> 00:01:38.340
reconciliation to even be performative.

27
00:01:38.340 --> 00:01:46.645
Slash also, it is what enables us to have
performative declarative code in UI.

28
00:01:46.645 --> 00:01:51.542
Because having it, we're gonna see
interstitial, and intermediary, and

29
00:01:51.542 --> 00:01:56.527
intermediate, I don't know, none of
them quite work, version of our page.

30
00:01:56.527 --> 00:02:01.086
Will allow us to maybe archive
the last version based on

31
00:02:01.086 --> 00:02:07.050
the previous data from the user and
maybe compare those two.

32
00:02:07.050 --> 00:02:12.601
In JavaScript, work out the actual
differences, and then pinpoint change,

33
00:02:12.601 --> 00:02:18.590
the real list of elements in C++ that
will actually change what the user sees.

34
00:02:18.590 --> 00:02:23.803
So we both get the benefit of a visual
representation in JavaScript of what's

35
00:02:23.803 --> 00:02:29.030
gonna show up, just for our ability as
engineers to be able to compose our UI.

36
00:02:29.030 --> 00:02:31.066
That means move pieces around and

37
00:02:31.066 --> 00:02:35.650
move little units of view around in
our JavaScript to appear on the page.

38
00:02:35.650 --> 00:02:40.256
And we're going to from that optimize
our performance to save ourselves

39
00:02:40.256 --> 00:02:43.210
making unnecessary
changes to the real page.

