WEBVTT

1
00:00:00.040 --> 00:00:01.750
All right, we have our content displayed.

2
00:00:01.750 --> 00:00:03.580
Now it's time for user action.

3
00:00:03.580 --> 00:00:07.213
It's not a closed system,
it's a system where users can come in and

4
00:00:07.213 --> 00:00:10.410
cause events to happen in
response to their action.

5
00:00:10.410 --> 00:00:11.560
What is the use of action here?

6
00:00:11.560 --> 00:00:15.243
We're gonna keep it pretty simple,
and it's a user's gonna type.

7
00:00:15.243 --> 00:00:20.534
I think they're gonna have
to type will unfortunately,

8
00:00:20.534 --> 00:00:26.594
type will, and there it is,
will shows, it's extraordinary,

9
00:00:26.594 --> 00:00:32.010
it's so happy to paint my fingers but
not the whiteboard.

10
00:00:32.010 --> 00:00:36.574
There it is, and Will will go

11
00:00:36.574 --> 00:00:41.830
into the value automatically.

12
00:00:41.830 --> 00:00:43.880
I think our friend online
was almost implying that.

13
00:00:43.880 --> 00:00:45.524
Like, hold on, it's already
automatically there, fantastic.

14
00:00:45.524 --> 00:00:46.707
Thank goodness it is.

15
00:00:46.707 --> 00:00:52.020
So, 2 is an event saying please go and
execute handle input.

16
00:00:52.020 --> 00:00:55.712
And that's what we go and do,
we go and execute handle input.

17
00:00:55.712 --> 00:00:57.630
Data to view is off the call stack.

18
00:00:57.630 --> 00:01:01.800
So, call stack is gonna
have executed on it.

19
00:01:01.800 --> 00:01:07.095
Well, actually, Matric,
can you tell me what's gonna happen from

20
00:01:07.095 --> 00:01:13.050
our handleInput function is gonna be
added to what and what and executed how?

21
00:01:13.050 --> 00:01:13.622
Tell me what's gonna happen.

22
00:01:13.622 --> 00:01:16.580
&gt;&gt; Is it assigned to callback queue first,
right?

23
00:01:16.580 --> 00:01:17.186
&gt;&gt; Yes.

24
00:01:17.186 --> 00:01:20.780
&gt;&gt; And then the message loop
is gonna put it to call stack.

25
00:01:20.780 --> 00:01:22.450
&gt;&gt; Yes, perfect.

26
00:01:22.450 --> 00:01:27.370
And that's where now handle
input will be executed.

27
00:01:27.370 --> 00:01:31.580
We don't add porins, instead,
we rely on JavaScript doing so.

28
00:01:31.580 --> 00:01:35.860
There it is and
it gets to create a brand new what Metric?

29
00:01:37.760 --> 00:01:39.710
&gt;&gt; Would be assigned to the point.

30
00:01:41.370 --> 00:01:42.680
&gt;&gt; We're gonna execute.

31
00:01:42.680 --> 00:01:45.120
&gt;&gt; It's gonna execute handle input, right?

32
00:01:45.120 --> 00:01:48.420
&gt;&gt; Execute handle input,
create a new, everyone together.

33
00:01:48.420 --> 00:01:50.930
Execution context, fantastic, exactly.

34
00:01:50.930 --> 00:01:53.096
We've got some code to run.

35
00:01:53.096 --> 00:01:55.600
&gt;&gt; [LAUGH]
&gt;&gt; It's got some code to run.

36
00:01:55.600 --> 00:01:58.940
So we're gonna create a new
execution context for it.

37
00:01:58.940 --> 00:02:01.070
And there it is, running handle input.

38
00:02:01.070 --> 00:02:04.308
It's a very small one though,
because all it's gonna do is change data,

39
00:02:04.308 --> 00:02:06.890
that's the only thing we
can do is change data.

40
00:02:06.890 --> 00:02:11.286
And the data we're gonna
change is the value of post,

41
00:02:11.286 --> 00:02:16.366
which we're going to assign to
the result of getting the value

42
00:02:16.366 --> 00:02:21.055
that was just inserted by the user,
the string will, and

43
00:02:21.055 --> 00:02:26.600
then assigning that to post,
beautiful, there it is.

44
00:02:26.600 --> 00:02:29.050
As a JavaScript string, the string Will.

45
00:02:29.050 --> 00:02:30.940
Forgive me for using my name,
but I hope it's not so bad.

46
00:02:30.940 --> 00:02:34.673
We'll be using that to then remove,
or not remove, but implicitly,

47
00:02:34.673 --> 00:02:37.440
we're not gonna display
some of the results.

48
00:02:37.440 --> 00:02:42.357
So it's hopefully not something
to self-congratulatory,

49
00:02:42.357 --> 00:02:45.090
it's rather the opposite.

50
00:02:45.090 --> 00:02:49.797
So there it is, data change done, and
how nice that we know our data changes

51
00:02:49.797 --> 00:02:52.960
happening in one handler function,
beautiful.

52
00:02:52.960 --> 00:02:56.500
Not lots of different things up
displaying content just changing data.

53
00:02:56.500 --> 00:03:02.056
It's not a truth, it's a move,
is an effort, it's at a tactic to make our

54
00:03:02.056 --> 00:03:07.636
lives easier to reason about this
complex state, and view relationship.

55
00:03:07.636 --> 00:03:14.750
And so now, we move to queue,
we move to automatically.

56
00:03:14.750 --> 00:03:16.670
Well, this is off the call stack.

57
00:03:16.670 --> 00:03:21.091
And we know that what's gonna happen is
our data to view function is going to

58
00:03:21.091 --> 00:03:26.370
execute because it does love to execute
every bloody, sorry, I didn't just swear.

59
00:03:26.370 --> 00:03:30.900
Sorry, every few moments, every 15
milliseconds, do I add the parens, Phil?

60
00:03:32.390 --> 00:03:33.840
&gt;&gt; Not yourself.

61
00:03:33.840 --> 00:03:38.180
&gt;&gt; No, exactly, JavaScript's gonna
add data to view to the call stack.

62
00:03:38.180 --> 00:03:40.320
I'm just gonna do D to V.

63
00:03:40.320 --> 00:03:42.840
So the call stack, there it is.

64
00:03:42.840 --> 00:03:46.060
It creates everyone together a brand new.

65
00:03:46.060 --> 00:03:47.340
&gt;&gt; Execution context.

66
00:03:47.340 --> 00:03:48.899
&gt;&gt; Beautiful, and so

67
00:03:48.899 --> 00:03:55.100
we're now gonna convert our data to
our view based on this new data.

68
00:03:55.100 --> 00:03:58.642
And this data is not just gonna
change the contents of our boxes,

69
00:03:58.642 --> 00:04:01.540
it's actually gonna switch
out one of those boxes.

70
00:04:01.540 --> 00:04:03.840
It's gonna not even create it.

71
00:04:03.840 --> 00:04:07.986
Okay, let's do it, let's dive into it.

72
00:04:07.986 --> 00:04:12.521
Alexa, if you don't mind doing it again,
now that new setup, our new state,

73
00:04:12.521 --> 00:04:13.840
what are we creating?

74
00:04:13.840 --> 00:04:16.520
And we are gonna create these
from scratch are, aren't we?

75
00:04:16.520 --> 00:04:19.510
Yes, so tell me what's gonna
be reassigned to JS input?

76
00:04:19.510 --> 00:04:22.560
&gt;&gt; Yes, we're gonna create a brand new.

77
00:04:22.560 --> 00:04:25.450
&gt;&gt; Yeah.
&gt;&gt; JavaScript object with create element.

78
00:04:25.450 --> 00:04:27.620
&gt;&gt; Let's do the first one, exactly.

79
00:04:27.620 --> 00:04:31.820
Just input is gonna be reassigned
to a brand new created.

80
00:04:31.820 --> 00:04:36.464
Talk over me, like so if you don't mind
&gt;&gt; Yeah, so we're gonna use that

81
00:04:36.464 --> 00:04:41.330
create element method on the document
object to create a new unattached input.

82
00:04:41.330 --> 00:04:43.820
&gt;&gt; Perfect, brilliant.

83
00:04:43.820 --> 00:04:47.679
Brilliant, everyone get that what
Alexa said they're a new unattached

84
00:04:47.679 --> 00:04:48.570
input element.

85
00:04:48.570 --> 00:04:50.900
&gt;&gt; It's just floating around in there.

86
00:04:50.900 --> 00:04:56.531
&gt;&gt; Okay, yeah, exactly, there it is.

87
00:04:56.531 --> 00:04:58.120
Look at that lovely pen.

88
00:04:58.120 --> 00:05:02.160
Very happy and,
that was a Bob Ross reference, wasn't it?

89
00:05:02.160 --> 00:05:05.490
Very happy pen here, and?

90
00:05:05.490 --> 00:05:08.219
&gt;&gt; So we're reassigning JS input,

91
00:05:08.219 --> 00:05:13.676
we're gonna get that new JavaScript
object that has all the same,

92
00:05:13.676 --> 00:05:19.760
getter setters on it but our hidden
link because we are reassigning it.

93
00:05:19.760 --> 00:05:25.994
&gt;&gt; Do we remove this one, I think just for
the first one we're going to,

94
00:05:25.994 --> 00:05:30.941
so we truly know that it's
lost its JavaScript label,

95
00:05:30.941 --> 00:05:35.995
this input element here,
because we are reassigning to

96
00:05:35.995 --> 00:05:41.790
a brand new object as the output
of this create element call.

97
00:05:41.790 --> 00:05:46.704
Not the document I never fall for the trap
of document.createelement is going to

98
00:05:46.704 --> 00:05:50.040
return out to an object,
as you said rightly, Alexa.

99
00:05:51.240 --> 00:05:53.290
So there we go.

100
00:05:53.290 --> 00:05:57.332
I hope the camera pans down to my pen
experts who needs to be acknowledged for

101
00:05:57.332 --> 00:05:59.320
the hard work that they're doing.

102
00:05:59.320 --> 00:06:04.382
So that is a brand new object
linking to as you rightly said,

103
00:06:04.382 --> 00:06:08.841
Alexa, a brand new C++
instance of the input class

104
00:06:08.841 --> 00:06:12.300
in C++ an object and it's a link to it.

105
00:06:13.470 --> 00:06:16.990
There it is, and
it has all of the relevant functions.

106
00:06:16.990 --> 00:06:22.480
It looks exactly the same as before,
but it is a new one attached to, dear.

107
00:06:22.480 --> 00:06:23.840
That's I don't even know that is.

108
00:06:23.840 --> 00:06:29.606
It is a new one attached to, it was
actually wrong it's on input isn't it,

109
00:06:29.606 --> 00:06:34.654
it's a new one that's attached
to our underlying input object.

110
00:06:34.654 --> 00:06:40.201
There it is, okay, and
then the same for jazz div,

111
00:06:40.201 --> 00:06:45.110
we declare but not,
what am I talking about?

112
00:06:45.110 --> 00:06:47.270
So you never take it for granted?

113
00:06:47.270 --> 00:06:48.810
What is gonna happen here?

114
00:06:48.810 --> 00:06:54.720
Why will you tell me what's gonna
be assigned here to JS div?

115
00:06:54.720 --> 00:06:58.560
&gt;&gt; Yeah, so online five first we're
gonna execute the ternary statement.

116
00:06:58.560 --> 00:07:00.610
&gt;&gt; Beautiful.
&gt;&gt; We're gonna check the value of

117
00:07:00.610 --> 00:07:02.264
post which currently is Will.

118
00:07:02.264 --> 00:07:04.680
&gt;&gt; It is well, is it true?

119
00:07:04.680 --> 00:07:05.700
Yes, it is.

120
00:07:05.700 --> 00:07:07.580
So what do we assign to jazz div?

121
00:07:07.580 --> 00:07:11.321
&gt;&gt; As a result we're not creating accessor
objects we're not creating a new node

122
00:07:11.321 --> 00:07:14.510
we're creating an empty or
reassigning JS div to an empty string.

123
00:07:14.510 --> 00:07:15.890
&gt;&gt; Fantastic.

124
00:07:15.890 --> 00:07:20.060
Okay, then we're gonna add a handler.

125
00:07:20.060 --> 00:07:23.459
It's the same handler but function but

126
00:07:23.459 --> 00:07:27.785
we're re adding it here as
our handler with handle

127
00:07:27.785 --> 00:07:32.729
input being attached to
the input handler property, and

128
00:07:32.729 --> 00:07:37.950
this is what we've just done
there in line ten, I guess.

129
00:07:37.950 --> 00:07:43.281
Use the oninput setter on
the jsinput newly linked accessor

130
00:07:43.281 --> 00:07:49.470
object to the new input DOM element
to which we attach a handle input.

131
00:07:50.480 --> 00:07:52.510
Function as its input handler.

132
00:07:52.510 --> 00:07:53.980
By the way,
we can call that function anything.

133
00:07:53.980 --> 00:07:58.392
We can call it y, as long as
it's the function that then gets

134
00:07:58.392 --> 00:08:03.720
assigned to the input handler
using the input setter, beautiful.

135
00:08:03.720 --> 00:08:09.317
And now, we're going to go ahead and,

136
00:08:09.317 --> 00:08:16.451
we're gonna go ahead and
run in line 12, what?

137
00:08:16.451 --> 00:08:17.734
Let's have y again.

138
00:08:19.597 --> 00:08:22.270
&gt;&gt; Yeah, we're going to look up.

139
00:08:22.270 --> 00:08:26.418
We're going to call the replace method
on the body object which is itself

140
00:08:26.418 --> 00:08:27.516
a property of the.

141
00:08:27.516 --> 00:08:30.350
&gt;&gt; Right, let me just write this out,
forgive me, one second.

142
00:08:30.350 --> 00:08:33.864
So, we're going to say, sorry again,
say it was perfect what you were saying,

143
00:08:33.864 --> 00:08:36.359
I just wasn't listening,
I was thinking about my pens.

144
00:08:36.359 --> 00:08:39.085
&gt;&gt; [LAUGH]
&gt;&gt; Very fair.

145
00:08:39.085 --> 00:08:44.305
We're going to call the replace
children method on the body object,

146
00:08:44.305 --> 00:08:48.720
which is itself a property of
the document global object.

147
00:08:49.820 --> 00:08:51.760
Then it's slightly different this time.

148
00:08:51.760 --> 00:08:52.870
&gt;&gt; Right.

149
00:08:52.870 --> 00:08:53.790
&gt;&gt; Shall I go into that?

150
00:08:53.790 --> 00:08:54.840
&gt;&gt; Yeah, go for it please.

151
00:08:54.840 --> 00:08:55.570
&gt;&gt; Yeah, yeah.

152
00:08:55.570 --> 00:08:59.929
&gt;&gt; Of the two arguments,
the first, JS input,

153
00:08:59.929 --> 00:09:03.960
is very similar to the previous element.

154
00:09:03.960 --> 00:09:04.710
&gt;&gt; Very similar.

155
00:09:04.710 --> 00:09:07.230
&gt;&gt; Attaching it to the DOM.

156
00:09:07.230 --> 00:09:10.627
The second argument, however, JS div,
is currently just an empty string.

157
00:09:10.627 --> 00:09:13.190
&gt;&gt; Perfect, so
that'll be essentially ignored.

158
00:09:13.190 --> 00:09:18.548
And we end up with, note by the way,
here's another case where

159
00:09:18.548 --> 00:09:24.670
that JS div setting text content,
I skipped over it knowing it won't break.

160
00:09:24.670 --> 00:09:29.561
Paul raised this earlier knowing it won't
break, would I in practice actually

161
00:09:29.561 --> 00:09:33.503
determine that it's better to say,
if Js div is not an element,

162
00:09:33.503 --> 00:09:38.390
then don't try and add content to it,
but in this case it doesn't break.

163
00:09:38.390 --> 00:09:41.920
And my purpose is to try and
keep things as minimal as possible.

164
00:09:41.920 --> 00:09:44.280
And so, yeah, same thing here.

165
00:09:44.280 --> 00:09:48.753
Our Js input, js div, js div and
empty string acts as ignore this element,

166
00:09:48.753 --> 00:09:50.230
don't append it.

167
00:09:50.230 --> 00:09:54.200
And so why, what is the element
that gets appended to our page?

168
00:09:54.200 --> 00:09:55.980
&gt;&gt; Just the input element.

169
00:09:55.980 --> 00:09:57.680
&gt;&gt; Just the new input element.

170
00:09:57.680 --> 00:10:03.060
And these two get unappended.

171
00:10:03.060 --> 00:10:08.300
And we get instead a link
to our new input which we

172
00:10:08.300 --> 00:10:13.520
set the did I forget to
set the value of it?

173
00:10:13.520 --> 00:10:19.120
After we checked the conditional I
forgot to update my value of JS input.

174
00:10:19.120 --> 00:10:22.454
Let me do that,
what was the value set, y2?

175
00:10:22.454 --> 00:10:23.860
&gt;&gt; It was the string Will.

176
00:10:23.860 --> 00:10:24.740
&gt;&gt; Yeah, thank you.

177
00:10:24.740 --> 00:10:29.187
And it's in white because it is

178
00:10:29.187 --> 00:10:34.220
coming from JavaScript data.

179
00:10:34.220 --> 00:10:40.798
And it's set, therefore,
we are going to remove this element,

180
00:10:40.798 --> 00:10:46.666
and a whole brand new element
is being appended with Will.

181
00:10:46.666 --> 00:10:52.263
And the user won't even notice
a difference as long as we set for

182
00:10:52.263 --> 00:10:57.755
that element to be refocused on
via the JSinput.focus method

183
00:10:57.755 --> 00:11:02.840
that ensures the user's cursor
jumps straight into it.

184
00:11:02.840 --> 00:11:06.810
So that as they're writing,
they're not like I wrote a letter.

185
00:11:06.810 --> 00:11:08.998
I mean, we didn't get to it's
550 milliseconds too fast, and

186
00:11:08.998 --> 00:11:11.250
it will bounce out if we
didn't write anything.

187
00:11:11.250 --> 00:11:13.525
Now that's because in reality,

188
00:11:13.525 --> 00:11:19.307
we are rebuilding our entire model of the
page here, based off our underlying data.

189
00:11:19.307 --> 00:11:24.671
And that is incredibly nice for us as
developers to be able to say everything

190
00:11:24.671 --> 00:11:30.050
the user sees is gonna be defined in
relationship to some underlying data.

191
00:11:30.050 --> 00:11:32.634
And we're not gonna say if
the data changes this way,

192
00:11:32.634 --> 00:11:37.010
if there were already elements only
remove them under this condition, nope.

193
00:11:37.010 --> 00:11:41.692
Everything will be one to one data
generates the exact elements exactly as

194
00:11:41.692 --> 00:11:43.663
user sees them from that data.

195
00:11:43.663 --> 00:11:48.754
And then user action can only affect
what you see via changing that data,

196
00:11:48.754 --> 00:11:53.846
so you wanna keep that function one to
one it better handle the creation of

197
00:11:53.846 --> 00:11:59.356
elements on the very first time, and
the later edit of them, not by changing or

198
00:11:59.356 --> 00:12:06.180
removing them, but just by saying, do it
again, conditional on the underlying data.

199
00:12:06.180 --> 00:12:10.724
Problem with that, and we're already
seeing a preview of it, is while it

200
00:12:10.724 --> 00:12:15.440
gives us a full picture of what is gonna
be displayed, a list of elements in.

201
00:12:15.440 --> 00:12:20.248
Sorry while it gives us a full picture of
what's gonna be displayed from our data

202
00:12:20.248 --> 00:12:24.266
in JavaScript, which we could even
use to draw out in JavaScript,

203
00:12:24.266 --> 00:12:28.780
[COUGH] draw out in JavaScript elements
before they appear on the DOM.

204
00:12:28.780 --> 00:12:33.803
The downside of it is, hold on,
we are recreating elements on the DOM,

205
00:12:33.803 --> 00:12:37.571
we could have 1000 of them,
are we really going to

206
00:12:37.571 --> 00:12:42.430
have that on every single time
a minor detail and data changes?

207
00:12:42.430 --> 00:12:46.200
So, if we hadn't by the way,
had Will here and

208
00:12:46.200 --> 00:12:51.228
we'd had let's say Wyat or
John we said, or Alexa, or Phil or

209
00:12:51.228 --> 00:12:56.030
whatever then we would still
have had our div created.

210
00:12:56.030 --> 00:13:00.260
JS div is going to be the result of
first checking your posts as well.

211
00:13:00.260 --> 00:13:05.545
If it is, don't even create
an element as we perfectly got here

212
00:13:05.545 --> 00:13:11.645
from why don't create an accessor instead,
just create empty string.

213
00:13:11.645 --> 00:13:18.523
If we did get a post of, let's say, value
John, then as Alexa was saying earlier,

214
00:13:18.523 --> 00:13:24.246
we would create an element unattached
in the C++ list of elements.

215
00:13:24.246 --> 00:13:29.302
And we would then assign an object
accessing it with a hidden property

216
00:13:29.302 --> 00:13:34.619
into JSdiv, into which we would then
add the text, or with which we would

217
00:13:34.619 --> 00:13:40.930
then add the text to the DOM element,
the text being, let's say, John.

218
00:13:40.930 --> 00:13:45.060
All right, everything you see is now
dependent on underlying data and

219
00:13:45.060 --> 00:13:49.510
it is funneled through one function,
what is that function known as?

220
00:13:49.510 --> 00:13:56.509
It's a component, it describes in full,
only took us x number of hours.

221
00:13:56.509 --> 00:14:01.245
To get to a full UI component
describing in full underlying data, and

222
00:14:01.245 --> 00:14:06.473
its appearance on the page under all
conditions of what that underlying data

223
00:14:06.473 --> 00:14:12.300
could be, under all conditions of what
their history of use interaction is.

224
00:14:12.300 --> 00:14:17.436
Because all user action ends
up becoming state, therefore,

225
00:14:17.436 --> 00:14:22.275
a function that describes
the translation of that state,

226
00:14:22.275 --> 00:14:28.122
that data to view is a full description
of the entire piece of content.

227
00:14:28.122 --> 00:14:31.259
Its underlying data all
possible conditions for

228
00:14:31.259 --> 00:14:35.083
what can be displayed are all
captured by the description of

229
00:14:35.083 --> 00:14:39.905
the relationship between that state
that data and what the user sees.

230
00:14:39.905 --> 00:14:44.757
Don't forget, it should also, and
must and does, attach the handler,

231
00:14:44.757 --> 00:14:47.416
there could be many of them in practice,

232
00:14:47.416 --> 00:14:52.525
that then passes back the user's action
as a submission to change that data.

233
00:14:53.645 --> 00:14:56.512
Where we have hopefully
reasoned through and designed,

234
00:14:56.512 --> 00:14:59.676
based on that data, whatever it is,
not what came before, but

235
00:14:59.676 --> 00:15:02.860
whatever that data is at that
moment display our content of it.

236
00:15:04.350 --> 00:15:09.093
All right, let's have thumbs on this
fully now all we've changed is add

237
00:15:09.093 --> 00:15:13.448
the creation of the elements as
well into this data view function,

238
00:15:13.448 --> 00:15:15.804
partially known as a UI component.

239
00:15:15.804 --> 00:15:18.610
I wanna see your thumbs, you lost me.

240
00:15:18.610 --> 00:15:23.203
Paul played me there, pulling like this,
like that, all right, very.

241
00:15:23.203 --> 00:15:25.390
&gt;&gt; [LAUGH]
&gt;&gt; It's okay, I wanna see clarifications.

242
00:15:25.390 --> 00:15:28.307
Alexa has got a clarification,
Ian's clear, Paul's clear,

243
00:15:28.307 --> 00:15:30.920
Wyatt's got a clarification,
Alexa, take it away.

244
00:15:30.920 --> 00:15:35.966
&gt;&gt; Small thing about replace children just
to clarify my understanding because I have

245
00:15:35.966 --> 00:15:41.240
never used C++ and I don't know the
details of how everything works in there.

246
00:15:41.240 --> 00:15:45.996
But when we do replace children and
we like unattach the previous

247
00:15:45.996 --> 00:15:50.400
elements from the body or
like remove the reference to it and

248
00:15:50.400 --> 00:15:54.893
because we no longer have
a JavaScript like pointer to them,

249
00:15:54.893 --> 00:15:59.810
immediately garbage collected,
we don't have a memory leak.

250
00:15:59.810 --> 00:16:04.520
&gt;&gt; Yes, well, I mean,
it's gonna depend on the engine

251
00:16:04.520 --> 00:16:09.140
design is gonna depend on
the engine design, okay.

252
00:16:09.140 --> 00:16:14.163
So I often brought up this tool that
I found, maybe people even used it,

253
00:16:14.163 --> 00:16:18.685
that Microsoft has that allows
you to look for any memory leaks,

254
00:16:18.685 --> 00:16:24.043
that is elements on the DOM that do not
have labels in JavaScript but are not,

255
00:16:24.043 --> 00:16:29.153
also not attached, meaning you can't
use traversal like searching for

256
00:16:29.153 --> 00:16:31.620
selectors to even retrieve them.

257
00:16:31.620 --> 00:16:35.173
They are only gonna be retrievable
by a label, but the label's gone,

258
00:16:35.173 --> 00:16:36.690
which would be a memory leak.

259
00:16:36.690 --> 00:16:41.907
That's elements that don't have any access
anywhere in our runtime from JavaScript,

260
00:16:41.907 --> 00:16:44.937
any access by us as
programmers ever again, and yet

261
00:16:44.937 --> 00:16:49.290
they're still left in C++,
that would be a memory leak.

262
00:16:49.290 --> 00:16:52.232
There is a tool from Microsoft that can
identify any of those that you might

263
00:16:52.232 --> 00:16:53.220
have missed.

264
00:16:53.220 --> 00:16:56.331
That makes me somewhat think there may be
scenarios where they could still sneak

265
00:16:56.331 --> 00:16:59.304
through but I don't know, that could
have just been the implementation for

266
00:16:59.304 --> 00:17:01.800
a given browser historically or
something like that.

267
00:17:01.800 --> 00:17:06.720
Because in practice, once they're replaced
here in a modern browser they will be

268
00:17:06.720 --> 00:17:08.650
cleaned up and removed.

269
00:17:08.650 --> 00:17:11.883
So maybe there's older browsers
where that's not the case but

270
00:17:11.883 --> 00:17:14.700
in this they would be exactly
as you say Alexa removed.

271
00:17:15.750 --> 00:17:19.446
Okay, folks, so we are now going to
function that fully creates element and

272
00:17:19.446 --> 00:17:22.070
relate to data or
view is known as a UI component.

273
00:17:22.070 --> 00:17:24.753
Given we said,
I really do like that phrasing,

274
00:17:24.753 --> 00:17:27.920
there are two things we're
doing with UI engineering.

275
00:17:27.920 --> 00:17:30.258
One, display content, well,
we're not gonna miss a chance, are we?

276
00:17:30.258 --> 00:17:32.346
One,
&gt;&gt; Display content.

277
00:17:32.346 --> 00:17:33.348
&gt;&gt; Two, let the user.

278
00:17:33.348 --> 00:17:34.118
&gt;&gt; Change the content.

279
00:17:34.118 --> 00:17:37.420
&gt;&gt; Yeah, change it, exactly,
change the content, exactly, change it.

280
00:17:37.420 --> 00:17:40.270
Well, change it, change the content
is wonderfully ambiguous.

281
00:17:40.270 --> 00:17:43.546
Record right to cuz in the real
world they're the same thing,

282
00:17:43.546 --> 00:17:48.450
content is what I see and it's its state,
its reality where it is it's changeable.

283
00:17:48.450 --> 00:17:51.357
State is the ability to then see that
these pixels in the universe and

284
00:17:51.357 --> 00:17:54.520
move them here, not in the computer
those are two separate things.

285
00:17:54.520 --> 00:17:58.250
However the more we can make
them the same the better.

286
00:17:58.250 --> 00:18:01.255
Particularly difficult in JavaScript
because data's in one and

287
00:18:01.255 --> 00:18:03.173
what you see is in another runtime C++.

288
00:18:03.173 --> 00:18:05.137
Function that fully creates elements and

289
00:18:05.137 --> 00:18:08.550
sets up that data to view relationship
that sounds pretty useful.

290
00:18:08.550 --> 00:18:12.890
If we want data to view our content to be
bound together it's called a UI component,

291
00:18:12.890 --> 00:18:17.416
combines everything into one function,
creates elements, sets that data content,

292
00:18:17.416 --> 00:18:21.461
attaches handles, and displays,
describes in full what the user will see.

293
00:18:21.461 --> 00:18:26.824
In how it relates to underlying data the
view and the data I would call the content

294
00:18:26.824 --> 00:18:31.386
that's not to say like the content
is the view of the data in a sense,

295
00:18:31.386 --> 00:18:35.789
ties Data View handles how user
can change the underlying data and

296
00:18:35.789 --> 00:18:41.349
therefore what they see because it also
reruns the update view with that new data.

297
00:18:41.349 --> 00:18:46.360
React, angular, views, felt, all built
out UI components are such a core part.

298
00:18:46.360 --> 00:18:51.430
Because what's even more awesome is once
you have one, you could have others.

299
00:18:51.430 --> 00:18:55.600
You could rerun this one if you
gave this a name like create input.

300
00:18:55.600 --> 00:19:00.080
I don't know what you call it, create
input preview, which is input preview.

301
00:19:00.080 --> 00:19:02.255
Then now, we'd even call it,
not even create,

302
00:19:02.255 --> 00:19:04.550
because it's not quite saying create.

303
00:19:04.550 --> 00:19:06.691
It's a description of the full
relationship between the data

304
00:19:06.691 --> 00:19:07.232
and the views.

305
00:19:07.232 --> 00:19:10.480
I don't wanna even call it input and
preview.

306
00:19:10.480 --> 00:19:13.206
You may wanna split them out into two,
but let's say we kept them as one,

307
00:19:13.206 --> 00:19:14.120
input preview.

308
00:19:14.120 --> 00:19:17.750
You could now run that 20 times and
have 20 input previews.

309
00:19:17.750 --> 00:19:20.837
Ours wouldn't quite work cuz we'd
globally saving them, in practice,

310
00:19:20.837 --> 00:19:22.550
we wouldn't globally save them.

311
00:19:22.550 --> 00:19:26.901
We'd keep them in here, that handler would
have access to them because the handle

312
00:19:26.901 --> 00:19:31.210
be defined inside and get via closure,
access to our credit elements.

313
00:19:31.210 --> 00:19:35.934
In order for us to keep our diagramming
simple, we've stored them in global, but

314
00:19:35.934 --> 00:19:40.620
in practice, we would probably store
them locally in this UI component.

315
00:19:40.620 --> 00:19:45.729
Encapsulating bundling up our full
end-to-end data to view creation and

316
00:19:45.729 --> 00:19:50.512
the relationship between the data and
the view, both from the user's

317
00:19:50.512 --> 00:19:54.750
action back to the data and
from the data to what the user sees.

