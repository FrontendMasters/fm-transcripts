[00:00:00]
>> When you're building for Gatsby by default, the way that Gatsby works is to put all of the pages, both server side rendered and client side rendered. So you start by building the site down to static files, so that if JavaScript is disabled, you can still load the page.

[00:00:18]
When the component hits the browser and rehydrates, it then like JavaScript fires, mounts the page builds a react version of it and you end up with a fully functional react app on top of this the static route. In client only rendering, what you end up with is you run into these situations where let's say, for example, you wanna build a search page.

[00:00:44]
So your search results page cannot exist without some kind of input from the user. It's completely impractical to try to guess all of the possible search combinations that could exist and build that ahead of time. So instead what we do is we wanna build what's called a client only route where there is no server side rendering step, we're instead gonna say hey Gatsby only, like, put this file out there so that all of the logic happens only when we get to the client.

[00:01:17]
So if you load this with JavaScript disabled, it's gonna be an empty page. So with that being said, what I wanna do is let's actually build ourselves a search component and the way I'm gonna do that is let's start by giving it a few styles. So we're going to do a search.module.CSS.

[00:01:36]
And this is because we're gonna have a search field search button and like a clear reset button. And I wanna make sure that those aren't just like gencon jank, we're gonna do a little bit of styling on it. So we'll have a form in that will make that display flex.

[00:01:53]
I am a big fan of display flex if you haven't already picked up on that. And we can go space between so that they kinda equally distributed across the page. We'll give them a gap of 1rem. For the search input, I want this to be font size of 1rem.

[00:02:12]
So a thing that is a little bit frustrating and a little bit confusing about inputs, is by default, they don't respect the document font size. So by doing this font size 1 rem, the font size in the input will actually be the same as the font size for the rest of the CSS.

[00:02:29]
And another little fun fact is if you've ever been on a website and you tap into like a search bar or to enter your email and the page zooms in. That's because the font is smaller than 16 pixels. So if you want to avoid your website zooming in when people touch your inputs on a browser, make the font bigger and it will stop doing that.

[00:02:49]
So this will prevent that from happening effectively. Then we're going to set padding, or 0.25 on the top and bottom so that it's got a little bit of breathing room and one on the left and right to give it some input like shape. Then we'll set the width to be 100%.

[00:03:09]
And I want that to basically occupy all the available space that the buttons aren't using. Then for the buttons, we're gonna do a font size of 1 rem, and we'll do, just the the same padding. So let's do 0.25 and 1. And I think that's good enough, right?

[00:03:30]
So then let's go in and let's make our first page. So the way that Gatsby works is we looked at these file based routes here. Gatsby also supports something called dynamic routes. So if we create, let's say, like a search folder And in this, I wanted to make everything that hits that search route hit like the same component.

[00:04:00]
We can do what's called a catch all, which is the brackets and three dots and then dot js. This is very cool, it's very helpful and it gives us the ability to say if you hit search, go ahead and just bring everything at this sub route into this page and we'll do stuff with it on the client side.

[00:04:23]
So in here we are going to write a react component as usual import react from react. And then I also wanna get the navigate library out of Gatsby. And what this navigate library does is it lets us do programmatic. So the same thing that link does, where when you click it, it takes you to another page and all those things, navigate lets us do that but programmatically.

[00:04:48]
Then I'm gonna get my style, so my form, my input and my button. And I don't know why it came out of that. Let's get it out of styles, got to go up another level, cuz we're in the search folder here we're gonna get styles and search.module.CSS. Then we can export default function, we'll call it search client only and this gives us params.

[00:05:18]
So what params is, is whatever is in the URL, and it gets broken up by slashes, so if we have one thing, it'll show us like a little well, let's just look at it. And actually it's easier to show than to explain. So what we'll do is we'll get query.

[00:05:38]
Actually, let's start by just doing this let's console.log params. And then let's make it visual, let's do return pre JSON stringify params. Okay, so this will give us the ability to hit anything in the search. So let's look, we got started, let's start the server. Now that this has started, when we look at the search, we can see that because we used to catch all route, it gives us this star.

[00:06:18]
And that star is like everything that's in here. And so we can put whatever we want in here, some more stuff. And it'll just feed us that path, whatever we put in here. And so if we were to do something like our search query we wanted to search for, I don't know, the hobbit.

[00:06:38]
It just gives us the search text right there. So we can actually build a search form like that and it's all coming right through the page. So let's do that, let's build ourselves a search form. So what I'm gonna do is I want to in here, get our query.

[00:06:54]
And that'll be, we're gonna decode the URL components. We don't want any like percent 20s or things like that. We will get whatever comes out of params star. And then we want to use some react stuff. So we're gonna store the current query and then we'll have the ability to set the current query.

[00:07:16]
And that's gonna be react use state. And we'll start with the whatever the query is, then we're gonna keep our results. So we're gonna do a search, we wanna hold on to the search result. So have the ability to set the results and that's going to be in react, use state.

[00:07:38]
And we'll set that to null by default. And then we want to do a status and set status. And this I hope that David Khurshid who wrote x date is not watching because he's gonna send me angry email, but I'm gonna use a kind of a. Status flag, like what are we doing?

[00:08:04]
So then in here, I'm going to add a couple functions. So the first one is we wanna be able to handle the search. And so when we get a search, we're gonna get, it's gonna be as form submission. And so the first thing that we wanna do is prevent that form from actually submitting.

[00:08:20]
We instead want to grab that here, so we're gonna prevent default. That'll prevent the form from actually submitting in one set, let us deal with it. Then I wanna get the form data, which will be using the built in browser form data API. If you've never used this, this is something that when I learned about it, as soon as Hinton pointed it out to me, I felt like a dang superhero I had been doing this the hard way prior to this and wow, is this easier.

[00:08:53]
So I can actually just get whatever the name of the field is. So if I've got my field down here, let's set these up so we can kinda look at what happens. If I've got a form and the way that form is gonna work, I'm not gonna fully mark it up yet, but if we've got an Input of a type search and we give it a name of search.

[00:09:16]
Then what I can do up here is do a form.getsearchand I'll get whatever the value of this is. It's so easy, It's built into the browser. Yeah, form management has really used to scare me and now I know I don't mind it, I kinda like it. Then once we've got that we can set the current query to be whatever the query is.

[00:09:44]
And then I'm also going to navigate the browser I wanna send this to search and we will encode the URL component for queries so that we don't have any, if there's URL characters or any special characters in the string, it won't break our URL. And once we've navigated, that'll be the end of how we handle our search.

[00:10:11]
So, the other thing that we wanna handle is just a reset. So let's create a function called handle search reset. That is going to just set the current query to nothing, make it blank. And then we'll navigate back to search. Okay, so that's that function. And the last one I'm not gonna write just yet.

[00:10:39]
Let's stub it out though. So it's gonna be a function called Book Search. It's gonna take a query. And that one is going to, Look up a book. So the other thing that we're gonna do is we want to watch for whenever the current query changes. So we're gonna use effect for that.

[00:11:08]
And the way that use effect works is we pass in an array of what we wanna track. So we're gonna pass in current query. And then we can do stuff whenever the current query happens. So what I wanna do is if the current query is empty. We're just gonna set the result to know and we'll just return will be done.

[00:11:32]
There's nothing else that we wanna do there. Otherwise if the current query is not empty, we're gonna run this Book Search and and pass it in. So this is what's actually gonna run our search, whenever we update the current query here, this will cause the search to run.

[00:11:54]
And then in here is where we'll set the result so that we can show it on the screen. So let's build out our basic form, so let's tell people where they are, we'll say, search for a book. And then in our form. So our form is gonna have a class name of form and on submit we're gonna run that handle search.

[00:12:23]
Inside of that we have the input and we'll give this a class name of input. Then we'll do a button. That button will have a class name of button. The text on it will be search. And that's really all that buttons gonna do. So let's duplicate that one.

[00:12:46]
And this one's gonna be different. This is gonna be a type reset button. And this will say, what's it gonna say? We'll call it reset. And then let's also give it an unclick. Of handling the surgery set. So effectively what we're doing here is we're saying, in this search form, let's look at what it looks like.

[00:13:11]
Form is not defined. What are they? There we go. So now we've got this search and so what a reset type is if I say some value If I reset it clears the form, right? And this is also built into a search form. So there's ways to do that.

[00:13:36]
And then what we should see here is we won't get any results yet but if I search, we should see it update. There it is. We get the hobbit up in the screen, in the search bar. So, pretty sweet, pretty helpful, very useful. And the next thing for us to do is to actually write this book query.

[00:13:56]
So let's do that. And the way that we're gonna do that is we're gonna use that open Library Search again. So the first thing I wanna do, is I'm gonna set the status of our document to loading. So this is kind of very bad state management. Then we're gonna do a response which will be a waiting, fetch and I'm going to Https, we wanna hit openlibrary.org.

[00:14:23]
We're gonna hit the search.jsonendpoint. And this works with just a queue and then whatever our query is, so we can pass in the query just like that. This is, let me make that a little bit bigger so we can actually see what's going on. So we're gonna fetch that, and then after we have fetched that we'll check down here if res is not okay.

[00:14:45]
So if something went wrong with the with the query, we will just throw a new error, because that would mean that something went wrong with the search and so it's okay to fail if that's the case. We probably want more graceful error handling we're not going for perfect.

[00:15:04]
We're going for learning today. Okay, so If we get past here, we know that we've got a good result. So let's get our results. It'll be await res Jason, because we know we're getting back Jason because we call the Jason endpoint. And then, we can set our results to result.

[00:15:27]
And we can set our status to idle. And so effectively what we've done now, is we've created a little poorly managed state machine, that will say kinda where things are, and down here, what we can do is we can start to respond to that in the UI a little bit.

[00:15:46]
So, what I'm gonna do is if our status is loading we wanna show something like loading. Results, right? And then if our status is idle and the current query is not, that's what I was trying to push, is not empty. Then we want to show results. Otherwise, we're just gonna show null.

[00:16:35]
So let's get these results shown here. We'll do an h2, say search results for, CurrentQuery and then down here, we'll just set them up as an unordered list. Make sure that we've got a result because it's always possible that it comes back empty. And then we'll go through the result.docs.

[00:17:00]
So what comes back from the search is metadata and then docs is the actual list of results. We can map those, get to doc, and inside here we can set up a li key. So doc.key is a, that's a unique field in there. And I don't wanna teach how the open library API works.

[00:17:31]
So I'm kinda just flying through what the fields are. What we could do is run this in the browser and look at the fields and then kind of reverse engineer it. But for the sake of not getting too lost in the weeds, I'm trying to make sure that we cover this as quickly as possible.

[00:17:50]
So we've got the strong tag here that's gonna show the title and I want that to be the doc.title. And then I'm gonna put in who the doc.author is if the author is set, so I'm gonna say doc.author_name, which is gonna be an array actually. Oddly enough, being singular, and then, so we'll say, doc.author_name and then I wanna optionally chain this because it might be set and still empty.

[00:18:23]
So just trying to guard against unexpected chaos here. So let's save that. And this should work, right? Let's give it a try. So, hey, look it's already doing it. So we've searched for the Hobbit. Let's search for another book. Ready Player One. There we go, we've got results.

[00:18:45]
Let's search for just one more. What's another book? I've only read two books, apparently. Another book that I've read that I liked was Zen and the Art of Motorcycle Maintenance. And there it is. So this is cool, right? And we can make this more useful. We could link to a doc page, we could figure out a way to hook this ISBM up to another page where we could get more information.

[00:19:16]
But I'm not worried about that, I just kinda wanna show how you would set up these client-only pages. And as you can see, this is not a particularly simple component but the nice thing about it is that everything that's happening in here with the exception of this navigate calls.

[00:19:34]
These are all being done as it's just React, the only Gatsby specific thing we're pulling in here is this navigate function and the fact that this file is named something funky to make Gatsby pick it up wherever. The other thing that's called up is this is also, it's URL navigable.

[00:19:56]
So if I visit a page, like I wanna come see the Hobbit, it'll load the Hobbit for me. So I didn't pull it out and put it in the in the query. So you could share a set of search results with somebody. And so this is nice, right?

[00:20:10]
It's kind of a stateful transfer of information if you store the query in the URL like that.

