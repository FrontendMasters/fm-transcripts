[00:00:00]
>> We are gonna build out some custom pages. So for the authors, we can do some pretty standard stuff. Now that we've got these authors, I wanna be able to use just the normal file based, like we're gonna use the author slug and we're gonna build a page.

[00:00:16]
So let's start there and because I didn't add a slug for the books, let's also add. A helper, called slugify, which will let us turn the titles of the books into URL slugs so that we can make pages out of them. So now that I've got this, I'm going to start well, let's create the page first.

[00:00:39]
So I'm going to create a new page in here, and we're gonna call this (Author slug).js. Now note, we're using curly braces here, and then a data type and the field we want to use as the path. This is a way to dynamically generate content based on the data in your graphQL layer.

[00:01:01]
So by creating this, what I'm able to do is Gatsby now will say, hi, I see a file for this author type, do we have authors? Do those authors have slug fields? If so, create one page for each author in this array. It's a really powerful flows, really, really nice.

[00:01:23]
And lets us get a whole bunch of stuff done very short order without having to dig into further Gatsby node API's. And then finally we're going to use this slagify. What did I import here? That is not what I wanted I wanted graphQL get slugify from slugify. Okay so first we're going to do a query and when you generate pages from a from a data type like this, the way that Gatsby will do it is it's going to run a query, it'll build a query that is just for the nodes, the ID and whatever field you used.

[00:02:06]
So it's going to generate this query for the ID in the slug. The ID and the slug will then get passed in the page context, which is to refresh your memory there, the page context is here. And anything that gets passed here is available to the page as the page context prop, and also it'll get set as a graphQL variable.

[00:02:33]
So I have the ability here, let's do AuthorPage. And this is going to give us a graphQL variable, which is the ID. And I don't remember what the type of the ID is so let's hover. And it's an ID type so I will say we need to get an ID.

[00:02:53]
And then I wanna get a single author. So let's start the server here actually. So that I can I can build this query in Gatsby instead of guessing at what things are. I think it's gonna yell about my author page that's created and not saved, but that's okay.

[00:03:20]
Let's get into the graphical, I'm going to copy paste my query here. All right, and then this is expecting a query variable which I can grab from down here. So we'll set an ID and our author ID we'll have to find one of those. So let's actually maybe start by running this query so that I can get, Here is an author ID.

[00:03:51]
So we'll get this stuff for n-k-jemisin. So here will be our ID, I'm going to set that value, and that's going to be the variable that's set by Gatsby. And then inside of this, I want to get an author and I want their ID to equal. ID, not equals why did it create that?

[00:04:23]
Okay, inside of that I can get their name and their slug and their books and see let's not filter on that, that's not what I wanted. So what I want, is I want their, start with their name. And then I want their books. For each book, I want the ID, I want the name, I want the series, and I want the series order, because we're going to on each author page, I wanna display their name and then a list of their books and if they are in a series I want to say like book one of the whatever series.

[00:04:59]
So this will be our query and this is what expecting type string okay let's do a string there we go. Okay, so it wants to string glad we checked it because that would have failed otherwise, right? Again, a reason that I really liked this flow of building the query in the browser, instead of trying to just write them by hand is you get to run them and make sure the data comes back the way you expect.

[00:05:24]
But here we go. So if I get an author with an ID of this string here generated by Gatsby, then I'm able to pull up their name and a list of their books. So let's copy this move into here. All right, and now when we build out our page, that page is going to have access to this data.

[00:05:48]
So let's do export default AuthorPage and that has the data and in our data we will have let's start with the basics. I guess we're gonna get the concert will be the author, and that'll be data.author. And then we'll have our books, which will be author.books. Okay and then we can return just do a regular old div.

[00:06:21]
I'm going to do the author name. And then before we try to do anything with the books just yet, let's just dump it and look at it. Okay, so this should put us in pretty good shape. Let's get out here and let's look at our 404 page. What don't you like?

[00:06:46]
Gotta call it a function if you're using a function. All right, so here is our list and you can see it generated a thing for each one. So let's jump in here and we've got a page, that page includes the book information. So how do we want to do linking?

[00:07:06]
Let's think about the way that we want our books to be linked. I like my URLs to be descriptive, so, if books are related to each other, I want them to tell me that right? So for a book like Dark Matter, it's not part of a series. So I would want the URL to be like slash book, slash dark matter.

[00:07:27]
But for one of these N.K. Jemisin books that are part of the series I would actually want that to be included in the URL. So I would want it to be slash books, or slash book slash, the Broken Earth Trilogy slash The Stones Sky. Like that's the way that I would want that to work so that I know in my head that I'm looking at a book that is part of a series and I can kind of group those just by looking at URLs and understand what I'm reading.

[00:07:54]
So that means we need to generate our URLs a little bit differently. And I also want to make sure that these show up in order like if, for whatever reason these got entered as book two went in first and then one and three I don't want that to show up on the site.

[00:08:06]
So I wanna sort them as well. So I'm going to create a little helper function here that we're going to call sortAndExtendBooks and that's gonna accept our books. And inside of it, we're going to return the books and we're just gonna do some some function stuff with it.

[00:08:26]
So let's do some chaining. We'll start by sorting and we'll get book a book b. And we're gonna return whether the a.series order is less than the b.series order. And I can't remember exactly how this works like you, you have to, I always have to try this both ways and then see what happens if you do a minus b goes ascending.

[00:08:54]
And if you go b minus a, it goes descending. Because it's basically if it's a positive value, it moves up in the list. And if it's a negative value it moves down in the list I think so it's I don't know that the sort is a little bit confusing, but effectively this will give us what we want it'll put it in series order.

[00:09:13]
Then, we're going to map across each book, and I want to extend each book. So I'm going to set up this function here, and inside of it, let's get the series first. So if there is a series, we wanna do some stuff. I want to just create some like display text for this.

[00:09:36]
So we'll say book.series and then we'll say like it's book number, book.seriesOrder. So this would be like the Broken Earth trilogy book one, book two, book three. Okay, that's good and then if we don't have that, I wanted to just be empty text. So we'll just leave it blank if you don't have a series.

[00:10:02]
So then, we can get a display name. And that display name is going to be the book name and the series. So if it's empty, it'll just be white space we don't care. If it does have a series and it'll be the name of the book, and then in parentheses the Broken Earth Trilogy book one.

[00:10:26]
Next, we're gonna set up the book slug and the book slug is going to use slugify and we just pass in the book.name. I want it to be lowercase. So this will, passing this option in just means that instead of being like capital T, the Broken Earth, it'll be the broken earth.

[00:10:46]
And it converts into a kebab case, which is kind of nice so it's what you would expect in a URL. Finally, we wanna actually build out the path but it's gonna be a different path based on whether or not we have a series or not. So let's start with saying if the book.series is not null, then I want to set the series slug, which will be the same general approach slugify book series.

[00:11:17]
And we'll set lower to true. And then down here we will set the path to be book and then we'll do series slug and book slug. Okay, so that's what we'll get if we have a book with a series. Now if we don't have a series, We will instead set the path to be just regular old book and then book slug.

[00:11:49]
All right, happy with that and then let's just return our modified books. So we're gonna put back all the regular book things, but then we'll add in the display name and the path as additional fields on our book. So that means that down here, we just want to change this out sort and extend books.

[00:12:14]
Okay, so if we save this, go figure out what I type owed I pluralized function somehow. There we go. All right, so now we can see that it's been extended each one of these now has a display name that is doing what we want. And it has a path that includes the series name and then the regular book name.

[00:12:35]
And if we go out to one that's not part of a series, we can see the display name is just the book name, and the path is book and the book name. And these are slugifies, and now, we can link to these. So let's update our output then to actually do that.

[00:12:51]
So instead of just dumping this, we're going to instead, we'll create a list and let's tag that will say books by author name. And inside of this, we'll do a books.map and for each book, we're going to output some JSX. Okay, so we're gonna do a list item that'll have a key of book that ID.

[00:13:30]
That's a guaranteed unique string in Gatsby so we can trust it to work. And I wanna bring in the link that's not coming in from Gatsby is it? All right, so let me import link. We've already got it. Import link from Gatsby and then we're going to link to the book.path and we're gonna show the book.displayname.

[00:13:54]
All right and finally, we'll just add a link at the bottom to head back to the homepage, or sorry, to head to an author's page. Which, this doesn't exist yet, we'll build this next. But, rather than having to come back in here and remembering to do it, let's just set it up now.

[00:14:12]
So do an arrow pointing left, this is an HTML entity, and then we'll go back to all authors. And if I save that, look at it go, we got ourselves a page. So if I come in here go to N.K. Jemisin here's a list of all those books and if I click to it, we can see that it's taking us to the right place.

[00:14:35]
But we haven't built those pages yet. So let's build out this author's page. And to do that, we're going to just do a plain old page, right? And this is what's nice about this is, we did all this work to create custom data. But now we can just build pages the way that we would normally build them, it's really nice.

[00:14:54]
So we're going to import everything as react from react, and then we'll get out graphql and we're going to need the link as well. We that helping is not helping is it From Gatsby, and we're going to export a const of query, that's gonna be a tagged graphql, Query, and this one doesn't need any variables.

[00:15:28]
So we could actually do this as a static query. But I don't know why I didn't I think I was just copy pasting thing. So we'll do it this way all author and inside of our author, we're going to get the nodes and we want their name and their slug.

[00:15:48]
So then we can export our component, which will be the default function called authors page. And that's gonna get some data, And let's pull out those authors there'll be data.allAuthor.nodes. We should make this simpler, why overcomplicate this? Let's cut out cognitive loops or cognitive overhead. So, instead, we're going to use static query.

[00:16:24]
And instead of having to pass things around in props, why don't we just get our data, right out of use static query, right? When you don't need to use the query, this makes more sense to me. It's like, hi, I want to use this query, here's the data that I want, give it to me.

[00:16:44]
And then we get our everything else stays the same. So functionally what we just did is identical but in terms of the the cognitive overhead of somebody reading this code, if they're not familiar with Gatsby, this doesn't require you to know that the query will get turned into data.

[00:16:58]
So unless you're using again, unless you're working with variables, it's usually easier to just do the the simple thing. So let's start by setting up a graphQL fragment because we don't have a JSX fragment instead, so that we don't end up with junky markup that we don't need.

[00:17:14]
So we'll do a listing of authors and then we'll do an unordered list and for each author We're going to return some stuff missing closing parentheses again, there we go. This is going to be a list item, it's gonna have a key of author.slug, that's a unique value that we can trust.

[00:17:39]
Then we can link to and we're going to make this author.slug, And we'll put in the author's name, author.name. All right, I think we've done it. What am I missing here? I'm missing a closing curly brace. Let's save it, let's look at it. All right, we now have our authors pulling in and we have a working website based on our custom data.

[00:18:21]
So that's great but we did throw ourselves a little bit of a curveball here because now when we look at our books, the books have different URL structure. So we can't just throw in like the book file thing. We're going to need to build these book links manually.

[00:18:38]
These pages are gonna have to get built manually. So let's do that.
>> So, calculating the slug locally each time can become repetitive is there a way to add that slug as a property in the graphQL tree using this page generation technique by using the naming trip, not Create Page hook?

[00:19:01]

>> 100%, yeah, we could have added another resolver in here. And so for example, the way we did a bi-link we could do a slug and just slugify the series and slugify the book name. Why I didn't do that? Great question. I don't know why I didn't do that.

[00:19:23]
It honestly is probably a better move because then we wouldn't have to calculate it in multiple places. So yeah, if I was gonna refactor this, that'd be a great place to refactor this code would be to just add a slug here, and then set that as a string and run slugify in this file instead of having to do it everywhere.

[00:19:45]
But, in the interest of not throwing myself too many curveballs because we got a lot to cover and I don't wanna run out of time. I'm going to not do that. So bear with me as we do some, a little bit of copy pasting around to make this work.

