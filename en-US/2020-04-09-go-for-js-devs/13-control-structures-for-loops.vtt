WEBVTT

1
00:00:00.100 --> 00:00:02.810
Next on the list,
we'll cover some details about for loops.

2
00:00:04.140 --> 00:00:06.360
And as we discussed at
the beginning of class,

3
00:00:06.360 --> 00:00:09.640
the loop that does not
exist is the do while.

4
00:00:09.640 --> 00:00:12.732
But there are some different
ways we can use for

5
00:00:12.732 --> 00:00:16.068
loops to do some dynamic
things within the logic.

6
00:00:16.068 --> 00:00:20.251
I am looking at the for.go file
in the basic syntax directory.

7
00:00:22.700 --> 00:00:29.280
Once again, I'll be uncommenting
the whole file and starting at the top.

8
00:00:29.280 --> 00:00:32.470
So our basic for loop is gonna
look super similar to JavaScript.

9
00:00:32.470 --> 00:00:36.210
And this is one of the only occasions
where you're gonna see semicolons hanging

10
00:00:36.210 --> 00:00:37.800
out in Go.

11
00:00:37.800 --> 00:00:41.854
And so if we have an integer,
assign it to a value of one.

12
00:00:41.854 --> 00:00:47.160
Bar i assigned to one, we have three
statements that instantiate a for loop.

13
00:00:47.160 --> 00:00:47.661
The first is.

14
00:00:49.192 --> 00:00:53.470
This one up here, we're setting
the initial value of i to one.

15
00:00:53.470 --> 00:00:55.930
And then we're saying hey,
keep going in this for

16
00:00:55.930 --> 00:01:00.760
loop until i reaches 100,
is less than or equal to 100.

17
00:01:00.760 --> 00:01:03.363
And then for every iteration
increment the variable by one.

18
00:01:07.265 --> 00:01:13.480
We wanna go ahead and run this code,
open up our terminal.

19
00:01:18.482 --> 00:01:23.300
We're gonna go run, we are in basic
syntax code and then our for loop.

20
00:01:24.900 --> 00:01:27.785
So when we run Go you'll see that our for

21
00:01:27.785 --> 00:01:31.553
loop has printed out all
of the integers to 100.

22
00:01:45.653 --> 00:01:52.000
Option two is we can actually kill both of
the statements to the left and the right.

23
00:01:52.000 --> 00:01:56.170
So on this top one, if we review
the conditionals in the middle, for

24
00:01:56.170 --> 00:01:59.200
if i is less than or equal to 100.

25
00:01:59.200 --> 00:02:01.670
In the second version here,
the behavior of this for

26
00:02:01.670 --> 00:02:03.710
loop will actually turn out
kind of like a while loop.

27
00:02:03.710 --> 00:02:07.140
So while i is less than or equal to 100,
do the stuff that's in the middle.

28
00:02:07.140 --> 00:02:09.895
So even though we don't actually have
a while loop syntax, we can make a for

29
00:02:09.895 --> 00:02:11.356
loop behave a little bit differently.

30
00:02:16.218 --> 00:02:17.135
Save and rerun.

31
00:02:23.373 --> 00:02:25.932
And then this last one here,
which is my favorite and

32
00:02:25.932 --> 00:02:29.142
a really powerful version of our for
loop uses the range keyword.

33
00:02:29.142 --> 00:02:32.480
And so on line 29 we have a sentence.

34
00:02:33.560 --> 00:02:35.925
It is assigned to the value
of this as a sentence.

35
00:02:35.925 --> 00:02:40.700
And then our for loop takes
a couple additional arguments here.

36
00:02:40.700 --> 00:02:44.880
So we're kind of circling back to that
structure that we saw with the if blocks,

37
00:02:44.880 --> 00:02:47.960
where we have a couple different
variables on the left.

38
00:02:47.960 --> 00:02:51.340
And then we have our shorthand
syntax with the colon equal sign.

39
00:02:51.340 --> 00:02:54.420
Which means that these variables
are getting assigned to whatever's on

40
00:02:54.420 --> 00:02:55.870
the right-hand side.

41
00:02:55.870 --> 00:02:58.018
So indexing letter is getting assigned
to the range keyword, which means,

42
00:02:58.018 --> 00:02:58.966
I'm gonna iterate over a thing.

43
00:02:58.966 --> 00:03:02.696
And then what are we iterating over?

44
00:03:02.696 --> 00:03:06.208
We're iterating over my sentence,
which is a string.

45
00:03:06.208 --> 00:03:09.170
So Go is allowing us to treat a string
kind of like a collection of things,

46
00:03:09.170 --> 00:03:10.230
like an array.

47
00:03:10.230 --> 00:03:13.343
And so we're iterating over every
element which is in this string,

48
00:03:13.343 --> 00:03:15.485
so we're iterating over
each of the letters.

49
00:03:15.485 --> 00:03:18.319
So once we're in the for loop here,

50
00:03:18.319 --> 00:03:23.330
I want to use the function print
line function to print index.

51
00:03:23.330 --> 00:03:24.946
And then that actual index value,
and then a letter.

52
00:03:24.946 --> 00:03:28.209
And then whatever thing we're
looking at within our sentence.

53
00:03:28.209 --> 00:03:30.700
I'm gonna save this and run it.

54
00:03:30.700 --> 00:03:34.943
I wanna call attention to some interesting
behavior that we're gonna see here.

55
00:03:34.943 --> 00:03:38.121
So we're iterating over the sentence.

56
00:03:38.121 --> 00:03:39.813
Our sentence is a series of letters,

57
00:03:39.813 --> 00:03:43.620
but you'll notice that the thing we're
printing out is actually two numbers.

58
00:03:43.620 --> 00:03:44.460
So on the left-hand side,

59
00:03:44.460 --> 00:03:47.590
we're seeing a series of integers that
increment, those are the index values.

60
00:03:47.590 --> 00:03:51.500
And then on the right-hand side, we're
actually seeing integers, not letters,

61
00:03:51.500 --> 00:03:52.230
which is surprising.

62
00:03:54.770 --> 00:03:55.840
So behind the scenes,

63
00:03:55.840 --> 00:03:58.960
similar to how when you're talking
about what from to print line returns.

64
00:03:58.960 --> 00:04:02.350
We're talking about bytes here, we're not
actually talking about the letter itself.

65
00:04:02.350 --> 00:04:06.190
And this is where type conversion
can come back and really handy.

66
00:04:06.190 --> 00:04:08.726
So if I actually do want
the string version of my letter.

67
00:04:13.218 --> 00:04:19.617
We can circle into this for loop here, and
then wrap our letter in the word string.

68
00:04:23.213 --> 00:04:24.967
Run this again.

69
00:04:24.967 --> 00:04:29.281
&gt;&gt; Think you need one more-
&gt;&gt; Thank you,

70
00:04:29.281 --> 00:04:31.935
I do need one more parentheses.

71
00:04:31.935 --> 00:04:35.280
So now you'll see that actually the more
expected behavior of the index on the left

72
00:04:35.280 --> 00:04:36.650
and then the letter on the right.

73
00:04:38.270 --> 00:04:40.300
Takeaways from this
particular structure though,

74
00:04:40.300 --> 00:04:42.190
is really to keep an eye
on that range keyword.

75
00:04:42.190 --> 00:04:44.820
Range indicates, okay,
we wanna iterate over something.

76
00:04:44.820 --> 00:04:46.800
I don't have a set number of conditionals.

77
00:04:46.800 --> 00:04:49.660
We're not working with a classic for
loop like this.

78
00:04:49.660 --> 00:04:52.117
I want to kind of for
each my way around a particular thing,

79
00:04:52.117 --> 00:04:53.432
in this case it's a sentence.

