WEBVTT

1
00:00:00.000 --> 00:00:03.484
&gt;&gt; Kyle Simpson: So there are corner
cases, we know that that's the reality,

2
00:00:03.484 --> 00:00:04.959
there were corner cases.

3
00:00:04.959 --> 00:00:09.334
We don't deal with corner cases in any
language but least of all, JavaScript,

4
00:00:09.334 --> 00:00:10.650
by simply avoiding it.

5
00:00:10.650 --> 00:00:15.931
You don't avoid the whole mechanism just
to get around a couple of corner cases.

6
00:00:17.448 --> 00:00:21.238
&gt;&gt; Kyle Simpson: You have to adopt
a coding style that makes your types and

7
00:00:21.238 --> 00:00:24.867
the values that are in those
types plain and obvious,

8
00:00:24.867 --> 00:00:27.789
that's the only effective way to do this.

9
00:00:27.789 --> 00:00:30.025
Some people goes so
far as to used whole type systems, and

10
00:00:30.025 --> 00:00:32.649
we'll get into that a little bit
later like TypeScript and stuff.

11
00:00:32.649 --> 00:00:37.269
I don't think you have to go that far but
you can adopt a coding style which makes

12
00:00:37.269 --> 00:00:40.640
the kinds of types that you're
doing much more obvious.

13
00:00:40.640 --> 00:00:45.201
I make the claim that a quality
JavaScript program is going to have to

14
00:00:45.201 --> 00:00:46.569
embrace coercion.

15
00:00:46.569 --> 00:00:49.900
You have to make sure that the types
involved in every operation are clear.

16
00:00:49.900 --> 00:00:53.828
And by the way that means that you
shouldn't be designing all these

17
00:00:53.828 --> 00:00:57.197
polymorphic functions that can
take any sort of value and

18
00:00:57.197 --> 00:01:00.020
do 15 different things
based upon the value.

19
00:01:00.020 --> 00:01:03.491
You're asking for
coercion problems when you do that and

20
00:01:03.491 --> 00:01:08.200
then papering over them, but I used
the triple, I used the triple equals.

21
00:01:08.200 --> 00:01:11.045
Why not just design a function
that only takes numbers and

22
00:01:11.045 --> 00:01:13.720
then make another function
that only takes strings?

23
00:01:13.720 --> 00:01:16.722
Or make a function that takes numbers and
strings, and

24
00:01:16.722 --> 00:01:19.526
it's very clear it can only
be those two types, and

25
00:01:19.526 --> 00:01:23.659
I know what corner cases I have to worry
about between numbers and strings.

26
00:01:23.659 --> 00:01:27.715
We can choose to be more obvious
about how we manage our types,

27
00:01:27.715 --> 00:01:31.462
how much we overload,
how polymorphic we make our code.

28
00:01:31.462 --> 00:01:35.209
We can opt in to more problems or
opt out of problems as a result.

29
00:01:37.309 --> 00:01:40.432
&gt;&gt; Kyle Simpson: Biggest takeaway that
I want you to get here is that these

30
00:01:40.432 --> 00:01:44.553
are fact of your programs and it is
within your purview to decide how much or

31
00:01:44.553 --> 00:01:47.550
how little you're gonna be
affected by those facts.

32
00:01:51.400 --> 00:01:54.738
&gt;&gt; Kyle Simpson: That is not to suggest
that the only solution to our problem is

33
00:01:54.738 --> 00:01:59.260
that everything have to rigidly,
everything's completely statically typed.

34
00:01:59.260 --> 00:02:04.105
We have to just basically go write Java or
C Plus Plus so that we get some

35
00:02:04.105 --> 00:02:08.868
kind of like sound type system,
that is a reaction to this problem,

36
00:02:08.868 --> 00:02:12.576
it is not the the reaction
I think that is necessary.

37
00:02:12.576 --> 00:02:16.088
So the message I'm preaching here
is you can learn these systems,

38
00:02:16.088 --> 00:02:19.236
use them appropriately and
make them obvious in your code.

39
00:02:21.500 --> 00:02:24.732
&gt;&gt; Kyle Simpson: I do not think that
this typing systems are weaknesses,

40
00:02:24.732 --> 00:02:28.739
I actually think this is one of
JavaScript's strongest qualities.

41
00:02:28.739 --> 00:02:33.464
It's an unsung hero, I think it's
one of the reasons why JavaScript is

42
00:02:33.464 --> 00:02:37.560
the ubiquitous language that it
is today because it has been so

43
00:02:37.560 --> 00:02:40.429
palatable to so many different use cases.

44
00:02:40.429 --> 00:02:45.413
The first truly multi-paradigm
language and a big reason why it has

45
00:02:45.413 --> 00:02:50.500
been able to survive multi-paradigm
is because of its type system.

46
00:02:50.500 --> 00:02:53.258
And that's completely opposite from
what every one of my peers and

47
00:02:53.258 --> 00:02:55.040
everything else that you've ever heard.

48
00:02:55.040 --> 00:02:59.860
Everybody else has always told you this
is the worst part of JavaScript and

49
00:02:59.860 --> 00:03:04.849
I'm gonna put my foot down and say it's
one of the best parts of JavaScript.

50
00:03:04.849 --> 00:03:07.270
And if you're not using it,
your programs are missing out

