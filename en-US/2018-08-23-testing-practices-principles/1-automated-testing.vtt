WEBVTT

1
00:00:00.000 --> 00:00:05.799
&gt;&gt; Kent C. Dodds: Who knows what this is?
&gt;&gt; Kent C. Dodds: Yeah?

2
00:00:05.799 --> 00:00:08.600
&gt;&gt; Speaker 2: It's the first actual case

3
00:00:08.600 --> 00:00:13.588
of a bug being found in
a computer at a mainframe at

4
00:00:13.588 --> 00:00:17.333
a naval laboratory, I think.
&gt;&gt; Kent C. Dodds: Yeah, yeah.

5
00:00:17.333 --> 00:00:21.991
So this is Relay # 70,
Panel F, a moth in relay.

6
00:00:21.991 --> 00:00:26.539
So this is not where
the term bug came from.

7
00:00:26.539 --> 00:00:27.851
That's a pretty common misconception.

8
00:00:27.851 --> 00:00:32.138
This is just the first actual
case of a bug being found.

9
00:00:32.138 --> 00:00:36.544
So at least the first recorded
case of a bug being found.

10
00:00:36.544 --> 00:00:41.138
And the term bug was used I think
by Thomas Edison used it in

11
00:00:41.138 --> 00:00:45.173
a letter to somebody else,
and even before that.

12
00:00:45.173 --> 00:00:48.570
And but the term bug is used to
describe a problem in a system.

13
00:00:48.570 --> 00:00:53.320
And we write a lot of systems
now in code with software.

14
00:00:53.320 --> 00:00:57.127
And we find bugs in our
systems all the time.

15
00:00:57.127 --> 00:01:03.606
It's one of the fun things about
software is it's so fluid.

16
00:01:03.606 --> 00:01:09.168
And that fluidity is a great opportunity
for bugs to sneak into things.

17
00:01:09.168 --> 00:01:13.739
So we're finding bugs a lot more than
they used to find moths in relays.

18
00:01:13.739 --> 00:01:18.357
But yeah, this is what a bug is and
we don't want bugs in our software.

19
00:01:18.357 --> 00:01:20.872
So what kind of bugs are there?

20
00:01:20.872 --> 00:01:24.812
What kind of bugs do you find in software?

21
00:01:24.812 --> 00:01:25.928
I'll give you just one hint.

22
00:01:25.928 --> 00:01:27.557
There are security bugs.

23
00:01:27.557 --> 00:01:30.501
What other kind of bugs
can you find in software?

24
00:01:30.501 --> 00:01:33.571
What's the bug that you found yesterday
cuz you find them all the time?

25
00:01:33.571 --> 00:01:37.967
What kind of bugs?
&gt;&gt; Speaker 2: Memory leaks.

26
00:01:37.967 --> 00:01:38.844
&gt;&gt; Kent C. Dodds: Memory leaks, yes,

27
00:01:38.844 --> 00:01:42.094
great.
&gt;&gt; Speaker 2: Logic errors.

28
00:01:42.094 --> 00:01:42.970
&gt;&gt; Kent C. Dodds: Logic, yep,

29
00:01:42.970 --> 00:01:43.776
logic bugs.

30
00:01:43.776 --> 00:01:46.384
&gt;&gt; Speaker 2: Integration.
&gt;&gt; Kent C. Dodds: What?

31
00:01:46.384 --> 00:01:47.269
Integration bugs, yep.

32
00:01:47.269 --> 00:01:49.656
Yeah, you're talking to Twitter's API or
something.

33
00:01:49.656 --> 00:01:51.667
There's a bug in that integration or
even your own APIs.

34
00:01:51.667 --> 00:01:56.456
Any other kinds of bugs?
&gt;&gt; Speaker 2: Off by one.

35
00:01:56.456 --> 00:01:58.128
&gt;&gt; Kent C. Dodds: Off by one errors, yeah.

36
00:01:58.128 --> 00:01:59.791
&gt;&gt; Speaker 2: Race conditions.

37
00:01:59.791 --> 00:02:00.642
&gt;&gt; Kent C. Dodds: Uh-huh, yeah,

38
00:02:00.642 --> 00:02:04.072
race conditions.
&gt;&gt; Speaker 2: No pointer exception.

39
00:02:04.072 --> 00:02:06.147
&gt;&gt; Kent C. Dodds: No pointer exception.

40
00:02:06.147 --> 00:02:06.986
Man.

41
00:02:06.986 --> 00:02:09.145
I prefer undefined is not a function.

42
00:02:09.145 --> 00:02:13.072
[LAUGH] But yeah, so
they're regression bugs that used to work,

43
00:02:13.072 --> 00:02:16.796
doesn't work anymore,
business logic, accessibility.

44
00:02:16.796 --> 00:02:20.252
There are lots and
lots of different kinds of bugs.

45
00:02:20.252 --> 00:02:24.074
And this isn't a comprehensive list or
anything, but

46
00:02:24.074 --> 00:02:27.325
bugs can surface in all
areas of our software.

47
00:02:27.325 --> 00:02:30.645
So what do we do about these bugs?

48
00:02:30.645 --> 00:02:33.065
How do we prevent these
bugs from happening?

49
00:02:33.065 --> 00:02:39.748
So there's sonic typing is
a great way to do that.

50
00:02:39.748 --> 00:02:42.697
So how many people here are using
a type checker in their JavaScript?

51
00:02:42.697 --> 00:02:45.245
Is it TypeScript, TypeScript?

52
00:02:45.245 --> 00:02:46.699
Flow, anybody using Flow?

53
00:02:46.699 --> 00:02:48.085
All right, yeah.

54
00:02:48.085 --> 00:02:50.479
So I prefer Flow because I like Babel.

55
00:02:50.479 --> 00:02:53.500
I guess Babel you'd be able
to do TypeScript sort of.

56
00:02:53.500 --> 00:02:58.133
But yeah, so I highly recommend that you

57
00:02:58.133 --> 00:03:03.319
leverage static typing in your Javascript.

58
00:03:03.319 --> 00:03:09.115
It will just take away a whole category of
bugs that could appear in your software.

59
00:03:09.115 --> 00:03:13.212
It will also take you a lot longer
to write JavaScript because it

60
00:03:13.212 --> 00:03:17.327
sometimes adding types to
Javascript is really frustrating.

61
00:03:17.327 --> 00:03:21.293
But in general,
it makes your software better and so

62
00:03:21.293 --> 00:03:24.367
I definitely recommend static typing.

63
00:03:24.367 --> 00:03:27.582
This is also a form of static analysis.

64
00:03:27.582 --> 00:03:29.475
Linting, ESLint is a fantastic tool.

65
00:03:29.475 --> 00:03:32.128
If you're not using ESLint,
I recommend you do.

66
00:03:32.128 --> 00:03:36.305
If you're using ESLint to check style,
code style, please stop.

67
00:03:36.305 --> 00:03:37.420
We don't need that.

68
00:03:37.420 --> 00:03:39.823
We have prettier formatted all.

69
00:03:39.823 --> 00:03:44.458
ESLint's job should be to
catch common bugs that static

70
00:03:44.458 --> 00:03:46.928
type checkers can't catch.

71
00:03:46.928 --> 00:03:52.330
And lots of that involves domain
specific things like in our code base,

72
00:03:52.330 --> 00:03:56.756
we can't do this because of
this other thing or whatever.

73
00:03:56.756 --> 00:03:58.572
So you can write a custom ESLint rule for
that.

74
00:03:58.572 --> 00:04:03.425
So and ESLint also has a bunch of rules
that are useful that static types

75
00:04:03.425 --> 00:04:07.305
don't generally catch,
type checkers don't catch.

76
00:04:07.305 --> 00:04:10.304
So linting is another form of testing, and

77
00:04:10.304 --> 00:04:14.066
these two things are generally
pretty easy to set up.

78
00:04:14.066 --> 00:04:17.646
And so
I definitely recommend using these things.

79
00:04:17.646 --> 00:04:23.021
And we're not gonna be talking about or
using these things directly at all today.

80
00:04:23.021 --> 00:04:28.371
But I just mention them because
it's really, really valuable.

81
00:04:28.371 --> 00:04:32.193
So then testing is the next thing,
the next layer of defense.

82
00:04:32.193 --> 00:04:34.462
ESLint can't catch logic errors.

83
00:04:34.462 --> 00:04:38.767
Type checking can't catch logic errors,
anything like that.

84
00:04:38.767 --> 00:04:44.622
And so there's still a big category of
bugs that we need to catch with testing.

85
00:04:44.622 --> 00:04:50.835
So what kinds of test are available to us,
these automated tests?

86
00:04:50.835 --> 00:04:54.777
I'll give you a hint, there's unit tests,

87
00:04:54.777 --> 00:04:57.589
what other kinds?
&gt;&gt; Speaker 2: Integration test.

88
00:04:57.589 --> 00:04:58.625
&gt;&gt; Kent C. Dodds: Integration tests, yep.

89
00:04:58.625 --> 00:05:00.151
&gt;&gt; Speaker 2: And end tests.

90
00:05:00.151 --> 00:05:00.807
&gt;&gt; Kent C. Dodds: And end tests,

91
00:05:00.807 --> 00:05:01.772
there's still more.

92
00:05:01.772 --> 00:05:03.173
What other-
&gt;&gt; Speaker 2: Acceptance tests.

93
00:05:03.173 --> 00:05:03.949
&gt;&gt; Kent C. Dodds: Acceptance tests.

94
00:05:03.949 --> 00:05:06.427
I'm not sure what order they are anymore,
so I'm gonna.

95
00:05:06.427 --> 00:05:07.477
[LAUGH]
&gt;&gt; Speaker 2: Regression

96
00:05:07.477 --> 00:05:08.120
test.
&gt;&gt; Kent C. Dodds: Regression test,

97
00:05:08.120 --> 00:05:12.847
yep.
&gt;&gt; Kent C. Dodds: Any other forms of

98
00:05:12.847 --> 00:05:14.704
tests?
&gt;&gt; Speaker 2: Performance.

99
00:05:14.704 --> 00:05:15.731
&gt;&gt; Kent C. Dodds: Yep, performance, yep.

100
00:05:15.731 --> 00:05:17.412
&gt;&gt; Speaker 2: Stress test, load test.

101
00:05:17.412 --> 00:05:17.947
&gt;&gt; Kent C. Dodds: Yep,

102
00:05:17.947 --> 00:05:22.789
yep, stress tests.
&gt;&gt; Kent C. Dodds: I think we covered

103
00:05:22.789 --> 00:05:24.300
every single formula,
no, I'm just kidding.

104
00:05:24.300 --> 00:05:25.391
There are many more.

105
00:05:25.391 --> 00:05:29.978
So penetration tests is security,
performance, regression, yeah,

106
00:05:29.978 --> 00:05:32.317
all three of the ones you mentioned.

107
00:05:32.317 --> 00:05:35.841
Accessibility, that's a11y, accessibility.

108
00:05:35.841 --> 00:05:38.541
Very, very important,
we should be testing that.

109
00:05:38.541 --> 00:05:43.214
Internationalization, how many times
have you had a localization bug?

110
00:05:43.214 --> 00:05:44.762
All the time.

111
00:05:44.762 --> 00:05:49.329
I cannot ship internationalized software
without having some bug within my

112
00:05:49.329 --> 00:05:50.909
internationalization.

113
00:05:50.909 --> 00:05:55.886
Most of the time it has to do with right
to left conversion and things look funny.

114
00:05:55.886 --> 00:06:01.315
Or yeah, or the text is way longer in
language x than English or something.

115
00:06:01.315 --> 00:06:05.408
So yeah, there's some things you
can do to automate that, and

116
00:06:05.408 --> 00:06:07.736
then a whole bunch of other things.

117
00:06:07.736 --> 00:06:11.091
We're not gonna cover all of these.

118
00:06:11.091 --> 00:06:15.352
It would take weeks to cover all
of these with any amount of depth.

119
00:06:15.352 --> 00:06:19.471
So yeah, we're gonna focus
on just a couple of these.

120
00:06:19.471 --> 00:06:21.748
So this is an example of
static code analysis.

121
00:06:21.748 --> 00:06:23.996
'three' is not defined.

122
00:06:23.996 --> 00:06:26.164
ESLink can save us from that.

123
00:06:26.164 --> 00:06:32.583
And then Flow can tell us, hey, well,
three is defined, but it's a string.

124
00:06:32.583 --> 00:06:33.279
It should be a number.

125
00:06:33.279 --> 00:06:38.390
And so it can tell us that these types
are incompatible with each other.

126
00:06:38.390 --> 00:06:43.442
Unit tests, this is a basic unit test.

127
00:06:43.442 --> 00:06:47.731
We've got a little function here and
we call it and we did a value back.

128
00:06:47.731 --> 00:06:52.171
That's the simplest form of a code
automated test that I can think of.

129
00:06:52.171 --> 00:06:55.816
And we're gonna be seeing
what that test function and

130
00:06:55.816 --> 00:06:58.984
what that expect function
are supposed to do.

131
00:06:58.984 --> 00:07:01.694
We'll be writing it ourselves.

132
00:07:01.694 --> 00:07:04.797
But that's, yeah, that's basic unit test.

133
00:07:04.797 --> 00:07:07.257
Integration test are generally
a little bit more complicated.

134
00:07:07.257 --> 00:07:10.984
You have to start up the server, and
then you have to hit an endpoint or

135
00:07:10.984 --> 00:07:12.223
something like that.

136
00:07:12.223 --> 00:07:15.193
Maybe you have to have a database up and
running.

137
00:07:15.193 --> 00:07:19.017
And so often these integration
tests can be more complicated.

138
00:07:19.017 --> 00:07:22.159
This is for bank and stuff.

139
00:07:22.159 --> 00:07:27.437
You could also have integration tests on
the UI that is mocking out all server

140
00:07:27.437 --> 00:07:33.062
requests and stuff, but is integrating
how your UI is interacting with itself.

141
00:07:33.062 --> 00:07:37.682
And so yeah, there's more of
a layer above unit test where it's

142
00:07:37.682 --> 00:07:40.174
testing several units together.

143
00:07:40.174 --> 00:07:44.912
The line between unit and
integration test is a little bit fuzzy.

144
00:07:44.912 --> 00:07:48.007
But then we also have end-to-end tests.

145
00:07:48.007 --> 00:07:49.182
We're not gonna cover these today.

146
00:07:49.182 --> 00:07:54.435
But the general idea is you pull
up the entire application and

147
00:07:54.435 --> 00:07:58.562
try to use it as close to
as the user as possible.

