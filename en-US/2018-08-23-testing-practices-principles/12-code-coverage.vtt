WEBVTT

1
00:00:00.000 --> 00:00:03.403
&gt;&gt; Kent C. Dodds: So
the next thing that I wanna jump into is,

2
00:00:03.403 --> 00:00:05.776
I skipped over this earlier.

3
00:00:05.776 --> 00:00:10.739
And I think that it's probably still
relevant to everybody so I wanna take

4
00:00:10.739 --> 00:00:15.879
a quick break into, from exercises in
coding and talk about code coverage.

5
00:00:15.879 --> 00:00:19.088
So this project is keeping
track of code coverage, and

6
00:00:19.088 --> 00:00:23.289
we're not gonna talk about how to
configure tools to make that happen.

7
00:00:23.289 --> 00:00:27.381
We'll do that tomorrow
in the React workshop.

8
00:00:27.381 --> 00:00:32.534
But suffice it to say that most tools
in the JavaScript ecosystem are using

9
00:00:32.534 --> 00:00:37.369
the same code coverage reporting tool and
that's called Istanbul.

10
00:00:37.369 --> 00:00:41.560
And those tools will create
a coverage directory with

11
00:00:41.560 --> 00:00:44.269
an lcov-report inside of there.

12
00:00:44.269 --> 00:00:48.892
And that's actually just this little tiny
web app thing, not really a web app,

13
00:00:48.892 --> 00:00:52.626
it's just a website, for your,
to report your code coverage.

14
00:00:52.626 --> 00:00:58.578
So you can actually pull that up in
the browser if you run Open, Coverage,

15
00:00:58.578 --> 00:01:04.926
lcov-report, Index.html, then you
get this beautiful coverage report.

16
00:01:04.926 --> 00:01:07.023
How many people have seen this before?

17
00:01:07.023 --> 00:01:08.273
Okay, a handful of you.

18
00:01:08.273 --> 00:01:10.923
So here at the bottom it
says generated by Istanbul,

19
00:01:10.923 --> 00:01:14.369
you can click on that to learn more
about what Istanbul is all about.

20
00:01:14.369 --> 00:01:15.618
It's pretty cool.

21
00:01:15.618 --> 00:01:19.954
So let's take a look at some
of the server side stuff.

22
00:01:19.954 --> 00:01:24.065
If we look at our controllers,
we're in server source controllers.

23
00:01:24.065 --> 00:01:28.627
These are actual files that have
various levels of coverage.

24
00:01:28.627 --> 00:01:32.172
If it's all red that means
it's not covered at all.

25
00:01:32.172 --> 00:01:36.855
So here let's take a look at one
that has a little bit of coverage.

26
00:01:36.855 --> 00:01:41.509
So the highlighting here is
indicating what lines of code have

27
00:01:41.509 --> 00:01:43.754
been run during the test run.

28
00:01:43.754 --> 00:01:48.461
So what this means is, and
here is a spoiler alert, don't look, but

29
00:01:48.461 --> 00:01:51.464
what this means is that
during the test run,

30
00:01:51.464 --> 00:01:54.729
I actually never ran
this authorize function.

31
00:01:54.729 --> 00:01:59.623
And so what that can indicate to me is
that this authorized function might work,

32
00:01:59.623 --> 00:02:00.364
might not.

33
00:02:00.364 --> 00:02:03.934
It might actually even have a very
obvious error where it's trying to access

34
00:02:03.934 --> 00:02:06.068
a property that doesn't exist or anything.

35
00:02:06.068 --> 00:02:11.072
There's no way for our test to tell us
that because this code is never run.

36
00:02:11.072 --> 00:02:15.878
And so that's what the code coverage
report is trying to communicate to us.

37
00:02:15.878 --> 00:02:19.492
And then for statements here,
we have this e next to the if,

38
00:02:19.492 --> 00:02:23.827
that means that alts cases is
never covered for this statement.

39
00:02:23.827 --> 00:02:26.370
And we see that alt statements never run.

40
00:02:26.370 --> 00:02:30.272
Here, we see the if cases
never run in this situation.

41
00:02:30.272 --> 00:02:32.987
So we are testing the update
user function but

42
00:02:32.987 --> 00:02:37.497
we're not testing what happens if
that user isn't authorized to update.

43
00:02:37.497 --> 00:02:41.972
And so this can give us a good
idea of what areas of our code

44
00:02:41.972 --> 00:02:43.694
base are not tested.

45
00:02:43.694 --> 00:02:48.077
And what's more important than figuring
out what areas of our code base

46
00:02:48.077 --> 00:02:52.180
are not tested is determining what
use cases are not being tested?

47
00:02:52.180 --> 00:02:54.327
What used cases are you not supporting?

48
00:02:54.327 --> 00:02:58.828
Because maybe we have this,
this educates here, and

49
00:02:58.828 --> 00:03:01.837
get users where there are no users.

50
00:03:01.837 --> 00:03:04.247
But that pretty much never ever happens.

51
00:03:04.247 --> 00:03:07.201
And so we only really care about this.

52
00:03:07.201 --> 00:03:11.430
If there are no users, and that's probably
indicative of some other bigger problems.

53
00:03:11.430 --> 00:03:13.947
So we don't really care to
take any time to cover that.

54
00:03:13.947 --> 00:03:18.136
I'm not suggesting that's
a real world situation, but

55
00:03:18.136 --> 00:03:22.949
in general we should think
critically about this code coverage.

56
00:03:22.949 --> 00:03:25.653
One mistake that I've
seen teams make is and

57
00:03:25.653 --> 00:03:30.270
I've actually seen this more from
management than software developers.

58
00:03:30.270 --> 00:03:35.948
But creating a mandate that you
have to have 100% code coverage.

59
00:03:35.948 --> 00:03:39.939
That's a very bad idea for
application development.

60
00:03:39.939 --> 00:03:46.815
Because what winds up happening is you
have this curve of the value that the code

61
00:03:46.815 --> 00:03:53.293
coverage provides to you as you go up
the code coverage percentage chain.

62
00:03:53.293 --> 00:03:59.619
So after a certain point that really
kind of depends on your used cases and

63
00:03:59.619 --> 00:04:04.714
things, thereÂ´s a huge amount
of diminishing returns.

64
00:04:04.714 --> 00:04:08.968
And certainly I feel pretty safe to
say that in almost all applications,

65
00:04:08.968 --> 00:04:14.009
the 100% code coverage, you've long
passed the point of diminishing returns.

66
00:04:14.009 --> 00:04:18.945
The last 10% of code coverage,
the tests you have to write to get

67
00:04:18.945 --> 00:04:23.194
that last 10% are really finicky,
hard to maintain.

68
00:04:23.194 --> 00:04:27.842
They have to do really weird hacks,
you have to start changing your

69
00:04:27.842 --> 00:04:32.918
source code to expose certain hooks
that only are useful for your tests.

70
00:04:32.918 --> 00:04:35.268
Certain things like that.

71
00:04:35.268 --> 00:04:40.733
So driving your tests by your code
coverage exclusively, it's a bad idea.

72
00:04:40.733 --> 00:04:45.429
Another thing that the code
coverage report doesn't

73
00:04:45.429 --> 00:04:49.704
tell us is will getting
coverage here will give me

74
00:04:49.704 --> 00:04:54.521
the same boost as if I were
to put my coverage work here?

75
00:04:54.521 --> 00:04:57.049
I do it one place, I do it in the other,

76
00:04:57.049 --> 00:05:00.372
I'm gonna get the same
boost to my code coverage.

77
00:05:00.372 --> 00:05:04.618
They don't give me the same boost in my
confidence or in what actually matters, so

78
00:05:04.618 --> 00:05:07.510
maybe getting coverage here
isn't really a huge deal,

79
00:05:07.510 --> 00:05:10.298
but I'm still gonna get that
boost in code coverage.

80
00:05:10.298 --> 00:05:13.625
So the code coverage report
is just telling you, and

81
00:05:13.625 --> 00:05:16.583
this is what I'm really
trying to get across.

82
00:05:16.583 --> 00:05:21.407
The code coverage report is only
telling you what code has been ran

83
00:05:21.407 --> 00:05:22.814
during your test.

84
00:05:22.814 --> 00:05:28.507
It's not trying to make any suggestion on
where you need to start writing tests,

85
00:05:28.507 --> 00:05:31.951
or what use cases you're
missing necessarily.

86
00:05:31.951 --> 00:05:35.205
It's just telling you
what use cases you're,

87
00:05:35.205 --> 00:05:39.362
or what code you're not actually
running during your test.

88
00:05:39.362 --> 00:05:43.671
So does anybody have questions
about code coverage,

89
00:05:43.671 --> 00:05:47.365
yes?
&gt;&gt; Speaker 2: So during lunch we we're

90
00:05:47.365 --> 00:05:52.560
talking about basically
regularity of the tests.

91
00:05:52.560 --> 00:05:58.422
And finding the right balance between
testing very fundamental assumptions

92
00:05:58.422 --> 00:06:04.115
in your codes versus testing the thing
that has all kinds of dependencies.

93
00:06:04.115 --> 00:06:07.892
And in the process of testing
at a higher level component,

94
00:06:07.892 --> 00:06:12.134
you're essentially testing whether
all those subcomponents or

95
00:06:12.134 --> 00:06:14.941
those dependencies work.
&gt;&gt; Kent C. Dodds: Yeah.

96
00:06:14.941 --> 00:06:16.032
&gt;&gt; Speaker 2: [INAUDIBLE]

97
00:06:16.032 --> 00:06:17.147
&gt;&gt; Kent C. Dodds: That's applicable

98
00:06:17.147 --> 00:06:17.935
here, yeah.

99
00:06:17.935 --> 00:06:21.026
So that's a good question, so
at what point do you test?

100
00:06:21.026 --> 00:06:25.826
I could test this authorize function
by itself, I could expose it and

101
00:06:25.826 --> 00:06:27.496
then test it by itself.

102
00:06:27.496 --> 00:06:33.506
But it's actually maybe being used
in the route for registration.

103
00:06:33.506 --> 00:06:37.318
And so should I test the authorized
function in isolation, or

104
00:06:37.318 --> 00:06:42.542
should I just test the registration or the
log in, and then I'll get that coverage.

105
00:06:42.542 --> 00:06:46.133
So you're gonna get
coverage in both places.

106
00:06:46.133 --> 00:06:50.026
So I would suggest the basic principle for
testing,

107
00:06:50.026 --> 00:06:54.449
as I said earlier,
the more your tests resemble the way your

108
00:06:54.449 --> 00:06:58.625
software is used the more
confidence they can give you.

109
00:06:58.625 --> 00:07:03.300
That principle shouldn't
be treated as dogma either.

110
00:07:03.300 --> 00:07:08.187
There are trade-offs with if you consider,

111
00:07:08.187 --> 00:07:12.686
okay, what if I'm in a world where people

112
00:07:12.686 --> 00:07:17.586
are plentiful and
time is plentiful as well?

113
00:07:17.586 --> 00:07:21.847
The best way to test your software would
be to have people go through manually

114
00:07:21.847 --> 00:07:26.120
every flow in your software and make
sure that everything is still working.

115
00:07:26.120 --> 00:07:28.059
The problem is, that takes too long.

116
00:07:28.059 --> 00:07:31.955
Humans are actually error prone and
so you do wanna automate that.

117
00:07:31.955 --> 00:07:36.004
But yeah, so maybe automating that process
of clicking through your whole app,

118
00:07:36.004 --> 00:07:38.216
that's what we call an end-to-end task.

119
00:07:38.216 --> 00:07:41.173
And those would be great but
there are trade-offs with that as well.

120
00:07:41.173 --> 00:07:44.267
They take a long time,
they're kinda flaky, finicky,

121
00:07:44.267 --> 00:07:47.043
and sometimes they can be
pretty hard to maintain.

122
00:07:47.043 --> 00:07:48.108
There are resource incentives.

123
00:07:48.108 --> 00:07:51.285
So there are trade-offs at every level,
and so

124
00:07:51.285 --> 00:07:55.584
the actual decision of where you
focus your time and your tests.

125
00:07:55.584 --> 00:07:58.424
And whether or
not we should test this in isolation, or

126
00:07:58.424 --> 00:08:02.330
if we should test it as part of
an integration test or an end-to-end test.

127
00:08:02.330 --> 00:08:06.775
You need to develop an intuition about
that, but just keep in mind the idea,

128
00:08:06.775 --> 00:08:10.387
the closer your tests resemble
the way your software is used,

129
00:08:10.387 --> 00:08:12.762
the more confidence they'll give you.

130
00:08:12.762 --> 00:08:17.381
And so if you can,
reasonably cover this code in a way that's

131
00:08:17.381 --> 00:08:22.466
closer to how the software is used
then that's generally better.

132
00:08:22.466 --> 00:08:26.971
I'll talk a little bit more toward the end
about this subject, I have some more

133
00:08:26.971 --> 00:08:31.765
specific guidance, but hopefully that
kind of helps answer your question there.

134
00:08:31.765 --> 00:08:35.455
Yeah.
&gt;&gt; Speaker 3: So jumping off that,

135
00:08:35.455 --> 00:08:43.865
coverage tells you which functions
have been touched during tests.

136
00:08:43.865 --> 00:08:47.503
Is there any tooling
to many different ways

137
00:08:47.503 --> 00:08:52.264
to invoke a function you know,
different parameters?

138
00:08:52.264 --> 00:08:55.970
Is there any way to, like kinda gauge how

139
00:08:55.970 --> 00:09:00.369
well each function is exercised?
&gt;&gt; Kent C. Dodds: Yeah, yeah, so

140
00:09:00.369 --> 00:09:05.918
what you're talking about is, I don't
know if this is an official word for

141
00:09:05.918 --> 00:09:08.399
it, but I call it data coverage.

142
00:09:08.399 --> 00:09:10.814
I can call this authorized function or

143
00:09:10.814 --> 00:09:13.991
maybe a better example
would be our sum function.

144
00:09:13.991 --> 00:09:18.922
So I can call the sum function with a
number, what happens if I pass at nothing?

145
00:09:18.922 --> 00:09:21.249
What happens if I pass at a string?

146
00:09:21.249 --> 00:09:24.240
What happens if I pass at
more arguments or whatever?

147
00:09:24.240 --> 00:09:29.784
And so as far as I'm aware there's no tool
that can give you that kind of coverage.

148
00:09:29.784 --> 00:09:34.221
However, static type checking
tools do have mechanisms for

149
00:09:34.221 --> 00:09:38.316
telling you how well your
types are covering your code.

150
00:09:38.316 --> 00:09:43.326
And so those can help you with that.

151
00:09:43.326 --> 00:09:48.037
And it actually,
by using a static type checker you kind of

152
00:09:48.037 --> 00:09:52.654
remove that category of concern
from your application so

153
00:09:52.654 --> 00:09:56.033
you don't really need to worry about it.

154
00:09:56.033 --> 00:09:57.059
Good question.

155
00:09:57.059 --> 00:10:01.375
But that said you also have a situation
where yes this accepts this string but

156
00:10:01.375 --> 00:10:04.283
what happens if it's
a really really long string?

157
00:10:04.283 --> 00:10:05.092
Or something like that.

158
00:10:05.092 --> 00:10:08.253
You can't really get that
from a type checker either.

159
00:10:08.253 --> 00:10:13.171
So at some point, having some sort of
data coverage would be kind of cool, but

160
00:10:13.171 --> 00:10:14.239
I'm not aware.

161
00:10:14.239 --> 00:10:17.558
You could build it,
that'd be awesome, yeah.

162
00:10:17.558 --> 00:10:21.146
That's a fun thing about software
is we can solve our own problems.

163
00:10:21.146 --> 00:10:26.242
Is anyone curious to see how this
code coverage report is generated?

164
00:10:26.242 --> 00:10:29.958
I can show you in just a really
quick demo what things look like.

165
00:10:29.958 --> 00:10:34.977
So the Istanbul, the code coverage tool,
I'm pretty sure it

166
00:10:34.977 --> 00:10:40.107
use to use some really weird regex
stuff to put things in place.

167
00:10:40.107 --> 00:10:42.518
Now it's actually just a Babel plugin.

168
00:10:42.518 --> 00:10:46.188
It's very cool and there's actually a
front end masters course where I show you

169
00:10:46.188 --> 00:10:47.797
how to make custom Babel plugins.

170
00:10:47.797 --> 00:10:50.952
I did that last year,
it's pretty fun stuff.

171
00:10:50.952 --> 00:10:56.272
But this is a utils file from
one of my open source projects.

172
00:10:56.272 --> 00:10:59.592
I copied this a while back so
it might be a little different.

173
00:10:59.592 --> 00:11:04.092
Just some regular functions,
we export all of these things.

174
00:11:04.092 --> 00:11:08.581
So here's how Istanbul keeps
track of what lines are run,

175
00:11:08.581 --> 00:11:12.807
what functions are run,
ternaries, all that stuff.

176
00:11:12.807 --> 00:11:18.083
It converts your beautiful,
let's see, how long is this file?

177
00:11:18.083 --> 00:11:22.540
309-line file to a 2945-line file.

178
00:11:22.540 --> 00:11:30.389
Most of that is taken up by this enormous
object [COUGH] up here at the top.

179
00:11:30.389 --> 00:11:36.808
That has an entry for every single line,
function, branch, everything.

180
00:11:36.808 --> 00:11:38.959
So here we have all
the statements in a code.

181
00:11:38.959 --> 00:11:40.840
Here's the first statement.

182
00:11:40.840 --> 00:11:45.816
It starts on line 3, column 16,
and ends on line 3 column 17.

183
00:11:45.816 --> 00:11:51.434
It uses that so it knows where to
highlight things that aren't covered.

184
00:11:51.434 --> 00:11:53.851
Yeah?
&gt;&gt; Speaker 2: Clarify, is that gem,

185
00:11:53.851 --> 00:11:56.964
what we're starring at,
that object, is that generated?

186
00:11:56.964 --> 00:11:58.022
&gt;&gt; Kent C. Dodds: Yeah, and

187
00:11:58.022 --> 00:12:02.849
it happens in memory,
you don't type this out.

188
00:12:02.849 --> 00:12:04.598
And yes, this happens in memory as well.

189
00:12:04.598 --> 00:12:08.487
So like you never
actually see these files.

190
00:12:08.487 --> 00:12:11.619
I just made it for you because I care.

191
00:12:11.619 --> 00:12:14.063
So then we have the same thing for
functions.

192
00:12:14.063 --> 00:12:17.196
We have a map of every function,
what it's called,

193
00:12:17.196 --> 00:12:21.700
where the declaration starts and ends,
where the whole function exists.

194
00:12:21.700 --> 00:12:23.369
And then we have branches.

195
00:12:23.369 --> 00:12:27.098
Those are if statements,
ternaries, switch statements.

196
00:12:27.098 --> 00:12:28.610
This is where all those start.

197
00:12:28.610 --> 00:12:32.627
This one's interesting because
you have multiple locations for

198
00:12:32.627 --> 00:12:34.386
these different branches.

199
00:12:34.386 --> 00:12:40.877
Often you'll have like the consequence and
the alternate for like an if statement.

200
00:12:40.877 --> 00:12:47.151
And then we have a record of how
many times that statement or

201
00:12:47.151 --> 00:12:51.132
that function or that branch is run.

202
00:12:51.132 --> 00:12:56.877
And so once we have all that established,
then we take that variable and

203
00:12:56.877 --> 00:13:02.935
we increment every single one of these
records anytime a statement is run.

204
00:13:02.935 --> 00:13:07.018
And this is actually using a not so
commonly used, and for

205
00:13:07.018 --> 00:13:10.603
good reason,
the comma operator in JavaScript.

206
00:13:10.603 --> 00:13:14.197
So this is the original source code,
it's ID counter =1.

207
00:13:14.197 --> 00:13:19.099
Now ID counter = ( increment
this statement, and then 1.

208
00:13:19.099 --> 00:13:21.707
And the comma operator just says okay,
whatever comes after this.

209
00:13:21.707 --> 00:13:24.601
It's like, ignore the first thing,

210
00:13:24.601 --> 00:13:29.769
this is what the evaluation of this
expression should evaluate to.

211
00:13:29.769 --> 00:13:34.047
So that's kind of fine, and then we've
got the same thing for ternaries, and for

212
00:13:34.047 --> 00:13:35.917
functions, and statements here.

213
00:13:35.917 --> 00:13:40.973
And it just kinda messes up our code in
terrible ways, but in reliable ways so

214
00:13:40.973 --> 00:13:46.435
that our tests will operate the same,
whether we're recording coverage or not.

215
00:13:46.435 --> 00:13:49.491
So anyway, the reason that I wanna
show you this is just so you have

216
00:13:49.491 --> 00:13:53.401
an understanding of what's going on under
the hood for generating code coverage.

217
00:13:53.401 --> 00:13:58.460
In addition to what the value of code
coverage brings to your application.

218
00:13:58.460 --> 00:14:02.930
It does bring value but
it shouldn't be taken as

219
00:14:02.930 --> 00:14:06.971
an indicator of something that it's not.

220
00:14:06.971 --> 00:14:09.990
It shouldn't be taken as
an indicator of confidence,

221
00:14:09.990 --> 00:14:13.794
it should really be taken as an indicator
of what lines have been run,

222
00:14:13.794 --> 00:14:16.433
what functions have been run,
what happened.

