WEBVTT

1
00:00:00.060 --> 00:00:03.706
So we're just going to jump right in and
start going over the basics there's no

2
00:00:03.706 --> 00:00:06.910
code in this section but I just wanted
to kind of show you some things so

3
00:00:06.910 --> 00:00:10.280
that as we start doing it you can try
to recall from your memory the more you

4
00:00:10.280 --> 00:00:13.982
recall from your memory the better you're
going to be the more it's going to set

5
00:00:13.982 --> 00:00:17.408
deep within your head and then you can
just start doing it yourself For me,

6
00:00:17.408 --> 00:00:21.320
I had to type something out like four or
five times before it really sticks.

7
00:00:21.320 --> 00:00:23.250
And so hopefully just try to follow along.

8
00:00:23.250 --> 00:00:25.120
I've made tons of little exercises.

9
00:00:25.120 --> 00:00:28.610
So you can type the word out, like
the function out 10 times, so by the end,

10
00:00:28.610 --> 00:00:30.960
you just can do it without thinking.

11
00:00:30.960 --> 00:00:33.510
All right, so
there's gonna be no programming.

12
00:00:33.510 --> 00:00:37.320
So I just wanted to go over a couple of
differences in Rust versus TypeScript.

13
00:00:37.320 --> 00:00:39.390
So first off, variables in TypeScript.

14
00:00:39.390 --> 00:00:40.000
Here you go.

15
00:00:40.000 --> 00:00:41.320
This should all look familiar.

16
00:00:41.320 --> 00:00:43.130
const foo, sort of a constant.

17
00:00:43.130 --> 00:00:45.620
let foo,
this is a variable you can change.

18
00:00:45.620 --> 00:00:49.010
const foo as a const,
this is a great C joke.

19
00:00:50.480 --> 00:00:51.210
Here's Rust.

20
00:00:51.210 --> 00:00:52.510
Rust looks pretty similar.

21
00:00:52.510 --> 00:00:53.410
This is a constant.

22
00:00:53.410 --> 00:00:54.700
It's always a constant.

23
00:00:54.700 --> 00:00:57.030
There's no changing it,
no matter what its data structure is.

24
00:00:57.030 --> 00:00:58.480
You say let foo.

25
00:00:58.480 --> 00:00:59.830
You cannot change foo.

26
00:00:59.830 --> 00:01:01.940
Let mut foo, you can change.

27
00:01:01.940 --> 00:01:03.220
You can change its value, all that.

28
00:01:03.220 --> 00:01:04.450
So there's only two types.

29
00:01:04.450 --> 00:01:07.530
There's not this third weird
version that partially applies.

30
00:01:08.590 --> 00:01:09.900
All right.

31
00:01:09.900 --> 00:01:13.330
Another thing that's unique about Rust
with variables is we have shadowing.

32
00:01:13.330 --> 00:01:15.700
So this would be illegal in TypeScript.

33
00:01:15.700 --> 00:01:18.700
This is completely legal in Rust.

34
00:01:18.700 --> 00:01:20.310
This is really, really handy.

35
00:01:20.310 --> 00:01:23.206
As you can see right here,
you can get a file, you can read a file,

36
00:01:23.206 --> 00:01:26.280
you can tokenize the files,
you can just have file, file contents.

37
00:01:26.280 --> 00:01:29.535
So you can do something where sometimes
you want to use the same name to describe

38
00:01:29.535 --> 00:01:30.767
this thing as it changes, and

39
00:01:30.767 --> 00:01:33.450
you can't do it in TypeScript
because you're changing types.

40
00:01:33.450 --> 00:01:36.476
But in Rust, shadowing is perfectly fine
as long as you use the left keyword right

41
00:01:36.476 --> 00:01:37.400
beforehand.

42
00:01:37.400 --> 00:01:40.260
So foo right here is say some vector.

43
00:01:40.260 --> 00:01:42.940
Foo right here is whatever
the method returns.

44
00:01:42.940 --> 00:01:44.580
Super cool, very, very handy.

45
00:01:44.580 --> 00:01:46.850
At first I hated it because I thought,
who would do this?

46
00:01:46.850 --> 00:01:47.900
This is bad programming.

47
00:01:47.900 --> 00:01:48.980
Why would you ever wanna do this?

48
00:01:48.980 --> 00:01:51.070
Why would we be changing types on a name?

49
00:01:51.070 --> 00:01:53.190
Now I can't help but
to use it all the time.

50
00:01:53.190 --> 00:01:56.520
I know it happens,
life changes that you use it.

51
00:01:56.520 --> 00:01:59.550
If conditions,
looks pretty straightforward, right?

52
00:01:59.550 --> 00:02:00.370
They're the same thing.

53
00:02:00.370 --> 00:02:01.370
Drop the parentheses.

54
00:02:01.370 --> 00:02:04.320
If you add the parentheses,
Rust is just gonna warn you say, hey,

55
00:02:04.320 --> 00:02:06.901
you can't do that, or
it's gonna say you can do that, but

56
00:02:06.901 --> 00:02:11.620
you shouldn't do that stylistically, you
don't need to do that, they're redundant.

57
00:02:11.620 --> 00:02:13.070
So, pretty straightforward.

58
00:02:13.070 --> 00:02:14.870
Loops, almost the same.

59
00:02:14.870 --> 00:02:17.390
So, here's like a basic for loop.

60
00:02:17.390 --> 00:02:19.230
In Rust, you use a range.

61
00:02:19.230 --> 00:02:23.433
So, for i in 0 up to but
not including 10, or for

62
00:02:23.433 --> 00:02:26.950
i starting at 0 up to and including 10.

63
00:02:26.950 --> 00:02:29.640
So, you've got inclusive,
exclusive ranges.

64
00:02:29.640 --> 00:02:31.310
You can also assign ranges to variables.

65
00:02:31.310 --> 00:02:32.460
You can use them.

66
00:02:32.460 --> 00:02:35.120
They're actually just like
a fundamental concept.

67
00:02:35.120 --> 00:02:37.090
Pretty fun, wild loops.

68
00:02:37.090 --> 00:02:39.690
Again, pretty much the same
between the two languages.

69
00:02:39.690 --> 00:02:42.780
You already know them,
just don't use the parenthesis you do.

70
00:02:42.780 --> 00:02:43.988
You'll get warned.

71
00:02:43.988 --> 00:02:45.100
Forever loops.

72
00:02:45.100 --> 00:02:48.490
You either have four colon,
colon or semicolon semicolon.

73
00:02:48.490 --> 00:02:50.610
That or wild true in rust.

74
00:02:50.610 --> 00:02:51.880
You just have loop.

75
00:02:51.880 --> 00:02:54.630
So pretty akin to something
like go that had four.

76
00:02:55.920 --> 00:02:59.680
Collections, when you're
iterating over a collection,

77
00:02:59.680 --> 00:03:04.430
here's your classic for of loop for
any object right here for entries.

78
00:03:04.430 --> 00:03:07.880
You have it for an array,
or you can go over indices.

79
00:03:07.880 --> 00:03:08.740
These all look familiar.

80
00:03:08.740 --> 00:03:13.440
I assume everyone here is familiar enough
with JavaScript to feel okay about that.

81
00:03:13.440 --> 00:03:17.034
You also have these things that exist
people associate them with this whole

82
00:03:17.034 --> 00:03:20.170
looping thing you have array dot
map which does clone your array,

83
00:03:20.170 --> 00:03:23.420
you have array dot filter which does
clone your array of array dot for

84
00:03:23.420 --> 00:03:25.940
each which iterates over your collection.

85
00:03:25.940 --> 00:03:29.878
Array reduce always a bad decision and
map dot for each the weirdest interface in

86
00:03:29.878 --> 00:03:33.300
the universe value slash key is
just the strangest way to do it.

87
00:03:33.300 --> 00:03:34.830
But that's how arrays do it.

88
00:03:34.830 --> 00:03:36.080
I know it's a map, though.

89
00:03:36.080 --> 00:03:37.190
It's a different data structure.

90
00:03:37.190 --> 00:03:38.390
Why'd you got to do that, TC39?

91
00:03:38.390 --> 00:03:39.470
You're killing me.

92
00:03:39.470 --> 00:03:42.640
All right, Rust,
it's a little bit different.

93
00:03:42.640 --> 00:03:44.645
You just go 4X in some array or

94
00:03:44.645 --> 00:03:49.480
in something you don't have to
have this little &amp;some array here.

95
00:03:49.480 --> 00:03:51.610
We will talk about that later.

96
00:03:51.610 --> 00:03:53.530
And you can do things like this.

97
00:03:53.530 --> 00:03:57.172
That's just a vector akin to a list,
and I can map over something,

98
00:03:57.172 --> 00:03:59.970
or filter over something, or do anything.

99
00:03:59.970 --> 00:04:03.990
And then at the end, I can just tell it
what data structure to become at the end.

100
00:04:03.990 --> 00:04:07.189
And so in this case, I'm telling
it to become a vector, or a list,

101
00:04:07.189 --> 00:04:08.940
of the same type that's up here.

102
00:04:08.940 --> 00:04:11.720
So probably I32, I think,
is the default one.

103
00:04:11.720 --> 00:04:13.100
I don't remember what it is.

104
00:04:13.100 --> 00:04:15.850
Functions, again pretty much the same.

105
00:04:15.850 --> 00:04:18.970
As you can see right here, function, fn.

106
00:04:18.970 --> 00:04:20.870
We just call them functions.

107
00:04:20.870 --> 00:04:24.340
Parameters again,
pretty much the same thing.

108
00:04:24.340 --> 00:04:28.520
Arg colon type, arg colon type.

109
00:04:28.520 --> 00:04:30.230
Everyone that's familiar with TypeScript,

110
00:04:30.230 --> 00:04:32.610
you already pretty much know
a huge amount of Rust syntax.

111
00:04:32.610 --> 00:04:36.830
There's only a few things that get
a little bit complicated with the syntax.

112
00:04:36.830 --> 00:04:41.222
Returns, this is like,
depending on how you view the world,

113
00:04:41.222 --> 00:04:43.750
this might be a little bit harder.

114
00:04:43.750 --> 00:04:48.497
So a very popular notion, especially
among them Twitter elite TypeScript devs,

115
00:04:48.497 --> 00:04:53.120
is don't do return values or
don't do return types on your functions.

116
00:04:53.120 --> 00:04:54.460
You have to do that in Rust.

117
00:04:54.460 --> 00:04:56.610
You've got to tell it
what you're gonna return.

118
00:04:56.610 --> 00:04:58.360
There's no implicit return types.

119
00:04:58.360 --> 00:05:01.640
You're just gonna have
to hashtag deal with it.

120
00:05:01.640 --> 00:05:03.800
And so this is legal in TypeScript.

121
00:05:03.800 --> 00:05:05.310
You just couldn't do that in Rust.

122
00:05:05.310 --> 00:05:07.710
You have to tell it,
I'm gonna return a usize.

123
00:05:07.710 --> 00:05:11.369
We'll go over the different types
of ints and all that just because,

124
00:05:11.369 --> 00:05:14.334
if you've only done TypeScript,
the word number has so

125
00:05:14.334 --> 00:05:17.070
many meetings,
whereas in Rust, it's reduced.

126
00:05:17.070 --> 00:05:19.430
All right, closures.

127
00:05:19.430 --> 00:05:21.160
These are all pretty straightforward.

128
00:05:21.160 --> 00:05:24.770
You can define a closure with
a parameter and then return it.

129
00:05:24.770 --> 00:05:27.130
Or you can do more of this auto return.

130
00:05:27.130 --> 00:05:29.480
If it's a single statement,
you don't have to do anything.

131
00:05:29.480 --> 00:05:30.320
Rust is identical.

132
00:05:30.320 --> 00:05:33.680
The only difference is that we use
a bar instead of a parentheses.

133
00:05:33.680 --> 00:05:35.770
It emotionally hurts me that we use a bar.

134
00:05:35.770 --> 00:05:39.285
But it does make sense when you know about
the unit because then you couldn't do

135
00:05:39.285 --> 00:05:41.090
an empty closure and it all breaks up.

136
00:05:41.090 --> 00:05:42.380
I believe that's the reasoning.

137
00:05:42.380 --> 00:05:43.080
I haven't read that.

138
00:05:43.080 --> 00:05:49.020
That's just my own personal, self-defense
mechanism for why we had to use bars.

139
00:05:49.020 --> 00:05:49.800
But there you go.

140
00:05:49.800 --> 00:05:51.120
Pretty much identical, right?

141
00:05:51.120 --> 00:05:53.360
Nothing seems too hard here.

142
00:05:53.360 --> 00:05:58.134
Classes and methods, again,
TypeScript, you do class, properties,

143
00:05:58.134 --> 00:06:02.350
constructor, methods,
static, private, protected.

144
00:06:02.350 --> 00:06:05.610
You have all these different variations
in which you can work on classes.

145
00:06:05.610 --> 00:06:08.672
I know some of you right now,
you see the word class.

146
00:06:08.672 --> 00:06:10.298
Man, you're like getting hot and

147
00:06:10.298 --> 00:06:14.010
bothered because, we're functional
programmers only in TypeScript land.

148
00:06:14.010 --> 00:06:14.570
I get it.

149
00:06:14.570 --> 00:06:16.970
I'm sorry this is traumatic for
some of you.

150
00:06:16.970 --> 00:06:19.110
Now Rust does it a little bit different.

151
00:06:19.110 --> 00:06:22.050
I want you to really look at this just for
a moment,

152
00:06:22.050 --> 00:06:26.810
is that you define a struct, which is a
series of properties or pub properties for

153
00:06:26.810 --> 00:06:29.730
things people can access on the outside.

154
00:06:29.730 --> 00:06:34.034
So this would be private, this is public,
there's no protected, there's no

155
00:06:34.034 --> 00:06:38.533
package level scoping is just pub private
and then you have an implementation and so

156
00:06:38.533 --> 00:06:43.170
then I say hey the implementation for
foo wish that was the name of my struct.

157
00:06:43.170 --> 00:06:45.836
Here is a function this
would be a static function,

158
00:06:45.836 --> 00:06:49.340
this would be a public static
function that anyone can use.

159
00:06:49.340 --> 00:06:52.880
This would be a function that refers
to itself or an instance, method,

160
00:06:52.880 --> 00:06:54.610
or a method as we'd call it.

161
00:06:54.610 --> 00:06:57.420
This would be a method that
could change values on itself.

162
00:06:57.420 --> 00:07:01.905
You have to define each type of function,
cuz each one has different implications

163
00:07:01.905 --> 00:07:06.080
and that will become evident when
we talk about the borrow checker.

164
00:07:06.080 --> 00:07:07.080
You can also make them public.

165
00:07:07.080 --> 00:07:12.038
So this is a method in which takes
not a reference to yourself, but

166
00:07:12.038 --> 00:07:13.400
the self itself.

167
00:07:13.400 --> 00:07:15.985
That may be a little bit confusing
what the heck's the difference

168
00:07:15.985 --> 00:07:17.395
between a reference to yourself and

169
00:07:17.395 --> 00:07:20.600
a self will get there but each one's
a little you know a little different.

170
00:07:20.600 --> 00:07:24.300
So what stuck out to you the difference
between- Class definition.

171
00:07:25.750 --> 00:07:27.830
And how Rust does it.

172
00:07:27.830 --> 00:07:29.440
Just one thing.

173
00:07:29.440 --> 00:07:32.908
&gt;&gt; The data and the behavior
are defined in separate blocks,

174
00:07:32.908 --> 00:07:35.150
very explicitly separate blocks.

175
00:07:35.150 --> 00:07:35.890
&gt;&gt; Yes.

176
00:07:35.890 --> 00:07:40.292
So if you couldn't hear that data and
behavior are defined in two blocks,

177
00:07:40.292 --> 00:07:43.020
this may seem like a trivial point.

178
00:07:43.020 --> 00:07:45.830
But trust me,
this is the coolest thing in the universe.

179
00:07:45.830 --> 00:07:48.570
This will blow your mind
by the end of the day.

180
00:07:48.570 --> 00:07:50.090
This is the greatest thing ever.

181
00:07:50.090 --> 00:07:53.546
This allows for composing behavior,
not upfront definition of behavior,

182
00:07:53.546 --> 00:07:56.790
because that's one thing that classes
are really frustrating about.

183
00:07:56.790 --> 00:07:58.970
And that's why you have abstract classes.

184
00:07:58.970 --> 00:08:00.653
This is why you have hierarchies,

185
00:08:00.653 --> 00:08:04.140
because you can't wrap on additional
behavior in any easy way.

186
00:08:04.140 --> 00:08:05.650
You have to IOC it.

187
00:08:05.650 --> 00:08:06.710
You have to do something else.

188
00:08:06.710 --> 00:08:07.790
You have to create a new class.

189
00:08:07.790 --> 00:08:12.010
You have to compose it in a more
difficult way than you can say with Rust.

190
00:08:12.010 --> 00:08:13.130
So very exciting.

191
00:08:13.130 --> 00:08:14.218
Trust me.

192
00:08:14.218 --> 00:08:15.440
We got a question.

193
00:08:15.440 --> 00:08:17.230
&gt;&gt; In Go, we have structing composition.

194
00:08:18.340 --> 00:08:21.550
&gt;&gt; Go has some interesting things, right?

195
00:08:21.550 --> 00:08:28.708
You can inherit properties
from a separate struct,

196
00:08:28.708 --> 00:08:34.900
but you don't inherit their behaviors.

197
00:08:34.900 --> 00:08:37.553
I don't know all the specifics
of how they can do that,

198
00:08:37.553 --> 00:08:40.740
but it's not the same because you
do define the methods later on.

199
00:08:40.740 --> 00:08:43.628
But the methods require the receiver
to be of the same type, and

200
00:08:43.628 --> 00:08:47.190
I believe Go has some form of duct slash
structural typing that makes it work.

201
00:08:49.020 --> 00:08:49.840
Yeah.

202
00:08:49.840 --> 00:08:52.040
&gt;&gt; So struct is like a interface and

203
00:08:52.040 --> 00:08:56.490
imple is like a class that
implements that interface.

204
00:08:56.490 --> 00:09:01.505
&gt;&gt; No, so struct is not an interface
struct is a concrete set of properties and

205
00:09:01.505 --> 00:09:03.495
one thing you have to break and

206
00:09:03.495 --> 00:09:08.920
we'll talk about this here shortly is
that memory plays a huge role into this.

207
00:09:08.920 --> 00:09:11.880
When you're in JavaScript,
you just create things.

208
00:09:11.880 --> 00:09:13.850
You don't think about how
they're laid out memory.

209
00:09:13.850 --> 00:09:15.950
You don't think about
what it's actually doing.

210
00:09:15.950 --> 00:09:20.169
In Rust, you have to define the blueprint
of exactly how is this thing gonna be laid

211
00:09:20.169 --> 00:09:22.320
out, and then Rust lays it out in memory.

212
00:09:22.320 --> 00:09:25.840
So this actually has a defined size to it.

213
00:09:25.840 --> 00:09:28.490
There is a certain amount of bytes
that are associated with it.

214
00:09:28.490 --> 00:09:31.740
And so this is the concrete item,
you can instantiate a foo.

215
00:09:32.740 --> 00:09:37.480
This is just the implementation it
creates functions that will hang off

216
00:09:37.480 --> 00:09:42.141
your struct so that way you can go
struct dot whatever or foo dot this and

217
00:09:42.141 --> 00:09:47.049
you can call an instance method or
foo colon colon to call a static method.

218
00:09:49.830 --> 00:09:51.560
Alright, interfaces.

219
00:09:51.560 --> 00:09:55.180
Interfaces are really where the super
secret sauce of Rust takes off.

220
00:09:55.180 --> 00:09:56.800
Not so great in TypeScript.

221
00:09:56.800 --> 00:09:58.000
You have two different
things in TypeScript.

222
00:09:58.000 --> 00:09:59.790
You have type and you have interfaces.

223
00:09:59.790 --> 00:10:03.940
Interfaces particularly I'm not very
fond of in TypeScript for two reasons.

224
00:10:03.940 --> 00:10:05.650
One, you can have properties on interface.

225
00:10:05.650 --> 00:10:07.250
I just think that's not a good move.

226
00:10:07.250 --> 00:10:08.410
They like that move.

227
00:10:08.410 --> 00:10:11.330
And second, you can do this
whole interface merging thing.

228
00:10:11.330 --> 00:10:14.725
So if I define foo here, and
then I redefine foo here,

229
00:10:14.725 --> 00:10:17.980
foo is the amalgamation
of both those interfaces.

230
00:10:17.980 --> 00:10:21.970
So you'll actually have properties,
method, and hey, another method required

231
00:10:21.970 --> 00:10:24.991
to be a foo, which both have some
cool things you can do with it,

232
00:10:24.991 --> 00:10:27.955
meaning that if you're trying
to integrate with a library but

233
00:10:27.955 --> 00:10:31.810
extend it to have your own behavior,
you can add methods to interfaces.

234
00:10:31.810 --> 00:10:34.998
But at the same time you run into
these bugs where you're like,

235
00:10:34.998 --> 00:10:36.150
why is this like this?

236
00:10:36.150 --> 00:10:37.300
I'm looking at the definition.

237
00:10:37.300 --> 00:10:38.840
Why do I need this extra method on here?

238
00:10:38.840 --> 00:10:40.722
It's because someone
else has defined it and

239
00:10:40.722 --> 00:10:43.620
you don't realize you've
just been interface merged.

240
00:10:43.620 --> 00:10:45.130
It's unique.

241
00:10:45.130 --> 00:10:47.850
It's cool, but it is what it is.

242
00:10:47.850 --> 00:10:52.871
Whereas, Rust it's a little different
trait is effectively an interface and

243
00:10:52.871 --> 00:10:57.580
you can define the same things,
but no properties are allowed.

244
00:10:57.580 --> 00:10:59.970
And how you implement a trait
is you do the same thing.

245
00:10:59.970 --> 00:11:06.950
The implementation of Foo for
implementation of trait Foo for my struct.

246
00:11:06.950 --> 00:11:08.520
Struct would be just like a struct.

247
00:11:08.520 --> 00:11:10.160
It can also be an enum.

248
00:11:10.160 --> 00:11:12.070
So that's the syntax for it.

249
00:11:12.070 --> 00:11:14.494
And then you put in the methods
that have been defined here, and

250
00:11:14.494 --> 00:11:17.120
only the methods that
have been defined there.

251
00:11:17.120 --> 00:11:17.620
Yep.
Mark.

252
00:11:18.620 --> 00:11:22.434
&gt;&gt; Could you elaborate on why defining
properties on an interface is bad and

253
00:11:22.434 --> 00:11:24.970
why you would want to avoid it?

254
00:11:24.970 --> 00:11:28.270
&gt;&gt; In general, I always feel like
prop this is just a personal belief.

255
00:11:28.270 --> 00:11:29.760
Okay, we're getting into
the personal realm.

256
00:11:29.760 --> 00:11:32.440
I'll accept that as being true.

257
00:11:32.440 --> 00:11:34.930
Is that properties
are an implementation detail.

258
00:11:34.930 --> 00:11:38.901
They are something that I'm gonna
manipulate thei my state bag,

259
00:11:38.901 --> 00:11:42.930
this is how I interact with my system,
my closed system.

260
00:11:42.930 --> 00:11:45.980
And so I've just never been fond
of properties on interfaces.

261
00:11:45.980 --> 00:11:49.352
A lot of languages never allow you to
do that Java, plenty of other ones,

262
00:11:49.352 --> 00:11:50.610
Rust, whatever.

263
00:11:50.610 --> 00:11:54.370
And so it's a unique take
to allow properties on it.

264
00:11:54.370 --> 00:11:56.210
I'm not sure why they made that decision.

265
00:11:56.210 --> 00:11:59.881
I bet you there's a great decision or
a great reason for it, it just feels funny

266
00:11:59.881 --> 00:12:03.946
to me to have properties on an interface,
because interfaces aren't supposed to have

267
00:12:03.946 --> 00:12:08.270
any implementation requirements other than
what methods you're supposed to have.

268
00:12:08.270 --> 00:12:12.862
This one's both having your data shape and
what methods you should have,

269
00:12:12.862 --> 00:12:14.799
which is unique in some sense.

270
00:12:16.198 --> 00:12:19.700
Any who because,
who cares how you define length.

271
00:12:19.700 --> 00:12:22.567
If it's a function, you can define
it however you want it could be

272
00:12:22.567 --> 00:12:26.950
amalgamation of three different properties
but by, enforcing a property specifically.

273
00:12:26.950 --> 00:12:29.840
Now you have a different way
you have to tackle things.

274
00:12:29.840 --> 00:12:31.980
It is making an implementation detail for
you.

275
00:12:31.980 --> 00:12:33.560
There you go.
All right, one more question.

276
00:12:33.560 --> 00:12:35.370
&gt;&gt; Do you still need a struct?

277
00:12:36.620 --> 00:12:37.280
&gt;&gt; For a trait?

278
00:12:38.460 --> 00:12:41.200
If you're asking,
do you still need a struct, yes.

279
00:12:41.200 --> 00:12:45.870
Structs and traits are two
unrelated things in some sense.

280
00:12:45.870 --> 00:12:50.360
A struct is your property layout,
exactly what's gonna be on the item.

281
00:12:50.360 --> 00:12:54.440
A trait is an implementation
of a method on that struct.

282
00:12:54.440 --> 00:12:56.290
It's how you can interact with the struct.

283
00:12:56.290 --> 00:12:57.990
It's an interface onto it.

284
00:12:59.270 --> 00:13:00.030
Yeah?

285
00:13:00.030 --> 00:13:03.830
&gt;&gt; Can you use a struct without
having an implementation?

286
00:13:03.830 --> 00:13:05.750
&gt;&gt; Can you use a struct without
having an implementation?

287
00:13:05.750 --> 00:13:06.420
Absolutely.

288
00:13:06.420 --> 00:13:08.380
It's just a series of properties.

289
00:13:08.380 --> 00:13:09.550
Nothing you don't need.

290
00:13:09.550 --> 00:13:11.990
If you've ever used C, you've got it.

291
00:13:11.990 --> 00:13:14.270
It's effectively the same
thing as a C struct.

292
00:13:14.270 --> 00:13:16.850
It may be packed in binary,
slightly different.

293
00:13:16.850 --> 00:13:19.910
I believe you can even make it
pack in binary the same way, but

294
00:13:19.910 --> 00:13:21.110
it has its own packing.

295
00:13:21.110 --> 00:13:23.060
It does what it does.

296
00:13:23.060 --> 00:13:24.310
It's just a series of properties.

297
00:13:24.310 --> 00:13:25.070
That's all it is.

298
00:13:25.070 --> 00:13:27.170
So you define your data shape.

299
00:13:27.170 --> 00:13:30.850
Then you define how that data
shape interacts with the world.

300
00:13:30.850 --> 00:13:32.920
So it's different,
it allows for composing.

