[00:00:00]
>> So we're just going to jump right in and start going over the basics there's no code in this section but I just wanted to kind of show you some things so that as we start doing it you can try to recall from your memory the more you recall from your memory the better you're going to be the more it's going to set deep within your head and then you can just start doing it yourself For me, I had to type something out like four or five times before it really sticks.

[00:00:21]
And so hopefully just try to follow along. I've made tons of little exercises. So you can type the word out, like the function out 10 times, so by the end, you just can do it without thinking. All right, so there's gonna be no programming. So I just wanted to go over a couple of differences in Rust versus TypeScript.

[00:00:37]
So first off, variables in TypeScript. Here you go. This should all look familiar. const foo, sort of a constant. let foo, this is a variable you can change. const foo as a const, this is a great C joke. Here's Rust. Rust looks pretty similar. This is a constant.

[00:00:53]
It's always a constant. There's no changing it, no matter what its data structure is. You say let foo. You cannot change foo. Let mut foo, you can change. You can change its value, all that. So there's only two types. There's not this third weird version that partially applies.

[00:01:08]
All right. Another thing that's unique about Rust with variables is we have shadowing. So this would be illegal in TypeScript. This is completely legal in Rust. This is really, really handy. As you can see right here, you can get a file, you can read a file, you can tokenize the files, you can just have file, file contents.

[00:01:26]
So you can do something where sometimes you want to use the same name to describe this thing as it changes, and you can't do it in TypeScript because you're changing types. But in Rust, shadowing is perfectly fine as long as you use the left keyword right beforehand. So foo right here is say some vector.

[00:01:40]
Foo right here is whatever the method returns. Super cool, very, very handy. At first I hated it because I thought, who would do this? This is bad programming. Why would you ever wanna do this? Why would we be changing types on a name? Now I can't help but to use it all the time.

[00:01:53]
I know it happens, life changes that you use it. If conditions, looks pretty straightforward, right? They're the same thing. Drop the parentheses. If you add the parentheses, Rust is just gonna warn you say, hey, you can't do that, or it's gonna say you can do that, but you shouldn't do that stylistically, you don't need to do that, they're redundant.

[00:02:11]
So, pretty straightforward. Loops, almost the same. So, here's like a basic for loop. In Rust, you use a range. So, for i in 0 up to but not including 10, or for i starting at 0 up to and including 10. So, you've got inclusive, exclusive ranges. You can also assign ranges to variables.

[00:02:31]
You can use them. They're actually just like a fundamental concept. Pretty fun, wild loops. Again, pretty much the same between the two languages. You already know them, just don't use the parenthesis you do. You'll get warned. Forever loops. You either have four colon, colon or semicolon semicolon. That or wild true in rust.

[00:02:50]
You just have loop. So pretty akin to something like go that had four. Collections, when you're iterating over a collection, here's your classic for of loop for any object right here for entries. You have it for an array, or you can go over indices. These all look familiar.

[00:03:08]
I assume everyone here is familiar enough with JavaScript to feel okay about that. You also have these things that exist people associate them with this whole looping thing you have array dot map which does clone your array, you have array dot filter which does clone your array of array dot for each which iterates over your collection.

[00:03:25]
Array reduce always a bad decision and map dot for each the weirdest interface in the universe value slash key is just the strangest way to do it. But that's how arrays do it. I know it's a map, though. It's a different data structure. Why'd you got to do that, TC39?

[00:03:38]
You're killing me. All right, Rust, it's a little bit different. You just go 4X in some array or in something you don't have to have this little &some array here. We will talk about that later. And you can do things like this. That's just a vector akin to a list, and I can map over something, or filter over something, or do anything.

[00:03:59]
And then at the end, I can just tell it what data structure to become at the end. And so in this case, I'm telling it to become a vector, or a list, of the same type that's up here. So probably I32, I think, is the default one. I don't remember what it is.

[00:04:13]
Functions, again pretty much the same. As you can see right here, function, fn. We just call them functions. Parameters again, pretty much the same thing. Arg colon type, arg colon type. Everyone that's familiar with TypeScript, you already pretty much know a huge amount of Rust syntax. There's only a few things that get a little bit complicated with the syntax.

[00:04:36]
Returns, this is like, depending on how you view the world, this might be a little bit harder. So a very popular notion, especially among them Twitter elite TypeScript devs, is don't do return values or don't do return types on your functions. You have to do that in Rust.

[00:04:54]
You've got to tell it what you're gonna return. There's no implicit return types. You're just gonna have to hashtag deal with it. And so this is legal in TypeScript. You just couldn't do that in Rust. You have to tell it, I'm gonna return a usize. We'll go over the different types of ints and all that just because, if you've only done TypeScript, the word number has so many meetings, whereas in Rust, it's reduced.

[00:05:17]
All right, closures. These are all pretty straightforward. You can define a closure with a parameter and then return it. Or you can do more of this auto return. If it's a single statement, you don't have to do anything. Rust is identical. The only difference is that we use a bar instead of a parentheses.

[00:05:33]
It emotionally hurts me that we use a bar. But it does make sense when you know about the unit because then you couldn't do an empty closure and it all breaks up. I believe that's the reasoning. I haven't read that. That's just my own personal, self-defense mechanism for why we had to use bars.

[00:05:49]
But there you go. Pretty much identical, right? Nothing seems too hard here. Classes and methods, again, TypeScript, you do class, properties, constructor, methods, static, private, protected. You have all these different variations in which you can work on classes. I know some of you right now, you see the word class.

[00:06:08]
Man, you're like getting hot and bothered because, we're functional programmers only in TypeScript land. I get it. I'm sorry this is traumatic for some of you. Now Rust does it a little bit different. I want you to really look at this just for a moment, is that you define a struct, which is a series of properties or pub properties for things people can access on the outside.

[00:06:29]
So this would be private, this is public, there's no protected, there's no package level scoping is just pub private and then you have an implementation and so then I say hey the implementation for foo wish that was the name of my struct. Here is a function this would be a static function, this would be a public static function that anyone can use.

[00:06:49]
This would be a function that refers to itself or an instance, method, or a method as we'd call it. This would be a method that could change values on itself. You have to define each type of function, cuz each one has different implications and that will become evident when we talk about the borrow checker.

[00:07:06]
You can also make them public. So this is a method in which takes not a reference to yourself, but the self itself. That may be a little bit confusing what the heck's the difference between a reference to yourself and a self will get there but each one's a little you know a little different.

[00:07:20]
So what stuck out to you the difference between- Class definition. And how Rust does it. Just one thing.
>> The data and the behavior are defined in separate blocks, very explicitly separate blocks.
>> Yes. So if you couldn't hear that data and behavior are defined in two blocks, this may seem like a trivial point.

[00:07:43]
But trust me, this is the coolest thing in the universe. This will blow your mind by the end of the day. This is the greatest thing ever. This allows for composing behavior, not upfront definition of behavior, because that's one thing that classes are really frustrating about. And that's why you have abstract classes.

[00:07:58]
This is why you have hierarchies, because you can't wrap on additional behavior in any easy way. You have to IOC it. You have to do something else. You have to create a new class. You have to compose it in a more difficult way than you can say with Rust.

[00:08:12]
So very exciting. Trust me. We got a question.
>> In Go, we have structing composition.
>> Go has some interesting things, right? You can inherit properties from a separate struct, but you don't inherit their behaviors. I don't know all the specifics of how they can do that, but it's not the same because you do define the methods later on.

[00:08:40]
But the methods require the receiver to be of the same type, and I believe Go has some form of duct slash structural typing that makes it work. Yeah.
>> So struct is like a interface and imple is like a class that implements that interface.
>> No, so struct is not an interface struct is a concrete set of properties and one thing you have to break and we'll talk about this here shortly is that memory plays a huge role into this.

[00:09:08]
When you're in JavaScript, you just create things. You don't think about how they're laid out memory. You don't think about what it's actually doing. In Rust, you have to define the blueprint of exactly how is this thing gonna be laid out, and then Rust lays it out in memory.

[00:09:22]
So this actually has a defined size to it. There is a certain amount of bytes that are associated with it. And so this is the concrete item, you can instantiate a foo. This is just the implementation it creates functions that will hang off your struct so that way you can go struct dot whatever or foo dot this and you can call an instance method or foo colon colon to call a static method.

[00:09:49]
Alright, interfaces. Interfaces are really where the super secret sauce of Rust takes off. Not so great in TypeScript. You have two different things in TypeScript. You have type and you have interfaces. Interfaces particularly I'm not very fond of in TypeScript for two reasons. One, you can have properties on interface.

[00:10:05]
I just think that's not a good move. They like that move. And second, you can do this whole interface merging thing. So if I define foo here, and then I redefine foo here, foo is the amalgamation of both those interfaces. So you'll actually have properties, method, and hey, another method required to be a foo, which both have some cool things you can do with it, meaning that if you're trying to integrate with a library but extend it to have your own behavior, you can add methods to interfaces.

[00:10:31]
But at the same time you run into these bugs where you're like, why is this like this? I'm looking at the definition. Why do I need this extra method on here? It's because someone else has defined it and you don't realize you've just been interface merged. It's unique.

[00:10:45]
It's cool, but it is what it is. Whereas, Rust it's a little different trait is effectively an interface and you can define the same things, but no properties are allowed. And how you implement a trait is you do the same thing. The implementation of Foo for implementation of trait Foo for my struct.

[00:11:06]
Struct would be just like a struct. It can also be an enum. So that's the syntax for it. And then you put in the methods that have been defined here, and only the methods that have been defined there. Yep. Mark.
>> Could you elaborate on why defining properties on an interface is bad and why you would want to avoid it?

[00:11:24]

>> In general, I always feel like prop this is just a personal belief. Okay, we're getting into the personal realm. I'll accept that as being true. Is that properties are an implementation detail. They are something that I'm gonna manipulate thei my state bag, this is how I interact with my system, my closed system.

[00:11:42]
And so I've just never been fond of properties on interfaces. A lot of languages never allow you to do that Java, plenty of other ones, Rust, whatever. And so it's a unique take to allow properties on it. I'm not sure why they made that decision. I bet you there's a great decision or a great reason for it, it just feels funny to me to have properties on an interface, because interfaces aren't supposed to have any implementation requirements other than what methods you're supposed to have.

[00:12:08]
This one's both having your data shape and what methods you should have, which is unique in some sense. Any who because, who cares how you define length. If it's a function, you can define it however you want it could be amalgamation of three different properties but by, enforcing a property specifically.

[00:12:26]
Now you have a different way you have to tackle things. It is making an implementation detail for you. There you go. All right, one more question.
>> Do you still need a struct?
>> For a trait? If you're asking, do you still need a struct, yes. Structs and traits are two unrelated things in some sense.

[00:12:45]
A struct is your property layout, exactly what's gonna be on the item. A trait is an implementation of a method on that struct. It's how you can interact with the struct. It's an interface onto it. Yeah?
>> Can you use a struct without having an implementation?
>> Can you use a struct without having an implementation?

[00:13:05]
Absolutely. It's just a series of properties. Nothing you don't need. If you've ever used C, you've got it. It's effectively the same thing as a C struct. It may be packed in binary, slightly different. I believe you can even make it pack in binary the same way, but it has its own packing.

[00:13:21]
It does what it does. It's just a series of properties. That's all it is. So you define your data shape. Then you define how that data shape interacts with the world. So it's different, it allows for composing.

