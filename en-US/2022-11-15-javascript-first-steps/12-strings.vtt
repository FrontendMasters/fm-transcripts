WEBVTT

1
00:00:00.015 --> 00:00:04.268
All right, so strings, as we have already
seen show up all the time in JavaScript.

2
00:00:04.268 --> 00:00:07.293
In our JavaScript lives,
we will run into strings a lot.

3
00:00:07.293 --> 00:00:10.117
And it's important to know
how to work with them and

4
00:00:10.117 --> 00:00:12.780
some of the tricks they can do.

5
00:00:12.780 --> 00:00:14.255
So, let's talk about working with strings.

6
00:00:14.255 --> 00:00:18.059
Or again, as I like to think of them,
the friendship bracelets of JavaScript.

7
00:00:18.059 --> 00:00:23.576
[LAUGH] So what are strings made up of?

8
00:00:23.576 --> 00:00:27.488
When you're trying to put together one
of these little friendship bracelets you

9
00:00:27.488 --> 00:00:30.089
might have a bunch of beads
each with a letter on them.

10
00:00:30.089 --> 00:00:36.595
In JavaScript, we have strings that
are made up of smaller units of text.

11
00:00:36.595 --> 00:00:40.231
Anybody know what we call
these tiny little units

12
00:00:40.231 --> 00:00:44.763
of text that usually correspond
to something like a letter?

13
00:00:44.763 --> 00:00:45.989
Any idea what we call these?

14
00:00:48.110 --> 00:00:51.268
So we call these little units or
these little letter beads.

15
00:00:51.268 --> 00:00:52.382
&gt;&gt; Characters.

16
00:00:52.382 --> 00:00:55.253
&gt;&gt; Characters, thank you Chat, beautiful.

17
00:00:55.253 --> 00:00:57.713
So characters are what
strings are made of.

18
00:00:57.713 --> 00:01:04.630
Each string is made up of zero or
more character units.

19
00:01:04.630 --> 00:01:09.609
And we could think of these as the little
beads that we could string together to

20
00:01:09.609 --> 00:01:13.064
spell out a word or
a whole sentence or whatever else.

21
00:01:13.064 --> 00:01:14.860
Maybe it's just emoji, who knows?

22
00:01:16.090 --> 00:01:23.070
So characters are the kind of
individual units that make up a string.

23
00:01:23.070 --> 00:01:28.759
So earlier when we had
the .length that we saw returned,

24
00:01:28.759 --> 00:01:33.510
we saw type of some string
.length as a number.

25
00:01:35.180 --> 00:01:42.579
The thing that that number to is
the number of characters in the string.

26
00:01:42.579 --> 00:01:46.938
So in this case, for example, maybe
the second example is easier to find.

27
00:01:46.938 --> 00:01:50.624
So what do you think super in
quotes .length is going to return?

28
00:01:50.624 --> 00:01:51.422
&gt;&gt; Five.

29
00:01:51.422 --> 00:01:53.055
&gt;&gt; Five, cuz we can count that.

30
00:01:53.055 --> 00:01:54.770
Let's just confirm.

31
00:01:57.133 --> 00:02:00.264
Okay, now, how about
supercalifragilisticexpialidocious

32
00:02:00.264 --> 00:02:00.859
.length?

33
00:02:00.859 --> 00:02:03.531
Does anybody off the top of their heads
know how to count a string that long?

34
00:02:03.531 --> 00:02:04.309
No, not me.

35
00:02:04.309 --> 00:02:07.892
Let's find out,
how long is this super long string?

36
00:02:07.892 --> 00:02:08.604
I didn't copy.

37
00:02:11.939 --> 00:02:13.030
Let's find out.

38
00:02:14.770 --> 00:02:16.212
Okay, it's not working.

39
00:02:16.212 --> 00:02:23.285
Let's type it out,
fragilisticexpialidocious.

40
00:02:23.285 --> 00:02:24.936
34 characters that's too long,

41
00:02:24.936 --> 00:02:28.301
it's too many characters that's why
I couldn't even handle it [LAUGH].

42
00:02:28.301 --> 00:02:34.275
[LAUGH] So when we wanna find out how
many characters we're working with

43
00:02:34.275 --> 00:02:40.160
in a particular string, we can use
the .length property to tell us.

44
00:02:40.160 --> 00:02:44.686
And, well, just another note,
let's say we had a string like before.

45
00:02:44.686 --> 00:02:47.630
I had some string .length.

46
00:02:49.922 --> 00:02:53.007
If I type that in, I get 11.

47
00:02:53.007 --> 00:02:55.745
So some four letters,
string as five letter six letters.

48
00:02:55.745 --> 00:02:58.934
Well, where's that extra
letter coming from?

49
00:02:58.934 --> 00:02:59.713
&gt;&gt; Space.

50
00:02:59.713 --> 00:03:00.615
&gt;&gt; The space.

51
00:03:00.615 --> 00:03:03.551
The space itself is a character.

52
00:03:03.551 --> 00:03:08.078
So I can even have a string
of just a space, and

53
00:03:08.078 --> 00:03:11.423
that is still a valid character.

54
00:03:11.423 --> 00:03:14.080
Space is as much a thing as a letter is.

55
00:03:15.090 --> 00:03:18.763
We can also have a string
with no characters,

56
00:03:18.763 --> 00:03:21.574
which is called the empty string.

57
00:03:21.574 --> 00:03:26.422
And if I asked for the length of that
it will tell me 0, still a string.

58
00:03:26.422 --> 00:03:29.334
Even though it has nothing inside of it,

59
00:03:29.334 --> 00:03:34.660
it's still a value of typestring which
I can prove to myself with typeof.

60
00:03:36.180 --> 00:03:40.635
So, characters are the units
from which strings are made up.

61
00:03:40.635 --> 00:03:45.208
And in each string,
characters are in a specific order, right?

62
00:03:45.208 --> 00:03:49.905
It would be kind of chaos if they weren't,
if every word or sentence that we

63
00:03:49.905 --> 00:03:54.391
tried to type was just like whatever
order you want, a jumble of beads.

64
00:03:54.391 --> 00:03:59.198
When we string together these beads,
these little characters we want

65
00:03:59.198 --> 00:04:03.850
them to go in a specific order, and
so each character gets a number.

66
00:04:03.850 --> 00:04:06.222
So, if we have our string

67
00:04:10.351 --> 00:04:15.576
ALOHA, Like on that little letter bead.

68
00:04:15.576 --> 00:04:22.691
We're imagining this on like a little
beaded bracelet or something like that.

69
00:04:22.691 --> 00:04:27.940
Each of these characters in our
string gets assigned a number.

70
00:04:27.940 --> 00:04:31.407
And we start in JavaScript at zero.

71
00:04:31.407 --> 00:04:35.678
So some people will say it looks
like this, you have each character.

72
00:04:35.678 --> 00:04:36.364
In this case,

73
00:04:36.364 --> 00:04:40.559
I'm drawing them like little beads just to
indicate that there are individual units.

74
00:04:40.559 --> 00:04:43.629
Some people would say, so we have

75
00:04:45.394 --> 00:04:52.764
Let's say the number 0 assigned to the A,
the number 1, L, 2, 3, 4.

76
00:04:52.764 --> 00:04:56.868
That essentially each bead
kind of gets its own number.

77
00:04:56.868 --> 00:04:59.253
This is a totally valid
way to think about it.

78
00:04:59.253 --> 00:05:03.961
I would say another way that
we could think about it,

79
00:05:03.961 --> 00:05:09.204
that might come in handy later
in our JavaScript lives is to

80
00:05:09.204 --> 00:05:15.315
think about 0 as being kind of
the point at which the string starts.

81
00:05:15.315 --> 00:05:18.454
And 1 at being the point,

82
00:05:18.454 --> 00:05:23.888
one character later,
and so on and so forth.

83
00:05:23.888 --> 00:05:30.595
So 2, 3, 4 and then at the end
of the string would come a five,

84
00:05:30.595 --> 00:05:35.839
and if we ask this, hey,
how long is this string?

85
00:05:35.839 --> 00:05:40.460
It'll say ALOHA has five characters,
it's five characters long.

86
00:05:40.460 --> 00:05:46.072
And if we asked it,
what is the character at position one?

87
00:05:46.072 --> 00:05:51.814
Let's say, it would tell me which
character starts at that number,

88
00:05:51.814 --> 00:05:53.390
at that one.

89
00:05:53.390 --> 00:05:57.463
So in this case, that would be L, exactly.

90
00:05:57.463 --> 00:06:02.169
So these are two different ways that
you can think about the numbers

91
00:06:02.169 --> 00:06:04.280
assigned to each character.

92
00:06:04.280 --> 00:06:10.867
One is that each kind of
chunk gets its own number.

93
00:06:10.867 --> 00:06:15.006
And the other is that the numbers actually
kind of appear in between the chunks

94
00:06:15.006 --> 00:06:16.541
in between the characters.

95
00:06:16.541 --> 00:06:21.986
And they are an indicator
of which character

96
00:06:21.986 --> 00:06:26.559
starts there, if that makes sense.

97
00:06:26.559 --> 00:06:31.435
Later on in life,
we might find that having that second

98
00:06:31.435 --> 00:06:36.312
mental representation is
helpful when we're talking

99
00:06:36.312 --> 00:06:41.412
about substrings or
smaller strings within the string.

100
00:06:41.412 --> 00:06:44.714
But for now, either way, whichever way
you find more useful to think about it,

101
00:06:44.714 --> 00:06:45.712
both of them are valid.

