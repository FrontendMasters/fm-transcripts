WEBVTT

1
00:00:00.053 --> 00:00:05.404
Some of these other operators,
they are similar to math class.

2
00:00:05.404 --> 00:00:09.486
They tell us how things compare.

3
00:00:09.486 --> 00:00:14.043
So we also have operators for like
greater than, less than, greater than, or

4
00:00:14.043 --> 00:00:18.892
equal to, less than or equal to, and they
involve our friends the angle brackets.

5
00:00:18.892 --> 00:00:23.406
So, the right angle
bracket is greater than

6
00:00:23.406 --> 00:00:27.310
the left angle bracket is less than and

7
00:00:27.310 --> 00:00:32.190
then if we put an equal
sign after those are the or

8
00:00:32.190 --> 00:00:38.674
equal to versions, and
we can kind of guess what type of value?

9
00:00:38.674 --> 00:00:44.001
If I asked JavaScript,
is 5 greater than 4?

10
00:00:44.001 --> 00:00:47.182
What kind of value do you think I'm gonna
get back as an answer to this question?

11
00:00:47.182 --> 00:00:49.139
&gt;&gt; Boolean.

12
00:00:49.139 --> 00:00:51.432
&gt;&gt; A boolean, true or false, right?

13
00:00:51.432 --> 00:00:55.208
True or false, 5 is greater than 4?

14
00:00:55.208 --> 00:00:56.467
We can confirm that.

15
00:01:01.187 --> 00:01:02.095
Good, we can confirm that.

16
00:01:02.095 --> 00:01:05.803
So 5 is greater than 4, true, as expected.

17
00:01:05.803 --> 00:01:10.595
5 is less than 4, false, as expected.

18
00:01:10.595 --> 00:01:14.495
So again, we have a lot of the time
we're asking JavaScript these yes or

19
00:01:14.495 --> 00:01:16.972
no questions, these true false questions.

20
00:01:16.972 --> 00:01:21.133
There are also a couple of
operators in JavaScript that

21
00:01:21.133 --> 00:01:24.035
tell us whether two things are equal.

22
00:01:24.035 --> 00:01:28.937
And confusingly,
JavaScript has two versions of these.

23
00:01:28.937 --> 00:01:31.970
These are not technical terms, but well,

24
00:01:31.970 --> 00:01:36.775
they were called the strict version
of the equality operators, and

25
00:01:36.775 --> 00:01:40.649
what I like to think of is
the loosey goosey version or,

26
00:01:40.649 --> 00:01:45.056
[LAUGH] some might call the sloppy
version of these operators.

27
00:01:45.056 --> 00:01:49.069
And confusingly,
these two versions of each operator,

28
00:01:49.069 --> 00:01:52.414
return different things
that sometimes lead to

29
00:01:52.414 --> 00:01:57.190
those unexpected JavaScript sort
of like what's happening here?

30
00:01:57.190 --> 00:01:59.144
So let's talk about these a little bit.

31
00:01:59.144 --> 00:02:04.332
So we have two operators for
something equals something else, which

32
00:02:04.332 --> 00:02:10.605
is asking JavaScript, does this value
equal this other value, are they the same?

33
00:02:10.605 --> 00:02:12.468
And if I use the strict version,

34
00:02:12.468 --> 00:02:15.583
I'm going to ask that with
three equal signs in a row.

35
00:02:15.583 --> 00:02:19.383
That is a single operator in JavaScript,
three equal signs in a row.

36
00:02:19.383 --> 00:02:23.981
And if I want to know just like
a vague loosey goosey answer to it,

37
00:02:23.981 --> 00:02:26.204
I can use just two equal signs.

38
00:02:26.204 --> 00:02:32.252
And likewise, we have a does
not equal version for each one.

39
00:02:32.252 --> 00:02:36.947
So the strict version is exclamation
point which often in programming

40
00:02:36.947 --> 00:02:40.605
means like not or opposite,
and then equal equal, and

41
00:02:40.605 --> 00:02:43.641
then not equal is
the loosey goosey version.

42
00:02:43.641 --> 00:02:48.517
So, what am I talking about the strict
versus the loosey goosey version,

43
00:02:48.517 --> 00:02:51.911
I am gonna ask you all to poke around and
figure out.

44
00:02:51.911 --> 00:02:58.550
For each of these examples,
does the strict triple equals operator,

45
00:02:58.550 --> 00:03:04.528
do the same thing as the loosey
goosey double equals operator?

46
00:03:04.528 --> 00:03:08.175
And if they are different,
how are they different?

47
00:03:08.175 --> 00:03:14.381
So let's just take a really brief moment
to ask JavaScript some questions like,

48
00:03:14.381 --> 00:03:20.403
is the number one equal to the number 1
is the string one equal to the string 1,

49
00:03:20.403 --> 00:03:23.704
and is the number 1 equal to the string 1.

50
00:03:23.704 --> 00:03:27.148
So take a moment,
guess at the answer first, and

51
00:03:27.148 --> 00:03:30.772
then ask JavaScript in
the console what it thinks.

52
00:03:39.615 --> 00:03:43.795
All right, so these operators,
these equal equal equal or

53
00:03:43.795 --> 00:03:47.649
equal equal strict loosey-goosey,
what do they do?

54
00:03:47.649 --> 00:03:48.443
Do they do things?

55
00:03:48.443 --> 00:03:49.052
Let's find out.

56
00:03:49.052 --> 00:03:49.825
Okay.

57
00:03:49.825 --> 00:03:53.495
So, what did we find this first row?

58
00:03:53.495 --> 00:03:58.475
Number 1, triple equal number 1 versus
number 1, double equal number 1.

59
00:03:58.475 --> 00:04:00.884
Do they do the same thing or
different things?

60
00:04:00.884 --> 00:04:01.939
&gt;&gt; Same.

61
00:04:01.939 --> 00:04:02.680
&gt;&gt; Same thing.

62
00:04:02.680 --> 00:04:06.130
And in both cases we get the answer true.

63
00:04:06.130 --> 00:04:07.044
Nice.

64
00:04:07.044 --> 00:04:08.894
How about the second line?

65
00:04:08.894 --> 00:04:12.134
Sring 1 equals string 1?.

66
00:04:12.134 --> 00:04:13.711
Same or different?

67
00:04:13.711 --> 00:04:14.445
&gt;&gt; Same.

68
00:04:14.445 --> 00:04:17.258
&gt;&gt; Same and the answer, true.

69
00:04:17.258 --> 00:04:17.798
Cool.

70
00:04:17.798 --> 00:04:18.511
All right.

71
00:04:18.511 --> 00:04:25.698
We're just checking our bases here,
making sure we're not losing it.

72
00:04:25.698 --> 00:04:28.485
What about the last line?

73
00:04:28.485 --> 00:04:33.914
So number one, triple equals number one.

74
00:04:33.914 --> 00:04:34.585
Let's try it out.

75
00:04:34.585 --> 00:04:41.767
Sorry, string 1, number 1,
triple equals string 1, false.

76
00:04:41.767 --> 00:04:43.075
Is that what you expect?

77
00:04:44.681 --> 00:04:47.589
I'm seeing nods, because we said these
are two different things, right?

78
00:04:47.589 --> 00:04:49.328
One is a number one is a string.

79
00:04:49.328 --> 00:04:50.684
They're not the same.

80
00:04:50.684 --> 00:04:54.889
They have something in common I guess
maybe, but they're totally different

81
00:04:54.889 --> 00:04:59.170
things, one is like talking about a number
and the other is the actual number.

82
00:04:59.170 --> 00:05:01.984
What about the loosey-goosey
double equals?

83
00:05:01.984 --> 00:05:09.312
So number one loosey-goosey
equals letter or string one.

84
00:05:09.312 --> 00:05:14.163
This returns true,
was anyone surprised by this?

85
00:05:14.163 --> 00:05:20.119
No, maybe we've just come to expect the
JavaScript says weird things sometimes.

86
00:05:20.119 --> 00:05:24.507
Does anybody know what is happening here,
or can anybody guess?

87
00:05:24.507 --> 00:05:28.845
Why the loosey goosey operator says that
these two are the same thing whereas

88
00:05:28.845 --> 00:05:31.432
the strict operator says that they're not?

89
00:05:31.432 --> 00:05:35.378
Any guesses what JavaScript
is thinking here if we can

90
00:05:35.378 --> 00:05:40.123
anthropomorphize our programming
languages, which why not.

91
00:05:40.123 --> 00:05:45.490
&gt;&gt; Triple equals, probably tries to
determine what type of data format

92
00:05:45.490 --> 00:05:50.313
it is versus double equals just
interprets the value itself.

93
00:05:50.313 --> 00:05:54.757
&gt;&gt; Interesting, okay, so this has
something to do definitely with the type

94
00:05:54.757 --> 00:05:57.488
of values that we're dealing with, right?

95
00:05:57.488 --> 00:06:03.370
And the triple equal is,
seems to care about the type of value.

96
00:06:03.370 --> 00:06:07.359
And so, it's saying that the number
1 is not the same thing as

97
00:06:07.359 --> 00:06:11.748
the string 1 because those
are different types of values exactly.

98
00:06:11.748 --> 00:06:17.717
The loosey goosey operator,
the double equals,

99
00:06:17.717 --> 00:06:21.417
it is doing an extra step here.

100
00:06:21.417 --> 00:06:26.199
What it's saying inside of JavaScript
if we again can anthropomorphize and

101
00:06:26.199 --> 00:06:28.299
pretend JavaScript is a person.

102
00:06:28.299 --> 00:06:33.755
It's saying, all right, these two
things they look kinda different but

103
00:06:33.755 --> 00:06:37.451
let me try to pretend that
they are the same value.

104
00:06:37.451 --> 00:06:41.596
What it's doing is
what's called casting or

105
00:06:41.596 --> 00:06:49.135
converting the values to be the same type
so that it can compare them more closely.

106
00:06:49.135 --> 00:06:52.781
And it's saying, okay,
if we convert these to the same value,

107
00:06:52.781 --> 00:06:56.104
the same type of value,
then they would be the same thing.

108
00:06:56.104 --> 00:07:00.492
So for
example like if I do one double equals 2,

109
00:07:00.492 --> 00:07:05.103
that's false because these
even if I convert them

110
00:07:05.103 --> 00:07:09.409
both to a string they're
not the same string.

111
00:07:09.409 --> 00:07:14.154
But the thing is that usually when
we're asking JavaScript whether two

112
00:07:14.154 --> 00:07:18.355
things are the same,
we care about the type of things they are.

113
00:07:18.355 --> 00:07:23.279
We usually don't want to find out that
the things that we thought were the same

114
00:07:23.279 --> 00:07:26.631
thing are actually of two
totally different types.

115
00:07:26.631 --> 00:07:30.966
JavaScript just managed to
convert them to the same type so

116
00:07:30.966 --> 00:07:34.155
that they could look like they were equal.

117
00:07:34.155 --> 00:07:37.671
So in almost every situation,
there's always an asterisk,

118
00:07:37.671 --> 00:07:41.120
there's always an almost, but
in almost every situation,

119
00:07:41.120 --> 00:07:43.839
you're gonna wanna use
the strict operators.

120
00:07:43.839 --> 00:07:50.507
So that triple equal and the exclamation
equal equal instead of the loosey goosey,

121
00:07:50.507 --> 00:07:56.616
two equals versions because almost always,
the type of your data matters.

122
00:07:56.616 --> 00:08:01.252
So I bring up these loosey goosey versions
just to tell you that they're out

123
00:08:01.252 --> 00:08:05.964
there and to tell you be careful that
you're not using the loosey goosey when

124
00:08:05.964 --> 00:08:08.486
you think you're using the strict one.

125
00:08:08.486 --> 00:08:11.699
Because you're gonna get different values,
and

126
00:08:11.699 --> 00:08:17.206
you're gonna maybe not have a good time if
you're thinking that you're doing strict

127
00:08:17.206 --> 00:08:22.503
comparison when really you're doing
a sloppy loosey goosey comparison, okay?

128
00:08:22.503 --> 00:08:27.060
So this is just a gotcha as it were.

129
00:08:27.060 --> 00:08:33.060
Okay, as we have said,
JavaScript has lots of operators,

130
00:08:33.060 --> 00:08:37.621
and there is a bunch of
other stuff out there.

131
00:08:37.621 --> 00:08:41.652
Anybody have any other guesses about
other operators that are out there?

132
00:08:41.652 --> 00:08:47.164
We saw one earlier the percentage and
the double asterisks for

133
00:08:47.164 --> 00:08:51.302
modulo and or remainder and
exponentiation.

134
00:08:51.302 --> 00:08:54.120
&gt;&gt; Is there a coalesce type
function in JavaScript?

135
00:08:54.120 --> 00:08:54.799
&gt;&gt; Interesting.

136
00:08:54.799 --> 00:08:56.428
A coalesce function.

137
00:08:56.428 --> 00:08:59.451
Can you tell us a little
bit about coalesce?

138
00:08:59.451 --> 00:09:03.198
&gt;&gt; In SQL, it evaluates
multiple values to determine if

139
00:09:03.198 --> 00:09:06.876
any of them have a something
that's assigned to it.

140
00:09:06.876 --> 00:09:11.052
Once it finds one, that's a sign that has
something assigned to it, it says, okay,

141
00:09:11.052 --> 00:09:12.561
I'll take the very first one.

142
00:09:12.561 --> 00:09:15.315
&gt;&gt; Right, okay.
&gt;&gt; So useful sometimes with SQL.

143
00:09:15.315 --> 00:09:19.159
&gt;&gt; Sure, yeah, so in C so maybe there's
another programming language we know

144
00:09:19.159 --> 00:09:23.243
like SQL or some other language that has
a certain operator, like coalesce, and

145
00:09:23.243 --> 00:09:25.905
we want to find out does
JavaScript have that thing?

146
00:09:25.905 --> 00:09:32.954
Where we can do, go to our friend MDN
type in coalesce and see what we get.

147
00:09:32.954 --> 00:09:36.009
Well, there's not really
the answer to the question,

148
00:09:36.009 --> 00:09:39.259
is not really something equivalent
to coalesce in SQL, but

149
00:09:39.259 --> 00:09:42.966
there is something that's called
a nullish coalescing operator.

150
00:09:42.966 --> 00:09:43.656
What is that?

151
00:09:43.656 --> 00:09:44.345
I don't know.

152
00:09:44.345 --> 00:09:44.928
Let's find out.

153
00:09:44.928 --> 00:09:46.147
Let's play around.

154
00:09:46.147 --> 00:09:51.020
So we have a bunch of like logical
operators that like this one

155
00:09:51.020 --> 00:09:52.272
is one of them.

156
00:09:52.272 --> 00:09:56.964
There's things like logical OR and
AND, and we're gonna talk more about

157
00:09:56.964 --> 00:10:01.969
those when we talk about conditionals and
logical values and stuff like that.

158
00:10:01.969 --> 00:10:06.822
But the point is that you can find
them all on our good friend MDN.

159
00:10:06.822 --> 00:10:11.610
And if you're ever wondering, my favorite
programming language has an operator like

160
00:10:11.610 --> 00:10:15.977
this, does my new favorite programming
language JavaScript have that operator?

161
00:10:15.977 --> 00:10:20.371
You can look it up in the operators page,
as we saw before.

162
00:10:20.371 --> 00:10:21.426
Cool.

163
00:10:21.426 --> 00:10:27.815
So once again, the takeaway from this
whole course is MDN, [LAUGH] just kidding.

164
00:10:27.815 --> 00:10:31.694
&gt;&gt; Someone was saying AND
and OR plus, plus.

165
00:10:33.750 --> 00:10:37.002
&gt;&gt; AND and OR, plus, plus, yes.

166
00:10:37.002 --> 00:10:41.472
Okay, so
these are also operators that we can.

167
00:10:41.472 --> 00:10:44.227
If we go to I don't actually know
if this will work if we yes, okay,

168
00:10:44.227 --> 00:10:45.874
we can even type it into the search box.

169
00:10:45.874 --> 00:10:50.457
So AND AND is another logical operator for
logical AND.

170
00:10:50.457 --> 00:10:54.588
Again, we'll come back to it when
we talk about conditionals, and

171
00:10:54.588 --> 00:10:58.585
truth values and things like that and
the other one was plus plus.

172
00:10:58.585 --> 00:11:02.911
That is, also, an operator that
is called the increment operator,

173
00:11:02.911 --> 00:11:07.029
which kind of adds one to like a counter,
or something like that.

174
00:11:07.029 --> 00:11:11.031
So, again great examples of other
operators that are part of the huge

175
00:11:11.031 --> 00:11:14.895
constellation of different operators
we can have in JavaScript,

176
00:11:14.895 --> 00:11:16.903
that are built into the language.

177
00:11:16.903 --> 00:11:21.191
And that we can always look up the details
of and like how does it work again and

178
00:11:21.191 --> 00:11:24.881
what's an example and all of that
good stuff is in our friend MDN.

179
00:11:24.881 --> 00:11:28.850
So anytime you're curious about
a particular operator that you see in

180
00:11:28.850 --> 00:11:33.355
somebody else's code maybe, or you know
the name of the thing you wanna do, but

181
00:11:33.355 --> 00:11:37.820
you can't remember what the symbol is
MDN is your friend, MDN is your friend.

182
00:11:37.820 --> 00:11:39.759
Yeah, I'm gonna be saying that a lot.

