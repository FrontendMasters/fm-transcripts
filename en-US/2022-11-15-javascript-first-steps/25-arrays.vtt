WEBVTT

1
00:00:00.370 --> 00:00:03.518
Earlier we talked about,
[LAUGH] we talked about values.

2
00:00:03.518 --> 00:00:05.541
Earlier, we talked about values and

3
00:00:05.541 --> 00:00:08.879
different types of data that
JavaScript lets us represent.

4
00:00:08.879 --> 00:00:13.520
And today we're gonna be talking
about grouping values into

5
00:00:13.520 --> 00:00:18.624
larger collections that we can
work with multiple values of time.

6
00:00:18.624 --> 00:00:22.618
Because as our friend Michelle Yeoh
told us in Star Trek Discovery,

7
00:00:22.618 --> 00:00:24.100
we deserve many things.

8
00:00:24.100 --> 00:00:27.454
Although I think she was talking
about bad things, but whatever.

9
00:00:27.454 --> 00:00:34.410
[LAUGH] So, arrays are a great way for us
to keep multiple related values together.

10
00:00:34.410 --> 00:00:38.636
And we can think of it as kind of
a collection, an ordered collection,

11
00:00:38.636 --> 00:00:39.434
let's say.

12
00:00:39.434 --> 00:00:45.226
So for example, our friend here has
explained some synonyms of array,

13
00:00:45.226 --> 00:00:48.432
like plethora and array, and cornucopia.

14
00:00:48.432 --> 00:00:54.047
And we've got a synonyms
variable here that is pointing

15
00:00:54.047 --> 00:01:00.144
to an array of strings representing
each of those synonyms.

16
00:01:00.144 --> 00:01:05.396
So, once we have declared
an array like this, declared and

17
00:01:05.396 --> 00:01:10.124
assigned a variable to store an array,
for example,

18
00:01:10.124 --> 00:01:16.653
we can access it in using some similar
spells as what we used with strings.

19
00:01:16.653 --> 00:01:19.494
So just like strings in arrays,

20
00:01:19.494 --> 00:01:24.439
every element in the array
gets a number assigned to it,

21
00:01:24.439 --> 00:01:28.451
which, once again we
call those numbers an?

22
00:01:28.451 --> 00:01:29.600
&gt;&gt; Index?

23
00:01:29.600 --> 00:01:30.472
&gt;&gt; Index, beautiful.

24
00:01:30.472 --> 00:01:35.204
So, if we ask for the length of an array,

25
00:01:35.204 --> 00:01:41.899
it'll return back the number
of elements in that array.

26
00:01:41.899 --> 00:01:48.173
And we can also pick out individual
elements from that array using our friends

27
00:01:48.173 --> 00:01:54.465
the square bracket notation with an index
number, or the dot index of spell.

28
00:01:54.465 --> 00:01:57.616
And then a value that we're searching for

29
00:01:57.616 --> 00:02:01.314
to find the first index
where that value occurs.

30
00:02:01.314 --> 00:02:08.637
Okay, so let's try to review a little bit
how indices are represented in JavaScript.

31
00:02:08.637 --> 00:02:10.831
Let's move over to the whiteboard.

32
00:02:13.434 --> 00:02:19.945
Okay, so we have an array, I'm gonna use
the square brackets to indicate that.

33
00:02:19.945 --> 00:02:24.686
And we have some values inside the array,
right?

34
00:02:24.686 --> 00:02:29.832
We had plethora,
these are long words, array,

35
00:02:29.832 --> 00:02:36.618
and I'm just gonna make it corn,
[LAUGH] instead of cornucopia.

36
00:02:36.618 --> 00:02:41.595
Okay, so we said that in JavaScript we get

37
00:02:41.595 --> 00:02:45.872
numbers assigned to each element.

38
00:02:45.872 --> 00:02:51.536
So can you just walk me through,
what number does plethora get?

39
00:02:51.536 --> 00:02:52.308
0, nice.

40
00:02:52.308 --> 00:02:54.407
An array?

41
00:02:54.407 --> 00:02:57.676
1, and corn?

42
00:02:57.676 --> 00:02:59.487
2, beautiful.

43
00:02:59.487 --> 00:03:05.938
And again, one way we can think about this
is that each item receives this number,

44
00:03:05.938 --> 00:03:10.252
this index kind of corresponds
to an individual item.

45
00:03:10.252 --> 00:03:14.397
But just like strings,
just like we talked about yesterday,

46
00:03:14.397 --> 00:03:19.577
we could also think about it as though
0 starts at the beginning of the array,

47
00:03:19.577 --> 00:03:24.457
and then kind of at each comma in
the array, we have a new index starting.

48
00:03:24.457 --> 00:03:28.093
So by the time we get to
the end of the array,

49
00:03:28.093 --> 00:03:32.344
we've reached the number
of things in the array.

50
00:03:32.344 --> 00:03:37.236
So that's where the kind
of length number is usually

51
00:03:37.236 --> 00:03:42.028
higher than the index of
the last item in the array.

52
00:03:42.028 --> 00:03:48.044
So if I wanted to get out the corn item,

53
00:03:48.044 --> 00:03:50.678
what could I do?

54
00:03:50.678 --> 00:03:54.682
How could I tell JavaScript I want
to select corn out of this array,

55
00:03:54.682 --> 00:03:56.767
which I think we called synonyms?

56
00:03:56.767 --> 00:03:58.953
So can anybody walk me through?

57
00:03:58.953 --> 00:04:02.308
Maybe, yeah, OJ, go ahead.

58
00:04:02.308 --> 00:04:06.490
&gt;&gt; Synonyms, open square bracket,
2, close square brackets.

59
00:04:06.490 --> 00:04:11.689
&gt;&gt; Exactly, so
we can do something like synonyms,

60
00:04:13.840 --> 00:04:19.786
[2] and that will tell JavaScript,
okay, take the synonyms array,

61
00:04:19.786 --> 00:04:26.130
go look for the index 2, and tell me
which items starts at that index, yeah?

62
00:04:26.130 --> 00:04:29.642
Great, okay, any questions so far?

63
00:04:29.642 --> 00:04:34.715
This is basically the exact same way that
we talk about indices with characters and

64
00:04:34.715 --> 00:04:40.021
strings, works the same with objects or,
sorry, elements, let's say in arrays.

65
00:04:40.021 --> 00:04:44.124
Awesome, awesome possum.

66
00:04:45.973 --> 00:04:50.668
And so similarly, we can also use some of
those spells that we learned with strings

67
00:04:50.668 --> 00:04:52.857
to search for values within an array.

68
00:04:52.857 --> 00:04:57.364
So we saw index of is one thing
we can do to find out what

69
00:04:57.364 --> 00:05:00.447
number corresponds to some value.

70
00:05:00.447 --> 00:05:04.506
We can also check if an array
includes a certain value.

71
00:05:04.506 --> 00:05:09.434
So what do you think synonyms.includes
plethora is going to return?

72
00:05:09.434 --> 00:05:11.301
Paul?

73
00:05:11.301 --> 00:05:12.733
&gt;&gt; Boolean, true or false.

74
00:05:12.733 --> 00:05:16.679
&gt;&gt; A Boolean, yes, always includes is
gonna return a yes or no answer, a true or

75
00:05:16.679 --> 00:05:18.945
false value, Boolean, excellent point.

76
00:05:18.945 --> 00:05:24.080
And in this case, what do you think
synonyms.includes("plethora")

77
00:05:24.080 --> 00:05:25.470
is going to return?

78
00:05:25.470 --> 00:05:26.213
&gt;&gt; True.

79
00:05:26.213 --> 00:05:32.103
&gt;&gt; True, okay, and
what about synonyms.includes ("variety")?

80
00:05:32.103 --> 00:05:33.390
Jason, what do you think?

81
00:05:33.390 --> 00:05:34.288
&gt;&gt; False.

82
00:05:34.288 --> 00:05:39.166
&gt;&gt; False, exactly, we don't have variety
in our synonyms array, at least not yet.

83
00:05:39.166 --> 00:05:43.932
However, we can put
things there if we want.

84
00:05:43.932 --> 00:05:47.977
If we there is something that we don't
have in our array that we want in it,

85
00:05:47.977 --> 00:05:52.486
unlike with strings, we're gonna talk
a little bit later about some differences

86
00:05:52.486 --> 00:05:54.149
between strings and arrays.

87
00:05:54.149 --> 00:05:58.582
Unlike with strings we can
modify what is in an array.

88
00:05:58.582 --> 00:06:04.473
So, what do you think
each of these lines does?

89
00:06:04.473 --> 00:06:07.874
I'm gonna let everybody take
a moment to think about it.

90
00:06:07.874 --> 00:06:12.622
What does each of these lines
do to our synonyms array?

91
00:06:12.622 --> 00:06:19.092
And some of these you might have to guess,
some you might have a good intuition for.

92
00:06:19.092 --> 00:06:23.301
While everybody is thinking about it,
I am going to go in and

93
00:06:23.301 --> 00:06:28.103
open up a console in a new tab cuz
we don't really care about things,

94
00:06:28.103 --> 00:06:31.577
and I'm just going to
create my synonyms array.

95
00:06:31.577 --> 00:06:36.882
Okay, so now the question is, so
what do each of these lines do?

96
00:06:36.882 --> 00:06:40.916
All right, let's take them one at a time.

97
00:06:40.916 --> 00:06:46.238
What do you all think happens when I say

98
00:06:46.238 --> 00:06:51.070
synonyms[1] = "variety"?

99
00:06:51.070 --> 00:06:51.739
Any guesses?

100
00:06:52.999 --> 00:06:55.382
Do you have a guess?

101
00:06:55.382 --> 00:06:59.893
&gt;&gt; Replaces the element index 1.

102
00:06:59.893 --> 00:07:03.909
&gt;&gt; Okay, so we have a guess that it's
gonna replace the element at index 1.

103
00:07:03.909 --> 00:07:07.074
So what was previously at index 1,
which was what?

104
00:07:07.074 --> 00:07:09.664
What was previously at
index 1 in this array?

105
00:07:09.664 --> 00:07:10.417
&gt;&gt; Array.

106
00:07:10.417 --> 00:07:11.459
&gt;&gt; Array, exactly.

107
00:07:11.459 --> 00:07:14.400
We're thinking maybe now
it's gonna be variety.

108
00:07:14.400 --> 00:07:15.279
Let's find out.

109
00:07:15.279 --> 00:07:19.248
Okay, so synonyms now indeed,

110
00:07:19.248 --> 00:07:23.070
has variety instead of array.

111
00:07:23.070 --> 00:07:25.152
Nice, nicely done.

112
00:07:25.152 --> 00:07:26.899
Was there a question from the chat?

113
00:07:26.899 --> 00:07:30.019
Or were just-
&gt;&gt; They were also just-

114
00:07:30.019 --> 00:07:30.845
&gt;&gt; Getting the answers.

115
00:07:30.845 --> 00:07:32.317
&gt;&gt; Array will be replaced by variety.

116
00:07:32.317 --> 00:07:34.818
&gt;&gt; Great, okay, how about this one?

117
00:07:34.818 --> 00:07:37.811
This is a new thing,
maybe we haven't seen before.

118
00:07:37.811 --> 00:07:40.109
Any guess what this does?

119
00:07:43.805 --> 00:07:44.573
Paul?

120
00:07:44.573 --> 00:07:47.954
&gt;&gt; Yeah, it takes the last,
so take cornucopia,

121
00:07:47.954 --> 00:07:50.837
return that and take it out of the array.

122
00:07:50.837 --> 00:07:55.652
&gt;&gt; Okay, so pop is kind of
a fun little method where it's

123
00:07:55.652 --> 00:08:00.360
going to pop off,
[LAUGH] the last thing in the array,

124
00:08:00.360 --> 00:08:04.854
and return that as a value
that we can capture, for

125
00:08:04.854 --> 00:08:09.691
example, by assigning it
to the last item variable.

126
00:08:09.691 --> 00:08:14.041
So if I run this code, and
now I ask for last item,

127
00:08:14.041 --> 00:08:20.962
it's going to be cornucopia, which was
the last item in the synonyms array.

128
00:08:20.962 --> 00:08:26.145
But importantly, now synonyms doesn't

129
00:08:26.145 --> 00:08:30.148
have cornucopia in it anymore.

130
00:08:30.148 --> 00:08:36.626
So, this is something that
changes the array and

131
00:08:36.626 --> 00:08:41.372
pops out the value of the last item.

132
00:08:41.372 --> 00:08:42.280
Okay, great.

133
00:08:42.280 --> 00:08:45.086
Now, how about this one?

134
00:08:45.086 --> 00:08:50.484
synonyms.push("multitude").

135
00:08:50.484 --> 00:08:54.994
So pop and
push are kind of two array spells that we

136
00:08:54.994 --> 00:08:58.081
can use to do things to the array.

137
00:08:58.081 --> 00:09:04.972
And where pop removed something from
the end of the array, push is going to,

138
00:09:08.875 --> 00:09:13.349
Add something on, or you could say sort of
append something to the end of the array.

139
00:09:13.349 --> 00:09:20.202
So if you've worked with other programming
languages that have similar array or

140
00:09:20.202 --> 00:09:25.455
list type collections,
they often have methods like these.

141
00:09:25.455 --> 00:09:29.487
Sometimes they're named different things,
like append instead of push or

142
00:09:29.487 --> 00:09:30.689
something like that.

143
00:09:30.689 --> 00:09:35.013
But in JavaScript, pop and push are how
we can either take things away,

144
00:09:35.013 --> 00:09:37.406
or add things in to the end of the array.

145
00:09:37.406 --> 00:09:42.278
And there are also symmetrical
methods we can use to put things, or

146
00:09:42.278 --> 00:09:45.935
take things away from
the beginning of the array.

147
00:09:45.935 --> 00:09:49.312
But we don't need to worry
about all of it right now.

148
00:09:49.312 --> 00:09:53.004
Any questions on this so far?

149
00:09:53.004 --> 00:09:58.011
These are some new things, so it's okay if

150
00:09:58.011 --> 00:10:05.536
it takes us a little while to kinda
get used to working with them.

151
00:10:05.536 --> 00:10:08.653
All right, so far we've been looking
at an array that has stuff in it, but

152
00:10:08.653 --> 00:10:10.433
we could also have an array that is empty.

153
00:10:10.433 --> 00:10:14.943
An empty array we can create by just
having two square brackets next to

154
00:10:14.943 --> 00:10:17.134
each other with nothing in that.

155
00:10:17.134 --> 00:10:20.671
And we can also have an array
with just one thing in it.

156
00:10:20.671 --> 00:10:26.228
It's important to know that JavaScript
sees, if we have the string

157
00:10:26.228 --> 00:10:32.466
value lonely versus an array with only
the string value lonely inside of it,

158
00:10:32.466 --> 00:10:38.914
do you think JavaScript sees those as
the same thing, or as different things?

159
00:10:38.914 --> 00:10:41.565
String lonely versus array
containing string lonely?

160
00:10:41.565 --> 00:10:44.172
&gt;&gt; Different.

161
00:10:44.172 --> 00:10:45.411
&gt;&gt; I think they're different.

162
00:10:45.411 --> 00:10:46.839
&gt;&gt; Different, different,
I'm hearing a couple differents.

163
00:10:46.839 --> 00:10:50.271
Yes, exactly,
JavaScript sees those as different things,

164
00:10:50.271 --> 00:10:54.307
even though to us as humans, it maybe
feels like the meaning is the same.

165
00:10:54.307 --> 00:10:57.940
As far as JavaScript is concerned,
if it's wrapped in those square brackets,

166
00:10:57.940 --> 00:11:01.210
it's an array, even if it's just
one thing, or if it's zero things.

167
00:11:01.210 --> 00:11:02.695
Yeah, question.

168
00:11:02.695 --> 00:11:05.382
&gt;&gt; Okay, so yesterday we were
talking about the triple equals and

169
00:11:05.382 --> 00:11:06.252
the double equals.

170
00:11:06.252 --> 00:11:11.477
So these are definitely different
because they're different types,

171
00:11:11.477 --> 00:11:16.976
but the value is kind of the same,
would a double equals come back as a true?

172
00:11:16.976 --> 00:11:18.356
&gt;&gt; Let's find out.

173
00:11:18.356 --> 00:11:22.744
So the question,
if I understood it right, is,

174
00:11:25.996 --> 00:11:30.011
If we do lonely double equals array,

175
00:11:30.011 --> 00:11:34.035
lonely, will it come back as a true?

176
00:11:34.035 --> 00:11:40.241
[LAUGH] Double equals, you are so sneaky.

177
00:11:40.241 --> 00:11:43.894
But again, this is why I would
say it really makes sense

178
00:11:43.894 --> 00:11:48.670
to always use our triple equals,
because these are different things.

179
00:11:48.670 --> 00:11:51.688
If they can do different things,
we can ask for different things.

180
00:11:51.688 --> 00:11:56.993
For example, if I ask for, let's say if I,

181
00:11:56.993 --> 00:12:03.398
my goodness, browser,
stop being so helpful, okay.

182
00:12:03.398 --> 00:12:11.347
If I ask for the element at index 0
of this array, what am I gonna get?

183
00:12:11.347 --> 00:12:15.699
Well, spoilers, it's gonna return
the first thing in the array, right,

184
00:12:15.699 --> 00:12:16.725
which is lonely.

185
00:12:16.725 --> 00:12:18.037
What happens if I do this?

186
00:12:18.037 --> 00:12:20.353
And I ask for 0 here?

187
00:12:20.353 --> 00:12:21.862
&gt;&gt; L?

188
00:12:21.862 --> 00:12:24.543
&gt;&gt; It's gonna return L, exactly.

189
00:12:24.543 --> 00:12:26.517
So these are different things,
they behave differently.

190
00:12:26.517 --> 00:12:28.197
So double equals lies.

191
00:12:28.197 --> 00:12:32.346
[LAUGH] It's too loosey goosey
in my opinion, it's too,

192
00:12:32.346 --> 00:12:35.459
I don't know, it doesn't really reflect

193
00:12:35.459 --> 00:12:40.223
real life of how we want to move
through our JavaScript programs.

194
00:12:40.223 --> 00:12:44.790
So keep in mind that double
equals can give you some

195
00:12:44.790 --> 00:12:48.390
unexpected behavior in your program.

196
00:12:48.390 --> 00:12:53.163
So generally, I say try to avoid it,
unless you really, really,

197
00:12:53.163 --> 00:12:57.852
really decide that it is exactly
what you want in that moment, but

198
00:12:57.852 --> 00:13:03.242
the chances that you're gonna need
that are pretty slim in my experience.

199
00:13:03.242 --> 00:13:06.959
&gt;&gt; It's funny the follow up
course is Karl Simpson's,

200
00:13:06.959 --> 00:13:09.527
and they hope give you a way to use it.

201
00:13:09.527 --> 00:13:10.382
But like you said,

202
00:13:10.382 --> 00:13:13.174
you really need to understand
kind of the rules that are on it.

203
00:13:13.174 --> 00:13:17.366
&gt;&gt; Yeah, exactly, it's one of these
things where it can be useful.

204
00:13:17.366 --> 00:13:21.830
Everything in JavaScript it can
have its uses, but in general,

205
00:13:21.830 --> 00:13:26.386
since we're just starting out,
when in doubt, triple equals.

206
00:13:26.386 --> 00:13:31.850
Okay, we've seen so far arrays that
are just holding one type of thing,

207
00:13:31.850 --> 00:13:38.033
strings, but arrays actually don't care,
going back to JavaScript's general

208
00:13:38.033 --> 00:13:43.159
loosey goosey noose around types,
which we talked about earlier.

209
00:13:43.159 --> 00:13:47.088
Arrays don't really care what
kind of stuff is in them.

210
00:13:47.088 --> 00:13:50.729
They behave the same, whether you've
got an array full of numbers, or

211
00:13:50.729 --> 00:13:54.977
you've got an array full of strings, or
you've got an array full of other arrays,

212
00:13:54.977 --> 00:13:58.279
[LAUGH] or you've got an array
full of different types of things.

213
00:13:58.279 --> 00:14:03.496
Like here we have mixed array, which it's
got some strings, it's got some numbers,

214
00:14:03.496 --> 00:14:07.512
it's got a false, it's got document
which is what type of thing?

215
00:14:07.512 --> 00:14:12.200
Remember our document,
our good old friend document is what type?

216
00:14:12.200 --> 00:14:15.618
So it is something related to HTML, but

217
00:14:15.618 --> 00:14:22.152
as far as JavaScript's kind of type
notions are concerned it is an, yeah?

218
00:14:22.152 --> 00:14:24.249
&gt;&gt; [INAUDIBLE]
&gt;&gt; Object, exactly, yeah.

219
00:14:24.249 --> 00:14:28.786
So, we could say it's a specific type
of object called maybe an HTML element,

220
00:14:28.786 --> 00:14:31.399
I can't remember exactly, but in general,

221
00:14:31.399 --> 00:14:34.732
it is, as far as JavaScript is concerned,
type object.

222
00:14:34.732 --> 00:14:37.885
So we've got a whole bunch of different
type things in this array, and

223
00:14:37.885 --> 00:14:40.194
that's totally fine,
JavaScript does not care.

