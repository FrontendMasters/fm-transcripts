WEBVTT

1
00:00:00.350 --> 00:00:07.520
So we need to return
the array from this function.

2
00:00:07.520 --> 00:00:10.250
So the very first thing we need
to do is declare an array.

3
00:00:11.760 --> 00:00:12.493
&gt;&gt; Yes, okay, exactly.

4
00:00:12.493 --> 00:00:16.053
So we need an array of like
the multiple choice options.

5
00:00:16.053 --> 00:00:18.046
Like n multiple choice option.

6
00:00:18.046 --> 00:00:19.865
So 3 or 5 or what have you.

7
00:00:19.865 --> 00:00:20.847
Yeah.

8
00:00:20.847 --> 00:00:21.550
&gt;&gt; onst.

9
00:00:23.746 --> 00:00:24.620
&gt;&gt; Choices?

10
00:00:24.620 --> 00:00:25.880
&gt;&gt; Choices, yeah, sounds good.

11
00:00:25.880 --> 00:00:26.600
&gt;&gt; Sure.

12
00:00:26.600 --> 00:00:30.150
&gt;&gt; And
then it's equals just two square brackets.

13
00:00:30.150 --> 00:00:32.380
&gt;&gt; So make it empty for now.

14
00:00:32.380 --> 00:00:37.920
And then ultimately what we're
gonna do is return that array.

15
00:00:37.920 --> 00:00:41.470
But first we need to put stuff in it,
okay,

16
00:00:41.470 --> 00:00:44.419
[LAUGH]
&gt;&gt; Now I got it, okay.

17
00:00:44.419 --> 00:00:46.030
&gt;&gt; Okay, cool.

18
00:00:46.030 --> 00:00:49.899
&gt;&gt; So now we want to do a while loop.

19
00:00:49.899 --> 00:00:55.133
And it's while and
then in the parentheses,

20
00:00:55.133 --> 00:00:58.999
choices.length is less than n.

21
00:00:58.999 --> 00:01:02.990
&gt;&gt; n, exactly.

22
00:01:02.990 --> 00:01:08.330
Let's say n is 3, we are going to do
something until we have enough things

23
00:01:08.330 --> 00:01:14.380
in that array that the length of the array
is 3, meaning it's not less than 3.

24
00:01:14.380 --> 00:01:18.000
So similarly to how we added
our five random numbers before.

25
00:01:18.000 --> 00:01:18.500
Cool.

26
00:01:21.027 --> 00:01:23.127
&gt;&gt; And then the curly brackets.

27
00:01:25.673 --> 00:01:28.139
Well, we could do it exactly
the same way as before, but

28
00:01:28.139 --> 00:01:30.920
how does the correct
answer come into that?

29
00:01:30.920 --> 00:01:31.740
&gt;&gt; Great question.

30
00:01:31.740 --> 00:01:35.488
How do we make sure that the correct
answer is in that array?

31
00:01:37.951 --> 00:01:38.911
&gt;&gt; Can we push it in?

32
00:01:38.911 --> 00:01:39.610
&gt;&gt; We could push it.

33
00:01:40.780 --> 00:01:44.680
Do we wanna push the correct
answer inside of this while loop?

34
00:01:44.680 --> 00:01:45.950
&gt;&gt; No.

35
00:01:45.950 --> 00:01:47.940
&gt;&gt; We only wanna push
the correct answer one time.

36
00:01:47.940 --> 00:01:50.424
We don't want three buttons that
all say the correct answer,

37
00:01:50.424 --> 00:01:52.210
that would also not be
a very exciting quiz.

38
00:01:53.340 --> 00:01:56.080
So we could even do that before.

39
00:01:57.820 --> 00:02:00.358
So could you walk me
through that JSON example?

40
00:02:00.358 --> 00:02:02.094
&gt;&gt; Sure.

41
00:02:02.094 --> 00:02:09.600
So whatever our variable is,
&gt;&gt; Choices?

42
00:02:09.600 --> 00:02:10.210
&gt;&gt; Choices, yeap

43
00:02:16.585 --> 00:02:19.730
Dot push.

44
00:02:19.730 --> 00:02:21.110
&gt;&gt; Yeap.
&gt;&gt; Correct answer.

45
00:02:21.110 --> 00:02:23.824
The syntax always escapes me.

46
00:02:23.824 --> 00:02:26.380
&gt;&gt; Yeah, choices dot push, correct answer.

47
00:02:27.380 --> 00:02:31.131
So this will now make sure that there
is at least one thing in our array, and

48
00:02:31.131 --> 00:02:32.475
it is the correct answer.

49
00:02:32.475 --> 00:02:32.978
Which is great.

50
00:02:32.978 --> 00:02:36.876
Okay, excellent.

51
00:02:36.876 --> 00:02:40.594
Okay, so
now we need to put in some red herrings,

52
00:02:40.594 --> 00:02:45.610
we need to put in some wrong answers
to make the game interesting.

53
00:02:47.010 --> 00:02:48.279
I mean, interesting is a strong word but,

54
00:02:48.279 --> 00:02:51.895
[LAUGH]
&gt;&gt; Quick question, by doing this,

55
00:02:51.895 --> 00:02:54.550
is the correct answer always gonna
be the first one in the array?

56
00:02:56.050 --> 00:02:56.962
&gt;&gt; So good question.

57
00:02:56.962 --> 00:02:59.605
As written,
if let's say we add other stuff here,

58
00:02:59.605 --> 00:03:01.520
which we'll figure out in a second.

59
00:03:02.520 --> 00:03:07.401
In this case when I returned choices,
The first element in

60
00:03:07.401 --> 00:03:11.861
choices will be the first
thing that we pushed into it.

61
00:03:11.861 --> 00:03:13.750
Which is correct answer.

62
00:03:13.750 --> 00:03:18.580
So that would make it a little,
I don't know, a little obvious.

63
00:03:18.580 --> 00:03:23.456
If the first button is always
the one that has the right answer,

64
00:03:23.456 --> 00:03:28.148
then it'd be like, a test in
school where you know that all of

65
00:03:28.148 --> 00:03:31.944
the above is always the correct answer,
right?

66
00:03:31.944 --> 00:03:34.960
So what can we do to spice things up?

67
00:03:34.960 --> 00:03:37.680
Well, if we scroll up a little bit,

68
00:03:37.680 --> 00:03:44.100
we'll see that we have a utility
function up here called shuffleArray.

69
00:03:44.100 --> 00:03:46.504
And here's a fun exercise as homework.

70
00:03:46.504 --> 00:03:50.540
You can delete this function and
try to rewrite it.

71
00:03:50.540 --> 00:03:54.309
How could we shuffle all
of the items in an array?

72
00:03:54.309 --> 00:04:01.294
So in place, so the array is mutated,
and the order is randomized.

73
00:04:01.294 --> 00:04:05.820
And this is one solution we could use
to do that, there are others as well.

74
00:04:05.820 --> 00:04:09.798
So I'll leave that just because this is
sort of where we wanna learn some other

75
00:04:09.798 --> 00:04:11.520
constructs in JavaScript.

76
00:04:11.520 --> 00:04:14.894
We'll leave that for
a optional exercise for reader.

77
00:04:14.894 --> 00:04:19.499
But suffice it to say, in our program
here we already have a utility

78
00:04:19.499 --> 00:04:24.200
function called shuffleArray that
we could use to shake things up.

79
00:04:25.400 --> 00:04:30.107
So maybe actually now before
we even add other stuff,

80
00:04:30.107 --> 00:04:37.130
we know what we wanna do here before we
return the array, is we wanna shuffle it.

81
00:04:38.180 --> 00:04:43.125
So how can I apply this shuffling
function to the array that I'm

82
00:04:43.125 --> 00:04:47.244
outputting from my get
multiple choices function?

83
00:04:51.970 --> 00:04:54.580
&gt;&gt; You add the shuffleArray as
part of the return statement.

84
00:04:54.580 --> 00:04:56.360
&gt;&gt; Okay,
we could do it in the return statement.

85
00:04:56.360 --> 00:05:00.971
So this would be like,
I could return shuffleArray and

86
00:05:00.971 --> 00:05:07.300
pass in the array because that's
the structure of our shuffleArray.

87
00:05:07.300 --> 00:05:11.430
That's how we parametrize shuffleArray
that takes in the array as in argument.

88
00:05:11.430 --> 00:05:16.206
So we could first call the function on it,
which is going to change choices,

89
00:05:16.206 --> 00:05:20.180
it's gonna mutate it, and
then return that mutated version.

90
00:05:21.210 --> 00:05:22.090
Great.

91
00:05:22.090 --> 00:05:25.067
Okay, but right now we're shuffling
an array of length one, so

92
00:05:25.067 --> 00:05:27.110
not too much is changing.

93
00:05:27.110 --> 00:05:28.990
So let's add the other stuff.

94
00:05:28.990 --> 00:05:29.690
Okay, great job.

95
00:05:31.510 --> 00:05:33.723
So how can we go through and

96
00:05:33.723 --> 00:05:39.320
add a randomly selected element
from our possible choices?

97
00:05:39.320 --> 00:05:41.170
&gt;&gt; Choices dot push?

98
00:05:41.170 --> 00:05:43.310
Open parenthesis get random element.

99
00:05:44.770 --> 00:05:46.743
&gt;&gt; Get random element.

100
00:05:46.743 --> 00:05:48.200
&gt;&gt; Open parenthesis breeds.

101
00:05:49.290 --> 00:05:51.732
&gt;&gt; And
then if we look at random element and

102
00:05:51.732 --> 00:05:55.876
IDE is helping us out a little bit here,
but if we don't have that,

103
00:05:55.876 --> 00:05:59.511
we can scroll up and
see what does random element look for.

104
00:05:59.511 --> 00:06:01.611
It takes in the array again, and so

105
00:06:01.611 --> 00:06:05.680
we can pass in our possible choices
array is what you said, right?

106
00:06:08.180 --> 00:06:09.157
&gt;&gt; Breeds.

107
00:06:09.157 --> 00:06:10.190
&gt;&gt; Sorry, breeds, yes.

108
00:06:10.190 --> 00:06:13.760
Okay, so if we pass in breeds here,
in this case,

109
00:06:13.760 --> 00:06:19.115
in this script where we're calling
this get multiple choices function and

110
00:06:19.115 --> 00:06:24.220
we're passing in breeds as the argument,
these would be equivalent.

111
00:06:24.220 --> 00:06:28.120
But what happens if I wanna reuse this?

112
00:06:28.120 --> 00:06:30.131
Get multiple choices function for

113
00:06:30.131 --> 00:06:34.909
a new game that I wanna build that doesn't
involve dogs or breeds, then this would

114
00:06:34.909 --> 00:06:39.499
always return me choices of dog breeds
even if I wanted JavaScript value quiz.

115
00:06:39.499 --> 00:06:41.099
Which value is this thing?

116
00:06:42.310 --> 00:06:44.326
Sorry which type is this value?

117
00:06:44.326 --> 00:06:49.661
So in this case we don't really wanna hard
code which means kind of bake it in so

118
00:06:49.661 --> 00:06:54.095
that we're always using that
same value that breeds constant,

119
00:06:54.095 --> 00:06:59.140
which is in caps because it's
a value we don't expect to change.

120
00:06:59.140 --> 00:07:02.712
Since we're passing in
the breeds away anyway,

121
00:07:02.712 --> 00:07:07.166
we're passing it in as the third
argument to this function,

122
00:07:09.325 --> 00:07:13.617
What inner scope variable, essentially,

123
00:07:13.617 --> 00:07:18.450
is this gonna get within
our function body?

124
00:07:18.450 --> 00:07:23.775
What is JavaScript gonna name that
value within our function body here?

125
00:07:23.775 --> 00:07:25.826
&gt;&gt; Possible choices.

126
00:07:25.826 --> 00:07:28.183
&gt;&gt; Possible choices, yeah.

127
00:07:28.183 --> 00:07:30.827
In this case, they're equivalent.

128
00:07:30.827 --> 00:07:34.248
But if we ever wanted to reuse this
function, and often when we're writing

129
00:07:34.248 --> 00:07:37.770
little utility functions like this,
we wanna keep them flexible.

130
00:07:37.770 --> 00:07:40.453
Like for example the fact that
maybe we wanna change this so

131
00:07:40.453 --> 00:07:41.721
that we have five choices.

132
00:07:41.721 --> 00:07:44.288
It's a little bit harder, or
maybe we wanna lower it to just two,

133
00:07:44.288 --> 00:07:46.060
make it a little easier.

134
00:07:46.060 --> 00:07:48.260
We can change some of those options later.

135
00:07:48.260 --> 00:07:51.901
So in this case,
let's use the name of the parameter.

136
00:07:51.901 --> 00:07:52.893
Great.

137
00:07:54.587 --> 00:07:55.582
Okay.

138
00:07:57.182 --> 00:08:02.367
Can anybody see any possibilities

139
00:08:02.367 --> 00:08:08.275
of something that might go wrong here?

140
00:08:08.275 --> 00:08:09.956
I'm seeing some nodding.

141
00:08:09.956 --> 00:08:13.559
What might happen in
the way this is written?

142
00:08:13.559 --> 00:08:18.350
&gt;&gt; We're gonna get too many options.

143
00:08:18.350 --> 00:08:23.263
I think we don't we have to have n-1
in our Y loop because we already put in

144
00:08:23.263 --> 00:08:25.100
one value into that array.

145
00:08:26.120 --> 00:08:31.220
So we're gonna put in 3, so
we come up with four choices essentially.

146
00:08:31.220 --> 00:08:35.016
&gt;&gt; Okay, so one thing is we wanna make
sure we're getting the right number of

147
00:08:35.016 --> 00:08:35.576
choices.

148
00:08:35.576 --> 00:08:41.117
So the question is, Are we

149
00:08:41.117 --> 00:08:46.127
gonna ignore this first value
that we put into the array and

150
00:08:46.127 --> 00:08:51.120
add three random traces and
now have four total?

151
00:08:51.120 --> 00:08:53.440
So that is something
we should think about.

152
00:08:53.440 --> 00:08:55.197
So is that going to happen here?

153
00:08:55.197 --> 00:08:56.460
Let's think through it.

154
00:08:56.460 --> 00:08:58.710
When I declare choices what's its length?

155
00:09:00.580 --> 00:09:01.750
0.

156
00:09:01.750 --> 00:09:08.618
When this line runs, what does
the new length of choices become?

157
00:09:08.618 --> 00:09:12.561
1.
So by the time I get to this condition,

158
00:09:12.561 --> 00:09:15.420
choices length is already 1.

159
00:09:16.750 --> 00:09:22.280
So if n is 3,
how many times is this line gonna run?

160
00:09:24.680 --> 00:09:25.250
&gt;&gt; Twice.
&gt;&gt; Twice.

161
00:09:25.250 --> 00:09:26.650
&gt;&gt; Two, exactly.

162
00:09:26.650 --> 00:09:31.505
So in this case because we pushed,
what would be different is if we had

163
00:09:31.505 --> 00:09:35.709
moved this down here for
example, then we're in trouble.

164
00:09:35.709 --> 00:09:39.126
Because now we're gonna
run that choices push,

165
00:09:39.126 --> 00:09:44.310
get random element line three times,
and then push a fourth thing.

166
00:09:44.310 --> 00:09:47.160
So great to be looking out for
this kind of stuff.

167
00:09:47.160 --> 00:09:49.245
But in this case since we had
put it before the while loop,

168
00:09:49.245 --> 00:09:51.550
we're probably okay on that front.

169
00:09:51.550 --> 00:09:52.680
Okay, awesome, awesome point.

170
00:09:53.870 --> 00:09:58.555
Any other concerns anybody has?

171
00:09:58.555 --> 00:09:59.160
Yeah.

172
00:10:00.310 --> 00:10:05.041
&gt;&gt; Well, you've got a possibility that one
of those random elements might be the same

173
00:10:05.041 --> 00:10:06.400
as the correct answer.

174
00:10:07.750 --> 00:10:08.377
&gt;&gt; Yes.

175
00:10:08.377 --> 00:10:14.960
So math dot random when we call it,

176
00:10:18.540 --> 00:10:22.055
We might have to call it
a bunch of times in order for

177
00:10:22.055 --> 00:10:26.659
anything to be similar, but
there's no guarantee that it's not

178
00:10:26.659 --> 00:10:31.620
gonna return two values that are really
at least close if not the same.

179
00:10:31.620 --> 00:10:34.357
So we have a 0.85 and a 0.89.

180
00:10:34.357 --> 00:10:38.290
What we're doing in our granum element
function probably matters here.

181
00:10:38.290 --> 00:10:40.184
So let's take a look at it.

182
00:10:40.184 --> 00:10:44.460
What we're doing is we're
calling math dot random.

183
00:10:44.460 --> 00:10:50.137
And since that's always a number between 0
and 1, we're multiplying it by the array

184
00:10:50.137 --> 00:10:56.450
length to kinda scale up the random values
that we'll get to the length of the array.

185
00:10:56.450 --> 00:11:00.372
And then because we don't have
decimal integer in our arrays,

186
00:11:00.372 --> 00:11:04.157
we're doing another operation
called math thought floor.

187
00:11:04.157 --> 00:11:07.433
Which what this does is
it takes the integer,

188
00:11:07.433 --> 00:11:11.932
that's the lower end of whatever
decimal you're giving it.

189
00:11:11.932 --> 00:11:16.992
So let's take a look,
this is just some math we're doing.

190
00:11:16.992 --> 00:11:21.981
If I have three things in my array,
math.random times

191
00:11:21.981 --> 00:11:26.324
3 now is gonna be some
number between 0 and 3.

192
00:11:26.324 --> 00:11:31.592
And I'm gonna take the floor
of that number which means

193
00:11:31.592 --> 00:11:37.520
essentially the integer
before the decimal point.

194
00:11:37.520 --> 00:11:41.020
Cuz I don't care about the decimals
cuz these are arrays and

195
00:11:41.020 --> 00:11:43.820
we don't have array at index 0.11111.

196
00:11:43.820 --> 00:11:48.160
We only have array at index 0, the item
at index 0 and the item at index one.

197
00:11:48.160 --> 00:11:49.480
We only deal with integers.

198
00:11:49.480 --> 00:11:54.956
So when I do math dot floor
of math dot random times 3,

199
00:11:54.956 --> 00:12:00.436
I always get an integer value
somewhere between 0 and

200
00:12:00.436 --> 00:12:04.603
2, because floor takes the lower end.

201
00:12:04.603 --> 00:12:08.578
There's also a ceiling operation
that takes the higher integer.

202
00:12:08.578 --> 00:12:12.094
So what this means is
that because like for

203
00:12:12.094 --> 00:12:16.314
example here my math.random
returned times 3,

204
00:12:16.314 --> 00:12:21.846
returned different numbers, but
there were still not quite 1.

205
00:12:21.846 --> 00:12:24.040
They were still 0 point something.

206
00:12:24.040 --> 00:12:26.840
The floor of those is both gonna be 0.

207
00:12:26.840 --> 00:12:31.515
So that means we might get the same
index here multiple times when

208
00:12:31.515 --> 00:12:34.383
we call this function multiple times.

209
00:12:34.383 --> 00:12:36.330
Meaning we'd get the same element.

210
00:12:36.330 --> 00:12:40.846
So we wanna make sure that we don't
have two of the same choice cuz again,

211
00:12:40.846 --> 00:12:43.600
that would probably be
a bug in our program.

212
00:12:43.600 --> 00:12:46.570
That wouldn't be what we
want the page to look like.

213
00:12:46.570 --> 00:12:47.943
So what can we do about it?

214
00:12:52.854 --> 00:12:53.932
What can we do about it?

215
00:12:57.197 --> 00:13:02.233
&gt;&gt; Can you do a four for every answer
that gets returned by the random

216
00:13:02.233 --> 00:13:08.495
element that does not exist as the correct
answer to just keep doing it and so on?

217
00:13:08.495 --> 00:13:12.145
&gt;&gt; Okay, so we could say, so
I heard a few things in there,

218
00:13:12.145 --> 00:13:16.908
we wanna keep doing this until we get
something that isn't in our array.

219
00:13:16.908 --> 00:13:18.745
Now the question is, do we need a 4?

220
00:13:18.745 --> 00:13:23.390
Well, we're already looping,
we've already got a loop going on,

221
00:13:23.390 --> 00:13:25.480
it's the while loop, right?

222
00:13:26.600 --> 00:13:31.395
So maybe what we need here is
we need to ask JavaScript, hey,

223
00:13:31.395 --> 00:13:34.230
is this thing already in our array?

224
00:13:36.000 --> 00:13:41.090
&gt;&gt; Can we do add, add and
say whatever value that's being

225
00:13:41.090 --> 00:13:47.409
returned by that get random element
is not equal to correct answer.

226
00:13:48.468 --> 00:13:53.180
&gt;&gt; While choices dot length
was less than add, right?

227
00:13:53.180 --> 00:13:54.300
The both have to be true.

228
00:13:55.960 --> 00:13:58.662
Whatever the value that's being
returned is not the correct answer,

229
00:13:58.662 --> 00:13:59.630
keep doing this.

230
00:13:59.630 --> 00:14:01.072
&gt;&gt; Okay, I see where you're going,

231
00:14:01.072 --> 00:14:03.700
you're saying we could add
more to our conditional here.

232
00:14:03.700 --> 00:14:04.210
&gt;&gt; Yeah.

233
00:14:04.210 --> 00:14:06.200
&gt;&gt; I mean, our condition here, yeah.

234
00:14:06.200 --> 00:14:09.922
Well, the thing is that when
we're evaluating this condition,

235
00:14:09.922 --> 00:14:11.824
we're not in the while loop yet.

236
00:14:11.824 --> 00:14:15.283
So we haven't gotten anything
from the choices yet.

237
00:14:15.283 --> 00:14:17.510
We don't have our random element yet.

238
00:14:17.510 --> 00:14:21.570
But I see where you're going and
that would be something to investigate.

239
00:14:21.570 --> 00:14:25.993
But right now,
when we're inside of the while loop,

240
00:14:25.993 --> 00:14:30.430
what we can do,
is we can look at this random element.

241
00:14:32.000 --> 00:14:36.929
And we can decide whether we
actually do want it in our array,

242
00:14:36.929 --> 00:14:42.052
want to push it into our array,
or whether we don't want to push

243
00:14:42.052 --> 00:14:47.095
it in our array, for
example because it's already in there.

244
00:14:48.985 --> 00:14:54.734
So how could we test whether or
not this random element returned by

245
00:14:54.734 --> 00:14:59.765
them get random element is
already in our choices array?

246
00:15:00.775 --> 00:15:05.642
Does anybody remember a Spell includes?

247
00:15:05.642 --> 00:15:09.993
So we have a array includes,
which can tell us whether or

248
00:15:09.993 --> 00:15:13.340
not a certain value is
already in an array.

249
00:15:14.550 --> 00:15:17.587
So what I could do here is,

250
00:15:17.587 --> 00:15:22.974
let's say capture my get
random element value

251
00:15:22.974 --> 00:15:28.499
as a possibility let's say,
possibility, or

252
00:15:28.499 --> 00:15:34.178
random element, or
whatever you wanna call it.

253
00:15:35.786 --> 00:15:38.547
Whatever it is that you wanna call it.

254
00:15:38.547 --> 00:15:43.084
You could call it candidate,
for example, choice candidate.

255
00:15:43.084 --> 00:15:44.064
Whatever we wanna name it.

256
00:15:46.235 --> 00:15:47.785
We can capture it as a variable.

257
00:15:47.785 --> 00:15:52.546
And then how can we test
to find out whether or

258
00:15:52.546 --> 00:15:57.700
not each candidate is in
array using includes?

259
00:16:00.771 --> 00:16:03.877
So the name of the array
that we wanna test it in is,

260
00:16:06.590 --> 00:16:11.040
The array we care about your choices,
this is what we're building.

261
00:16:11.040 --> 00:16:15.400
We wanna make sure we wanna see does
choices already have this candidate in it?

262
00:16:17.200 --> 00:16:19.510
&gt;&gt; So we've got if don't mean.

263
00:16:19.510 --> 00:16:24.965
&gt;&gt; So how we would test here is we
could do choices includes candidate,

264
00:16:24.965 --> 00:16:30.336
and that's gonna return or
that's gonna give us a Boolean value.

265
00:16:30.336 --> 00:16:31.240
True or false?

266
00:16:32.420 --> 00:16:34.410
So we can make that, you said?

267
00:16:34.410 --> 00:16:37.189
&gt;&gt; Into an if statement
&gt;&gt; We can make that the condition of an if

268
00:16:37.189 --> 00:16:41.718
statement, If choice is

269
00:16:41.718 --> 00:16:47.278
includes candidate, Do something.

270
00:16:47.278 --> 00:16:52.294
In this case actually we care If choices

271
00:16:52.294 --> 00:16:57.616
does not include our candidate, right?

272
00:16:57.616 --> 00:16:58.270
Yeah, two.

273
00:16:58.270 --> 00:17:00.440
&gt;&gt; Can we just use exclamation mark?

274
00:17:00.440 --> 00:17:04.590
&gt;&gt; We can use the exclamation mark,
exactly.

275
00:17:04.590 --> 00:17:08.864
So if choices dot includes
candidate is false, so

276
00:17:08.864 --> 00:17:14.257
if choices does not include the candidate,
then in that case,

277
00:17:14.257 --> 00:17:18.732
we can move up our choices
push into this if block, so

278
00:17:18.732 --> 00:17:22.900
that we make sure, my goodness, syntax.

279
00:17:22.900 --> 00:17:28.137
Okay, so
that we make sure that we are only pushing

280
00:17:28.137 --> 00:17:35.503
if choices does not include the potential
candidate that we just got.

281
00:17:35.503 --> 00:17:38.345
We got random element.

