WEBVTT

1
00:00:05.311 --> 00:00:07.986
&gt;&gt; Nina Zakharenko: Let's
look at our lists, so

2
00:00:07.986 --> 00:00:11.778
that would be this exercise right here.

3
00:00:15.119 --> 00:00:20.059
&gt;&gt; Nina Zakharenko: So
if I had a new list with the characters,

4
00:00:27.636 --> 00:00:30.098
&gt;&gt; Nina Zakharenko: Of hello.

5
00:00:30.098 --> 00:00:36.190
Can look at it,
I can append something to my list.

6
00:00:36.190 --> 00:00:41.850
Where does append insert
the that new value?

7
00:00:41.850 --> 00:00:42.839
&gt;&gt; Student: At the end of the list.

8
00:00:42.839 --> 00:00:46.060
&gt;&gt; Nina Zakharenko: At the end,
that's right.

9
00:00:46.060 --> 00:00:48.365
We can look at the length of my list.

10
00:00:51.310 --> 00:00:57.480
&gt;&gt; Nina Zakharenko: And
we can do a little bit of list slicing.

11
00:00:57.480 --> 00:01:02.355
So, I mentioned earlier that you can

12
00:01:02.355 --> 00:01:07.079
access items in a list by position.

13
00:01:07.079 --> 00:01:12.062
There's something called
slicing that lets you

14
00:01:12.062 --> 00:01:16.810
access more than one item
in the list at a time.

15
00:01:16.810 --> 00:01:22.267
So if I wanted to access the first
few items, let's put 3 here,

16
00:01:22.267 --> 00:01:27.840
that would give me back the items
from position 0 to position 3.

17
00:01:30.633 --> 00:01:34.247
&gt;&gt; Nina Zakharenko: I can also optionally,
if I'm looking at the beginning or

18
00:01:34.247 --> 00:01:37.070
the end,
I can leave off one of these values.

19
00:01:37.070 --> 00:01:42.209
So if this is not present then,
&gt;&gt; Nina Zakharenko: It

20
00:01:42.209 --> 00:01:47.150
does the same thing that's
kind of the inferred value.

21
00:01:47.150 --> 00:01:52.100
And,
&gt;&gt; Nina Zakharenko: Negative indexing is

22
00:01:52.100 --> 00:01:53.051
possible too.

23
00:01:53.051 --> 00:02:00.083
So if I wanted to look at the very last
item in the list, I would use index -1.

24
00:02:02.659 --> 00:02:08.820
&gt;&gt; Nina Zakharenko: There are a few
other ways of interacting with our list.

25
00:02:08.820 --> 00:02:15.014
I can call remove on the list
in person the string out,

26
00:02:15.014 --> 00:02:19.980
will that remove all
of the instances of l?

27
00:02:19.980 --> 00:02:21.179
&gt;&gt; Student: The first instance.

28
00:02:21.179 --> 00:02:24.900
&gt;&gt; Nina Zakharenko: Just the first one,
that's right.

29
00:02:24.900 --> 00:02:32.269
I can also insert,
&gt;&gt; Nina Zakharenko: Don't forget,

30
00:02:32.269 --> 00:02:33.053
like I did,

31
00:02:33.053 --> 00:02:38.480
where I got an error that you have to pass
a position to insert a required argument.

32
00:02:42.889 --> 00:02:47.029
&gt;&gt; Nina Zakharenko: So
I talked about popping.

33
00:02:47.029 --> 00:02:52.067
But there's another way of
deleting items from a list,

34
00:02:52.067 --> 00:02:55.185
and that's with the del keyword.

35
00:02:55.185 --> 00:03:00.242
And you can say delete
the item at my_list 0,

36
00:03:02.390 --> 00:03:04.120
&gt;&gt; Nina Zakharenko: And it'll be gone.

37
00:03:04.120 --> 00:03:08.372
Personally I really don't
like this type of syntax,

38
00:03:08.372 --> 00:03:13.860
it doesn't really fit in with the other
data types that we looked at.

39
00:03:13.860 --> 00:03:18.238
It's kind of there you might
see it in other Python code,

40
00:03:18.238 --> 00:03:20.530
but I recommend not using it.

41
00:03:20.530 --> 00:03:26.117
Or we could just pop,
&gt;&gt; Nina Zakharenko: The last

42
00:03:26.117 --> 00:03:28.169
item on the list.

43
00:03:28.169 --> 00:03:32.216
Optionally we can pass
an argument into pop, and

44
00:03:32.216 --> 00:03:35.485
that would be the position to pop from.

45
00:03:38.499 --> 00:03:43.254
&gt;&gt; Nina Zakharenko: We can see if a
particular value is in my list with the in

46
00:03:43.254 --> 00:03:45.271
keyword, it's not.

47
00:03:46.390 --> 00:03:55.954
And we can sort in place with
my_list.sort(reverse=True), oops.

48
00:03:55.954 --> 00:04:00.340
Reverse=True, and now we'll see my
list is sorted in reverse order.

49
00:04:02.290 --> 00:04:05.790
Remember that calling .sort
doesn't return anything.

50
00:04:05.790 --> 00:04:13.483
If we wanted a copy instead of
modifying the list in place,

51
00:04:13.483 --> 00:04:18.507
we would call sorted on my_list, and

52
00:04:18.507 --> 00:04:24.325
also parse in the reverse=True argument.

53
00:04:24.325 --> 00:04:25.425
Okay, working with sets.

54
00:04:28.667 --> 00:04:33.280
&gt;&gt; Nina Zakharenko: Remember
that tape of empty brackets is

55
00:04:33.280 --> 00:04:38.448
a dictionary,
to make a new set we need to use

56
00:04:38.448 --> 00:04:43.295
the set constructor
&gt;&gt; Nina Zakharenko: We

57
00:04:43.295 --> 00:04:48.300
can check that with type or just look at
the variable and see that it's a set.

58
00:04:48.300 --> 00:04:53.388
We can add items to our set, or
we can just override it with

59
00:04:53.388 --> 00:04:58.847
a non-empty,
&gt;&gt; Nina Zakharenko: With some values.

60
00:04:58.847 --> 00:05:03.350
I can, oops, sorry.

61
00:05:03.350 --> 00:05:08.419
I can add a value to it.

62
00:05:08.419 --> 00:05:15.309
I can also remove,
&gt;&gt; Nina Zakharenko: A value from it.

63
00:05:15.309 --> 00:05:18.050
Okay, so that's mutable.

64
00:05:18.050 --> 00:05:21.008
I can also test for membership with the in

65
00:05:21.008 --> 00:05:26.069
keyword
&gt;&gt; Nina Zakharenko: Unlike with less,

66
00:05:26.069 --> 00:05:28.839
every item in the start has to be unique.

67
00:05:28.839 --> 00:05:34.564
So if I have my_set and
I try to add 3 to it again,

68
00:05:34.564 --> 00:05:39.469
we'll see that it's only in there once.

69
00:05:39.469 --> 00:05:41.379
Looking at some set operations,

70
00:05:41.379 --> 00:05:46.802
making a new set
&gt;&gt; Nina Zakharenko: Oops,

71
00:05:46.802 --> 00:05:50.750
I now wanted to call it my_other_set,
so let me fix that.

72
00:05:51.940 --> 00:05:55.289
We can combine the two sets with a union.

73
00:05:55.289 --> 00:05:59.009
We use the symbols before but
we can also use the methods.

74
00:06:01.770 --> 00:06:04.349
&gt;&gt; Nina Zakharenko: So
that's all of the items that are in both.

75
00:06:04.349 --> 00:06:07.755
We can get the difference.

76
00:06:11.068 --> 00:06:16.648
&gt;&gt; Nina Zakharenko: So,
&gt;&gt; Nina Zakharenko: What's

77
00:06:16.648 --> 00:06:19.189
the value that is in both?

78
00:06:19.189 --> 00:06:22.529
Or we can get the intersection.

79
00:06:28.810 --> 00:06:32.919
&gt;&gt; Nina Zakharenko: So, these are the
values that are unique to each set.

80
00:06:32.919 --> 00:06:35.419
Each set already had four in it.

81
00:06:35.419 --> 00:06:40.954
Okay, looking at tuples,
we know that we can't

82
00:06:40.954 --> 00:06:46.085
make a one item tuple
with just parentheses,

83
00:06:46.085 --> 00:06:51.091
we know that we need to
insert a comma there.

84
00:06:53.380 --> 00:06:55.539
&gt;&gt; Nina Zakharenko: So
let's make a new tuple.

85
00:06:58.050 --> 00:07:05.340
&gt;&gt; Nina Zakharenko: What happens if we try
to add or change a value in our tuple.

86
00:07:05.340 --> 00:07:06.829
Is this possible?

87
00:07:06.829 --> 00:07:07.739
It's not.

88
00:07:07.739 --> 00:07:12.949
Tuples are immutable,
does not support item assignment.

89
00:07:12.949 --> 00:07:15.940
Let's make a new person.

90
00:07:15.940 --> 00:07:20.747
Jim, Jim has an age, he's 29 and

91
00:07:20.747 --> 00:07:24.600
he lives in Austin, Taxes.

92
00:07:24.600 --> 00:07:29.451
We can use tuple unpacking,
&gt;&gt; Nina Zakharenko: To quickly

93
00:07:29.451 --> 00:07:33.930
pull out all of the values in a tuple and
assign variables to them.

94
00:07:33.930 --> 00:07:38.748
Now we can look at Jim's name,
age and hometown.

95
00:07:38.748 --> 00:07:41.909
For dictionaries, remember,

96
00:07:41.909 --> 00:07:46.940
they kind of use those curly
braces just like a set,

97
00:07:46.940 --> 00:07:51.049
but instead it contains key value pairs.

98
00:07:51.049 --> 00:07:54.491
The key value is separated with a colon,
and

99
00:07:54.491 --> 00:07:58.129
each key value pair is
separated with a comma.

100
00:07:58.129 --> 00:08:04.189
What happens if we try to get the item
at position zero in our dictionary?

101
00:08:04.189 --> 00:08:08.772
&gt;&gt; [INAUDIBLE]
&gt;&gt; Nina Zakharenko: Unless key zero

102
00:08:08.772 --> 00:08:13.419
happens to be there, but
dictionaries do not have an order.

103
00:08:13.419 --> 00:08:19.549
Okay, let's add a few more
items in our dictionary.

104
00:08:29.240 --> 00:08:31.180
&gt;&gt; Nina Zakharenko: And
we can take a look at it here.

105
00:08:33.680 --> 00:08:38.273
Now there are three items,
to get the value for the key Hello,

106
00:08:38.273 --> 00:08:42.790
I would use the square bracket
like I would for a list access.

107
00:08:42.790 --> 00:08:45.996
But instead of putting in a position,
I would put in a key.

108
00:08:49.339 --> 00:08:53.640
&gt;&gt; Nina Zakharenko: I can also
use the mideck.get for a key.

109
00:08:53.640 --> 00:08:58.637
What is the difference between using
the square brackets to access a key in

110
00:08:58.637 --> 00:09:00.739
a dictionary and using .get?

111
00:09:02.969 --> 00:09:06.899
&gt;&gt; Student2: Once you use the key, error
that t comes back, or lack of an error.

112
00:09:06.899 --> 00:09:08.540
&gt;&gt; Nina Zakharenko: Yeah,lack of an error.

113
00:09:08.540 --> 00:09:13.054
So if I use .get on a key
that is not in my dictionary,

114
00:09:13.054 --> 00:09:18.920
I will not get an error,
whereas I will if I use the square.

115
00:09:18.920 --> 00:09:21.851
So my dictionary doesn't have baz in it,
right?

116
00:09:21.851 --> 00:09:25.967
I will get a key error for baz, but

117
00:09:25.967 --> 00:09:31.700
if I use my_dict.get("baz") no error.

118
00:09:31.700 --> 00:09:36.029
And I can also provide
a default value to get.

119
00:09:36.029 --> 00:09:42.250
So if I call get on a key that's no there,
I will get the default value back.

120
00:09:42.250 --> 00:09:47.866
If I call get on a key that is there,
what result will I see?

121
00:09:47.866 --> 00:09:50.877
&gt;&gt; Student3: The key that's there.

122
00:09:50.877 --> 00:09:51.722
&gt;&gt; Nina Zakharenko: Or the value.

123
00:09:51.722 --> 00:09:52.489
&gt;&gt; Student3: The value.

124
00:09:52.489 --> 00:09:56.269
&gt;&gt; Nina Zakharenko: The value for
the key that's there, right?

125
00:09:56.269 --> 00:10:00.879
So, remember dictionaries
are key value pairs, so

126
00:10:00.879 --> 00:10:06.869
I can look at dictionary keys,
I can look at the dictionary values.

127
00:10:06.869 --> 00:10:11.570
Oops, I made a typo not value but values.

128
00:10:11.570 --> 00:10:17.811
But if I wanna look at the key value pairs
at once, I will need to look at items.

129
00:10:17.811 --> 00:10:23.482
Now we'll return into data structure
that kind of look like a list,

130
00:10:23.482 --> 00:10:27.669
but it basically contain
the sequence of tuples.

131
00:10:27.669 --> 00:10:32.989
And we'll use that later with tuple
unpacking when we talk about looping.

132
00:10:32.989 --> 00:10:36.768
Very quickly, mutability.

133
00:10:38.891 --> 00:10:41.805
&gt;&gt; Nina Zakharenko: Okay,
lists are mutable.

134
00:10:51.751 --> 00:10:54.319
&gt;&gt; Nina Zakharenko: We'll
see that the value changed.

135
00:10:54.319 --> 00:10:56.884
Dictionaries are also mutable.

136
00:11:04.130 --> 00:11:10.521
&gt;&gt; Nina Zakharenko: To add a new key,
her foo, and the value is bar.

137
00:11:10.521 --> 00:11:15.369
Okay, sets are also mutable.

138
00:11:18.230 --> 00:11:22.570
&gt;&gt; Nina Zakharenko: But
we can't change our set with,

139
00:11:25.200 --> 00:11:28.720
&gt;&gt; Nina Zakharenko: With the index here.

140
00:11:28.720 --> 00:11:29.580
Why is that?

141
00:11:30.750 --> 00:11:31.551
&gt;&gt; Student3: Because it's.

142
00:11:31.551 --> 00:11:33.147
&gt;&gt; Student: Not ordered.
&gt;&gt; Nina Zakharenko: It's not ordered.

143
00:11:36.589 --> 00:11:40.777
&gt;&gt; Nina Zakharenko: Okay, I can use .add,

144
00:11:40.777 --> 00:11:45.809
.remove, and .discard.

145
00:11:45.809 --> 00:11:50.286
Tuples on the other hand are immutable.

146
00:11:53.090 --> 00:11:56.700
&gt;&gt; Nina Zakharenko: So
if I try to change, I can do this, right?

147
00:11:56.700 --> 00:12:01.624
I can look at the first item
in my tuple that index 0.

148
00:12:01.624 --> 00:12:05.896
But if I try to change it,
when I get an error,

149
00:12:05.896 --> 00:12:10.850
the tuple object does not
support item assignment.

