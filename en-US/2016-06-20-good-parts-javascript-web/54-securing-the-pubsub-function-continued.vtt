WEBVTT

1
00:00:00.000 --> 00:00:03.712
[MUSIC]

2
00:00:03.712 --> 00:00:05.842
&gt;&gt; Speaker 1: There's
still one attack left, and

3
00:00:05.842 --> 00:00:07.840
this one is an out of order attack.

4
00:00:09.170 --> 00:00:11.120
That the attacker can cause

5
00:00:12.600 --> 00:00:17.410
a message to be delivered before another
message, at least to some subscribers.

6
00:00:17.410 --> 00:00:20.539
By doing so, he can create
confusion in the marketplace.

7
00:00:21.660 --> 00:00:26.530
How do you do that?

8
00:00:26.530 --> 00:00:27.720
&gt;&gt; Speaker 2: You did this in school,

9
00:00:27.720 --> 00:00:30.260
should it in your messages in
the order to be subscribers.

10
00:00:31.260 --> 00:00:33.550
&gt;&gt; Speaker 1: Each of the subscribers
should get them in the order that

11
00:00:33.550 --> 00:00:36.190
subscribed, and
they should also each of them

12
00:00:36.190 --> 00:00:38.370
should get the messages in
the order that they are sent.

13
00:00:38.370 --> 00:00:45.570
&gt;&gt; Speaker 3: And some subscribers
subscribe with the number?

14
00:00:45.570 --> 00:00:47.570
&gt;&gt; Speaker 2: No, that would cause
an exception to get thrown, and

15
00:00:47.570 --> 00:00:51.800
we already ignored those.

16
00:00:51.800 --> 00:00:55.010
&gt;&gt; Speaker 3: So we're assuming at this
point that we're working on the foreach

17
00:00:55.010 --> 00:01:02.090
loop rather than the previous either one,
but not to focus on this one.

18
00:01:02.090 --> 00:01:07.550
&gt;&gt; Speaker 1: You like,
since we can see that the corrections that

19
00:01:07.550 --> 00:01:15.898
we have made up to this point have fixed
this new And so much of the push push on.

20
00:01:15.898 --> 00:01:19.900
&gt;&gt; Speaker 3: It's very
easy pushing their function

21
00:01:21.230 --> 00:01:27.480
methods or screw with the order of it,
reverse it?

22
00:01:27.480 --> 00:01:30.260
&gt;&gt; Speaker 1: No, you're talking
about the first problem we did?

23
00:01:30.260 --> 00:01:30.880
&gt;&gt; Speaker 3: Yeah.

24
00:01:30.880 --> 00:01:35.120
&gt;&gt; Speaker 1: Yeah, and that one was
using store, because we could name

25
00:01:36.140 --> 00:01:40.440
where it was going to go, and that's when
we haven't provided an API for doing that.

26
00:01:40.440 --> 00:01:41.070
&gt;&gt; Speaker 3: Gotcha.

27
00:01:41.070 --> 00:01:44.750
&gt;&gt; Speaker 1: And the good thing
about this construction is that

28
00:01:44.750 --> 00:01:49.050
that's impossible because they, well,
it's something that we fix the thing,

29
00:01:49.050 --> 00:01:52.220
where they can get access to
the subscribers or a through this.

30
00:01:52.220 --> 00:01:55.697
There is no way that they can add
a property to subscribers except through

31
00:01:55.697 --> 00:01:56.954
the subscribe function.

32
00:02:06.003 --> 00:02:08.803
&gt;&gt; Speaker 2: Doesn't have
access to this anymore, to the-

33
00:02:08.803 --> 00:02:09.743
&gt;&gt; Speaker 1: That's correct.

34
00:02:25.963 --> 00:02:28.018
&gt;&gt; Speaker 4: Are we trying to
get the messages out of order or

35
00:02:28.018 --> 00:02:30.070
the subscribers out of order?

36
00:02:30.070 --> 00:02:31.095
&gt;&gt; Speaker 1: The message is out of order.

37
00:02:31.095 --> 00:02:35.237
&gt;&gt; Speaker 3: Set time out.

38
00:02:35.237 --> 00:02:39.818
Is and that would make,

39
00:02:39.818 --> 00:02:45.272
it would change where yours comes in.

40
00:02:45.272 --> 00:02:49.450
&gt;&gt; Speaker 1: Yeah, settimeout
might be part of the solution but

41
00:02:49.450 --> 00:02:52.970
it's not part of the problem.

42
00:02:52.970 --> 00:02:53.960
&gt;&gt; Speaker 2: You know we might wait.

43
00:02:53.960 --> 00:02:56.430
&gt;&gt; Speaker 1: We don't
have to wait on the site.

44
00:02:57.770 --> 00:03:00.730
&gt;&gt; Speaker 2: You know and that's because
it's synchronous anyways if it works if we

45
00:03:00.730 --> 00:03:08.639
just call everything just
exactly as in effect.

46
00:03:09.890 --> 00:03:12.420
&gt;&gt; Speaker 1: because it is
it stops everything ready.

47
00:03:12.420 --> 00:03:15.310
So yeah so that that's not part of this

48
00:03:21.360 --> 00:03:24.990
you know every time you click
every time somebody calls publish

49
00:03:24.990 --> 00:03:30.310
a publication is that's the message right?

50
00:03:31.920 --> 00:03:35.410
&gt;&gt; Speaker 2: Is gonna read
through the subscribers and

51
00:03:35.410 --> 00:03:38.290
call it and then what you're saying is

52
00:03:41.090 --> 00:03:45.630
I call it and then you call it after
me you're that you're in the bad guy

53
00:03:45.630 --> 00:03:49.323
you call it after me because somehow or
yours jumper wire infront of mine.

54
00:03:49.323 --> 00:03:49.823
&gt;&gt; Speaker 1: Yeah.

55
00:03:52.973 --> 00:03:53.786
&gt;&gt; Speaker 1: That's
what we're looking for.

56
00:03:53.786 --> 00:03:58.800
But you can't call it until it's
finished with mine because it's,

57
00:03:58.800 --> 00:04:00.366
the process is long.

58
00:04:00.366 --> 00:04:03.950
But that wrong.

59
00:04:03.950 --> 00:04:04.600
&gt;&gt; Speaker 2: Right.

60
00:04:04.600 --> 00:04:10.340
&gt;&gt; Speaker 3: Can I pass in
the pubsub object to my function?

61
00:04:10.340 --> 00:04:14.510
and then resubscribe myself
in the midst of a call.

62
00:04:14.510 --> 00:04:15.450
&gt;&gt; Speaker 1: You're close.

63
00:04:16.650 --> 00:04:19.090
It's not quite like that but
it's that kind of this.

64
00:04:19.090 --> 00:04:25.020
&gt;&gt; Speaker 2: Is this a vulnerability
in for huge not because these

65
00:04:25.020 --> 00:04:29.890
are just some preachy Right.

66
00:04:29.890 --> 00:04:33.490
&gt;&gt; Speaker 3: So are we essentially
creating an infinite loop

67
00:04:33.490 --> 00:04:34.400
based on what he said.

68
00:04:35.820 --> 00:04:37.440
&gt;&gt; Speaker 1: We are not looking for

69
00:04:37.440 --> 00:04:40.880
an infinite loop because an infinite loop
would be a denial of service attack.

70
00:04:42.030 --> 00:04:43.690
&gt;&gt; Speaker 3: Okay.
&gt;&gt; Speaker 1: And someone can do

71
00:04:43.690 --> 00:04:45.880
an infinite loop without calling our code.

72
00:04:45.880 --> 00:04:48.555
They can just sit in their own
code into an infinite loop so

73
00:04:48.555 --> 00:04:51.302
that that's not something
this code can defend against.

74
00:04:56.242 --> 00:05:00.390
&gt;&gt; Speaker 2: And inside of forEach,
can you change the value of s?

75
00:05:02.380 --> 00:05:03.340
&gt;&gt; Speaker 1: Yes.

76
00:05:03.340 --> 00:05:08.050
&gt;&gt; Speaker 2: So
if I publish one object, and

77
00:05:08.050 --> 00:05:11.330
then later on, publish another object And

78
00:05:11.330 --> 00:05:17.400
that separate object has a function in
it that sets aspect to the first object.

79
00:05:18.650 --> 00:05:21.010
Is that a nasty thing to do.

80
00:05:21.010 --> 00:05:24.190
&gt;&gt; Speaker 1: Well that's not likely to
happen because whatever function you're

81
00:05:24.190 --> 00:05:28.280
going to be doing, that will be
created outside of the scope and

82
00:05:28.280 --> 00:05:29.120
so will not see at.

83
00:05:33.620 --> 00:05:37.610
yeah only functions in
this scope can see us.

84
00:05:37.610 --> 00:05:39.790
&gt;&gt; Speaker 3: So if I pass it.

85
00:05:39.790 --> 00:05:44.510
The pops up to my subscribers function

86
00:05:44.510 --> 00:05:48.640
when my function is called
I call public Again.

87
00:05:48.640 --> 00:05:49.410
&gt;&gt; Speaker 1: Yes.
&gt;&gt; Speaker 3: And

88
00:05:49.410 --> 00:05:52.810
we restart to loop in the beginning again.

89
00:05:52.810 --> 00:05:55.440
&gt;&gt; Speaker 1: Exactly.
&gt;&gt; Speaker 3: And we keep on doing

90
00:05:55.440 --> 00:05:56.770
that we'll never get it.

91
00:05:56.770 --> 00:05:57.270
&gt;&gt; Speaker 1: Right.

92
00:05:59.620 --> 00:06:01.500
So, this is a tacky just describe.

93
00:06:01.500 --> 00:06:08.520
So, he subscribes a function
Which will publish and

94
00:06:08.520 --> 00:06:15.900
this function gets called in
the publication loop so he can cut it.

95
00:06:15.900 --> 00:06:19.680
He can then cause his own
message to get published and

96
00:06:19.680 --> 00:06:24.369
delivered to everybody who is after
himself in the subscriber list

97
00:06:25.640 --> 00:06:28.530
And in doing that,
he causes things to go out of order.

98
00:06:28.530 --> 00:06:32.360
&gt;&gt; Speaker 4: Leonardo in
the chat room beat us again.\

99
00:06:32.360 --> 00:06:33.235
&gt;&gt; Speaker 1: Way to go Leonardo.

100
00:06:33.235 --> 00:06:36.730
&gt;&gt; [LAUGH]
&gt;&gt; Speaker 4: Well Vincent was the first,

101
00:06:36.730 --> 00:06:39.480
yeah Vincent beat us last time.

102
00:06:39.480 --> 00:06:40.590
This time it was Leonardo.

103
00:06:40.590 --> 00:06:42.580
&gt;&gt; Speaker 1: You need
to be telling us that.

104
00:06:42.580 --> 00:06:44.500
Before-
&gt;&gt; Speaker 4: I know.

105
00:06:44.500 --> 00:06:45.070
&gt;&gt; Speaker 1: Yeah.

106
00:06:45.070 --> 00:06:46.660
&gt;&gt; Speaker 4: I didn't know it's like-
&gt;&gt; Speaker 2: He's

107
00:06:46.660 --> 00:06:48.350
a
&gt;&gt; Speaker 4: Yeah.

108
00:06:49.830 --> 00:06:50.750
&gt;&gt; Speaker 1: Okay, so

109
00:06:50.750 --> 00:06:54.510
the reason I used the limit
function that we wrote yesterday.

110
00:06:54.510 --> 00:06:59.050
Because if I don't then I'm just creating
a denial of service attack, right.

111
00:06:59.050 --> 00:07:02.380
We'll keep calling it over and
over again recursively.

112
00:07:02.380 --> 00:07:04.950
And a denial of service
attack doesn't accomplish

113
00:07:04.950 --> 00:07:08.970
the security exploit that we're trying
to do, it just impairs a system.

114
00:07:08.970 --> 00:07:10.530
&gt;&gt; Speaker 2: A limit's
what we wrote yesterday.

115
00:07:10.530 --> 00:07:11.940
&gt;&gt; Speaker 1: Yeah we
wrote limit yesterday, so

116
00:07:11.940 --> 00:07:17.200
that means when I get called I
am going to send one message.

117
00:07:19.610 --> 00:07:21.849
And that message will get
delivered before everybody else.

118
00:07:28.780 --> 00:07:31.290
So how would you fix that?

119
00:07:31.290 --> 00:07:33.990
&gt;&gt; Speaker 2: every time
somebody publishes a message.

120
00:07:33.990 --> 00:07:36.770
My message will go out it
would only ever happen once.

121
00:07:36.770 --> 00:07:39.700
&gt;&gt; Speaker 1: Well but I can control
it you know this is the simplest

122
00:07:39.700 --> 00:07:44.523
way to keep it from getting Getting
abusive but obviously we can put a smarter

123
00:07:44.523 --> 00:07:48.092
function in there that could change
its behavior every time it's called.

124
00:07:48.092 --> 00:07:53.127
&gt;&gt; Speaker 3: You could
take off the subscriber and

125
00:07:53.127 --> 00:07:58.654
make sure it's not an object right?

126
00:07:58.654 --> 00:08:00.570
The subscriber before you push.

127
00:08:00.570 --> 00:08:04.380
&gt;&gt; Speaker 1: No,
the subscribers have to be In fact,

128
00:08:04.380 --> 00:08:08.098
that's what the tri catch was for,
to guarantee that they are functions.

129
00:08:08.098 --> 00:08:09.969
&gt;&gt; Speaker 3: Okay.

130
00:08:09.969 --> 00:08:14.690
Can you-
&gt;&gt; Speaker 2: Would you just temporarily

131
00:08:14.690 --> 00:08:19.170
changed the value of publish to
something else, but it's frozen.

132
00:08:20.280 --> 00:08:21.590
&gt;&gt; Speaker 1: Right we,
yeah we fixed that one.

133
00:08:23.090 --> 00:08:26.240
&gt;&gt; Speaker 2: I was just trying to
think of a way to disable publish

134
00:08:26.240 --> 00:08:28.410
inside of this loop.

135
00:08:28.410 --> 00:08:31.540
So if you just set, you could, yeah,

136
00:08:31.540 --> 00:08:35.010
you put a var at the top of
this that says publish off.

137
00:08:35.010 --> 00:08:38.210
&gt;&gt; Speaker 1: Yeah, we could put a boolean
up at the top which says, we're in

138
00:08:38.210 --> 00:08:44.100
the publication mode, so subscribe or
publish is turned off while we're looping.

139
00:08:44.100 --> 00:08:46.510
That would certainly work.

140
00:08:46.510 --> 00:08:48.980
The way I would approach it is,

141
00:08:48.980 --> 00:08:53.390
I would do an asynchronous solution
because I like a synchrony.

142
00:08:53.390 --> 00:09:00.410
So there's something that's in browsers
and in Java and in node called setTimeout.

143
00:09:00.410 --> 00:09:03.130
And setTimeout receives a function and

144
00:09:03.130 --> 00:09:06.360
causes that function to get
executed in the future.

145
00:09:06.360 --> 00:09:11.220
And you can give it a time which says no
sooner than zero milliseconds from now

146
00:09:11.220 --> 00:09:12.540
call this function.

147
00:09:12.540 --> 00:09:15.090
But this function happens
in a different turn.

148
00:09:15.090 --> 00:09:17.560
So it'll get scheduled
after all of the current

149
00:09:17.560 --> 00:09:19.830
work in the current turn is finished.

150
00:09:19.830 --> 00:09:22.450
So this would cause.

151
00:09:22.450 --> 00:09:26.271
Everything to get lined
up in the timer queue and

152
00:09:26.271 --> 00:09:30.952
then if someone wants to
subscribe during a publication,

153
00:09:30.952 --> 00:09:35.169
their stuff will get added
later in the timer queue.

154
00:09:35.169 --> 00:09:39.987
So everything stays in order, we're using
the timer queue to sort the messages.

155
00:09:43.568 --> 00:09:45.286
&gt;&gt; Speaker 1: Now, so we could do that.

156
00:09:45.286 --> 00:09:48.658
&gt;&gt; Speaker 3: So you move the publication
off into a separate queue the one that

157
00:09:48.658 --> 00:09:51.666
gets processed independently
if whatever goes on here?

158
00:09:51.666 --> 00:09:56.279
&gt;&gt; Speaker 1: Right and it also means I
don't need to try catch here now because

159
00:09:57.390 --> 00:10:00.270
If it fails it'll fail in that turn.

160
00:10:00.270 --> 00:10:04.130
But then the system says, well that turns
finish and will go on to the next one.

161
00:10:04.130 --> 00:10:09.060
And so everything keeps going.

162
00:10:09.060 --> 00:10:12.610
Now it turns out there's one hazard in
this because of the design error in

163
00:10:12.610 --> 00:10:18.230
the way such a timeout works when you
pause such timeout it returns a number And

164
00:10:18.230 --> 00:10:23.000
you can pass that number to clear timeout
and that'll prevent things from happening.

165
00:10:23.000 --> 00:10:25.430
Unfortunately, it is
an easily guessable number.

166
00:10:25.430 --> 00:10:29.460
And that means if the attacker
can guess what the next

167
00:10:29.460 --> 00:10:31.220
clear timeout number is going to be.

168
00:10:31.220 --> 00:10:33.440
He can prevent messages
from being delivered.

169
00:10:33.440 --> 00:10:35.510
By cancelling those messages
that are in the queue.

170
00:10:36.680 --> 00:10:40.170
So we would have to fix that but
we'll fix that one another day.

