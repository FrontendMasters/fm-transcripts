WEBVTT

1
00:00:00.000 --> 00:00:03.696
[MUSIC]

2
00:00:03.696 --> 00:00:06.450
&gt;&gt; Douglas Crockford: So, I've been
thinking a lot about the next language.

3
00:00:06.450 --> 00:00:09.910
What's the language that
replaces JavaScript and

4
00:00:09.910 --> 00:00:11.550
I really hope there is a next language.

5
00:00:11.550 --> 00:00:15.520
Because if JavaScript is
the last programming language,

6
00:00:15.520 --> 00:00:16.990
that would be really sad.

7
00:00:16.990 --> 00:00:18.120
Wouldn't it?

8
00:00:18.120 --> 00:00:22.400
I mean, for our kids, right,we need
to leave them a better language.

9
00:00:23.450 --> 00:00:25.660
We can't allow JavaScript
to be the last language.

10
00:00:25.660 --> 00:00:29.760
So something is going to have
to have to succeed it and

11
00:00:29.760 --> 00:00:34.850
I've been searching for the next language,
and what are the signs?

12
00:00:34.850 --> 00:00:36.450
How will we know when it's here?

13
00:00:36.450 --> 00:00:39.710
And it's sort of like waiting the Messiah,
how do you know?

14
00:00:39.710 --> 00:00:42.740
And I don't know, but I'm looking for and

15
00:00:42.740 --> 00:00:45.850
then I'm starting to try to
understand what it's going to be.

16
00:00:45.850 --> 00:00:47.660
I'm confident, it's not here yet.

17
00:00:47.660 --> 00:00:48.480
Actually, I don't know that.

18
00:00:48.480 --> 00:00:54.230
It might be it's here, but
I just haven't recognized it yet, but

19
00:00:54.230 --> 00:00:57.268
there are people who tell me, it C#.

20
00:00:57.268 --> 00:00:58.994
No, no, no.

21
00:00:58.994 --> 00:01:00.871
Or it's Java,
it's been here the whole time, no, no.

22
00:01:00.871 --> 00:01:04.607
The next language is another language and
it's the thing,

23
00:01:04.607 --> 00:01:09.325
which is the right thing to replace
JavaScript and we haven't seen it yet.

24
00:01:09.325 --> 00:01:12.600
But I think a lot about what it's
going to be and what it's going to do.

25
00:01:14.570 --> 00:01:19.160
I am confident that when it arrives, we
will reject it out of hand, as we always

26
00:01:19.160 --> 00:01:23.910
do, because programmers are as emotional
and irrational as normal people.

27
00:01:23.910 --> 00:01:28.880
We think that we're not and maybe our
spouses tell us we're not, but it's true.

28
00:01:28.880 --> 00:01:33.660
We are and most of what we think about
what we do is based on emotion, and

29
00:01:33.660 --> 00:01:37.640
not on reason, even though we
imagine it's the other way around.

30
00:01:37.640 --> 00:01:43.010
So this sounds like a wild charge to make
of my own profession, but I have some

31
00:01:43.010 --> 00:01:48.970
good reasons for saying this and I think
the historical record backs me up on this.

32
00:01:48.970 --> 00:01:50.410
For example,

33
00:01:50.410 --> 00:01:54.309
it took a generation to agree that
high-level languages were a good idea.

34
00:01:55.390 --> 00:01:59.288
Back in the early days when everything
was in assembly language and

35
00:01:59.288 --> 00:02:04.242
the first high-level languages were being
developed, Fortran, COBOL and so on.

36
00:02:04.242 --> 00:02:08.291
Who would have most benefited
from use of those languages?

37
00:02:08.291 --> 00:02:09.210
The programmers.

38
00:02:10.950 --> 00:02:13.560
Who was it who was opposed
to those languages?

39
00:02:13.560 --> 00:02:14.470
It was the programmers.

40
00:02:14.470 --> 00:02:21.970
They were complaining that the languages
were taking control away from them.

41
00:02:21.970 --> 00:02:24.590
That they didn't give them
the performance that they needed.

42
00:02:24.590 --> 00:02:28.780
They had all these reasons for why they
wanted to stay down in the muck, that they

43
00:02:28.780 --> 00:02:34.810
didn't want to be elevated in these
more expressive, productive languages.

44
00:02:35.830 --> 00:02:39.968
It took a generation to agree
that goto was a bad idea.

45
00:02:39.968 --> 00:02:44.416
Publishes his letter in 67 and
that starts an argument,

46
00:02:44.416 --> 00:02:51.270
that literally goes on for 20 years and
the arguments were all silly arguments.

47
00:02:51.270 --> 00:02:54.090
Now, we need the performance of the goto.

48
00:02:54.090 --> 00:02:55.720
It's how I express myself.

49
00:02:55.720 --> 00:02:58.700
I can't be me, if I can't use goto.

50
00:02:58.700 --> 00:03:01.600
We have a goto tradition,
my grandfather used goto.

51
00:03:01.600 --> 00:03:06.375
You can't take my cold dead hand, all of
those arguments were all made about goto.

52
00:03:07.470 --> 00:03:10.590
It took a generation to agree
that objects were a good idea.

53
00:03:10.590 --> 00:03:15.726
So objects are first discovered
in Simula in Norway in 1967-

54
00:03:15.726 --> 00:03:17.592
&gt;&gt; Speaker 2: Under the ice.

55
00:03:17.592 --> 00:03:19.538
&gt;&gt; Douglas Crockford: I'm sorry.
&gt;&gt; Speaker 2: Under the ice.

56
00:03:19.538 --> 00:03:21.007
You said, they were discovered.

57
00:03:21.007 --> 00:03:22.334
&gt;&gt; Douglas Crockford: Well, in Norway.

58
00:03:22.334 --> 00:03:23.204
&gt;&gt; Speaker 2: Under the ice.

59
00:03:23.204 --> 00:03:26.960
&gt;&gt; Douglas Crockford: No, in Oslo.

60
00:03:26.960 --> 00:03:31.696
And as always happens with
the really important innovations,

61
00:03:31.696 --> 00:03:35.624
the world took no notice at all,
except for one guy,

62
00:03:35.624 --> 00:03:39.935
a graduate student at
the University of Utah, Alan Kay.

63
00:03:39.935 --> 00:03:43.850
Who then takes this idea to
Xerox PARC in California,

64
00:03:43.850 --> 00:03:46.721
thinking that this idea of objects is so

65
00:03:46.721 --> 00:03:53.530
incredibly powerful that he can use it
as a programming language for children.

66
00:03:53.530 --> 00:03:58.480
That children can use to program
their personal portable devices.

67
00:03:58.480 --> 00:04:00.850
There was a lot of his vision,
which was right.

68
00:04:00.850 --> 00:04:02.760
A lot of his vision we
haven't caught up to yet,

69
00:04:02.760 --> 00:04:04.900
we still don't have the language for
children.

70
00:04:04.900 --> 00:04:08.520
I don't think we have a language for
adults yet, but we're still working on it,

71
00:04:10.760 --> 00:04:14.105
but they then spent a decade
developing that language and

72
00:04:14.105 --> 00:04:18.200
did a brilliant, brilliant job on it.

73
00:04:18.200 --> 00:04:23.860
And so in the late 80s,
the industry had a choice.

74
00:04:23.860 --> 00:04:25.870
We're gonna go into object
oriented programming.

75
00:04:27.510 --> 00:04:30.265
It took a long time to get there,
but we're gonna do it.

76
00:04:30.265 --> 00:04:35.014
Are we gonna go with Smalltalk-80,
one of the best designed

77
00:04:35.014 --> 00:04:40.070
programming languages in history,
or are we gonna go with C++?

78
00:04:40.070 --> 00:04:44.410
And the decision was made by people
who fundamentally did not understand

79
00:04:44.410 --> 00:04:47.726
object-oriented programming and
they chose C++.

80
00:04:47.726 --> 00:04:49.680
Because in order to use that language,

81
00:04:49.680 --> 00:04:53.620
you did not need to understand anything
about object oriented programming.

82
00:04:53.620 --> 00:04:57.930
That language got some things
fundamentally wrong about object systems.

83
00:04:57.930 --> 00:05:00.830
Unfortunately, the language has
been extremely influential and

84
00:05:00.830 --> 00:05:05.950
has set the mold for virtually
everything that's happened ever since.

85
00:05:05.950 --> 00:05:07.690
I don't know if are ever going
to catch up to Smalltalk,

86
00:05:09.210 --> 00:05:12.070
then it took two generations to
agree that lambdas were a good idea.

87
00:05:13.440 --> 00:05:19.960
So, Alan Kay who is a Smalltalk guy,
he started by writing

88
00:05:19.960 --> 00:05:24.695
a little program in NOVA basic on
a Data General Mini Computer, which

89
00:05:24.695 --> 00:05:29.640
demonstrated his weird little language,
and he started touring with this idea.

90
00:05:29.640 --> 00:05:34.610
Taking it to labs and
universities, and he visited MIT.

91
00:05:34.610 --> 00:05:39.210
Very smart guys at MIT and he's telling
them about his new language, but

92
00:05:39.210 --> 00:05:41.200
it's still early in object
going to programming and

93
00:05:41.200 --> 00:05:44.880
he doesn't have the vocabulary that we
have now to describe what's going on.

94
00:05:44.880 --> 00:05:48.270
So he couldn't say you invoke
a method on an object,

95
00:05:48.270 --> 00:05:51.050
cuz nobody knew to say that yet.

96
00:05:51.050 --> 00:05:54.040
So he described it,
as you send a message to an object.

97
00:05:56.220 --> 00:06:00.370
Well, the guys at MIT listening to him
say, well, you're not actually sending

98
00:06:00.370 --> 00:06:05.390
a message, you're making a sub
routine indication within direction.

99
00:06:06.490 --> 00:06:08.501
But what if you did send a message?

100
00:06:08.501 --> 00:06:12.956
And that started research in
the actor model and the actor model,

101
00:06:12.956 --> 00:06:17.735
you actually have these entities
that are running in separate systems

102
00:06:17.735 --> 00:06:20.340
that can send messages to each other.

103
00:06:20.340 --> 00:06:24.230
That's basically what actors are and
the guy who came up with this,

104
00:06:24.230 --> 00:06:27.730
Carl Hewitt, is one of these guys who's so
amazingly smart.

105
00:06:27.730 --> 00:06:31.290
It's like he was born on the other
side of the paradigm shift.

106
00:06:31.290 --> 00:06:35.660
When he talks about stuff,
people cannot understand what he's saying.

107
00:06:35.660 --> 00:06:39.970
He's very clear, he's very eloquent,
he speaks really well, but

108
00:06:39.970 --> 00:06:42.220
he's talking from a frame of reference,
which is so

109
00:06:42.220 --> 00:06:46.040
foreign to the rest of humanity
that nobody understands him.

110
00:06:46.040 --> 00:06:48.700
Including the other people at MIT,
they were all very smart and

111
00:06:48.700 --> 00:06:51.060
they all had a lot of respect for
Carl, but

112
00:06:51.060 --> 00:06:53.850
they couldn't figure out what he was
raving about with all these actors.

113
00:06:53.850 --> 00:06:58.550
So a couple of them, Sussman and Steele,
decide we need to build something in order

114
00:06:58.550 --> 00:07:01.090
to understand what it is
that Carl's talking about.

115
00:07:01.090 --> 00:07:07.170
So they start by taking LISP and
rewriting it into a language which

116
00:07:07.170 --> 00:07:12.220
models the actor model, and they didn't
fully implement the actor model.

117
00:07:12.220 --> 00:07:17.920
So they never did figure it out,
but the language that they created

118
00:07:17.920 --> 00:07:23.310
was called Scheme and
they had accidentally discovered

119
00:07:23.310 --> 00:07:27.510
functions with lexical closure and all the
stuff that we've been working on today.

120
00:07:27.510 --> 00:07:29.680
So, the fact that you could
have higher order functions,

121
00:07:29.680 --> 00:07:33.670
functions that return functions and all
that stuff happened happened by accident,

122
00:07:33.670 --> 00:07:36.110
trying to figure out what
Carl Hewitt was talking about.

123
00:07:36.110 --> 00:07:42.770
And that is maybe the most important
discovery in the history of programming.

124
00:07:42.770 --> 00:07:47.350
And as always happens,
the world took no notice of it at all and

125
00:07:47.350 --> 00:07:52.811
it just sat around at MIT for years and
years going nowhere and is only now,

126
00:07:52.811 --> 00:07:57.505
finally after 40 years,
finally coming to the mainstream.

127
00:07:57.505 --> 00:08:01.732
And it's coming to the mainstream, because
it was actually a really good idea and

128
00:08:01.732 --> 00:08:02.720
its time has come.

129
00:08:02.720 --> 00:08:03.620
We really need it now.

130
00:08:04.930 --> 00:08:07.260
So the reason these things take so long,

131
00:08:09.180 --> 00:08:13.009
everything takes at least a generation,
is because we don't change minds.

132
00:08:14.700 --> 00:08:19.930
We have to wait for
a generation to retire or die before

133
00:08:19.930 --> 00:08:24.870
we can get critical mass on the next new
idea and that's the way progress goes.

134
00:08:24.870 --> 00:08:28.990
We imagine this is an extremely innovative
industry, and in some ways it is, but

135
00:08:28.990 --> 00:08:31.020
in some ways,
we're just like everybody else.

136
00:08:32.060 --> 00:08:33.465
So, I lived through the goto thing.

137
00:08:33.465 --> 00:08:37.784
I remember when that was happening and
all the arguments, and they were really

138
00:08:37.784 --> 00:08:41.720
emotional angry arguments, and
all the arguments were from emotion.

139
00:08:41.720 --> 00:08:46.200
There was very little
argument from fact and

140
00:08:46.200 --> 00:08:50.980
it just went on, and on, and on,
and on, and then it got quiet.

141
00:08:52.160 --> 00:08:54.620
It was like, are they gone?

142
00:08:56.220 --> 00:08:57.380
Can we get rid of the goto now?

143
00:08:58.620 --> 00:09:01.560
And we did,
we got rid of it and it's gone.

144
00:09:01.560 --> 00:09:06.066
And we're not missing it and
all of the promises

145
00:09:06.066 --> 00:09:09.990
that the world was going to end,
if we took rid of goto or

146
00:09:09.990 --> 00:09:12.660
the lives of programmers
are gonna be made more miserable.

147
00:09:12.660 --> 00:09:15.020
None of that turned out to be true,
we're not missing it.

148
00:09:15.020 --> 00:09:16.890
We're doing great without it.

149
00:09:16.890 --> 00:09:21.176
In fact, some of our languages have maybe
a little bit too much goto left in them,

150
00:09:21.176 --> 00:09:23.010
but we're getting by.

151
00:09:23.010 --> 00:09:24.978
So, it turns out we never needed goto.

152
00:09:24.978 --> 00:09:25.499
Don't need it.

153
00:09:25.499 --> 00:09:27.200
We're doing better without it.

154
00:09:27.200 --> 00:09:33.780
And in fact, what actually happened
was by getting rid of goto,

155
00:09:33.780 --> 00:09:37.640
it made it easier to write
programs of greater complexity.

156
00:09:38.890 --> 00:09:44.610
Because if your only control construct
is goto and conditional goto,

157
00:09:44.610 --> 00:09:50.180
there's a limit to how complex a program
can get before it comes unmanageable.

158
00:09:50.180 --> 00:09:54.938
And by getting rid of goto, we could
do better with larger programs and

159
00:09:54.938 --> 00:10:00.070
we could do better at achieving our
ambitions in terms of writing software.

160
00:10:01.070 --> 00:10:05.552
So, the people who are arguing against
goto were the people who would have

161
00:10:05.552 --> 00:10:06.936
benefited from goto.

162
00:10:06.936 --> 00:10:11.551
They're benefited from getting rid of
goto and it is always like that, and

163
00:10:11.551 --> 00:10:14.190
I expect it will always be like that.

164
00:10:14.190 --> 00:10:19.030
So in looking for the next language,
I'm looking for it to be different in

165
00:10:19.030 --> 00:10:24.010
some important ways and I'm expecting it
to be crucified for those differences.

