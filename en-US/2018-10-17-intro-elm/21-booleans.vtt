WEBVTT

1
00:00:00.000 --> 00:00:02.218
&gt;&gt; Richard Feldman: So Booleans,
Elm has two Boolean values,

2
00:00:02.218 --> 00:00:05.860
which I think is the correct number,
if you're gonna have Booleans.

3
00:00:05.860 --> 00:00:10.081
True and false, they are capitalized like
they are in Python, there is a very good

4
00:00:10.081 --> 00:00:13.647
specific reason for why they
are capitalized unlike in JavaScript.

5
00:00:13.647 --> 00:00:14.604
Where they're not capitalized.

6
00:00:14.604 --> 00:00:18.248
We're gonna know why they're capitalized
a little bit later, but for now,

7
00:00:18.248 --> 00:00:21.232
it's enough to know that they
happen to be capitalized in Elm.

8
00:00:21.232 --> 00:00:24.679
There are a bunch of different
Boolean comparisons you can do,

9
00:00:24.679 --> 00:00:28.332
so == is one, so x == y,
that will return either True or False.

10
00:00:28.332 --> 00:00:31.458
You can say not,
which is just a plain function in Elm.

11
00:00:31.458 --> 00:00:34.124
So in JavaScript,
that's the exclamation point operator, but

12
00:00:34.124 --> 00:00:36.119
in all these there's no
special syntax to that.

13
00:00:36.119 --> 00:00:39.922
There's just a function called not which
if you give it true it returns false and

14
00:00:39.922 --> 00:00:40.563
vice versa.

15
00:00:40.563 --> 00:00:43.210
There's a short hand for not equal to.

16
00:00:43.210 --> 00:00:44.760
So it's a slash equals.

17
00:00:44.760 --> 00:00:49.472
This comes from the ML family of languages
which is what Elm syntax is based on.

18
00:00:49.472 --> 00:00:53.745
So they don't use exclamation point equals
to mean not equals, they use slash equals.

19
00:00:53.745 --> 00:00:56.775
The idea is it's supposed to kinda
look like if you squint an equal or

20
00:00:56.775 --> 00:00:59.871
the slash through it for
like the not equal's Mathematical symbol.

21
00:00:59.871 --> 00:01:00.927
But it does the same thing.

22
00:01:00.927 --> 00:01:02.767
It just means not equals.

23
00:01:02.767 --> 00:01:03.768
There's also and

24
00:01:03.768 --> 00:01:07.581
and or, which look and work the same
way that they do in JavaScript.

25
00:01:07.581 --> 00:01:09.435
Nothing really special there,

26
00:01:09.435 --> 00:01:14.045
just same kind of semantics that you
would find in most programming languages.

