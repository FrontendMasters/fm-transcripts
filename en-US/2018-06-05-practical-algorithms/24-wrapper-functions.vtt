WEBVTT

1
00:00:00.000 --> 00:00:04.436
&gt;&gt; Bianca Gandolfo: So next we're going to
talk a little bit about two patterns for

2
00:00:04.436 --> 00:00:05.383
recursion.

3
00:00:05.383 --> 00:00:07.491
The first one is a wrapper function, and

4
00:00:07.491 --> 00:00:12.338
the second is the accumulator pattern.
&gt;&gt; Bianca Gandolfo: [LAUGH] I

5
00:00:12.338 --> 00:00:14.079
love my own jokes.

6
00:00:14.079 --> 00:00:18.018
So awesome, okay, so back to our looping,

7
00:00:18.018 --> 00:00:24.092
we're going to loop first,
this is our original loop, actually.

8
00:00:24.092 --> 00:00:28.881
So the loop that we already did,
we're using a wrapper function.

9
00:00:28.881 --> 00:00:34.957
And in this one,
we are just passing our values each time.

10
00:00:34.957 --> 00:00:43.156
So let's investigate how this loop
works using our call stack game.

11
00:00:43.156 --> 00:00:46.713
All right, so let's call,
what are we gonna call it with,

12
00:00:46.713 --> 00:00:52.749
let's just call it with 1 and 3, so.
&gt;&gt; Bianca Gandolfo: So

13
00:00:52.749 --> 00:00:58.448
this is like our function's
actually being called over here.

14
00:00:58.448 --> 00:01:01.491
And then somewhere else,
inside your execution environment,

15
00:01:01.491 --> 00:01:04.477
your browser, or
wherever you're running your JavaScript,

16
00:01:04.477 --> 00:01:10.708
this is happening,
&gt;&gt; Bianca Gandolfo: Over there.

17
00:01:10.708 --> 00:01:15.708
Okay, so i is 1, and
3 is the end, okay, so

18
00:01:15.708 --> 00:01:23.976
we're just gonna remove this console.log.
&gt;&gt; Bianca Gandolfo: Just so

19
00:01:23.976 --> 00:01:26.656
that we have a little more space here.

20
00:01:26.656 --> 00:01:31.460
So we will start, so
this is a lot shorter than the other one,

21
00:01:31.460 --> 00:01:34.490
but it's doing the exact same thing.

22
00:01:34.490 --> 00:01:38.510
So we are going to check,

23
00:01:38.510 --> 00:01:42.916
is i greater than 3, yes.

24
00:01:42.916 --> 00:01:48.910
So we're gonna do the thing where we
add our function to the call stack.

25
00:01:48.910 --> 00:01:50.722
Cuz we're executing the function,

26
00:01:50.722 --> 00:01:53.242
and we're creating a new
execution environment.

27
00:01:53.242 --> 00:01:57.474
All of these scoped variables live in
a separate world from these scoped

28
00:01:57.474 --> 00:01:58.257
variables.

29
00:01:58.257 --> 00:02:02.667
How, then, do we get i and
end in this execution context,

30
00:02:02.667 --> 00:02:06.450
we get that by passing it in,
so what do we pass in?

31
00:02:06.450 --> 00:02:11.040
And I'm just gonna put our line there,
we are passing in i + 1,

32
00:02:11.040 --> 00:02:15.464
which is 2, then end,
we're not doing anything to it, 3.

33
00:02:15.464 --> 00:02:19.738
So we're just passing it through,
and then we say i is two,

34
00:02:19.738 --> 00:02:22.998
2, end is 3, that is still working for us.

35
00:02:22.998 --> 00:02:27.859
So we're going to call it again,
we're gonna add it to our call stack.

36
00:02:27.859 --> 00:02:31.551
Again, we're just leaving off right here,
just a little reference of where we were

37
00:02:31.551 --> 00:02:35.681
before.
&gt;&gt; Bianca Gandolfo: So then, 2,

38
00:02:37.272 --> 00:02:43.260
&gt;&gt; Bianca Gandolfo: [LAUGH] 2 + 1 is 3.

39
00:02:43.260 --> 00:02:48.452
Okay, so is 3 less than 3, no,
so we have our implicit return.

40
00:02:48.452 --> 00:02:51.954
Implicit return, and we pop, again,

41
00:02:51.954 --> 00:02:56.846
we are gonna finish up where
we left off with this line.

42
00:02:56.846 --> 00:03:00.638
And we're gonna move down here, we're
gonna have our implicit return and pop,

43
00:03:00.638 --> 00:03:02.612
random continue here where this line is.

44
00:03:02.612 --> 00:03:05.913
And again, this is important if we were
doing more work, which a lot of times,

45
00:03:05.913 --> 00:03:08.979
you will be doing more work in your
recursive functions after this line.

46
00:03:08.979 --> 00:03:13.882
And it's important to recognize that the
stuff that happens after this line, even

47
00:03:13.882 --> 00:03:18.646
though this is the first call, anything
that happens after this line is actually

48
00:03:18.646 --> 00:03:22.743
happening last, so just keep that in mind.
&gt;&gt; Speaker 2: What's the purpose of this

49
00:03:22.743 --> 00:03:24.419
if it returns back undefined,

50
00:03:24.419 --> 00:03:28.018
right, so why are we even doing this?
&gt;&gt; Bianca Gandolfo: Just as an exercise on

51
00:03:28.018 --> 00:03:33.728
how we can loop and how we can pass things
around, and get to a certain base case.

52
00:03:33.728 --> 00:03:39.194
Without having to worry about, what is
an intermediary step that we need to take,

53
00:03:39.194 --> 00:03:43.200
and what is our big picture
problem that we're solving.

54
00:03:43.200 --> 00:03:44.510
We're starting with a small problem,

55
00:03:44.510 --> 00:03:48.820
which is, let's just loop and console.log
some stuff, and see how this executes.

56
00:03:48.820 --> 00:03:53.363
And then we're gonna take this and
apply it to some sub problems.

57
00:03:53.363 --> 00:03:59.059
Right, recursion is just all
about breaking a bigger problem

58
00:03:59.059 --> 00:04:04.545
into sub problems and
then calculating through each loop.

59
00:04:04.545 --> 00:04:08.535
Okay, so implicit return,

60
00:04:08.535 --> 00:04:13.853
pops it off, so this is doing the exact

61
00:04:13.853 --> 00:04:18.733
same thing as,
&gt;&gt; Bianca Gandolfo: Our other

62
00:04:18.733 --> 00:04:20.266
one that we were doing earlier.

63
00:04:20.266 --> 00:04:23.763
Which is defining a function,
calling it here,

64
00:04:23.763 --> 00:04:27.187
while we're retaining
access to the closure.

65
00:04:27.187 --> 00:04:30.169
So one is using a closure with

66
00:04:30.169 --> 00:04:34.631
a recursion,
&gt;&gt; Bianca Gandolfo: And

67
00:04:34.631 --> 00:04:37.784
this one is not, that's the difference.

68
00:04:45.953 --> 00:04:48.140
&gt;&gt; Bianca Gandolfo: Any questions about

69
00:04:48.140 --> 00:04:53.037
the difference between these approaches?
&gt;&gt; Speaker 3: So

70
00:04:53.037 --> 00:04:57.462
we said the first one has a closure in it?
&gt;&gt; Bianca Gandolfo: Yep.

71
00:04:57.462 --> 00:04:59.893
&gt;&gt; Speaker 3: But there's no returning of

72
00:04:59.893 --> 00:05:04.357
the function though, right, so-
&gt;&gt; Bianca Gandolfo: No, yeah,

73
00:05:04.357 --> 00:05:09.910
that's a good point,
so this closure is not.

74
00:05:09.910 --> 00:05:14.137
So a closure happens when you have
a function inside of a function,

75
00:05:14.137 --> 00:05:18.762
which in JavaScript land is all the time,
so it's kind of almost silly.

76
00:05:18.762 --> 00:05:26.835
However, things get interesting when you
return a function that is in a closure.

77
00:05:26.835 --> 00:05:30.614
So that's when we can do the interesting
thing with the generic memowise, is

78
00:05:30.614 --> 00:05:34.875
because we're returning that function that
has access to closure scoped variables.

79
00:05:34.875 --> 00:05:38.138
And so we have this interesting interface
where we can interact with scoped

80
00:05:38.138 --> 00:05:39.396
variables that are static.

81
00:05:39.396 --> 00:05:46.140
And then we can create new execution
context for our child function.

82
00:05:46.140 --> 00:05:49.548
So interesting things can
happen when we do that, but

83
00:05:49.548 --> 00:05:53.042
you don't have to do that for
it to be a closure, yeah.

84
00:05:53.042 --> 00:05:58.348
And so end, for example,
the fact that we're referencing

85
00:05:58.348 --> 00:06:04.187
end while we're in here is accessing
a closure scoped variable,

86
00:06:04.187 --> 00:06:06.735
yeah.
&gt;&gt; Bianca Gandolfo: But

87
00:06:06.735 --> 00:06:08.045
you don't need to know the vocab words.

88
00:06:08.045 --> 00:06:10.836
You just need to be able to make it work,
and

89
00:06:10.836 --> 00:06:14.496
understand how it runs when
you press this play button.

