WEBVTT

1
00:00:02.586 --> 00:00:03.590
&gt;&gt; Bianca: I'm gonna keep going guys.

2
00:00:03.590 --> 00:00:05.610
Divide and conquer, are you ready?

3
00:00:05.610 --> 00:00:10.160
So, Divide and
Conquer is a recursive technique for

4
00:00:11.630 --> 00:00:15.510
taking a larger problem,
breaking into subproblems and

5
00:00:17.060 --> 00:00:21.980
doing work on each of those subproblems
to reach some goal, some solution.

6
00:00:21.980 --> 00:00:24.110
And let's take a look at some results.

7
00:00:24.110 --> 00:00:30.360
So a classic example of a Divide and
Conquer algorithm is Binary Search.

8
00:00:30.360 --> 00:00:36.790
So, Mario here is looking at
a sorted list of numbers.

9
00:00:36.790 --> 00:00:41.543
Let's say this is 1, 2,
3, you know 6, 9, 12,

10
00:00:41.543 --> 00:00:44.431
there's about 15 or 16 here.

11
00:00:44.431 --> 00:00:46.110
Let's say there's 16.

12
00:00:46.110 --> 00:00:51.640
And let's say that we're looking for,
say that's 10, okay.

13
00:00:51.640 --> 00:00:54.160
I'm not counting each one.

14
00:00:54.160 --> 00:00:59.230
So we can do, you know,
we can go through and

15
00:00:59.230 --> 00:01:03.520
look at each one until we get to 10 and
that's going to be a linear search.

16
00:01:03.520 --> 00:01:05.260
Where we just go and look at each one.

17
00:01:05.260 --> 00:01:11.950
However, since it's sorted we can break it
in half and just search within one-half.

18
00:01:11.950 --> 00:01:17.290
So when we get to the middle, so the first
step of Divide and Conquer is we divide.

19
00:01:17.290 --> 00:01:19.170
And then once we get
into the division step,

20
00:01:19.170 --> 00:01:21.090
we need to decide which direction to go.

21
00:01:21.090 --> 00:01:25.970
We don't go both directions because
that would be against the whole point of

22
00:01:25.970 --> 00:01:30.140
the Divide and Conquer,
where we only want to evaluate half or

23
00:01:30.140 --> 00:01:33.080
a part of our data set.

24
00:01:33.080 --> 00:01:34.520
So we're going to go to the middle.

25
00:01:34.520 --> 00:01:38.885
We can say, is 10 less than 8 or
greater than 8 and

26
00:01:38.885 --> 00:01:42.270
we're gonna say it's greater than 8.

27
00:01:42.270 --> 00:01:45.490
So we're just gonna throw away, the rest.

28
00:01:45.490 --> 00:01:48.260
And we're gonna go to the middle
of the greater than side.

29
00:01:48.260 --> 00:01:53.490
So we know that everything to the right
is going to be greater than, let's say 8.

30
00:01:53.490 --> 00:01:58.740
And so we're gonna go into the middle of
8 which, let's say that's like 11 or so.

31
00:01:58.740 --> 00:02:04.736
Here and it's gonna say okay,
is 10 greater than 11 or less than 11.

32
00:02:04.736 --> 00:02:07.850
So it's a less than 11, so we're
gonna throw away all of these things.

33
00:02:07.850 --> 00:02:11.750
Again it's sorted so we know everything
to the right is gonna be greater than 11.

34
00:02:11.750 --> 00:02:18.960
And then we hop into the middle of the
rest of our data that we're looking at.

35
00:02:20.360 --> 00:02:24.782
And in this case, that's the answer.

36
00:02:24.782 --> 00:02:29.072
But we may even have to do it again
where we say is it greater than or

37
00:02:29.072 --> 00:02:31.770
less than until we get to our solution.

38
00:02:31.770 --> 00:02:37.490
And the reason that this
is an important algorithm

39
00:02:37.490 --> 00:02:42.080
is that it takes something that's linear
and turns it into logarithmic time.

40
00:02:42.080 --> 00:02:44.590
How do we know it's
logarithmic time because

41
00:02:44.590 --> 00:02:48.330
the work that we have to do is
cut in half every single time.

42
00:02:48.330 --> 00:02:51.080
So the data set that we're evaluating for

43
00:02:51.080 --> 00:02:56.630
our number is decreasing
by half each time.

44
00:02:58.520 --> 00:03:00.070
And so that's binary search.

45
00:03:00.070 --> 00:03:02.080
Again, binary search has to be sorted.

46
00:03:02.080 --> 00:03:06.270
You get an interview question and
it says, you have an assorted array,

47
00:03:06.270 --> 00:03:10.010
you should be thinking hm,
binary search, automatically.

48
00:03:11.040 --> 00:03:15.850
Or, if they're like, you're searching an
array, you can say is that array sorted?

49
00:03:15.850 --> 00:03:18.270
If it is, binary search is the way to go.

50
00:03:18.270 --> 00:03:21.180
If it's not,
there are other searching algorithms.

51
00:03:21.180 --> 00:03:23.343
But linear search is a good one,

52
00:03:23.343 --> 00:03:28.406
where you just are going to loop through
your list and look for that number.

