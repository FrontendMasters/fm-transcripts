WEBVTT

1
00:00:00.114 --> 00:00:04.137
&gt;&gt; Bianca Gandolfo: Space complexity,
I'm gonna pass the mic to you guys.

2
00:00:04.137 --> 00:00:08.181
So given our conversation
about time complexity,

3
00:00:08.181 --> 00:00:12.046
what do you think space
complexity is all about?

4
00:00:15.915 --> 00:00:18.569
&gt;&gt; Speaker 2: [INAUDIBLE] How much memory?

5
00:00:18.569 --> 00:00:22.295
&gt;&gt; Speaker 3: Dealing with stacks and
queues, possibly?

6
00:00:22.295 --> 00:00:23.632
I'm not super familiar, but.

7
00:00:23.632 --> 00:00:27.388
&gt;&gt; Bianca Gandolfo: Yeah,
yeah, so space is good, yeah.

8
00:00:27.388 --> 00:00:29.245
So stacks and queues,
those are data structures.

9
00:00:29.245 --> 00:00:34.769
And it's all about the space that
it takes up in memory, right?

10
00:00:34.769 --> 00:00:39.610
So if your algorithm is copying
your array a bunch of times, right?

11
00:00:39.610 --> 00:00:43.517
And you're making a new array, then in
memory you're having five arrays, and

12
00:00:43.517 --> 00:00:45.867
that's a certain amount
of space complexity.

13
00:00:45.867 --> 00:00:49.977
And it works on the same scale
of constant, linear, etc.,

14
00:00:49.977 --> 00:00:51.433
as time complexity.

15
00:00:51.433 --> 00:00:55.450
Except that instead of the number of
operations that are being executed,

16
00:00:55.450 --> 00:00:58.704
we're thinking about how much
more space are we taking up.

17
00:00:58.704 --> 00:01:01.422
So are we for
every loop creating a new array?

18
00:01:01.422 --> 00:01:08.870
Okay, so that's like n times the length
of the array of space every time.

19
00:01:08.870 --> 00:01:13.844
Or if we're what we call sorting in place,
where we don't make a new array,

20
00:01:13.844 --> 00:01:18.823
and then our space complexity is constant
even though our algorithm's time

21
00:01:18.823 --> 00:01:22.270
complexity could be
something totally different.

22
00:01:22.270 --> 00:01:26.038
So things to think about when you're
thinking about space complexity is are you

23
00:01:26.038 --> 00:01:27.455
making a new data structure?

24
00:01:27.455 --> 00:01:34.605
How often are you doing it
in comparison to your input?

25
00:01:34.605 --> 00:01:37.326
And also with your call stack.

26
00:01:37.326 --> 00:01:39.280
If you're doing recursion,

27
00:01:39.280 --> 00:01:44.524
that's another thing to consider is that
stack is also taking place in memory.

28
00:01:44.524 --> 00:01:50.181
However, that's not something you probably
need to go in depth about in an interview.

29
00:01:50.181 --> 00:01:54.646
Just be aware to just mention that
when you're talking about space

30
00:01:54.646 --> 00:01:56.648
complexity with recursion.

31
00:01:56.648 --> 00:02:00.515
And we're gonna go through a lot of
recursion, so we'll see that in action.

32
00:02:00.515 --> 00:02:04.831
All right,
&gt;&gt; Bianca Gandolfo: So here's some words,

33
00:02:04.831 --> 00:02:06.139
lots of words.

34
00:02:06.139 --> 00:02:11.072
Something that you should know from this
slide is that there are other notations.

35
00:02:11.072 --> 00:02:14.273
We just typically use big O notation
which is the worst case scenario.

36
00:02:14.273 --> 00:02:17.709
But there's also like the average case
scenario and the best case scenario and

37
00:02:17.709 --> 00:02:18.921
all these different ones.

38
00:02:18.921 --> 00:02:22.467
And you can learn about it
by following that link.

39
00:02:22.467 --> 00:02:27.157
However, in interviews it's expected
that we speak in the pessimistic big O

40
00:02:27.157 --> 00:02:27.886
notation.

41
00:02:27.886 --> 00:02:31.687
What is the worst case
scenario of this algorithm?

42
00:02:33.006 --> 00:02:34.322
&gt;&gt; Bianca Gandolfo: So
this is just a review,

43
00:02:34.322 --> 00:02:38.913
worst case scenario we're gonna drop any
non-significant operation or constants.

44
00:02:40.744 --> 00:02:41.754
&gt;&gt; Bianca Gandolfo: Break.

