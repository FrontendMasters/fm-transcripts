WEBVTT

1
00:00:00.030 --> 00:00:02.410
&gt;&gt; Speaker 1: So mergeSort,
we have our base case here.

2
00:00:02.410 --> 00:00:07.670
When your array is a sorted list of
length one, we are gonna return that.

3
00:00:10.440 --> 00:00:14.260
A couple other things that we need to
do is we're going to find the middle.

4
00:00:14.260 --> 00:00:16.760
We're gonna slice it into a left and
right side.

5
00:00:16.760 --> 00:00:23.110
And then we're going to recursively
merge the left and the right.

6
00:00:23.110 --> 00:00:26.510
Previously, we did something like this

7
00:00:27.600 --> 00:00:32.590
where we said,
&gt;&gt; Speaker 1: We said sortedLeft.

8
00:00:35.162 --> 00:00:36.850
This is how we had it before.

9
00:00:36.850 --> 00:00:37.975
And I'll put it like that, so

10
00:00:37.975 --> 00:00:42.984
that it's a little bit easier.
&gt;&gt; Speaker 1: So we'll just merge

11
00:00:42.984 --> 00:00:47.563
the sortedLeft with
the sortedRight just to

12
00:00:47.563 --> 00:00:52.513
keep it a little more
consistent with the pseudo

13
00:00:52.513 --> 00:00:56.856
code that we were going through earlier.

14
00:00:56.856 --> 00:01:01.925
All right, and here's our merge routine,

15
00:01:01.925 --> 00:01:06.035
which we have outside of our defined

16
00:01:06.035 --> 00:01:11.795
function.
&gt;&gt; Speaker 1: So you can

17
00:01:11.795 --> 00:01:17.120
see how we're keeping track of our left
and our right indices as we are pushing.

18
00:01:17.120 --> 00:01:20.848
We push, we increment, we push,

19
00:01:20.848 --> 00:01:26.121
we increment that one
until they're all empty,

20
00:01:26.121 --> 00:01:30.531
they're both empty.
&gt;&gt; Speaker 1: Okay,

21
00:01:30.531 --> 00:01:32.680
we also wanna say about this.

22
00:01:32.680 --> 00:01:37.908
So the way this executes is exactly
as we went over in the pseudocode.

23
00:01:41.652 --> 00:01:43.403
&gt;&gt; Speaker 1: Yeah, here it is for

24
00:01:43.403 --> 00:01:49.272
your viewing pleasure.
&gt;&gt; Speaker 1: Mergesort.

25
00:01:51.742 --> 00:01:54.745
&gt;&gt; Speaker 1: What's the most complicated

26
00:01:54.745 --> 00:02:01.444
thing to you about Mergesort?
&gt;&gt; Speaker 1: Is

27
00:02:01.444 --> 00:02:04.456
it the recursion, is it the merging part?

28
00:02:12.600 --> 00:02:14.505
&gt;&gt; Speaker 2: It's the recursion that

29
00:02:14.505 --> 00:02:17.773
also calls the different function.
&gt;&gt; Speaker 1: Mm-hm,

30
00:02:17.773 --> 00:02:19.467
so we have this forking recursion,

31
00:02:19.467 --> 00:02:22.690
which is a little bit different
than our other recursive examples.

32
00:02:22.690 --> 00:02:24.030
We weren't forking, right?

33
00:02:24.030 --> 00:02:27.160
So we recursed left and recursed right,

34
00:02:27.160 --> 00:02:30.614
yeah.
&gt;&gt; Speaker 2: We

35
00:02:30.614 --> 00:02:32.210
may think hypothetically it makes sense.

36
00:02:32.210 --> 00:02:34.199
It's really more the code part of it.

37
00:02:34.199 --> 00:02:36.190
There are just so many detail.

38
00:02:36.190 --> 00:02:38.285
How do you keep track of
all of the moving parts?

39
00:02:38.285 --> 00:02:39.380
&gt;&gt; Speaker 1: Mm-hm.

40
00:02:39.380 --> 00:02:40.100
&gt;&gt; Speaker 2: That's where, for me,

41
00:02:40.100 --> 00:02:41.460
it's hard to wrap my brain around that.

42
00:02:41.460 --> 00:02:42.760
But I understand how it works in theory,

43
00:02:42.760 --> 00:02:45.890
when you show the diagram of it.
&gt;&gt; Speaker 1: Yeah, yeah,

44
00:02:45.890 --> 00:02:47.520
yeah.
&gt;&gt; Speaker 2: It's the implemetation

45
00:02:47.520 --> 00:02:48.906
that's the-
&gt;&gt; Speaker 1: [CROSSTALK] Yeah,

46
00:02:48.906 --> 00:02:51.439
absolutely, and
that's one of those things, yeah,

47
00:02:51.439 --> 00:02:55.088
it comes with doing this translation from,
okay, here's a pretty picture.

48
00:02:55.088 --> 00:02:58.290
How do we translate that into real code?

49
00:02:58.290 --> 00:03:01.630
We're drawing boxes, but
what does that box represent?

50
00:03:01.630 --> 00:03:03.090
What is that native structure?

51
00:03:03.090 --> 00:03:06.590
We have these arrows pointing,
what does that arrow mean?

52
00:03:06.590 --> 00:03:09.760
Is that a function call?

53
00:03:09.760 --> 00:03:10.680
Is that a loop?

54
00:03:11.990 --> 00:03:15.150
So these are all important
things to get some practice on.

55
00:03:15.150 --> 00:03:18.060
But yeah, I agree that that's
the most complex part for

56
00:03:18.060 --> 00:03:23.060
most people is to make that leap.
&gt;&gt; Speaker 2: So

57
00:03:23.060 --> 00:03:27.430
what it would be the real test case for
it, right, or use case for it?

58
00:03:27.430 --> 00:03:29.465
Like what would you like, you know what?

59
00:03:29.465 --> 00:03:31.560
Mergesort is exactly
the solution that I need in

60
00:03:31.560 --> 00:03:32.868
this particular-
&gt;&gt; Speaker 1: So

61
00:03:32.868 --> 00:03:35.750
Mergesort is one of the best sorts.

62
00:03:35.750 --> 00:03:38.130
So if you ever need to sort anything for

63
00:03:38.130 --> 00:03:41.490
an interview, Mergesort is
probably what they're looking for.

64
00:03:41.490 --> 00:03:45.280
Quick sort is what JavaScript
uses under the hood.

65
00:03:45.280 --> 00:03:48.960
I think it might also sometimes use
Mergesort, depending on the scenario.

66
00:03:48.960 --> 00:03:54.940
But yeah,
pretty much if you wanted to impress

67
00:03:54.940 --> 00:03:58.190
an interviewer over the sorting question,
you can always implement Mergesort.

68
00:04:00.650 --> 00:04:09.090
However, my interviewing strategy in
general is to start with a simple answer.

69
00:04:09.090 --> 00:04:11.878
Reference the more complicated answer, but

70
00:04:11.878 --> 00:04:15.189
not necessarily jump into
implementing Mergesort.

71
00:04:15.189 --> 00:04:21.530
In a high-pressure scenario,
there's a lot of ways it could go wrong.

72
00:04:21.530 --> 00:04:23.783
And you wanna optimize it for
things going right.

73
00:04:23.783 --> 00:04:25.757
So you could say something like,

74
00:04:25.757 --> 00:04:30.145
is it all right if I start with a naive
sorting algorithm like bubble sort?

75
00:04:30.145 --> 00:04:33.900
i understand that in a lot of
cases it's quadratic time.

76
00:04:33.900 --> 00:04:37.764
And it would be better to do
maybe something like Mergesort,

77
00:04:37.764 --> 00:04:38.835
which is n log n.

78
00:04:38.835 --> 00:04:42.272
However, I think within the time
constraints of our interview,

79
00:04:42.272 --> 00:04:44.980
it would be easier if I just
went with a bubble sort.

80
00:04:44.980 --> 00:04:49.320
Or you can just not even talk about
Mergesort, implement it in bubble sort.

81
00:04:49.320 --> 00:04:53.730
Say that you could do better by
doing a divide and conquer sort.

82
00:04:53.730 --> 00:04:57.410
So acknowledge that you
understand you've heard of it.

83
00:04:57.410 --> 00:04:58.728
But try to avoid implementing it.

84
00:04:58.728 --> 00:05:00.880
This is my strategy.

85
00:05:00.880 --> 00:05:07.738
Just because if you see
it's quite a bit of code.

86
00:05:07.738 --> 00:05:11.990
You could do off by one.

87
00:05:11.990 --> 00:05:20.850
There's a lot of situations where,
here's another place we go off by one.

88
00:05:20.850 --> 00:05:23.749
There are a lot of places
where you can mess it up.

89
00:05:23.749 --> 00:05:27.920
So I think if you can get away with it,
don't do this.

90
00:05:27.920 --> 00:05:31.963
But if you're really good at it and you
wanna get really good at it, then yeah,

91
00:05:31.963 --> 00:05:34.436
that would be very
impressive to do Mergesort.

92
00:05:34.436 --> 00:05:39.670
I would be impressed if someone did
a Mergesort in one of my interviews.

93
00:05:39.670 --> 00:05:42.010
But I don't ask those kinda questions.

94
00:05:42.010 --> 00:05:43.165
But big companies do.

95
00:05:43.165 --> 00:05:45.778
Mm-hm?
&gt;&gt; Speaker 2: Can I ask you what,

96
00:05:45.778 --> 00:05:50.495
give us an example of what people
ask you during the interview

97
00:05:50.495 --> 00:05:54.135
where you have to use a sort to answer it?
&gt;&gt; Speaker 1: Yeah,

98
00:05:54.135 --> 00:05:58.671
I would just say you have an array
of unsorted integers, sort them.

99
00:05:58.671 --> 00:06:00.295
&gt;&gt; Speaker 2: That's just mostly the case,

100
00:06:00.295 --> 00:06:00.833
right?
&gt;&gt; Speaker 1: Mm-hm.

101
00:06:00.833 --> 00:06:03.403
&gt;&gt; Speaker 2: They're not gonna go really

102
00:06:03.403 --> 00:06:08.223
complex?
&gt;&gt; Speaker 1: Well, so for example,

103
00:06:08.223 --> 00:06:15.112
there might be code words for
you have a list and

104
00:06:15.112 --> 00:06:19.361
maybe you have timestamps.

105
00:06:19.361 --> 00:06:23.307
Or you're filtering by
the oldest timestamps.

106
00:06:23.307 --> 00:06:27.721
And so like the thing that you're
comparing might not be an integer.

107
00:06:27.721 --> 00:06:32.535
It could be a date or something.

108
00:06:32.535 --> 00:06:39.670
Yeah, what else?

109
00:06:39.670 --> 00:06:44.610
Yeah, and I think so there are other
scenarios where if your list is sorted,

110
00:06:44.610 --> 00:06:46.310
for example like a binary search, so

111
00:06:46.310 --> 00:06:51.030
if your list is already sorted,
then that helps you.

112
00:06:51.030 --> 00:06:57.430
And so you can always do
the JavaScript native sort as well.

113
00:06:57.430 --> 00:07:00.130
You just have to remember if it's
a comparison sort with numbers,

114
00:07:00.130 --> 00:07:01.470
you need to remember that callback.

115
00:07:01.470 --> 00:07:05.781
What you do, you call a, b, a- b.

116
00:07:05.781 --> 00:07:11.518
Remember that, and then you can get around
all of this raw implementation detail.

117
00:07:11.518 --> 00:07:16.408
But there are some scenarios where
having a list that's sorted will

118
00:07:16.408 --> 00:07:20.460
make your algorithm faster,
like for a binary search.

119
00:07:20.460 --> 00:07:23.550
So if you're trying to search, you say,
okay, well, can I sort it first?

120
00:07:23.550 --> 00:07:26.510
Once it's sorted, it can speed things up.

121
00:07:26.510 --> 00:07:28.300
Or you could get it sorted,
that's nice, too.

