WEBVTT

1
00:00:00.160 --> 00:00:04.087
So I've mentioned binary like
a million times already.

2
00:00:04.087 --> 00:00:10.018
And Bynary is so fascinating because
at the core of it as Engineers,

3
00:00:10.018 --> 00:00:14.294
all we are doing is moving ones and
zeros around.

4
00:00:14.294 --> 00:00:16.230
It doesn't matter what
language you're writing.

5
00:00:16.230 --> 00:00:19.540
It doesn't matter how high level or
low it's.

6
00:00:19.540 --> 00:00:21.081
At the end of the day,

7
00:00:21.081 --> 00:00:26.750
all we're doing is manipulating these
tiny switches on a computer, on a CPU.

8
00:00:26.750 --> 00:00:32.134
And we're just turning them on and
off a billion times a second.

9
00:00:32.134 --> 00:00:33.860
That's it.

10
00:00:33.860 --> 00:00:38.150
There's something beautiful
in that simplicity.

11
00:00:38.150 --> 00:00:44.128
In that the things we build and
these amazing contracts like browsers and

12
00:00:44.128 --> 00:00:46.974
games, and ebooks and websites.

13
00:00:46.974 --> 00:00:50.846
[LAUGH] And
literally all the technology we use today,

14
00:00:50.846 --> 00:00:56.800
if it involves anything electronic, it's
just a one or zero at the end of the day.

15
00:00:57.830 --> 00:00:59.990
And I love that.

16
00:00:59.990 --> 00:01:04.990
I don't know there's a beauty to that.

17
00:01:04.990 --> 00:01:11.410
I think the equivalent would be if I could
speak and me speaking could create things.

18
00:01:11.410 --> 00:01:14.608
That's the same level that
I think a programming at.

19
00:01:14.608 --> 00:01:19.097
Honestly, and this is my
probably my first rant of the day

20
00:01:19.097 --> 00:01:22.100
I really think programming is magic.

21
00:01:23.370 --> 00:01:25.973
Okay, hear me out that
seems a little strange,

22
00:01:25.973 --> 00:01:28.130
but we all use this fundamental force.

23
00:01:28.130 --> 00:01:31.530
We use binary to manipulate
data to do things.

24
00:01:31.530 --> 00:01:32.547
So, we all understand that.

25
00:01:32.547 --> 00:01:35.338
It doesn't matter what type of
language you're writing in.

26
00:01:35.338 --> 00:01:38.280
It's gonna compile down to binary
ultimately and run on a computer.

27
00:01:39.520 --> 00:01:44.013
But kind of like Hogwarts and Harry
Potter, there are different schools of

28
00:01:44.013 --> 00:01:48.449
thought about how we should use this
binary language to get our our means.

29
00:01:48.449 --> 00:01:53.113
And people are firmly entrenched and
JavaScript is better and C is better or

30
00:01:53.113 --> 00:01:57.500
I wanna use Rusts or Elm or
whatever language you want to use.

31
00:01:57.500 --> 00:02:00.420
But at the end of the day,
it doesn't matter.

32
00:02:00.420 --> 00:02:04.950
It's all about binary and
how those instructions get written.

33
00:02:06.040 --> 00:02:07.350
I think that's so cool.

34
00:02:08.400 --> 00:02:13.290
To me there is no equivalence in the real
world or anywhere in the real world.

35
00:02:13.290 --> 00:02:17.302
But there is no other analogy I can think
of that as as powerful as the ability to

36
00:02:17.302 --> 00:02:19.370
have turn something on or off.

37
00:02:19.370 --> 00:02:22.420
And that dictates all these
wonderful things we're gonna build.

38
00:02:23.770 --> 00:02:27.250
So, moving talking more about binary.

39
00:02:27.250 --> 00:02:29.150
Let's talk about
the nomenclature behind binary.

40
00:02:30.870 --> 00:02:36.710
Binary, the smallest unit of computing
we think of it's actually a one.

41
00:02:36.710 --> 00:02:39.690
I say ones and zeros, but
a zero is just a state.

42
00:02:39.690 --> 00:02:42.190
So zero being off, one being on.

43
00:02:42.190 --> 00:02:42.740
That's it.
So

44
00:02:42.740 --> 00:02:48.030
actually all we know about computing
is a one, which I don't know.

45
00:02:48.030 --> 00:02:48.540
Take a minute.

46
00:02:50.790 --> 00:02:53.130
Yeah, that's kinda weird, right?

47
00:02:53.130 --> 00:02:55.950
There's only one thing we do and
that's on or off.

48
00:02:55.950 --> 00:02:56.740
That's it.

49
00:02:56.740 --> 00:03:01.430
But the smallest unit and
information in binary is a bit.

50
00:03:01.430 --> 00:03:04.762
So it's a 1 or 0.

51
00:03:04.762 --> 00:03:07.350
A group of eight bits is called a byte.

52
00:03:07.350 --> 00:03:11.849
And a byte is generally the smallest
sequence of bits that we're gonna use,

53
00:03:11.849 --> 00:03:14.930
that we can get useful information out of.

54
00:03:14.930 --> 00:03:17.510
And I believe four bits is called a word.

55
00:03:17.510 --> 00:03:18.610
I haven't taken my CS.

56
00:03:18.610 --> 00:03:21.360
It's been a while since
I had my CS degree.

57
00:03:22.650 --> 00:03:23.650
Somehow they gave it to me.

58
00:03:23.650 --> 00:03:24.378
I don't know how.

59
00:03:24.378 --> 00:03:28.483
But I'm trying to remember this
nomenclature from back then, but

60
00:03:28.483 --> 00:03:30.108
we won't get into words.

61
00:03:30.108 --> 00:03:32.437
But once you understand what a byte is,

62
00:03:32.437 --> 00:03:35.764
we understand that a kilobyte
is about 1000 bytes.

63
00:03:35.764 --> 00:03:39.828
Give or take, it's actually, 1024 because
base two and all the other stuff.

64
00:03:39.828 --> 00:03:41.852
But, we will see bytes and

65
00:03:41.852 --> 00:03:46.638
bits later probably not that's as much but
we'll see bytes.

66
00:03:46.638 --> 00:03:49.646
Because we will be directly
manipulating these ones and

67
00:03:49.646 --> 00:03:52.080
zeros when we convert
data into a byte array.

68
00:03:55.180 --> 00:03:59.980
A one and
a zero is known as the base two system.

69
00:03:59.980 --> 00:04:07.209
So the bi, binary meaning two,
it's just a counting system in computers.

70
00:04:07.209 --> 00:04:11.289
The system we're most familiar
with is the base ten system,

71
00:04:11.289 --> 00:04:13.534
the decimal, deci meaning ten.

72
00:04:13.534 --> 00:04:18.356
And that just means that at any
given position a number can be

73
00:04:18.356 --> 00:04:20.210
zero through nine.

74
00:04:20.210 --> 00:04:24.796
So there's ten positions I know I
didn't say ten because ten is actually

75
00:04:24.796 --> 00:04:26.760
a construct of a nine and a one.

76
00:04:28.020 --> 00:04:30.590
I know it's a little bit different
way about thinking of things.

77
00:04:30.590 --> 00:04:33.626
Binary being based two means there's
only two possible numbers for

78
00:04:33.626 --> 00:04:34.650
any given position.

79
00:04:34.650 --> 00:04:35.894
That's a one or zero.

80
00:04:37.864 --> 00:04:43.280
And counting in base two,
we start off with the first position.

81
00:04:43.280 --> 00:04:46.220
So we're looking at right here,
we're looking at just the bite.

82
00:04:46.220 --> 00:04:48.680
So we're looking at eight
bits of information.

83
00:04:48.680 --> 00:04:56.280
And we count base two and we increment
by 24, 816, 32, 128, etc, etc, etc.

84
00:04:56.280 --> 00:04:59.712
That's why when you see memory written
out, it's always in 64 kilobytes or

85
00:04:59.712 --> 00:05:00.550
128 or 256.

86
00:05:00.550 --> 00:05:04.580
They're always some sort of power of two.

87
00:05:04.580 --> 00:05:06.430
That's how we count in binary.

88
00:05:08.120 --> 00:05:09.134
Don't worry,

89
00:05:09.134 --> 00:05:14.130
[LAUGH] I will not show you binary to ask
you to figure out what it what it means.

90
00:05:15.210 --> 00:05:17.090
I had to do that in school.

91
00:05:17.090 --> 00:05:19.730
And I still am resentful for
it because it doesn't really help you.

92
00:05:20.740 --> 00:05:24.440
[LAUGH] Like there's no way in programming
that I'm going to be doing binary.

93
00:05:24.440 --> 00:05:25.870
Generally speaking, hopefully not.

94
00:05:27.190 --> 00:05:29.640
I'm not gonna be thinking in bits as much.

95
00:05:29.640 --> 00:05:32.984
I will be thinking in bytes,
which are a little bit

96
00:05:32.984 --> 00:05:37.856
easier to reason about than just
saying like, Is that 12345.

97
00:05:37.856 --> 00:05:43.200
Is that five zeros or not, okay, so
five, that's 64 they flip that bit.

98
00:05:43.200 --> 00:05:46.566
Yeah, we're not really gonna do that
we're always gonna deal in bytes,

99
00:05:46.566 --> 00:05:49.950
generally speaking, and it just makes
reasoning about it much simpler.

100
00:05:52.450 --> 00:05:55.367
Are there any questions
about reading binary and

101
00:05:55.367 --> 00:05:59.890
how the counting system works in
base two and things like that?

102
00:05:59.890 --> 00:06:05.059
Because it's a little tricky
to think 24816 doubling and

103
00:06:05.059 --> 00:06:08.480
that any position can only be pne or zero.

104
00:06:08.480 --> 00:06:13.044
And using that we base all of our numbers,
everything we do strings, objects,

105
00:06:13.044 --> 00:06:14.760
numbers, doesn't matter.

106
00:06:14.760 --> 00:06:17.123
They're all based on
this system at the core.

107
00:06:19.783 --> 00:06:21.469
Okay, I know.

108
00:06:21.469 --> 00:06:28.030
If you're saying this is so technical
already, I'm sorry, I'm not really sorry.

109
00:06:28.030 --> 00:06:29.640
Yeah, you're gonna learn something.

110
00:06:29.640 --> 00:06:30.810
It's awesome.

111
00:06:30.810 --> 00:06:33.460
We're building up our this
foundation of knowledge.

112
00:06:33.460 --> 00:06:34.700
You may know some of this.

113
00:06:34.700 --> 00:06:36.682
You may not be probably heard of it.

114
00:06:36.682 --> 00:06:37.950
But I guarantee you've heard of it.

115
00:06:39.530 --> 00:06:42.960
Okay, so it gets even more complicated.

116
00:06:42.960 --> 00:06:45.580
So we have, a byte of data.

117
00:06:45.580 --> 00:06:49.090
So that's eight bits,
as we said before, but

118
00:06:49.090 --> 00:06:55.400
depending on the computer architecture,
we might read bytes in ascending order.

119
00:06:55.400 --> 00:06:59.904
So that means the right most
is the smallest number And

120
00:06:59.904 --> 00:07:04.220
the left most is the largest number at or
we read it.

121
00:07:04.220 --> 00:07:07.070
So the left most is the largest number.

122
00:07:07.070 --> 00:07:10.418
And the right most is is the or
the leftmost, the smallest number and

123
00:07:10.418 --> 00:07:12.980
the right most is the largest number.

124
00:07:12.980 --> 00:07:17.140
This format is known as Endian,
which I always thought was a funny name.

125
00:07:18.160 --> 00:07:22.543
No one says computer engineers don't have
a sense of humor because the naming is is

126
00:07:22.543 --> 00:07:23.640
interesting.

127
00:07:23.640 --> 00:07:28.684
But what we're gonna use today a web
assembly and almost all, not almost all,

128
00:07:28.684 --> 00:07:33.180
but most of the modern computers
use us Little Endian format.

129
00:07:33.180 --> 00:07:35.800
That is we read from right to left.

130
00:07:38.050 --> 00:07:40.735
There are some systems that still use
big endian I can't think of any off

131
00:07:40.735 --> 00:07:41.910
the top of my head.

132
00:07:41.910 --> 00:07:46.420
But there have been some hilarious
catastrophic bugs when people

133
00:07:46.420 --> 00:07:50.359
import code that is meant to
be written in little endian.

134
00:07:50.359 --> 00:07:51.547
And it's in big endian and

135
00:07:51.547 --> 00:07:55.450
it just throws the whole system haywire
because it's literally reading backwards.

136
00:07:55.450 --> 00:07:57.500
It's like trying to understand a book.

137
00:07:57.500 --> 00:07:58.730
By reading it backwards.

138
00:07:58.730 --> 00:07:59.730
Is it possible?

139
00:07:59.730 --> 00:08:02.500
Yeah, is it the best way to code?

140
00:08:02.500 --> 00:08:06.751
No, I, I only throw this tidbit of about
Endian big endian because when you're

141
00:08:06.751 --> 00:08:11.257
reading documentation for webassembly and
particularly assembly script enough,

142
00:08:11.257 --> 00:08:13.668
some of the other things
we'll get to today,

143
00:08:13.668 --> 00:08:17.530
you will see that phrase Little Endian and
Now you know what it means.

144
00:08:17.530 --> 00:08:19.430
It just means the order
that we read the bytes in.

145
00:08:23.069 --> 00:08:25.870
Actually, that's a good time to jump.

146
00:08:25.870 --> 00:08:30.471
All right so, these are just jumped
into the official Web Assembly

147
00:08:30.471 --> 00:08:34.100
documents make that a little bigger.

148
00:08:34.100 --> 00:08:38.739
I will say generally
you're not gonna go here.

149
00:08:38.739 --> 00:08:43.204
[LAUGH] These docs, it's cool if
you're maybe a systems engineer or

150
00:08:43.204 --> 00:08:48.190
a computer engineer who builds
microarchitecture for web assembly.

151
00:08:48.190 --> 00:08:52.076
But I don't want you to be
overwhelmed if someone's like yeah,

152
00:08:52.076 --> 00:08:54.965
just check out the documentation
on web assembly.

153
00:08:54.965 --> 00:08:59.528
It's not really gonna be that useful to
you in the context of this class, but

154
00:08:59.528 --> 00:09:04.220
it exists just so you know that I'm
pointing you to the right resources.

155
00:09:04.220 --> 00:09:06.582
You can look up everything
we're gonna talk about, and

156
00:09:06.582 --> 00:09:09.657
they'll explain it in a much more
tactical manner generally speaking.

157
00:09:09.657 --> 00:09:13.894
But I wouldn't say you're gonna
spend too much time on this site.

158
00:09:13.894 --> 00:09:14.940
But it's here if you need it.

