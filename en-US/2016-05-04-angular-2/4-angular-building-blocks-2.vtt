WEBVTT

1
00:00:00.261 --> 00:00:04.001
[MUSIC]

2
00:00:04.001 --> 00:00:05.201
&gt;&gt; Lukas Ruebbelke: Data binding.

3
00:00:05.201 --> 00:00:09.711
So, this is quite interesting as
they've introduced all kinds of new and

4
00:00:09.711 --> 00:00:12.270
interesting syntax into our templates.

5
00:00:14.630 --> 00:00:17.490
And I think I have a picture here.

6
00:00:17.490 --> 00:00:18.590
Yes.

7
00:00:18.590 --> 00:00:23.350
So, we still have our classic double
curly braces string interpolation.

8
00:00:23.350 --> 00:00:28.020
But now, we have really,
two main bindings.

9
00:00:28.020 --> 00:00:31.010
You have property bindings and
event bindings.

10
00:00:31.010 --> 00:00:35.210
So now, you can bind to properties from
your component within your template,

11
00:00:35.210 --> 00:00:37.060
and it's a square bracket.

12
00:00:38.550 --> 00:00:42.410
If you want to listen for
an event on your template, and

13
00:00:42.410 --> 00:00:45.130
then convey that back to your component,
it's parenthesis.

14
00:00:46.380 --> 00:00:48.250
Or if you want to, do them both.

15
00:00:48.250 --> 00:00:51.475
So there was kind of this concession of
how in the world do we work with forms,

16
00:00:51.475 --> 00:00:52.890
we need two-way data binding.

17
00:00:52.890 --> 00:00:55.820
It only makes sense that when
I type in the text field,

18
00:00:55.820 --> 00:00:57.940
that I automatically get this information.

19
00:00:57.940 --> 00:01:00.800
I mean that was the real money demo.

20
00:01:00.800 --> 00:01:02.680
When Angular 1 first came out it was,
look,

21
00:01:02.680 --> 00:01:06.490
I can type in this text field and
it automatically updates over here.

22
00:01:06.490 --> 00:01:08.740
How are we gonna have that demo still?

23
00:01:08.740 --> 00:01:13.830
So, they said, well, let’s take this
one-way binding and this one-way binding,

24
00:01:13.830 --> 00:01:18.030
and we’re going to put them together,
and now we have two-way data binding.

25
00:01:18.030 --> 00:01:21.977
So, I guess two one-way streets
put together is a two -way street.

26
00:01:21.977 --> 00:01:26.682
And so, we have this hotdog
in a box kind of syntax here,

27
00:01:26.682 --> 00:01:32.130
of the box, the hot dog, and it's simply
saying, when this property changes,

28
00:01:32.130 --> 00:01:35.760
then it will fire off an event and it will
show up in your controller and vice versa.

29
00:01:37.350 --> 00:01:40.530
And so, you can see here,
I don't know where my mouse is.

30
00:01:40.530 --> 00:01:43.270
But you can see here,
this ng model message.

31
00:01:43.270 --> 00:01:45.080
That, that's what that looks like.

32
00:01:45.080 --> 00:01:47.040
So, pretty simple.

33
00:01:47.040 --> 00:01:49.110
Yes, we have a question in the back.

34
00:01:49.110 --> 00:01:52.154
&gt;&gt; Speaker 2: The first value,
is that just a one-time expression?

35
00:01:53.430 --> 00:01:55.380
&gt;&gt; Lukas Ruebbelke: What's that?
&gt;&gt; Speaker 2: Is that just an expression?

36
00:01:55.380 --> 00:02:01.274
The, cuz you have a property by
the template on the top level, value,

37
00:02:01.274 --> 00:02:06.920
is that just any expression of a value and
once its rendered and that's it?

38
00:02:06.920 --> 00:02:10.660
And there's no [INAUDIBLE]
component template?

39
00:02:10.660 --> 00:02:13.880
&gt;&gt; Lukas Ruebbelke: So, I believe this
actually will change in the component.

40
00:02:13.880 --> 00:02:17.213
So, this is almost
the equivalent of property, and

41
00:02:17.213 --> 00:02:23.530
there's some reasons why you would use
string turbulation over property binding.

42
00:02:23.530 --> 00:02:27.520
But they, when it updates in
the component, it will update as well.

43
00:02:27.520 --> 00:02:32.390
So it's still, I mean, so
string turbulation is always been one-way.

44
00:02:32.390 --> 00:02:34.690
But it's not a one-time deal.

45
00:02:34.690 --> 00:02:36.256
So, it's not a bind once, rather.

46
00:02:41.596 --> 00:02:46.330
&gt;&gt; Lukas Ruebbelke: And so, we're back on
familiar ground, a service is just a class

47
00:02:46.330 --> 00:02:51.420
that we make available to our injector
with the injectable metadata.

48
00:02:54.260 --> 00:02:55.990
I think we are almost in the home stretch.

49
00:02:57.420 --> 00:02:59.070
My voice is getting tired.

50
00:03:02.160 --> 00:03:05.180
So, a component is just a directive
with added template features.

51
00:03:06.270 --> 00:03:10.310
But we also have built-in
directives that come with

52
00:03:11.790 --> 00:03:15.600
Angular 2, NG4, NGF, NG-switch,
a few off top of my head.

53
00:03:16.980 --> 00:03:21.312
But again, there's just a handful
because now that we're using events and

54
00:03:21.312 --> 00:03:23.460
property binding, it's much simpler.

55
00:03:25.210 --> 00:03:31.211
So, in this case, we have a directive,
and we are just saying,

56
00:03:31.211 --> 00:03:36.896
hey take this thing and
apply it to the FEM blinker selector.

57
00:03:40.495 --> 00:03:41.715
&gt;&gt; Lukas Ruebbelke: Dependency injection.

58
00:03:41.715 --> 00:03:42.694
Yes?

59
00:03:42.694 --> 00:03:47.676
&gt;&gt; Speaker 3: Is it safe to assume that
a directive is basically a behavior

60
00:03:47.676 --> 00:03:50.276
modification of a component?

61
00:03:50.276 --> 00:03:52.535
&gt;&gt; Lukas Ruebbelke: Yes.

62
00:03:52.535 --> 00:03:53.495
&gt;&gt; Speaker 3: Okay.

63
00:03:53.495 --> 00:03:57.911
&gt;&gt; Lukas Ruebbelke: So, in Angular 1,
there was really kind of two styles of

64
00:03:57.911 --> 00:04:04.380
components or directives rather,
that is pretty obvious now in Angular 2.

65
00:04:04.380 --> 00:04:06.337
Is you had a component directive,

66
00:04:06.337 --> 00:04:10.600
that was kind of the self-encapsulated
thing that you would pass around.

67
00:04:10.600 --> 00:04:14.420
And so UI bootstrap is a really
good example of that, of like,

68
00:04:14.420 --> 00:04:19.391
I need this date-picker, and
so, you would basically go and

69
00:04:19.391 --> 00:04:23.330
say like, date or
UI dot date dot pick or whatever and

70
00:04:23.330 --> 00:04:28.720
had all of that behavior and
capsulate it within that directive.

71
00:04:28.720 --> 00:04:33.487
And so, up until Angular 2 is I always
referred to those kind of directives just

72
00:04:33.487 --> 00:04:34.921
simply as components.

73
00:04:34.921 --> 00:04:39.182
It was self-encapsulated, and
then you had what I would refer to as

74
00:04:39.182 --> 00:04:43.391
decorator directives that I have
this thing that already exists.

75
00:04:43.391 --> 00:04:45.091
I need to augment its behavior.

76
00:04:45.091 --> 00:04:47.135
And so, then, I would go in and

77
00:04:47.135 --> 00:04:51.500
do, essentially,
I would decorate it with a directive.

78
00:04:51.500 --> 00:04:55.315
So, that concept still applies and
it's pretty easy.

79
00:04:55.315 --> 00:05:00.629
And Angular 2 is that you have
a component which is the self-contained,

80
00:05:00.629 --> 00:05:05.858
encapsulated unit of functionality,
whereas a directive essentially

81
00:05:05.858 --> 00:05:10.340
augments any component's
behavior with new capabilities.

82
00:05:10.340 --> 00:05:14.762
So for instance, a drag-and-drop would
be a good example of that, a blank,

83
00:05:14.762 --> 00:05:16.777
if you wanted to blank a component.

84
00:05:16.777 --> 00:05:20.501
If I had a directive that I wanted
to turn the mic over to Scott,

85
00:05:20.501 --> 00:05:22.630
I think he has commentary.

86
00:05:22.630 --> 00:05:23.520
&gt;&gt; Scott: Yeah.

87
00:05:23.520 --> 00:05:24.350
Just to answer that.

88
00:05:24.350 --> 00:05:25.907
So, the analogy for

89
00:05:25.907 --> 00:05:31.410
the one-to-one ratio of how is it
now in Angular 2 versus Angular 1.

90
00:05:31.410 --> 00:05:34.920
In Angular 1, we made a directive and
used the restrict property.

91
00:05:34.920 --> 00:05:39.300
You had the E which was for element
directive, think of that as the component

92
00:05:39.300 --> 00:05:44.220
to Angular 2, and then you might have
placed an A for an attribute directive,

93
00:05:44.220 --> 00:05:47.300
that's a directive for Angular 2,
so those are the differences.

94
00:05:47.300 --> 00:05:53.440
E is the component,
A is the directive, that's really it.

95
00:05:53.440 --> 00:05:55.250
&gt;&gt; Lukas Ruebbelke: If you had a mic,
you could just drop it right now,

96
00:05:55.250 --> 00:05:56.265
and walk out the room.

97
00:05:56.265 --> 00:05:59.922
&gt;&gt; Speaker 5: [INAUDIBLE]
&gt;&gt; Lukas Ruebbelke: And he breaks his toe.

98
00:05:59.922 --> 00:06:03.900
&gt;&gt; [LAUGH]
&gt;&gt; Lukas Ruebbelke: So

99
00:06:03.900 --> 00:06:09.530
dependency injection, it works fairly
similar to Angular 1, I think, in theory.

100
00:06:09.530 --> 00:06:13.320
So, on the surfaces, I need this
thing delivered to my component.

101
00:06:13.320 --> 00:06:19.940
You put it in the constructor of
your class and it's available.

102
00:06:19.940 --> 00:06:25.213
The difference is that Angular
2 works on the concept of

103
00:06:25.213 --> 00:06:31.498
hierarchical dependency injection or
hierarchical injectors,

104
00:06:31.498 --> 00:06:36.810
so that each component
gets its own injector.

105
00:06:36.810 --> 00:06:41.964
And so, you can actually declare
services at a component level.

106
00:06:41.964 --> 00:06:45.580
Whereas in Angular 1,

107
00:06:45.580 --> 00:06:50.060
if you injected a service, it was
essentially an application singleton.

108
00:06:50.060 --> 00:06:51.910
That's all you were getting.

109
00:06:51.910 --> 00:06:54.220
In Angular 2, that's not the case.

110
00:06:54.220 --> 00:06:58.510
So, now, we're saying Angular 1 had
sort of a single high-level injector.

111
00:06:58.510 --> 00:07:03.330
Now, we're allowing injectors
at a component level.

112
00:07:03.330 --> 00:07:06.540
The reason being, I believe, is that

113
00:07:08.250 --> 00:07:12.580
as Angular starts to kind of gear itself
to be a large application platform,

114
00:07:13.650 --> 00:07:17.126
that there are used cases
where you would want to,

115
00:07:17.126 --> 00:07:21.860
on a sub-feature basis,
really dial in specific behavior.

116
00:07:22.920 --> 00:07:27.990
And so, with the kind of component system
architecture that exists in Angular 2,

117
00:07:27.990 --> 00:07:31.540
you can inject it to a certain component,
and

118
00:07:31.540 --> 00:07:34.200
it's only available to that component and
its children.

119
00:07:35.400 --> 00:07:38.320
And so, that's pretty neat that you
can actually create even kind of

120
00:07:38.320 --> 00:07:42.510
some variations of that on kind
of a per componentry basis.

121
00:07:42.510 --> 00:07:47.420
Now, if you need for this,
if you need a service to be available for

122
00:07:47.420 --> 00:07:53.000
your entire application, then you do it at
the top level when you bootstrap your app,

123
00:07:53.000 --> 00:07:56.962
and then it's going to
be available top down.

124
00:07:56.962 --> 00:07:58.060
So, for instance,

125
00:07:58.060 --> 00:08:01.670
when I bootstrap, I would generally
put in my router providers,

126
00:08:01.670 --> 00:08:05.760
because I want routing, obviously,
to be available for every single thing.

127
00:08:05.760 --> 00:08:10.670
Another thing is if you have, for
instance, a large application,

128
00:08:10.670 --> 00:08:15.860
you really could be very
specific about what gets what,

129
00:08:15.860 --> 00:08:18.110
instead of making it available
to kind of like everything.

130
00:08:18.110 --> 00:08:20.410
So, there's some performance
issues there as well.

131
00:08:21.620 --> 00:08:27.180
But in this case, you can see in
the experiment's component, I am basically

132
00:08:27.180 --> 00:08:32.690
injecting the state service and
the experiment service into it.

133
00:08:32.690 --> 00:08:34.480
And I've also marked it as private.

134
00:08:34.480 --> 00:08:37.850
This is a typescript thing,
that if you violate this,

135
00:08:37.850 --> 00:08:42.050
you'll get a compile time error, but
at run time, it just gets stripped out.

136
00:08:42.050 --> 00:08:45.680
And so, we're talking a little bit more
about typescript in the next module, but

137
00:08:45.680 --> 00:08:49.130
this is pretty much kind of how it works,

138
00:08:49.130 --> 00:08:54.030
is that I want to inject or I want to
make experiment service injectable.

139
00:08:54.030 --> 00:08:57.040
So, you just write your class,
injectable metadata, and

140
00:08:57.040 --> 00:09:02.470
then, it's now available to the injector,
and then from any other component or

141
00:09:02.470 --> 00:09:07.290
service or directive, you can then
inject that into its constructor.

142
00:09:10.060 --> 00:09:15.020
The one thing that I like is if we've
been through a few of these slides is,

143
00:09:15.020 --> 00:09:18.740
you'll start to notice that
again directives, components,

144
00:09:18.740 --> 00:09:23.790
even pipes which are essentially
Angular 1 filters, services,

145
00:09:23.790 --> 00:09:26.610
that they're really just classes.

146
00:09:26.610 --> 00:09:30.150
And so, now, you kinda have this unified
kind of syntax across everything.

