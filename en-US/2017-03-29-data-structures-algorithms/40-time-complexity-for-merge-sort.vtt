WEBVTT

1
00:00:00.170 --> 00:00:01.600
&gt;&gt; Bianca: Here is our analysis.

2
00:00:01.600 --> 00:00:03.610
We're just analyzing our pseudocode here.

3
00:00:03.610 --> 00:00:08.550
So all of this initializing and
base cases, etc, that's gonna be constant.

4
00:00:13.120 --> 00:00:15.250
This kind of stuff really
depends on the implementation.

5
00:00:15.250 --> 00:00:16.280
We don't really care.

6
00:00:16.280 --> 00:00:19.250
It can be a little more expensive,
but it's not super important.

7
00:00:19.250 --> 00:00:25.477
The things that we wanna really take
a look at is the merge left and right.

8
00:00:25.477 --> 00:00:28.550
So this is our n/2 operation.

9
00:00:28.550 --> 00:00:31.870
Whenever we're cutting something
in half your mind should be like

10
00:00:31.870 --> 00:00:32.820
only got algorithmic.

11
00:00:33.880 --> 00:00:38.360
But then you're gonna pause because
we have this thing called n*logn.

12
00:00:38.360 --> 00:00:40.940
Remember I was like,
I'll tell you about n*logn.

13
00:00:40.940 --> 00:00:45.170
So merge sort is in log in because, yeah,

14
00:00:45.170 --> 00:00:49.120
we're cutting in half, cutting in half,
but then we're merging it together.

15
00:00:49.120 --> 00:00:53.840
And remember we're talking about the time
complexity of the merge being linear.

16
00:00:53.840 --> 00:01:01.180
So that's the N part and then the log
in is the cutting in half part.

17
00:01:01.180 --> 00:01:02.498
And so we [SOUND] put it together and

18
00:01:02.498 --> 00:01:09.100
it's n*logn.
&gt;&gt; Bianca: Cool, are we good?

19
00:01:09.100 --> 00:01:13.070
So it would just be log in if we just cut
it half, cut in half like the phone book,

20
00:01:13.070 --> 00:01:16.350
where we just rip it in half and we throw
it away, rip it in half and throw it away.

21
00:01:16.350 --> 00:01:17.320
So we're ripping it in half and

22
00:01:17.320 --> 00:01:20.810
then we're like, my God,
I need to stitch it back together.

23
00:01:20.810 --> 00:01:25.150
So that part that we could
be saving us some time,

24
00:01:25.150 --> 00:01:27.120
we're like putting it back together.

25
00:01:27.120 --> 00:01:28.570
And so that's the N.

26
00:01:31.190 --> 00:01:33.082
Cool.
&gt;&gt; Speaker 2: Do we need to check

27
00:01:33.082 --> 00:01:34.723
whether they are even or odd?

28
00:01:34.723 --> 00:01:39.530
Like when you divide that by two?
&gt;&gt; Bianca: Yeah.

29
00:01:39.530 --> 00:01:43.170
Yea, yeah, so you're going to
have to come up with whether,

30
00:01:43.170 --> 00:01:46.530
where you're gonna cut it,
do some sort of rounding up.

31
00:01:46.530 --> 00:01:51.580
You know, math.max, or math.min,
depending on how you wanna do it.

32
00:01:51.580 --> 00:01:55.270
Yeah?
&gt;&gt; Speaker 2: So why, with the other ones

33
00:01:55.270 --> 00:01:59.520
even when we combined methods you
just took the worst case scenario.

34
00:01:59.520 --> 00:02:04.608
So why wouldn't we just call this one a.
&gt;&gt; Bianca: Yeah that's a good question,

35
00:02:04.608 --> 00:02:09.458
so the question is so before we just
kind of said [SOUND] we'll just axe it,

36
00:02:09.458 --> 00:02:11.301
and this one we combine it.

37
00:02:11.301 --> 00:02:16.410
And that's because it's really let's see,
that's a great question.

38
00:02:16.410 --> 00:02:22.440
So it really has to do with,
how do I explain this like that.

39
00:02:22.440 --> 00:02:23.039
&gt;&gt; Speaker 2: Is it because it's

40
00:02:23.039 --> 00:02:24.364
recursive?
&gt;&gt; Bianca: No.

41
00:02:24.364 --> 00:02:25.670
&gt;&gt; Speaker 2: No?

42
00:02:33.266 --> 00:02:34.573
&gt;&gt; Bianca: Maybe I don't have an answer

43
00:02:34.573 --> 00:02:35.830
to that question exactly.

44
00:02:37.440 --> 00:02:44.135
Yeah, does anyone know?
&gt;&gt; Bianca: Not

45
00:02:44.135 --> 00:02:51.210
even our math people know?
&gt;&gt; Bianca: Yeah.

46
00:02:53.310 --> 00:02:54.470
&gt;&gt; Speaker 2: What's the question again?

47
00:02:54.470 --> 00:02:56.095
&gt;&gt; Bianca: The question is why do we say

48
00:02:56.095 --> 00:02:59.629
this is n*logn and
not just login when before we were just,

49
00:02:59.629 --> 00:03:04.022
we just chopped things off, why don't
we just chop off n when we chop off-

50
00:03:04.022 --> 00:03:05.642
&gt;&gt; Speaker 2: Well n*logn is,

51
00:03:05.642 --> 00:03:09.320
it's a constant multiple of n, right.

52
00:03:09.320 --> 00:03:14.471
So if you say, on,
that could mean n or 2n or 5n or 100n,

53
00:03:14.471 --> 00:03:20.341
but the log n, logarithm grows very
slowly but it grows to infinity.

54
00:03:20.341 --> 00:03:27.009
&gt;&gt; Bianca: Mm-hm.

55
00:03:28.525 --> 00:03:30.480
&gt;&gt; Bianca: Yeah, it's a math thing.

56
00:03:30.480 --> 00:03:31.350
&gt;&gt; Speaker 3: Okay that makes sense,

57
00:03:31.350 --> 00:03:32.734
that makes sense.
&gt;&gt; Speaker 2: Yeah and

58
00:03:32.734 --> 00:03:37.414
there's been multiplying and adding
that if you said n + login, of course,

59
00:03:37.414 --> 00:03:40.860
the login would be smaller and
you could drop it.

60
00:03:40.860 --> 00:03:43.610
But it's because login is
going to infinity you can't

61
00:03:43.610 --> 00:03:46.195
just throw it away.
&gt;&gt; Bianca: Yeah and it could

62
00:03:46.195 --> 00:03:50.716
have something to do with this equation.
&gt;&gt; Bianca: But,

63
00:03:50.716 --> 00:03:54.980
I can't be 100% sure,
I'm not claiming to be a mathy person.

64
00:03:54.980 --> 00:03:58.660
But what I could tell you- Well, login is
the number of times your splitting, right?

65
00:03:58.660 --> 00:03:59.339
&gt;&gt; Speaker 2: The number of times

66
00:03:59.339 --> 00:04:02.300
you'll recurse.
&gt;&gt; Bianca: Mm-hm, mm-hm.

67
00:04:02.300 --> 00:04:05.360
And in is the merge, yeah.

68
00:04:05.360 --> 00:04:07.350
I can tell you that much for sure.

69
00:04:07.350 --> 00:04:10.832
The specifics in the math,
totally over my head.

70
00:04:16.315 --> 00:04:18.861
&gt;&gt; Speaker 2: That means when we split,

71
00:04:18.861 --> 00:04:23.721
the number of the splits
most of it times our most,

72
00:04:23.721 --> 00:04:26.535
for instance here you have.

73
00:04:26.535 --> 00:04:31.490
Yeah [INAUDIBLE] when you do split,

74
00:04:31.490 --> 00:04:36.020
it is just almost three times like that.

75
00:04:36.020 --> 00:04:38.838
Log in comes from that [INAUDIBLE] Yeah,
yeah, yeah.

76
00:04:38.838 --> 00:04:42.510
&gt;&gt; Bianca: Yeah, I agree that the log in

77
00:04:42.510 --> 00:04:46.190
part is the levels, right?

78
00:04:46.190 --> 00:04:48.820
It's like the number of levels
that come out of the splitting.

79
00:04:50.510 --> 00:04:52.840
And then the n is this part.

80
00:04:54.880 --> 00:04:56.980
And so
when I'm thinking about the calculation,

81
00:04:58.290 --> 00:05:02.990
I think of the levels times the merge,
which is linear.

82
00:05:04.990 --> 00:05:07.760
So that's how I think about it in my head,
but I don't know if that's a mathematical

83
00:05:07.760 --> 00:05:09.023
fact.
&gt;&gt; Speaker 2: Remember that merge

84
00:05:09.023 --> 00:05:09.681
itself is a loop?

85
00:05:09.681 --> 00:05:11.763
&gt;&gt; Bianca: Mm-hm.
&gt;&gt; Speaker 2: Right?

86
00:05:11.763 --> 00:05:15.500
So it's not linear [COUGH] it actually,
I mean a double loop.

87
00:05:15.500 --> 00:05:18.996
It's not- No, merge is linear.
&gt;&gt; Bianca: Merger is a singular loop.

88
00:05:21.683 --> 00:05:25.106
&gt;&gt; Bianca: So is n*logn [COUGH] is less

89
00:05:25.106 --> 00:05:29.180
[CROSSTALK] than n?
&gt;&gt; Speaker 2: It's more.

90
00:05:29.180 --> 00:05:32.276
N*logn is bigger.
&gt;&gt; [INAUDIBLE]

91
00:05:32.276 --> 00:05:35.541
&gt;&gt; Bianca: So let's take a look.

92
00:05:35.541 --> 00:05:37.228
&gt;&gt; Speaker 2: If she says n*logn,

93
00:05:37.228 --> 00:05:42.560
I'm good with that.
&gt;&gt; Bianca: Right, n*logn grow slower,

94
00:05:42.560 --> 00:05:47.140
but you're doing n times log in.

95
00:05:47.140 --> 00:05:48.880
Log in grows very slowly, so

96
00:05:48.880 --> 00:05:50.751
think of a line with slope-
&gt;&gt; Speaker 2: We don't even have

97
00:05:50.751 --> 00:05:52.980
an end log in on this graph.
&gt;&gt; Bianca: So slope is increasing, but

98
00:05:52.980 --> 00:05:54.340
it increases slowly.

99
00:05:56.644 --> 00:05:57.391
&gt;&gt; Speaker 2: Okay.
&gt;&gt; Bianca: Yeah.

100
00:05:57.391 --> 00:05:58.720
&gt;&gt; Speaker 2: So it's similar

101
00:05:58.720 --> 00:05:59.870
&gt;&gt; Bianca: Generally, so we put-

102
00:06:06.551 --> 00:06:08.318
&gt;&gt; Speaker 2: Okay, cool.

103
00:06:08.318 --> 00:06:11.884
Are we good on the in-logging craziness?
&gt;&gt; Bianca: Mm-hm.

104
00:06:11.884 --> 00:06:13.280
&gt;&gt; Speaker 2: [LAUGH] Yes we are.

105
00:06:13.280 --> 00:06:14.718
&gt;&gt; Bianca: So the merge is the end.

106
00:06:14.718 --> 00:06:19.630
Splits is the log-in.

107
00:06:19.630 --> 00:06:20.790
That's all I got for you.

108
00:06:20.790 --> 00:06:22.739
Everything else is gonna
require further research.

109
00:06:24.750 --> 00:06:29.300
We are going to go over the solution for
recursive merge sorts.

110
00:06:30.640 --> 00:06:32.290
You're ready?
How do we feel about merge sorts?

111
00:06:35.090 --> 00:06:37.220
Yeah?
&gt;&gt; Speaker 2: It exists.

112
00:06:37.220 --> 00:06:37.750
&gt;&gt; Bianca: It exists.

113
00:06:37.750 --> 00:06:38.430
It's a cool thing.

114
00:06:38.430 --> 00:06:40.370
It's faster than any of the other sorts.

115
00:06:41.410 --> 00:06:42.920
It's pretty awesome.

116
00:06:42.920 --> 00:06:44.070
All right.

117
00:06:44.070 --> 00:06:44.990
Let's check out the code.

118
00:06:46.380 --> 00:06:47.005
So first thing's first.

119
00:06:47.005 --> 00:06:49.312
We have our base case, right?

120
00:06:49.312 --> 00:06:54.780
So if it's just an array with length one.

121
00:06:54.780 --> 00:06:56.580
We are going to return.

122
00:06:58.120 --> 00:07:00.820
Then we have our divide and conquer.

123
00:07:00.820 --> 00:07:03.478
So we're just slicing it in half.

124
00:07:03.478 --> 00:07:05.760
The left half and right half.

125
00:07:07.410 --> 00:07:13.650
And then we are recursing,
first on the left and then on the right.

126
00:07:13.650 --> 00:07:15.090
And again, what this is doing,

127
00:07:15.090 --> 00:07:19.890
we're drilling deep first on the left,
left, left, left.

128
00:07:19.890 --> 00:07:22.366
Then right, then right, right, right.

129
00:07:22.366 --> 00:07:23.860
Does that make sense to you?

130
00:07:25.760 --> 00:07:26.880
It's our little pyramid.

131
00:07:28.030 --> 00:07:29.400
And here's where the magic happens.

132
00:07:29.400 --> 00:07:34.290
So with mergeSort, the sorting happens
on the combine step, hence mergeSort.

133
00:07:34.290 --> 00:07:36.580
It's gonna be different when we
talk about quickSort in a second.

134
00:07:37.580 --> 00:07:44.760
So here we are, we're going to pass
the leftSorted and the rightSorted.

135
00:07:44.760 --> 00:07:50.397
And that's gonna return up in here,
remember, once we get to the bottom.

136
00:07:50.397 --> 00:07:53.380
And that's it, that's our mergeSort.

137
00:07:54.860 --> 00:07:57.274
I know it's like, man, that looks so

138
00:07:57.274 --> 00:07:59.814
much easier when the solution's up.
&gt;&gt; Speaker 2: So

139
00:07:59.814 --> 00:08:02.971
I think where we were running
into trouble is within the merge,

140
00:08:02.971 --> 00:08:06.170
can you show the merge.
&gt;&gt; Bianca: Yeah, sure.

141
00:08:06.170 --> 00:08:06.692
Check on our merge.

142
00:08:06.692 --> 00:08:09.510
So here's our merge.

143
00:08:09.510 --> 00:08:13.260
We have your left and
right that we're passing in and

144
00:08:13.260 --> 00:08:16.580
we're going to start off with your
indexes, so we had those pointers.

145
00:08:16.580 --> 00:08:18.620
Remember we called them left and
right pointer?

146
00:08:18.620 --> 00:08:22.040
Here we iLeft and
iRight as well as our result array.

147
00:08:23.170 --> 00:08:27.181
So while the result.length
is less than both of

148
00:08:27.181 --> 00:08:32.170
these.
&gt;&gt; Bianca: We're gonna keep

149
00:08:32.170 --> 00:08:36.132
going.
&gt;&gt; Speaker 2: That's what you

150
00:08:36.132 --> 00:08:37.204
are missing.
&gt;&gt; Bianca: Yeah,

151
00:08:37.204 --> 00:08:38.899
that's gonna stop you from going forever.

152
00:08:38.899 --> 00:08:45.378
So if our left pointer is basically,

153
00:08:45.378 --> 00:08:49.767
to the end of that array,

154
00:08:49.767 --> 00:08:56.249
we're going to concat our results.

155
00:08:56.249 --> 00:08:57.660
Opposite is true here.

156
00:09:01.450 --> 00:09:02.580
Here we go.

157
00:09:02.580 --> 00:09:05.084
This left, left at the pointer, right,

158
00:09:05.084 --> 00:09:08.172
that value is less than
right at the right pointer.

159
00:09:08.172 --> 00:09:12.672
This is where we're pushing
&gt;&gt; Bianca: Otherwise,

160
00:09:12.672 --> 00:09:19.656
we are going to push the right.
&gt;&gt; Bianca: And at the end we return it.

161
00:09:19.656 --> 00:09:28.740
Cool.
&gt;&gt; Bianca: Sound good?

162
00:09:28.740 --> 00:09:30.890
You guys all have access to this
in the solution branch as well.

163
00:09:31.950 --> 00:09:35.040
So the question came up
before about n*logn and

164
00:09:35.040 --> 00:09:38.100
I couldn't find a definitive
answer on the internet, but

165
00:09:39.390 --> 00:09:44.500
essentially what we're saying
with n*logn is that so

166
00:09:44.500 --> 00:09:48.870
our merge is in, right?

167
00:09:48.870 --> 00:09:52.690
We have to merge with every
recursive call, which is login.

168
00:09:53.960 --> 00:09:57.350
So we have to multiply them together and
the question was,

169
00:09:57.350 --> 00:10:00.880
why don't we drop one of those digits.

170
00:10:00.880 --> 00:10:03.180
Why isn't it log in or
why isn't it just n?

171
00:10:03.180 --> 00:10:07.610
And the answer is because we
only drop significant digits and

172
00:10:07.610 --> 00:10:09.290
both of those are significant, right?

173
00:10:09.290 --> 00:10:13.070
So it's a little bit more than linear,
right?

174
00:10:13.070 --> 00:10:19.353
It's linear times log in and
it's less than a quadratic equation.

175
00:10:19.353 --> 00:10:21.590
And so both of them are significant.

176
00:10:21.590 --> 00:10:24.010
We multiply them because
it's in the recursive loop.

177
00:10:25.880 --> 00:10:28.050
And that's why it's n*logn.

178
00:10:28.050 --> 00:10:30.680
There's a bunch of mathematical
proofs you can go in and

179
00:10:30.680 --> 00:10:32.530
fool around with if you're into that.

180
00:10:32.530 --> 00:10:36.290
But in terms of estimating,
that's how we estimate that.

181
00:10:37.365 --> 00:10:40.640
So,to answer you question about why we
don't drop the n or drop the log in?

182
00:10:42.340 --> 00:10:43.030
Okay.

183
00:10:43.030 --> 00:10:43.530
Awesome.

