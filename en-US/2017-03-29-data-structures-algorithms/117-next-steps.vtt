WEBVTT

1
00:00:00.080 --> 00:00:03.000
&gt;&gt; Bianca Gandolfo: So
we have gone through a lot this week.

2
00:00:03.000 --> 00:00:06.850
We've covered most of
the fundamentals that you'll find

3
00:00:06.850 --> 00:00:10.980
in an introductory data structures and
algorithms class, right?

4
00:00:12.890 --> 00:00:16.259
Mostly like the first class of that
subject, you know what I mean?

5
00:00:16.259 --> 00:00:19.597
So if you think about like a college
course, a data structures and

6
00:00:19.597 --> 00:00:22.400
algorithms course is gonna
be usually two semesters.

7
00:00:22.400 --> 00:00:24.820
So you'll have the first semester and
the second semester.

8
00:00:24.820 --> 00:00:28.620
This is kind of like
a semester's worth of content

9
00:00:28.620 --> 00:00:30.810
of the first introductory lessons, right?

10
00:00:30.810 --> 00:00:37.640
So you might have three or four lessons
that build on each of these topics, right?

11
00:00:37.640 --> 00:00:41.050
So you kinda just took the first
hour of each of those topics.

12
00:00:41.050 --> 00:00:44.350
And there's more to it, however you don't

13
00:00:44.350 --> 00:00:47.890
commonly need to go beyond that if
you're just studying for interviews.

14
00:00:49.200 --> 00:00:52.390
Because most people, honestly,
forget that stuff anyway,

15
00:00:52.390 --> 00:00:55.590
and your interviewer is a person.

16
00:00:55.590 --> 00:00:57.920
So you tend to not have to go beyond that.

17
00:00:57.920 --> 00:01:00.730
But if you did,
I'm gonna give you some next steps of

18
00:01:00.730 --> 00:01:04.470
what are some cool things that
you can learn next, once you

19
00:01:05.600 --> 00:01:10.140
feel comfortable with the fundamentals
we've been covering in this class.

20
00:01:10.140 --> 00:01:12.610
So these are all sort of
building blocks that build,

21
00:01:12.610 --> 00:01:17.400
they work together, that underlie
how everything works right here.

22
00:01:18.650 --> 00:01:22.930
In your computer, on the Internet,
that kind of thing.

23
00:01:22.930 --> 00:01:24.540
So let's talk about next steps.

24
00:01:24.540 --> 00:01:27.650
So the very first day we talked
about object-oriented JavaScript,

25
00:01:27.650 --> 00:01:31.650
you learned how to create a class
in pseudoclassical style.

26
00:01:31.650 --> 00:01:35.120
So the next thing you might wanna
do is learn how to subclass and

27
00:01:35.120 --> 00:01:39.680
extend your classes according to
other object-oriented patterns.

28
00:01:39.680 --> 00:01:40.857
So I would look into that.

29
00:01:40.857 --> 00:01:44.670
You can learn how to
implement classes in ES6.

30
00:01:44.670 --> 00:01:49.899
There's this cool repo that has basically,
has most of the data structures and

31
00:01:49.899 --> 00:01:54.052
the algorithms that we have done
in this class written on ES6.

32
00:01:54.052 --> 00:01:56.810
And they also have some
in regular JavaScript.

33
00:01:58.540 --> 00:02:00.042
So you could check that out and

34
00:02:00.042 --> 00:02:05.570
see how that compares.
&gt;&gt; Bianca Gandolfo: Awesome,

35
00:02:05.570 --> 00:02:07.300
so we learned about time complexity.

36
00:02:07.300 --> 00:02:11.620
We were able to estimate,
generally estimate, right,

37
00:02:11.620 --> 00:02:13.160
how fast our algorithms were.

38
00:02:14.480 --> 00:02:17.533
And think about what parts of
them were the slow parts, and

39
00:02:17.533 --> 00:02:19.973
what parts of them were
maybe the first parts.

40
00:02:19.973 --> 00:02:25.664
Next you can do is to keep learning
about computational complexity theory.

41
00:02:25.664 --> 00:02:30.626
And you could take a whole class on this,
and learn about NP-Complete and

42
00:02:30.626 --> 00:02:35.044
all these different ways to estimate
how difficult a problem is.

43
00:02:35.044 --> 00:02:40.552
The other thing you could do is learn how
to calculate time complexity formally,

44
00:02:40.552 --> 00:02:43.640
and write out proofs,
and things like that.

45
00:02:44.970 --> 00:02:48.048
Those are more things that you
could do with time complexity.

46
00:02:48.048 --> 00:02:53.419
Sorting, so we learned elementary sorting,
recursive sortings.

47
00:02:53.419 --> 00:02:58.750
You can learn a non-comparison
sort like Radix sort.

48
00:02:58.750 --> 00:03:02.384
I had the video on over
lunch about Radix sort.

49
00:03:02.384 --> 00:03:06.324
You can learn how to combine
different sorts to create new sorts,

50
00:03:06.324 --> 00:03:10.290
like Timsort is a combination of
insertion sort with merge sort.

51
00:03:10.290 --> 00:03:14.590
And it's the underlying sort for Python.

52
00:03:16.400 --> 00:03:18.700
Most other languages are implementing
either merge sort or

53
00:03:18.700 --> 00:03:21.900
quick sort or both of them under the hood.

54
00:03:23.000 --> 00:03:26.390
So Timsort could be another fun one.

55
00:03:26.390 --> 00:03:29.500
Or you could just learn some other
sorts cuz they have funny names.

56
00:03:29.500 --> 00:03:31.790
Like gnome sort, stooge sort, bogosort.

57
00:03:31.790 --> 00:03:38.520
These are all kind of just silly sorts
that are kinda just silly examples.

58
00:03:38.520 --> 00:03:40.524
And all of these run
slower than bubble sort,

59
00:03:40.524 --> 00:03:42.910
and we already know bubble
sort is really slow.

60
00:03:42.910 --> 00:03:44.505
Bogosort, actually the other
name is stupidsort.

61
00:03:44.505 --> 00:03:49.107
So they're just like Bogosort,
I think they just have random

62
00:03:49.107 --> 00:03:54.607
permutations of each of the input
until finally find one that's sorted.

63
00:03:54.607 --> 00:03:56.378
So you randomly change it, one of them.
&gt;&gt; off screen: [LAUGH]

64
00:03:56.378 --> 00:03:56.968
&gt;&gt; Bianca Gandolfo: And then you

65
00:03:56.968 --> 00:03:57.553
check it.
&gt;&gt; off screen: My God!

66
00:03:57.553 --> 00:03:58.549
&gt;&gt; Bianca Gandolfo: And then you randomly

67
00:03:58.549 --> 00:04:00.560
change it, and then you check it.

68
00:04:00.560 --> 00:04:02.333
And so it's just a funny example.
&gt;&gt; off screen: Well,

69
00:04:02.333 --> 00:04:04.320
that's one way to do it.
&gt;&gt; Bianca Gandolfo: Yeah,

70
00:04:04.320 --> 00:04:07.710
so no one uses it in practice.

71
00:04:07.710 --> 00:04:11.500
The next day we talked about linked lists
and trees, sort of these general trees.

72
00:04:11.500 --> 00:04:14.990
The next steps,
you can learn how to do a prefix tree,

73
00:04:14.990 --> 00:04:16.970
which is used in auto complete.

74
00:04:16.970 --> 00:04:20.760
When you start typing in Google,
that's using a prefix tree.

75
00:04:20.760 --> 00:04:25.032
You can also use it as a solver for
Boggle or Words With Friends or something.

76
00:04:25.032 --> 00:04:28.025
You can use that for that.

77
00:04:28.025 --> 00:04:30.790
If you're lonely you can
create a dialogue tree.

78
00:04:30.790 --> 00:04:34.675
Which is what we use for
when you're interacting with

79
00:04:34.675 --> 00:04:39.440
non-player characters in video games and
you talk to them and they answer you.

80
00:04:39.440 --> 00:04:41.470
That would be a dialogue tree.

81
00:04:41.470 --> 00:04:43.970
You can create a scavenger hunt
game with your linked list.

82
00:04:44.970 --> 00:04:49.920
So that your next, you can only access
to your next by solving some riddle.

83
00:04:49.920 --> 00:04:53.017
It could be a fun game for a linked list.

84
00:04:53.017 --> 00:04:56.827
Also obviously, you can bind trees and
link lists with a bunch of other

85
00:04:56.827 --> 00:05:02.040
algorithms that could be useful.
&gt;&gt; Bianca Gandolfo: Binary search trees.

86
00:05:02.040 --> 00:05:05.500
You can balance your binary search
trees using a DSW algorithm.

87
00:05:05.500 --> 00:05:07.170
So you already have your
binary search tree.

88
00:05:07.170 --> 00:05:08.170
It's created.

89
00:05:08.170 --> 00:05:09.530
It's super lopsided.

90
00:05:09.530 --> 00:05:12.670
The DSW algorithm will
help you balance it.

91
00:05:12.670 --> 00:05:17.665
Or If you thought about this ahead of
time, you could just create an AVL tree or

92
00:05:17.665 --> 00:05:20.870
red-black tree, or a splay tree,
which are self balancing.

93
00:05:20.870 --> 00:05:26.250
So as you're adding nodes, it's going to
keep track of how deep it is and balance.

94
00:05:26.250 --> 00:05:31.539
And again,
a balance tree is a tree that doesn't

95
00:05:31.539 --> 00:05:38.129
have a layer that's too deeper
than any of the other layers.

96
00:05:38.129 --> 00:05:40.540
Does that make sense?

97
00:05:40.540 --> 00:05:46.645
The height is not lopsided, so
a balanced tree looks like a triangle.

98
00:05:46.645 --> 00:05:54.073
A unbalanced tree looks like it has like a
little tail somewhere, if you drew it out.

99
00:05:54.073 --> 00:05:58.693
Another thing, the next step could
be comparing a binary tree to binary

100
00:05:58.693 --> 00:06:03.820
to a binary heap, and then taking it
a step further and doing heap sort.

101
00:06:03.820 --> 00:06:07.490
We have exercises for binary heaps and

102
00:06:07.490 --> 00:06:12.660
heap sorts in our algorithm class repo, so
if you have time, you can check that out.

103
00:06:13.800 --> 00:06:19.020
For graphs, graphs are amazing, they are
applied to a bunch of different things.

104
00:06:19.020 --> 00:06:22.920
We learned how to represent them in both
an adjacency matrix and adjacency list.

105
00:06:22.920 --> 00:06:27.740
And then we talked about how
we can explore them [COUGH]

106
00:06:27.740 --> 00:06:29.900
either depth first or breath first.

107
00:06:29.900 --> 00:06:36.272
Those are the main sort of entry
points into graph algorithms.

108
00:06:36.272 --> 00:06:40.404
You could dive into graph theory and
discrete mathematics,

109
00:06:40.404 --> 00:06:42.680
if you really wanna be hardcore.

110
00:06:44.360 --> 00:06:50.580
You can learn topological sort
to figure out dependencies.

111
00:06:50.580 --> 00:06:54.157
Like if you're in college and you wanna
figure out what classes you need to

112
00:06:54.157 --> 00:06:58.370
graduate, in what order, because they all
require whatever, all these classes have

113
00:06:58.370 --> 00:07:01.911
these different requirements,
you can use topological sort for that.

114
00:07:01.911 --> 00:07:06.793
If you wanna calculate shortest
paths between two cities,

115
00:07:06.793 --> 00:07:11.040
Dijkstra's algorithm is really famous for
that.

116
00:07:11.040 --> 00:07:15.262
If you wanna learn how to find
minimum splay trees that are central

117
00:07:15.262 --> 00:07:18.958
to data mining,
you can use Prim's algorithm for that.

118
00:07:18.958 --> 00:07:21.593
And these are just sort of the next steps.

119
00:07:21.593 --> 00:07:27.780
And there's all kinds of branches
that you can go from there, right?

120
00:07:27.780 --> 00:07:31.160
So once you're starting to
find path algorithms, right?

121
00:07:31.160 --> 00:07:33.690
Then from Dijkstra's algorithm,
which is the most famous one,

122
00:07:33.690 --> 00:07:35.485
there's a bunch of different kinds, right?

123
00:07:35.485 --> 00:07:37.875
And you can keep going.

124
00:07:37.875 --> 00:07:42.617
And if you find yourself in Wikipedia,
you can look, you'll say like,

125
00:07:42.617 --> 00:07:47.300
pathfinding algorithms, and
it'll [SOUND] all these different ones.

126
00:07:48.800 --> 00:07:50.110
So hash tables.

127
00:07:50.110 --> 00:07:52.140
So we ended with hash tables.

128
00:07:52.140 --> 00:07:57.490
We made our own little pseudo
code hashing functions.

129
00:07:57.490 --> 00:08:02.558
We created our own hash tables
with different methods on it.

130
00:08:02.558 --> 00:08:07.418
Now you can just apply that knowledge,
if you want,

131
00:08:07.418 --> 00:08:10.700
to how version control works.

132
00:08:10.700 --> 00:08:15.010
It uses trees and hashing and
all these things all together to

133
00:08:15.010 --> 00:08:17.640
make sure that you don't lose
your code as you change it.

134
00:08:17.640 --> 00:08:18.147
It's really exciting.

135
00:08:18.147 --> 00:08:22.371
You can get curious
about bloom filters and

136
00:08:22.371 --> 00:08:28.020
how it's a kind of hash table
that we use in caching.

137
00:08:28.020 --> 00:08:30.688
Hashing, like I said earlier,
is used in security.

138
00:08:30.688 --> 00:08:36.710
And you can start by thinking about a hash
tree, which combines hashing with a tree.

139
00:08:36.710 --> 00:08:40.170
And this is something that's
really common in P2P networks.

140
00:08:40.170 --> 00:08:41.690
Do people do that still,

141
00:08:41.690 --> 00:08:43.953
where they download stuff from each other?
&gt;&gt; off screen: Torrents,

142
00:08:43.953 --> 00:08:45.760
yeah.
&gt;&gt; Bianca Gandolfo: Yeah, torrents.

143
00:08:45.760 --> 00:08:48.019
But torrents are still P2P, though, right?

144
00:08:48.019 --> 00:08:51.690
I don't participate in that kind of stuff,
so I don't really know.

145
00:08:51.690 --> 00:08:52.230
&gt;&gt; off screen: When I think

146
00:08:52.230 --> 00:08:54.446
about P2P networks,
I think of like LimeWire or

147
00:08:54.446 --> 00:08:55.050
Kazaa.
&gt;&gt; Bianca Gandolfo: Yeah that's

148
00:08:55.050 --> 00:08:55.573
what I'm thinking.
&gt;&gt; off screen: Or

149
00:08:55.573 --> 00:09:00.160
stuff like a specific network,
but torrents kinda replaced that.

150
00:09:00.160 --> 00:09:02.241
So it works person-to-person, but

151
00:09:02.241 --> 00:09:03.590
it's a different-
&gt;&gt; Bianca Gandolfo: It's called

152
00:09:03.590 --> 00:09:04.256
something else now.
&gt;&gt; off screen: Protocol, yeah.

153
00:09:04.256 --> 00:09:05.128
&gt;&gt; Bianca Gandolfo: Yeah, got it.

154
00:09:05.128 --> 00:09:09.537
Cool, and
the other thing you can think about is

155
00:09:09.537 --> 00:09:13.726
the complexity of
a distributed hash table,

156
00:09:13.726 --> 00:09:18.700
which underlies Box, or
Dropbox, or Google Drive.

157
00:09:19.760 --> 00:09:21.390
So that's kind of fun.

158
00:09:21.390 --> 00:09:25.462
And then, that's all I got, thank you.

159
00:09:25.462 --> 00:09:27.859
That's your next steps.

