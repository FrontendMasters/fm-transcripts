WEBVTT

1
00:00:00.100 --> 00:00:02.155
&gt;&gt; Bianca Gandolfo: So
let's pseudocode this real quick.

2
00:00:02.155 --> 00:00:05.533
Step one, go left until left is null.

3
00:00:07.540 --> 00:00:12.520
&gt;&gt; Bianca Gandolfo: So we'll have our,
&gt;&gt; Bianca Gandolfo: Function here

4
00:00:12.520 --> 00:00:14.189
called deleteMin.

5
00:00:25.284 --> 00:00:29.214
&gt;&gt; Bianca Gandolfo: Okay, so
we go left until left is null, but

6
00:00:29.214 --> 00:00:32.285
what does that look like in code?

7
00:00:32.285 --> 00:00:34.982
This makes sense in English.

8
00:00:34.982 --> 00:00:37.527
We don't have a go left.

9
00:00:37.527 --> 00:00:39.301
We don't have an until, really.

10
00:00:41.593 --> 00:00:47.106
&gt;&gt; Speaker 2: I looked in our code,
was just if this.left go.

11
00:00:47.106 --> 00:00:48.738
&gt;&gt; Bianca Gandolfo: Mm-hm.

12
00:00:48.738 --> 00:00:53.298
So if there's left recurse.

13
00:01:04.599 --> 00:01:06.350
&gt;&gt; Bianca Gandolfo: Recurse where though?

14
00:01:06.350 --> 00:01:11.345
So part of the recursion step, right,
is we need to break the problem into

15
00:01:11.345 --> 00:01:15.871
a smaller sub problem otherwise
we have an infinite loop, right?

16
00:01:15.871 --> 00:01:21.298
So if we just say recurse, or
what that really means is delete min.

17
00:01:21.298 --> 00:01:25.383
On the child.

18
00:01:25.383 --> 00:01:26.983
I would do that again.

19
00:01:26.983 --> 00:01:29.775
&gt;&gt; Speaker 2: This.left.child delete min.

20
00:01:29.775 --> 00:01:33.474
&gt;&gt; Bianca Gandolfo: Yep, so
we'd call it on the child node and

21
00:01:33.474 --> 00:01:38.463
this is breaking our problem
down into smaller pieces.

22
00:01:39.846 --> 00:01:42.707
&gt;&gt; Bianca Gandolfo: Cool, great.

23
00:01:45.299 --> 00:01:46.491
&gt;&gt; Bianca Gandolfo: Now what?

24
00:01:54.345 --> 00:01:58.984
&gt;&gt; Bianca Gandolfo: So for the case where
it was the three, and it was the leaf,

25
00:01:58.984 --> 00:02:02.038
a leaf meaning there's no children.

26
00:02:09.560 --> 00:02:14.378
&gt;&gt; Speaker 3: Don't you have to do
the step that modifies the tree before,

27
00:02:14.378 --> 00:02:16.089
I forget what it was.

28
00:02:16.089 --> 00:02:18.954
&gt;&gt; Bianca Gandolfo: What do
you wanna modify on the tree?

29
00:02:18.954 --> 00:02:23.922
&gt;&gt; Speaker 3: If the tree has children
setting changing the children

30
00:02:23.922 --> 00:02:27.383
to take the place of the deleted node.

31
00:02:29.303 --> 00:02:30.619
&gt;&gt; Bianca Gandolfo: So
that's if there is two children,

32
00:02:30.619 --> 00:02:31.983
right now we're just working on one.

33
00:02:31.983 --> 00:02:32.799
&gt;&gt; Speaker 3: Okay.

34
00:02:32.799 --> 00:02:33.679
&gt;&gt; Bianca Gandolfo: But yeah.

35
00:02:33.679 --> 00:02:36.679
We have to do something along those lines.

36
00:02:36.679 --> 00:02:39.009
&gt;&gt; Speaker 2: I remember-
&gt;&gt; Bianca Gandolfo: Good check in.

37
00:02:39.009 --> 00:02:42.452
[CROSSTALK]
&gt;&gt; Speaker 2: I remember from yesterday,

38
00:02:42.452 --> 00:02:45.670
the delete whatever it is,
has to be before the gibberish thing,

39
00:02:45.670 --> 00:02:47.714
that's how we stop it from-
&gt;&gt; Speaker 3: Deleting the whole tree.

40
00:02:47.714 --> 00:02:48.873
&gt;&gt; Speaker 2: Deleting everything, yeah.

41
00:02:48.873 --> 00:02:49.994
&gt;&gt; Bianca Gandolfo: Yeah,
yeah, yeah, yeah.

42
00:02:49.994 --> 00:02:54.355
Yeah, that' s a good reminder,
if we delete after our recursion,

43
00:02:54.355 --> 00:02:58.654
we're gonna delete the entire tree and
it's just gonna explode.

44
00:02:58.654 --> 00:03:00.902
It'll be some infinite loop.

45
00:03:03.917 --> 00:03:09.037
&gt;&gt; Speaker 2: So would it just
be this.value equals this.right?

46
00:03:11.221 --> 00:03:15.284
&gt;&gt; Bianca Gandolfo: So
if this.value equals, so

47
00:03:15.284 --> 00:03:20.328
we wanna see when the child is a leaf.

48
00:03:20.328 --> 00:03:23.088
So how do we check to see
if the child is a leaf?

49
00:03:23.088 --> 00:03:28.097
&gt;&gt; Speaker 2: If it doesn't have-
&gt;&gt; Speaker 3: If it doesn't have children.

50
00:03:28.097 --> 00:03:31.900
&gt;&gt; Bianca Gandolfo: So if this.left and

51
00:03:31.900 --> 00:03:37.721
this.right is null, right?

52
00:03:37.721 --> 00:03:38.497
Yeah.

53
00:03:40.992 --> 00:03:42.616
&gt;&gt; Bianca Gandolfo: Then
what do we wanna do?

54
00:03:58.330 --> 00:04:01.705
&gt;&gt; Speaker 2: I'm confused cuz I thought
we were on a case where it did have

55
00:04:01.705 --> 00:04:02.523
a child node.

56
00:04:02.523 --> 00:04:04.605
&gt;&gt; Bianca Gandolfo: Well let's
start from the beginning.

57
00:04:04.605 --> 00:04:05.796
&gt;&gt; Speaker 3: Yeah,
we're starting from the beginning.

58
00:04:05.796 --> 00:04:07.195
&gt;&gt; Speaker 2: Okay cool.

59
00:04:07.195 --> 00:04:09.720
&gt;&gt; Bianca Gandolfo: Just so
we have all the pieces here.

60
00:04:09.720 --> 00:04:17.162
&gt;&gt; Speaker 2: So
if this.left, is that right?

61
00:04:17.162 --> 00:04:19.172
&gt;&gt; Bianca Gandolfo: So
there's no children.

62
00:04:19.172 --> 00:04:21.730
You guys are calling me out on my errors.

63
00:04:23.534 --> 00:04:27.701
&gt;&gt; Speaker 2: This.value equals null?

64
00:04:27.701 --> 00:04:32.485
&gt;&gt; Bianca Gandolfo: So what happens if we
set a value inside of an object to null?

65
00:04:32.485 --> 00:04:34.485
This is a common mistake.

66
00:04:36.893 --> 00:04:37.701
&gt;&gt; Speaker 2: So
we don't wanna change the value-

67
00:04:37.701 --> 00:04:38.843
&gt;&gt; Speaker 3: We don't wanna change

68
00:04:38.843 --> 00:04:41.673
the value, you want to change
the pointer to that tree.

69
00:04:41.673 --> 00:04:45.224
&gt;&gt; Bianca Gandolfo: Yep, yep,
because even if the value is null.

70
00:04:45.224 --> 00:04:46.073
&gt;&gt; Speaker 3: We don't care.

71
00:04:46.073 --> 00:04:47.401
&gt;&gt; Bianca Gandolfo: It's still a node.

72
00:04:47.401 --> 00:04:48.537
The node will still exist.

73
00:04:48.537 --> 00:04:52.425
It's just instead of three,
it's now null which is gonna screw us up.

74
00:04:52.425 --> 00:04:54.362
&gt;&gt; Speaker 3: We need a pop back up.

75
00:04:55.511 --> 00:04:59.581
&gt;&gt; Bianca Gandolfo: Mm-hm, so
you could try popping back up but

76
00:04:59.581 --> 00:05:03.218
we did think of an easier way last time.

77
00:05:03.218 --> 00:05:04.814
&gt;&gt; Speaker 3: You passed the parent.

78
00:05:04.814 --> 00:05:05.384
&gt;&gt; Bianca Gandolfo: Mm-hm.

79
00:05:05.384 --> 00:05:07.438
&gt;&gt; Speaker 3: Yeah.

80
00:05:07.438 --> 00:05:10.970
&gt;&gt; Bianca Gandolfo: So we deleteMin and
we can pass the parent.

81
00:05:13.935 --> 00:05:14.720
&gt;&gt; Bianca Gandolfo: And
then what do we do?

82
00:05:14.720 --> 00:05:19.116
So now we have reference to the parent, so

83
00:05:19.116 --> 00:05:22.890
then you set their left to nothing.

84
00:05:22.890 --> 00:05:28.190
&gt;&gt; Speaker 3: Parent.left
&gt;&gt; Bianca Gandolfo: = null.

85
00:05:28.190 --> 00:05:32.346
Yeah, so this is removing that pointer,

86
00:05:32.346 --> 00:05:39.484
which makes the node available for
garbage collection, deleting it.

87
00:05:39.484 --> 00:05:41.100
Cool, great.

88
00:05:43.884 --> 00:05:49.470
&gt;&gt; Bianca Gandolfo: So,
&gt;&gt; Bianca Gandolfo: This is zero children,

89
00:05:49.470 --> 00:05:54.426
and then the other case that
we have Is one child, right?

90
00:05:54.426 --> 00:05:57.522
We'll never have two childs
just because that's for

91
00:05:57.522 --> 00:05:59.738
a minimum it wouldn't work, right?

92
00:05:59.738 --> 00:06:03.465
Cuz for
it to be a minimum it can't have a left.

93
00:06:03.465 --> 00:06:04.477
&gt;&gt; Speaker 3: Right.

94
00:06:07.301 --> 00:06:09.939
&gt;&gt; Bianca Gandolfo: Cool,
so for the case that it's

95
00:06:09.939 --> 00:06:15.216
5,
&gt;&gt; Bianca Gandolfo: What do we do?

96
00:06:18.094 --> 00:06:20.914
&gt;&gt; Speaker 3: You get the value, so

97
00:06:20.914 --> 00:06:26.096
you have to check if it has a right node.

98
00:06:26.096 --> 00:06:27.888
&gt;&gt; Bianca Gandolfo: Make it bigger?

99
00:06:27.888 --> 00:06:31.233
&gt;&gt; Speaker 3: If it doesn't have
a left node, and as a right node.

100
00:06:32.721 --> 00:06:35.981
&gt;&gt; Bianca Gandolfo: Okay, so if it has.

101
00:06:37.675 --> 00:06:42.435
&gt;&gt; Bianca Gandolfo: Not this.left,
and or or?

102
00:06:42.435 --> 00:06:43.644
&gt;&gt; Speaker 3: And.

103
00:06:43.644 --> 00:06:46.099
&gt;&gt; Bianca Gandolfo: Why is it and?

104
00:06:46.099 --> 00:06:48.660
&gt;&gt; Speaker 3: Because, if it has
a left node, it's not the minimum.

105
00:06:52.869 --> 00:06:54.462
&gt;&gt; Bianca Gandolfo: Cool.

106
00:06:54.462 --> 00:07:01.314
&gt;&gt; Speaker 3: Then you would set,
&gt;&gt; Speaker 3: The value

107
00:07:01.314 --> 00:07:05.356
of this one to its right node's value.

108
00:07:05.356 --> 00:07:09.881
So you would say this.value
= this.right.value I think.

109
00:07:09.881 --> 00:07:13.858
&gt;&gt; Bianca Gandolfo: So this.value?

110
00:07:13.858 --> 00:07:14.521
&gt;&gt; Speaker 3: Yeah.

111
00:07:14.521 --> 00:07:16.753
&gt;&gt; Bianca Gandolfo: So
you're gonna change the value.

112
00:07:16.753 --> 00:07:19.902
&gt;&gt; Speaker 2: It was the same thing I did,
the parent.left, right?

113
00:07:19.902 --> 00:07:22.911
&gt;&gt; Speaker 3: Or do you wanna
actually just change the node?

114
00:07:22.911 --> 00:07:27.389
You wanna change the node, okay.

115
00:07:27.389 --> 00:07:29.353
&gt;&gt; Bianca Gandolfo: So we're using
just simple integers in this case,

116
00:07:29.353 --> 00:07:31.920
but you could imagine our data
structure could be really complex.

117
00:07:31.920 --> 00:07:34.249
&gt;&gt; Speaker 3: Right, so
then, you would do parent.

118
00:07:38.104 --> 00:07:39.040
&gt;&gt; Speaker 3: Is it left?

119
00:07:39.040 --> 00:07:42.933
parent.left = this.right.

120
00:07:48.063 --> 00:07:49.392
&gt;&gt; Bianca Gandolfo: What say you?

121
00:07:51.952 --> 00:07:56.083
&gt;&gt; Bianca Gandolfo: Beautiful
people in this class

122
00:07:56.083 --> 00:07:57.192
&gt;&gt; Speaker 2: For the last if,

123
00:07:57.192 --> 00:08:01.091
why can't we just say L's
parent.left = this.right?

124
00:08:04.451 --> 00:08:07.179
&gt;&gt; Speaker 2: I think I lost the clock.

125
00:08:07.179 --> 00:08:08.420
&gt;&gt; Bianca Gandolfo: So you're saying?

126
00:08:12.560 --> 00:08:16.622
&gt;&gt; Speaker 2: Then wouldn't that execute
on all of them as it walks back up

127
00:08:16.622 --> 00:08:18.177
if it was just an else?

128
00:08:18.177 --> 00:08:22.443
&gt;&gt; Bianca Gandolfo: So you're saying
doing it after the recursion?

129
00:08:26.128 --> 00:08:28.301
&gt;&gt; Speaker 2: Yeah, and changing it to
an else, because I think what he said.

130
00:08:28.301 --> 00:08:30.909
But wouldn't that execute-
&gt;&gt; Speaker 3: Yeah,

131
00:08:30.909 --> 00:08:32.533
you wouldn't want it down there.

132
00:08:36.897 --> 00:08:38.978
&gt;&gt; Bianca Gandolfo: Shall we run it?

133
00:08:38.978 --> 00:08:40.227
&gt;&gt; Speaker 3: Yeah.

134
00:08:40.227 --> 00:08:40.986
&gt;&gt; Bianca Gandolfo: Let's vote.

135
00:08:40.986 --> 00:08:44.501
Who thinks we should do a second if?

136
00:08:44.501 --> 00:08:47.269
Who thinks it's better to have an else?

137
00:08:47.269 --> 00:08:49.138
&gt;&gt; Speaker 2: It didn't have an else if,
I just said else.

138
00:08:49.138 --> 00:08:50.625
&gt;&gt; Bianca Gandolfo: An else.
&gt;&gt; Speaker 2: Maybe I'm confused.

139
00:08:50.625 --> 00:08:51.442
&gt;&gt; Speaker 3: Yeah, he said else.

140
00:08:51.442 --> 00:08:52.346
&gt;&gt; Speaker 2: I just said else.

141
00:08:52.346 --> 00:08:53.273
&gt;&gt; Bianca Gandolfo: Okay.

142
00:08:53.273 --> 00:08:56.841
&gt;&gt; Speaker 3: I don't know what's
going to happen with else.

143
00:08:56.841 --> 00:09:00.326
I'd just be afraid because
if you do another if,

144
00:09:00.326 --> 00:09:04.333
then you're very clear about
what you're expecting.

145
00:09:04.333 --> 00:09:07.966
In this specific case, do this, right?

146
00:09:07.966 --> 00:09:09.571
If there is no left-
&gt;&gt; Bianca Gandolfo: There is two if

147
00:09:09.571 --> 00:09:11.590
statements too that we
should be mindful of.

148
00:09:11.590 --> 00:09:12.199
&gt;&gt; Speaker 3: Right.
&gt;&gt; Bianca Gandolfo: So

149
00:09:12.199 --> 00:09:16.691
we have if there's a left, and
this one says if there is no left.

150
00:09:16.691 --> 00:09:17.212
&gt;&gt; Speaker 3: Yeah.

151
00:09:17.212 --> 00:09:20.916
&gt;&gt; Speaker 2: So
is that also on the second if?

152
00:09:20.916 --> 00:09:27.472
Well, I didn't have the first if either.

153
00:09:27.472 --> 00:09:32.167
I just had If this left then
this left delete min else

154
00:09:32.167 --> 00:09:35.125
parent left equals this right.

155
00:09:38.724 --> 00:09:43.274
&gt;&gt; Bianca Gandolfo: Okay, well, let's
continue on our main train of thought.

156
00:09:43.274 --> 00:09:45.594
&gt;&gt; Speaker 4: Tegan had a couple
of comments in chat too.

157
00:09:45.594 --> 00:09:47.709
&gt;&gt; Bianca Gandolfo: Sure.

158
00:09:47.709 --> 00:09:48.877
&gt;&gt; Speaker 4: Her ideas.

159
00:09:50.786 --> 00:09:53.795
&gt;&gt; Bianca Gandolfo: See, would it be
this.left instead of not this.left?

160
00:09:56.189 --> 00:10:01.062
&gt;&gt; Bianca Gandolfo: So for this if,
we're imagining that it's a 5 with no 3,

161
00:10:01.062 --> 00:10:06.045
because 5 with no 3,
&gt;&gt; Bianca Gandolfo: Would be

162
00:10:06.045 --> 00:10:07.102
the minimum, right?

163
00:10:07.102 --> 00:10:12.310
So there wouldn't be a left, so
we're saying if there is no left,

164
00:10:12.310 --> 00:10:16.123
but there is a right,
then that's our minimum.

165
00:10:20.218 --> 00:10:22.370
&gt;&gt; Bianca Gandolfo: So
that's why we're saying no left.

166
00:10:25.152 --> 00:10:29.635
&gt;&gt; Bianca Gandolfo: Cool,
so what do you think?

167
00:10:29.635 --> 00:10:33.945
If there's no this.left,
there is a this.right,

168
00:10:33.945 --> 00:10:38.176
we'll set the parent's
left to the current right.

