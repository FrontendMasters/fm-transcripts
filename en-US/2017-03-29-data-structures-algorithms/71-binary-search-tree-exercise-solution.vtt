WEBVTT

1
00:00:00.200 --> 00:00:02.651
&gt;&gt; Bianca Gandolfo: So
let's talk about our solution here,

2
00:00:02.651 --> 00:00:06.484
compare it also to our pseudocode,
which I have at the bottom.

3
00:00:09.035 --> 00:00:10.801
&gt;&gt; Bianca Gandolfo: Okay?

4
00:00:10.801 --> 00:00:15.913
So, here we are, first line,
we are checking if

5
00:00:15.913 --> 00:00:21.668
the current value equals
the value that's passed in.

6
00:00:21.668 --> 00:00:22.168
Okay.

7
00:00:23.590 --> 00:00:24.890
Next thing we're saying,

8
00:00:26.110 --> 00:00:30.080
if our passing value is less than
the current value, what do we wanna do?

9
00:00:32.520 --> 00:00:34.607
Without looking at the code,
what do we wanna do?

10
00:00:34.607 --> 00:00:35.474
&gt;&gt; Speaker 2: Go left.

11
00:00:35.474 --> 00:00:36.380
&gt;&gt; Bianca Gandolfo: We wanna go left.

12
00:00:39.530 --> 00:00:41.070
Cool.
And here we are going left.

13
00:00:43.280 --> 00:00:50.740
We're catching this here with a double
bang to stop it, if there is no left.

14
00:00:51.890 --> 00:00:56.830
So double bang, this is forcing
it to a boolean true/false,

15
00:00:56.830 --> 00:01:01.980
so if this dot left is null,
it's going to return false, which means

16
00:01:01.980 --> 00:01:08.730
that is not going to,
go to the second side of end operator.

17
00:01:08.730 --> 00:01:13.250
So the logic behind the end operator,
is that they both have to return true,

18
00:01:14.900 --> 00:01:18.780
in order for it to return true.

19
00:01:18.780 --> 00:01:24.240
Either one is false It's gonna
return false, right, and operator.

20
00:01:24.240 --> 00:01:28.030
Except the way that it actually
works is if the first one is false,

21
00:01:28.030 --> 00:01:30.490
it doesn't even go to run the second side.

22
00:01:30.490 --> 00:01:34.337
And so we use the and
operator in this way as sort of a gate.

23
00:01:36.003 --> 00:01:40.109
&gt;&gt; Bianca Gandolfo: Cool, and we also use
the OR operator as sort of a default.

24
00:01:40.109 --> 00:01:45.204
We did that previously where
We say if something is

25
00:01:45.204 --> 00:01:50.800
undefined you say or
the default with the or operator.

26
00:01:52.370 --> 00:01:53.600
So that's just another one of those.

27
00:01:54.860 --> 00:01:56.624
Cool.

28
00:01:56.624 --> 00:02:01.499
Returning out from our
aversion as well cool,

29
00:02:01.499 --> 00:02:08.380
then if the value is greater than
the current value, same thing.

30
00:02:09.680 --> 00:02:11.877
If it doesn't exist, we'll return false.

31
00:02:14.301 --> 00:02:19.484
&gt;&gt; Bianca Gandolfo: Or,
&gt;&gt; Bianca Gandolfo: Return

32
00:02:19.484 --> 00:02:23.280
whatever this returns, right.

33
00:02:23.280 --> 00:02:25.895
If it,
maybe it's true somewhere under there.

34
00:02:29.867 --> 00:02:30.367
&gt;&gt; Bianca Gandolfo: Cool?

35
00:02:32.810 --> 00:02:38.386
Then if we go through all that business,
&gt;&gt; Speaker 3: It's unreachable, isn't it?

36
00:02:38.386 --> 00:02:41.883
&gt;&gt; Speaker 4: Isn't unreachable
&gt;&gt; Bianca Gandolfo: [CROSSTALK] Probably,

37
00:02:41.883 --> 00:02:43.304
let's see.

38
00:02:43.304 --> 00:02:45.428
&gt;&gt; Speaker 4: That's how mine is and
it works.

39
00:02:45.428 --> 00:02:46.050
&gt;&gt; Bianca Gandolfo: It works?

40
00:02:46.050 --> 00:02:51.500
&gt;&gt; Speaker 3: I guess it could be
a double equals, but not triple equals.

41
00:02:51.500 --> 00:02:52.031
&gt;&gt; Bianca Gandolfo: Hm?

42
00:02:52.031 --> 00:02:55.473
&gt;&gt; Speaker 3: I guess it could be
double equals, but not triple equals.

43
00:02:55.473 --> 00:02:57.058
&gt;&gt; Bianca Gandolfo: For the second line?

44
00:03:00.543 --> 00:03:01.288
&gt;&gt; Bianca Gandolfo: What do you mean?

45
00:03:01.288 --> 00:03:05.116
&gt;&gt; Speaker 2: He's saying you have to
go into one of those two if conditions,

46
00:03:05.116 --> 00:03:08.960
either the equals, less than or
greater than are all covered.

47
00:03:08.960 --> 00:03:11.075
So there shouldn't be any way
to get down to the false.

48
00:03:11.075 --> 00:03:12.880
&gt;&gt; Bianca Gandolfo: Right.
But he's saying if

49
00:03:12.880 --> 00:03:18.040
line 2 could technically be false if
it was double equals, but not triple.

50
00:03:18.040 --> 00:03:18.790
&gt;&gt; Speaker 2: So is it?

51
00:03:18.790 --> 00:03:22.680
&gt;&gt; Speaker 3: Yeah that's what I thought.

52
00:03:22.680 --> 00:03:25.190
&gt;&gt; Bianca Gandolfo: Well
we would hope not.

53
00:03:26.210 --> 00:03:29.030
But maybe this will just
catch the cases in which

54
00:03:29.030 --> 00:03:32.150
we don't enter into any
of those conditions.

55
00:03:32.150 --> 00:03:35.440
Which means it's not equal, it's not
less than, and it's not greater than.

56
00:03:36.700 --> 00:03:40.520
&gt;&gt; Speaker 4: Why didn't you, when you
had the value less Then this value

57
00:03:41.600 --> 00:03:46.600
have the check to see if this
dot left existed right in there.

58
00:03:46.600 --> 00:03:52.050
Instead of having the and
return contains value.

59
00:03:53.510 --> 00:03:57.260
So, like, at the end of value
less than this value, and

60
00:03:57.260 --> 00:04:01.507
then have your And this.left.

61
00:04:01.507 --> 00:04:03.800
&gt;&gt; Bianca Gandolfo: Yeah,
you could do that.

62
00:04:03.800 --> 00:04:07.474
But this will also return false for
us if we want.

63
00:04:10.706 --> 00:04:13.920
&gt;&gt; Speaker 4: But then that way I
only have the one return the false.

64
00:04:13.920 --> 00:04:15.489
&gt;&gt; Bianca Gandolfo: Yep,
yeah, that makes sense.

65
00:04:17.310 --> 00:04:18.060
Yeah.

66
00:04:18.060 --> 00:04:21.359
So if you didn't have this return here,
and

67
00:04:21.359 --> 00:04:26.010
you just checked here,
then this would be more useful for us.

68
00:04:29.015 --> 00:04:29.581
&gt;&gt; Bianca Gandolfo: Cool.

69
00:04:29.581 --> 00:04:30.710
Questions?

70
00:04:30.710 --> 00:04:32.800
&gt;&gt; Speaker 4: Yep,
a question online from Oscar.

71
00:04:32.800 --> 00:04:39.630
Why do you use Not this.right
instead of just this.right.

72
00:04:39.630 --> 00:04:43.135
&gt;&gt; Bianca Gandolfo: So the double
bang is forced to a boolean, and

73
00:04:43.135 --> 00:04:47.299
it's just to be sure that it
gets forced to a boolean.

74
00:04:47.299 --> 00:04:48.000
&gt;&gt; Speaker 5: Will it return undefined?

75
00:04:49.280 --> 00:04:51.530
&gt;&gt; Bianca Gandolfo: Yeah,
it might return undefined.

76
00:04:51.530 --> 00:04:57.640
Which is okay, but
they're just weird with JavaScript and

77
00:04:57.640 --> 00:05:02.090
the truthy and the falsy situation is
a little bit fuzzy when we force it.

78
00:05:02.090 --> 00:05:04.130
It's just more of a double-check
more than anything.

79
00:05:05.130 --> 00:05:07.410
It'll probably work just fine without it.

80
00:05:07.410 --> 00:05:12.120
But there's a chance that something
weird could happen, so double bang.

81
00:05:14.100 --> 00:05:15.350
So this would make it opposite, so

82
00:05:15.350 --> 00:05:19.910
if this was true this would make it false,
the double bang.

83
00:05:21.920 --> 00:05:24.944
If it's true it makes it true, yeah.

84
00:05:27.400 --> 00:05:29.622
&gt;&gt; Bianca Gandolfo: Yeah.

85
00:05:29.622 --> 00:05:33.414
&gt;&gt; Speaker 2: This is again,
just a general JavaScript question, but

86
00:05:33.414 --> 00:05:38.312
if you just did return this.left,
it would actually return the object or

87
00:05:38.312 --> 00:05:39.770
whatever, right?

88
00:05:39.770 --> 00:05:42.400
Is it the and that makes it?

89
00:05:43.850 --> 00:05:45.105
&gt;&gt; Speaker 3: Yeah.
&gt;&gt; Speaker 2: If you just did return

90
00:05:45.105 --> 00:05:47.800
this.left, and you didn't have the and
this.left contains value,

91
00:05:47.800 --> 00:05:49.320
it would just return the object, right?

92
00:05:50.960 --> 00:05:52.760
&gt;&gt; Bianca Gandolfo: So
you're saying if we didn't have this.

93
00:05:52.760 --> 00:05:55.003
&gt;&gt; Speaker 2: Yeah, or the double bang.

94
00:05:55.003 --> 00:05:56.145
Yeah that would-
&gt;&gt; Bianca Gandolfo: Yeah we return

95
00:05:56.145 --> 00:05:56.650
the object.

96
00:05:56.650 --> 00:05:59.020
&gt;&gt; Speaker 2: Yeah you don't want it to
return null, you want it to return false,

97
00:05:59.020 --> 00:06:00.290
I think that's the point.

98
00:06:00.290 --> 00:06:01.370
&gt;&gt; Bianca Gandolfo: Yeah.

99
00:06:01.370 --> 00:06:05.090
&gt;&gt; Speaker 2: Yeah so for
most cases it will even if it is null,

100
00:06:05.090 --> 00:06:08.610
null evaluates to false usually.

101
00:06:14.060 --> 00:06:16.061
&gt;&gt; Bianca Gandolfo: The valuation
falls but it's not, yeah.

102
00:06:16.061 --> 00:06:17.638
Okay.

103
00:06:17.638 --> 00:06:20.300
&gt;&gt; Speaker 2: Yeah.
Those are just little details not the most

104
00:06:20.300 --> 00:06:21.500
important thing.

105
00:06:23.670 --> 00:06:24.470
So what do we think?

106
00:06:26.350 --> 00:06:27.099
Does it makes sense?

107
00:06:28.660 --> 00:06:30.403
Cool, anyone do it differently?

108
00:06:32.990 --> 00:06:36.210
&gt;&gt; Speaker 2: More or less the same, cool.

109
00:06:36.210 --> 00:06:39.030
&gt;&gt; Bianca Gandolfo: I omitted the first
line, this.value = false, and

110
00:06:39.030 --> 00:06:40.820
I returned true at the end.

111
00:06:40.820 --> 00:06:43.080
&gt;&gt; Speaker 2: Yeah, so
you just flipped it, cool.

112
00:06:43.080 --> 00:06:44.094
&gt;&gt; Bianca Gandolfo: They're
about the same.

113
00:06:44.094 --> 00:06:51.101
&gt;&gt; Speaker 2: Yeah,
&gt;&gt; Speaker 2: Any a-ha moments yet?

114
00:06:52.120 --> 00:06:57.719
Still digesting both the food and
also contains.

115
00:06:57.719 --> 00:07:02.082
That stomach contains Thai food.

116
00:07:02.082 --> 00:07:03.281
Yum.

117
00:07:03.281 --> 00:07:06.720
Alright, so
let's check out what we have to do.

118
00:07:06.720 --> 00:07:07.310
Here, insert.

119
00:07:07.310 --> 00:07:10.556
We haven't looked at this yet, right?

120
00:07:10.556 --> 00:07:11.751
Let's check it out.

121
00:07:11.751 --> 00:07:13.629
I'm going to put it in here so
we have the pretty colors.

122
00:07:15.580 --> 00:07:18.050
&gt;&gt; Bianca Gandolfo: One question
before we move on, from Oscar.

123
00:07:18.050 --> 00:07:21.075
Is the time complexity O log n?

124
00:07:25.065 --> 00:07:28.280
&gt;&gt; Speaker 2: In the average/best case,
yes.

125
00:07:28.280 --> 00:07:29.145
Worst case, no.

126
00:07:32.941 --> 00:07:35.623
&gt;&gt; Speaker 2: Good question, though.

127
00:07:35.623 --> 00:07:40.478
Cool, so insert we went through
the pseudocode a moment ago, but

128
00:07:40.478 --> 00:07:43.050
let's just look at the real code.

129
00:07:44.250 --> 00:07:47.335
So if the value is less than or

130
00:07:47.335 --> 00:07:52.606
equal to the current value,
and there is a left,

131
00:07:52.606 --> 00:07:57.378
then you want to insert
on the current left.

132
00:07:57.378 --> 00:07:58.190
Yeah?

133
00:08:00.790 --> 00:08:01.840
The regressive call.

134
00:08:01.840 --> 00:08:04.280
Otherwise, you're gonna set it, right.

135
00:08:04.280 --> 00:08:10.150
If there's nothing there you're going to
put a new node in the current nodes left.

136
00:08:12.190 --> 00:08:18.580
The other condition is if it's greater and
there is a right.

137
00:08:18.580 --> 00:08:22.310
Then, you're gonna recurse
to the current node's right.

138
00:08:24.377 --> 00:08:28.216
&gt;&gt; Speaker 2: Otherwise, if there's no
right, then that's where we want to be.

139
00:08:30.222 --> 00:08:35.200
&gt;&gt; Speaker 2: And then, we call it a day,
and we want to just return out at the end.

140
00:08:35.200 --> 00:08:37.425
&gt;&gt; Bianca Gandolfo: So
that's returning the pair end, right?

141
00:08:37.425 --> 00:08:38.690
&gt;&gt; Speaker 2: Mm-hm.

142
00:08:38.690 --> 00:08:40.830
&gt;&gt; Bianca Gandolfo: Okay.
I understood it differently.

143
00:08:40.830 --> 00:08:44.520
&gt;&gt; Speaker 2: Well, it depends on where
you are in the recursive call, right?

144
00:08:44.520 --> 00:08:49.280
But at the end,
it's going to return the entire tree.

145
00:08:49.280 --> 00:08:51.020
It's gonna return a reference to it.

146
00:08:51.020 --> 00:08:53.173
Because that's what this
is at the very beginning.

147
00:08:57.519 --> 00:09:02.205
&gt;&gt; Speaker 2: But as you do these
recursive calls You're changing the value

148
00:09:02.205 --> 00:09:02.932
of this.

149
00:09:06.429 --> 00:09:10.341
&gt;&gt; Speaker 2: So depending on when you
land here, this could be different.

150
00:09:13.816 --> 00:09:16.215
&gt;&gt; Bianca Gandolfo: But
you aren't returning the recursive calls,

151
00:09:16.215 --> 00:09:17.860
you're only returning the top.

152
00:09:19.300 --> 00:09:24.465
&gt;&gt; Speaker 2: No but just imagine
a world where you did a recursive call,

153
00:09:24.465 --> 00:09:29.115
you didn't get into any of this,
this got skipped.

154
00:09:31.009 --> 00:09:33.489
&gt;&gt; Speaker 2: That's where
the return would pop up.

155
00:09:40.375 --> 00:09:44.069
&gt;&gt; Bianca Gandolfo: So will the
BinarySearchTree being returned always be

156
00:09:44.069 --> 00:09:48.655
the one that you called insert on,
or will it be one of the subtrees?

157
00:09:50.660 --> 00:09:55.146
&gt;&gt; Speaker 2: Yeah, the very last one
is definitely gonna be the top one to

158
00:09:55.146 --> 00:09:59.183
the route, whatever it started with
&gt;&gt; Bianca Gandolfo: So

159
00:09:59.183 --> 00:10:01.338
that's what you would
get as a return value?

160
00:10:03.929 --> 00:10:07.525
&gt;&gt; Speaker 2: So with this implementation,

161
00:10:07.525 --> 00:10:11.690
you could chain multiple inserts.

162
00:10:11.690 --> 00:10:17.922
So you could say my BST dot
insert three dot insert

163
00:10:17.922 --> 00:10:22.947
five dot insert 132, or whatever.

164
00:10:22.947 --> 00:10:24.482
&gt;&gt; Bianca Gandolfo: I was
returning the SubTree and

165
00:10:24.482 --> 00:10:26.770
I didn't get the use case for it.

166
00:10:26.770 --> 00:10:27.270
&gt;&gt; Speaker 2: Yeah.

167
00:10:29.690 --> 00:10:35.360
Yeah, for the most part, you're only going
to be interested in this at the end.

168
00:10:35.360 --> 00:10:35.860
Yeah.

169
00:10:38.100 --> 00:10:39.060
But it's going to return.

170
00:10:42.165 --> 00:10:45.015
&gt;&gt; Speaker 2: Every time you call
the function, it's going to return but

171
00:10:45.015 --> 00:10:48.300
it's going to get kind of
caught up in your recursion.

172
00:10:48.300 --> 00:10:50.330
It's going to get stuck in
there until the very last call

