WEBVTT

1
00:00:00.240 --> 00:00:01.590
&gt;&gt; Bianca: But
then that leads us to question, and

2
00:00:01.590 --> 00:00:06.030
this is something we haven't answered yet
in our examples, where do we do the work?

3
00:00:06.030 --> 00:00:08.420
And where do we even
approach that base case?

4
00:00:09.800 --> 00:00:14.981
So let's check out an example here.

5
00:00:14.981 --> 00:00:16.060
You guys ready for this?

6
00:00:16.060 --> 00:00:17.140
I'm just jumping to the example.

7
00:00:17.140 --> 00:00:19.640
I'm not even making you come
up with your own first.

8
00:00:19.640 --> 00:00:20.443
I'm just gonna tell you.

9
00:00:20.443 --> 00:00:25.365
Awesome, so let's say computeFactorial,

10
00:00:25.365 --> 00:00:29.515
and we're gonna pass it to 5, yeah?

11
00:00:32.993 --> 00:00:35.450
&gt;&gt; Bianca: And
this is a countdown inversion here.

12
00:00:37.050 --> 00:00:42.360
So we have our base case, if num equals 1,
could also be 2, that also works.

13
00:00:42.360 --> 00:00:45.410
Else, you're going to return this.

14
00:00:45.410 --> 00:00:48.580
So our base case is when it's 1.

15
00:00:48.580 --> 00:00:56.030
Otherwise, it's gonna be num times
whatever everything else computed to.

16
00:00:57.860 --> 00:00:59.950
Yeah, at this point,
it might still sound like magic.

17
00:00:59.950 --> 00:01:03.220
And so I'm gonna do our little
stack exercise with this, so

18
00:01:03.220 --> 00:01:04.470
we can track the numbers in our head.

19
00:01:06.360 --> 00:01:07.650
Ready?

20
00:01:07.650 --> 00:01:12.087
Any questions?
All right, here we go.

21
00:01:13.665 --> 00:01:18.795
&gt;&gt; Bianca: All right, so actually,
I'm just gonna do 3 cuz it's

22
00:01:18.795 --> 00:01:23.687
gonna be easier,
&gt;&gt; Bianca: Let's do 4 for

23
00:01:23.687 --> 00:01:24.830
good measure, okay.

24
00:01:26.230 --> 00:01:28.840
So we're gonna call our function,

25
00:01:28.840 --> 00:01:33.212
computeFactorial,
&gt;&gt; Bianca: And

26
00:01:33.212 --> 00:01:39.118
we're gonna put it on our stack,
here look, STACK.

27
00:01:39.118 --> 00:01:40.792
Look at that, perfect.

28
00:01:42.620 --> 00:01:45.280
Great, so we passed in 4.

29
00:01:45.280 --> 00:01:47.530
Can someone tell me what num
equals right now at this point?

30
00:01:48.850 --> 00:01:50.210
&gt;&gt; Speaker 2: 4.

31
00:01:50.210 --> 00:01:51.621
&gt;&gt; Bianca: It equals 4, exactly.

32
00:01:51.621 --> 00:01:55.314
So then also in those brackets
I'm just gonna put the number,

33
00:01:55.314 --> 00:01:59.590
since they all have the same name,
I'm mapping it to a certain number.

34
00:01:59.590 --> 00:02:02.500
So this call created this function.

35
00:02:03.660 --> 00:02:09.840
Okay, and in our num equals 4.

36
00:02:09.840 --> 00:02:12.884
So we jump in, does the num equal 1?

37
00:02:12.884 --> 00:02:17.380
No, so we skip over.

38
00:02:17.380 --> 00:02:22.670
Otherwise, we're gonna run this expression
and then we are gonna return it.

39
00:02:22.670 --> 00:02:26.944
So the first thing that happens in this
expression is we are gonna compute this

40
00:02:26.944 --> 00:02:28.050
function.

41
00:02:28.050 --> 00:02:30.870
So nothing happens until
we jump inside here.

42
00:02:32.480 --> 00:02:35.220
Actually, the very first thing that
happens is this is gonna be calculated.

43
00:02:35.220 --> 00:02:35.789
So what's num minus 1?

44
00:02:35.789 --> 00:02:36.370
&gt;&gt; Speaker 2: 3.

45
00:02:38.030 --> 00:02:39.969
&gt;&gt; Bianca: So, that'll be 3.

46
00:02:39.969 --> 00:02:41.980
And we're gonna call our function, and

47
00:02:41.980 --> 00:02:45.880
that is gonna be the second
time that we call our function.

48
00:02:45.880 --> 00:02:47.856
Here we are, so num === 3.

49
00:02:49.627 --> 00:02:54.576
&gt;&gt; Bianca: Great, and
then we are going to keep track here.

50
00:02:58.008 --> 00:03:00.223
&gt;&gt; Bianca: All right, still doesn't work,
not very interesting.

51
00:03:03.216 --> 00:03:04.485
&gt;&gt; Bianca: So this is 2.

52
00:03:04.485 --> 00:03:10.379
I'm just gonna skip a couple steps, is
that okay with you guys, following here?

53
00:03:10.379 --> 00:03:12.760
Cuz it doesn't get interesting
until we get to the bottom.

54
00:03:12.760 --> 00:03:14.116
So num at this point is what?

55
00:03:14.116 --> 00:03:18.850
2, and then we have our 4.

56
00:03:22.848 --> 00:03:27.057
&gt;&gt; Bianca: [SOUND] 1, 4, 1,

57
00:03:27.057 --> 00:03:32.515
[SOUND], we've found it.

58
00:03:32.515 --> 00:03:35.888
We've found the one, yay.

59
00:03:35.888 --> 00:03:39.870
So this is true, and this is where the
magic happens at this return statement.

60
00:03:39.870 --> 00:03:41.060
So we have hit our base case.

61
00:03:41.060 --> 00:03:43.250
This is when we want
our recursion to stop.

62
00:03:43.250 --> 00:03:44.520
You see how it's working?

63
00:03:44.520 --> 00:03:48.797
We go down, [NOISE],
we find it, and here we are.

64
00:03:48.797 --> 00:03:50.330
Return 1, okay?

65
00:03:51.430 --> 00:03:54.900
So when we return,
we return up to the next stack.

66
00:03:54.900 --> 00:03:57.331
So this is 4, so
we need to find our matching one.

67
00:03:57.331 --> 00:04:00.616
And it's gonna return 1 here

68
00:04:04.753 --> 00:04:08.420
&gt;&gt; Bianca: Do you see how I did that?

69
00:04:09.530 --> 00:04:15.005
Okay, so
now we're gonna return num times 1.

70
00:04:15.005 --> 00:04:17.037
What's num in this case?

71
00:04:17.037 --> 00:04:17.730
&gt;&gt; Speaker 2: 2.

72
00:04:17.730 --> 00:04:19.860
&gt;&gt; Bianca: 2, great.

73
00:04:19.860 --> 00:04:21.109
So this is the third one.

74
00:04:22.380 --> 00:04:24.700
Oops, sorry, I forgot to pop you off.

75
00:04:26.490 --> 00:04:30.271
This is gonna be 2, I almost said 3,
that would've been wrong.

76
00:04:30.271 --> 00:04:34.500
If I'm ever wrong, just say,
Bianca, you're wrong.

77
00:04:36.450 --> 00:04:39.850
So we pop this off cuz we're returning,
whenever we return, we pop.

78
00:04:39.850 --> 00:04:43.710
Popping this off, num in this case is 3.

79
00:04:43.710 --> 00:04:45.848
We're gonna pop that.

80
00:04:49.337 --> 00:04:52.922
&gt;&gt; Bianca: And that is 6.

81
00:04:52.922 --> 00:04:57.963
Okay, num in this case is 4.

82
00:04:57.963 --> 00:05:01.480
This is 24, yes.

83
00:05:02.480 --> 00:05:09.970
So this is 2, I'm sorry, this is the first
one, here, so this is going to return 24.

84
00:05:09.970 --> 00:05:15.014
This has been popped,
&gt;&gt; Bianca: Cool?

85
00:05:23.500 --> 00:05:26.327
&gt;&gt; Bianca: Really fast, over again.

86
00:05:26.327 --> 00:05:30.859
[SOUND] That's too much.

87
00:05:30.859 --> 00:05:36.856
So,
&gt;&gt; Bianca: I'm being really precise and

88
00:05:36.856 --> 00:05:41.903
specific, and maybe driving this in too
much for some people, but the reason is,

89
00:05:41.903 --> 00:05:47.120
I think I've said this already four times,
this is really important for tomorrow.

90
00:05:49.300 --> 00:05:54.181
Cool, any questions about
what is going on here?

91
00:06:00.186 --> 00:06:04.004
&gt;&gt; Speaker 2: This might be off topic,
but I have a question about style I would

92
00:06:04.004 --> 00:06:08.050
tend to leave off the else because
we already have a return in the if.

93
00:06:08.050 --> 00:06:11.435
Is that confusing or it doesn't matter?

94
00:06:11.435 --> 00:06:13.972
&gt;&gt; Bianca: Yeah,
it doesn't matter, not to me.

95
00:06:22.158 --> 00:06:24.415
&gt;&gt; Bianca: Cool, yeah,
sometimes for my examples,

96
00:06:24.415 --> 00:06:28.739
I make them more verbose to just show a
point, I think for this one, I don't know,

97
00:06:28.739 --> 00:06:30.280
I'm not-
&gt;&gt; Speaker 2: Yeah, it makes sense.

98
00:06:30.280 --> 00:06:33.164
&gt;&gt; Bianca: Doesn't really matter.

99
00:06:33.164 --> 00:06:36.190
&gt;&gt; Speaker 3: Some people who aren't super
familiar with JavaScript might not realize

100
00:06:36.190 --> 00:06:39.040
that if you do it,
like some languages aren't like that.

101
00:06:39.040 --> 00:06:41.740
You know how like you can do return and
if it doesn't hit this,

102
00:06:41.740 --> 00:06:42.820
then you can also return?

103
00:06:44.570 --> 00:06:46.050
It's a stylistic choice.

104
00:06:46.050 --> 00:06:48.840
&gt;&gt; Bianca: Yeah, okay, yeah.

105
00:06:50.090 --> 00:06:51.435
&gt;&gt; Speaker 2: A question from the channel.

106
00:06:51.435 --> 00:06:53.316
&gt;&gt; [SOUND]
&gt;&gt; Speaker 2: What does the 3 in curly

107
00:06:53.316 --> 00:06:54.460
brackets represent?

108
00:06:55.868 --> 00:06:57.337
&gt;&gt; Bianca: The 3?

109
00:06:57.337 --> 00:07:01.024
The 3 represents the,
it's like a name for the function,

110
00:07:01.024 --> 00:07:03.550
I gave each function a number.

111
00:07:03.550 --> 00:07:05.980
So this first function is number one.

112
00:07:05.980 --> 00:07:09.980
And here we are in our stack,
this is not actually happening,

113
00:07:09.980 --> 00:07:12.300
this is happening all under the hood.

114
00:07:12.300 --> 00:07:15.670
We're first calling this function one,
and so it's just mapping so

115
00:07:15.670 --> 00:07:18.540
that we can keep track of
which function is which.

116
00:07:18.540 --> 00:07:19.280
So for example,

117
00:07:19.280 --> 00:07:23.680
when this function returns,
we know that it returns from this call.

118
00:07:25.650 --> 00:07:26.590
So it's just keeping track.

119
00:07:28.400 --> 00:07:29.430
Yeah, mm-hm?

120
00:07:29.430 --> 00:07:32.231
&gt;&gt; Speaker 2: I do wanna offer
a clarification that you're right.

121
00:07:32.231 --> 00:07:38.903
Simplistically, it's the position
in the stack trace for that call.

122
00:07:38.903 --> 00:07:42.159
&gt;&gt; Bianca: Yeah, absolutely,
that's a good way to put it for sure.

123
00:07:42.159 --> 00:07:46.799
Cool, all right,

124
00:07:46.799 --> 00:07:53.180
were we are, factorial.

125
00:07:55.601 --> 00:07:56.990
&gt;&gt; Bianca: How we feeling about factorial?

126
00:07:58.580 --> 00:07:59.280
Feeling good about it?

127
00:08:00.320 --> 00:08:04.310
Great, it's one of those things,
I'm gonna talk about it,

128
00:08:04.310 --> 00:08:09.090
then when you get to it, then you're like,
crap, what's my base case and

129
00:08:09.090 --> 00:08:11.990
what's the work that I'm trying to do?

130
00:08:11.990 --> 00:08:13.890
That's gonna be the challenge and

131
00:08:13.890 --> 00:08:15.710
that's the challenge to work through and
that's okay.

132
00:08:17.690 --> 00:08:22.070
All right, so I have some more examples
here, but I feel like we're good.

133
00:08:22.070 --> 00:08:26.180
So I just wanna have
a vote from the audience.

134
00:08:27.630 --> 00:08:30.850
First one is, we will keep talking about

135
00:08:32.180 --> 00:08:35.530
these different examples of
recursion that are simple.

136
00:08:37.510 --> 00:08:41.150
Or the second one is we can
just hop into the exercises.

137
00:08:43.250 --> 00:08:45.120
In like a few minutes,
I have a couple of more slides.

138
00:08:46.700 --> 00:08:51.688
So hands up if you want me to keep talking
about these examples because you could use

139
00:08:51.688 --> 00:08:53.506
the further clarification.

140
00:08:56.705 --> 00:08:59.230
&gt;&gt; Bianca: And then keep your hands
down if you wanna do your exercises.

141
00:09:00.940 --> 00:09:05.850
Okay, I think we have a unanimous vote,
awesome, great.

142
00:09:05.850 --> 00:09:08.737
So they're here for
your reference if you want different ones.

143
00:09:12.687 --> 00:09:17.750
&gt;&gt; Bianca: Let's see, so
recursion versus loops.

144
00:09:17.750 --> 00:09:22.868
Loops, as it stands, are more
performant than recursion because of

145
00:09:22.868 --> 00:09:29.325
something called tail-call optimization,
which appears for us magically in ES6.

146
00:09:29.325 --> 00:09:32.650
If you wanna learn about that,
here are some links.

147
00:09:32.650 --> 00:09:37.396
There are lots of different,
there's certain ways that you

148
00:09:37.396 --> 00:09:42.440
need to go about that to utilize
ES6 tail-call optimization.

149
00:09:42.440 --> 00:09:45.340
But we're not gonna talk about
that today cuz it's kind of

150
00:09:47.430 --> 00:09:50.230
beyond our scope here, cool.

151
00:09:51.680 --> 00:09:55.762
Common patterns for recursion, so we have
wrapper functions and passing memos or

152
00:09:55.762 --> 00:09:56.598
accumulators.

153
00:09:56.598 --> 00:09:59.350
[SOUND], failed to save.

154
00:09:59.350 --> 00:09:59.850
That's okay.

155
00:10:01.940 --> 00:10:06.700
So wrapper function is when you just have
a function inside of another function.

156
00:10:09.010 --> 00:10:12.620
So we can call recurse here,
pass the start time.

157
00:10:12.620 --> 00:10:14.260
And again, these are all just loops.

158
00:10:16.110 --> 00:10:16.940
And so that's one way.

159
00:10:18.610 --> 00:10:19.659
You could save stuff in here.

160
00:10:26.875 --> 00:10:28.362
&gt;&gt; Bianca: Bye.

161
00:10:28.362 --> 00:10:34.620
You can save stuff in here, you can
do work onto a variable saved here.

162
00:10:34.620 --> 00:10:38.586
That's a better way of doing it than how
we were doing before with the tracker,

163
00:10:38.586 --> 00:10:40.825
remember we were using the tracker before?

164
00:10:40.825 --> 00:10:42.710
So this is one example.

165
00:10:42.710 --> 00:10:46.490
I call this a wrapper function,
I don't think that's a technical term for

166
00:10:46.490 --> 00:10:47.096
it though.

167
00:10:47.096 --> 00:10:49.947
And then memo or
accumilator, you can pass,

168
00:10:49.947 --> 00:10:53.780
just as we were doing in the factorial,
we can pass it along.

169
00:10:56.157 --> 00:11:00.497
&gt;&gt; Bianca: So every time we recurse, we
can pass along whatever value that we want

170
00:11:00.497 --> 00:11:05.730
that's getting closer to our base case,
or whatever result we're looking for.

171
00:11:05.730 --> 00:11:07.270
You can just pass it through.

172
00:11:07.270 --> 00:11:10.360
Just be mindful of the order in which it's

173
00:11:10.360 --> 00:11:13.420
being evaluated cuz that might
change how you're gonna do things.

