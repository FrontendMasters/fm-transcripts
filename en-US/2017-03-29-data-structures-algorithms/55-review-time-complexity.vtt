WEBVTT

1
00:00:00.050 --> 00:00:01.860
&gt;&gt; Bianca Gandolfo: All right,
we're going to get started.

2
00:00:01.860 --> 00:00:05.170
We're going to have
the world's quickest recap.

3
00:00:05.170 --> 00:00:07.080
All right?

4
00:00:07.080 --> 00:00:10.980
So we're going to rehash everything
we've done for the past couple days.

5
00:00:10.980 --> 00:00:12.380
But I have a big ask.

6
00:00:12.380 --> 00:00:13.980
A bold request of the audience.

7
00:00:13.980 --> 00:00:14.790
Are you guys ready?

8
00:00:15.960 --> 00:00:20.510
My request is, as we're going through,
I'm going to ask you on your reflections.

9
00:00:20.510 --> 00:00:23.070
On learning this material
over the past couple of days,

10
00:00:23.070 --> 00:00:26.490
what were things that
were confusing at first?

11
00:00:26.490 --> 00:00:33.030
What advice would you give to your
previous self when learning this material?

12
00:00:33.030 --> 00:00:34.270
Cool?

13
00:00:34.270 --> 00:00:36.040
Be mindful as we go
through the curriculum.

14
00:00:36.040 --> 00:00:39.714
Think of maybe an aha
moment that happened.

15
00:00:39.714 --> 00:00:44.420
Think of something that was
confusing at first, and

16
00:00:44.420 --> 00:00:47.685
then it became more clear after
something happened, etcetera.

17
00:00:49.120 --> 00:00:51.960
Does that make sense?

18
00:00:51.960 --> 00:00:53.730
Everyone understand the bolder quest?

19
00:00:54.830 --> 00:00:59.910
You have moments in your
mind that come to mind, no?

20
00:01:01.100 --> 00:01:01.780
We'll see.

21
00:01:01.780 --> 00:01:03.990
Okay, all right, keep it there.

22
00:01:05.290 --> 00:01:08.010
All right, so world's fastest recap.

23
00:01:08.010 --> 00:01:08.596
Are you ready?

24
00:01:08.596 --> 00:01:10.382
Ready?

25
00:01:10.382 --> 00:01:13.250
Get set, go.

26
00:01:13.250 --> 00:01:16.500
All right, so
does everyone remember time complexity?

27
00:01:16.500 --> 00:01:21.479
Time complexity is how we measure
the speed of our algorithm, right.

28
00:01:22.500 --> 00:01:26.560
So some common operations for
measuring time complexity.

29
00:01:26.560 --> 00:01:27.670
If we're running a statement.

30
00:01:28.930 --> 00:01:31.903
&gt;&gt; Bianca Gandolfo: Like
a return statement, for example,

31
00:01:31.903 --> 00:01:34.180
it's gonna be constant time.

32
00:01:35.180 --> 00:01:37.130
Lookups on arrays and

33
00:01:37.130 --> 00:01:42.560
objects are going to be constant
time if you access them directly.

34
00:01:42.560 --> 00:01:46.050
A loop that cuts a problem
in half every iteration.

35
00:01:46.050 --> 00:01:47.450
This is gonna be logarithmic,

36
00:01:48.490 --> 00:01:52.850
looping through all of the values of
an array, that's gonna be linear.

37
00:01:55.590 --> 00:02:01.000
And then we have linearithmic,
which is n(log)n when.

38
00:02:01.000 --> 00:02:04.430
We split it in half but
also we loop through the entire array.

39
00:02:06.910 --> 00:02:09.120
Or entire collection, it doesn't
necessarily have to be an array.

40
00:02:10.200 --> 00:02:15.020
So then we have O of n squared
quadratic time, double nested loops.

41
00:02:17.180 --> 00:02:21.277
Exponential time would
be triply nested loops.

42
00:02:21.277 --> 00:02:22.039
Cool?

43
00:02:22.039 --> 00:02:24.509
Questions here?

44
00:02:27.052 --> 00:02:29.650
&gt;&gt; Bianca Gandolfo: Okay, awesome.

45
00:02:29.650 --> 00:02:32.110
So here's our time complexity graph.

46
00:02:32.110 --> 00:02:34.770
This is from bigocheatsheet.com.

47
00:02:34.770 --> 00:02:40.080
I highly recommend that website if you
kinda wanna peek through more stuff about

48
00:02:40.080 --> 00:02:40.870
time complexity.

49
00:02:40.870 --> 00:02:45.720
Something that we discussed a couple
days ago is this n(log)n time,

50
00:02:45.720 --> 00:02:49.080
for when we're talking about merge source.

51
00:02:49.080 --> 00:02:49.810
You guys remember that?

52
00:02:51.230 --> 00:02:52.600
And just here graph,

53
00:02:52.600 --> 00:02:57.650
I just wanted to point out that it's
going to be slower than our linear right?

54
00:02:57.650 --> 00:03:00.690
So this is the number of operations
that have to be completed

55
00:03:00.690 --> 00:03:02.960
versus a number of elements, right?

56
00:03:02.960 --> 00:03:05.100
So for something that's constant times,

57
00:03:05.100 --> 00:03:07.820
it's gonna stay the same,
which is not even graphed here.

58
00:03:09.966 --> 00:03:15.320
Something that (log)n is going to grow but
then it's gonna grow more slowly

59
00:03:15.320 --> 00:03:20.650
over time as the problem keeps
getting cut in half in linear time.

60
00:03:20.650 --> 00:03:23.320
It's gonna be the same, proportional.

61
00:03:24.510 --> 00:03:29.690
n(log)n is a little bit slower
than linear time, I'm sorry,

62
00:03:29.690 --> 00:03:34.910
a little bit, yeah,
a little bit slower than linear time but

63
00:03:34.910 --> 00:03:37.220
also a little bit faster
than exponential time.

64
00:03:39.050 --> 00:03:40.041
&gt;&gt; Bianca Gandolfo: Right, and

65
00:03:40.041 --> 00:03:46.100
we have found that our fastest sorts
are running in n(log)n, right?

66
00:03:46.100 --> 00:03:48.350
Merge sort, quick sort,
we talked about that.

67
00:03:49.800 --> 00:03:55.020
And then we have exponential time,
and squared, which grows pretty fast.

68
00:03:55.020 --> 00:03:56.020
Shoop, see that?

69
00:03:56.020 --> 00:03:56.820
That's a bad thing.

70
00:03:58.060 --> 00:04:00.550
We learned that bubble sort and
search your sort, selection sort,

71
00:04:00.550 --> 00:04:05.720
all of these elementary sorts that
have these nested loops are gonna be,

72
00:04:07.787 --> 00:04:11.020
&gt;&gt; Bianca Gandolfo: Quadratic time, cool?

73
00:04:11.020 --> 00:04:14.049
Everything else just is
basically a straight line up.

74
00:04:16.270 --> 00:04:20.450
&gt;&gt; Bianca Gandolfo: So how do we estimate?

75
00:04:20.450 --> 00:04:22.550
Here's the steps.

76
00:04:22.550 --> 00:04:26.550
So you're gonna go through your algorithm,
estimate each line.

77
00:04:26.550 --> 00:04:31.150
Then you're either gonna multiply them or
add them,

78
00:04:31.150 --> 00:04:34.470
based on whether they're nested in a loop.

79
00:04:34.470 --> 00:04:36.440
Or, they are side by side.

80
00:04:36.440 --> 00:04:39.950
And then you're gonna drop any
non significant digits and

81
00:04:39.950 --> 00:04:41.490
just assume the worst case.

82
00:04:44.885 --> 00:04:46.354
&gt;&gt; Bianca Gandolfo: Cool?

83
00:04:49.764 --> 00:04:53.150
&gt;&gt; Bianca Gandolfo: All right.,
so here's our bold request.

84
00:04:55.410 --> 00:04:59.050
Who here did not know time
complexity before this class?

85
00:05:00.210 --> 00:05:00.710
Awesome.

86
00:05:01.910 --> 00:05:05.480
Who now feels like they have a pretty
solid understanding of time complexity?

87
00:05:06.680 --> 00:05:08.890
Cool, so what got you there?

88
00:05:08.890 --> 00:05:11.295
What was a big takeaway for you?

89
00:05:15.398 --> 00:05:19.639
&gt;&gt; Speaker 2: I think that chart you
showed earlier where you showed each,

90
00:05:19.639 --> 00:05:21.884
what is it level, or whatever,

91
00:05:21.884 --> 00:05:25.940
where you have the different types of-
&gt;&gt; Bianca Gandolfo: This one?

92
00:05:25.940 --> 00:05:27.000
&gt;&gt; Speaker 2: Yeah, that one.

93
00:05:27.000 --> 00:05:28.335
Operations, that's it.

94
00:05:28.335 --> 00:05:31.050
So that was helpful for me, to kind of
&gt;&gt; Bianca Gandolfo: So

95
00:05:31.050 --> 00:05:34.100
like maps being like, real operations.

96
00:05:34.100 --> 00:05:35.108
&gt;&gt; Speaker 2: Yeah.
&gt;&gt; Bianca Gandolfo: To their

97
00:05:35.108 --> 00:05:36.730
time complexity?

98
00:05:36.730 --> 00:05:38.120
&gt;&gt; Speaker 2: Yeah.
&gt;&gt; Bianca Gandolfo: Cool.

99
00:05:38.120 --> 00:05:39.520
&gt;&gt; Speaker 3: That was super helpful.

100
00:05:39.520 --> 00:05:44.800
And the thing that made it click
even more for me was that you

101
00:05:44.800 --> 00:05:49.210
drew out a graph showing how many
comparisons would have to happen.

102
00:05:49.210 --> 00:05:50.890
You know what I mean, like--
&gt;&gt; Bianca Gandolfo: The table.

103
00:05:50.890 --> 00:05:51.550
&gt;&gt; Speaker 2: Yeah, the table.

104
00:05:51.550 --> 00:05:52.570
Thank you.

105
00:05:52.570 --> 00:05:56.410
&gt;&gt; Bianca Gandolfo: Yeah, so
let's see, that'd be like writing out

106
00:05:58.380 --> 00:06:02.570
table showing number of comparisons.

107
00:06:02.570 --> 00:06:03.570
&gt;&gt; Speaker 2: Yeah.

108
00:06:03.570 --> 00:06:05.570
I think that's when it clicked for me.

109
00:06:05.570 --> 00:06:06.070
&gt;&gt; Bianca Gandolfo: Cool.

110
00:06:07.900 --> 00:06:10.100
Anything else?
Anything that was confusing at first?

111
00:06:10.100 --> 00:06:10.600
Tebit.

112
00:06:11.890 --> 00:06:16.010
&gt;&gt; Tebit: I get how to
find from this lesson.

113
00:06:16.010 --> 00:06:22.651
Time comma to the cell
complexity on the last slide.

114
00:06:22.651 --> 00:06:29.280
I didn't realize before this lesson

115
00:06:29.280 --> 00:06:34.090
how to find but the steps to find.

116
00:06:35.100 --> 00:06:39.770
The time it took,
time complexities where we had before.

117
00:06:39.770 --> 00:06:44.540
&gt;&gt; Bianca Gandolfo: Got it, so for
you it was the breakdown of the steps for

118
00:06:44.540 --> 00:06:47.300
estimating time complexity.

119
00:06:47.300 --> 00:06:50.040
And it's really important
that we recognize that we

120
00:06:50.040 --> 00:06:51.520
are estimating time complexity.

121
00:06:51.520 --> 00:06:55.820
There are mathematical proofs that
go behind calculating this and

122
00:06:55.820 --> 00:06:58.333
we have not gone there and
we will not go there in this class.

123
00:06:58.333 --> 00:06:59.913
Anything else?

124
00:07:02.347 --> 00:07:04.522
&gt;&gt; Bianca Gandolfo: Anything?

125
00:07:04.522 --> 00:07:06.358
Okay.

126
00:07:11.209 --> 00:07:14.390
&gt;&gt; Bianca Gandolfo: All right.

127
00:07:14.390 --> 00:07:18.201
So Christine says some example
walkthroughs were helpful,

128
00:07:18.201 --> 00:07:20.740
like when we doubled the sample size.

129
00:07:20.740 --> 00:07:24.450
For example, what's a useful way
to think about time complexity?

130
00:07:25.490 --> 00:07:31.590
Thinking about what happens
when we double the input.

131
00:07:31.590 --> 00:07:37.219
Let's say when we double and so we fit.

132
00:07:38.770 --> 00:07:41.800
Cool, all right.

133
00:07:41.800 --> 00:07:45.100
So further study is going to be
a formal analysis of algorithms.

134
00:07:45.100 --> 00:07:48.730
There are classes like this online
if that tickles your fancy.

