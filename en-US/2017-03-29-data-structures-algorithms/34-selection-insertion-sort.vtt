WEBVTT

1
00:00:00.130 --> 00:00:02.830
&gt;&gt; Bianca Gandolfo: So
now we're gonna talk about Selection Sort.

2
00:00:02.830 --> 00:00:06.777
I'm gonna give you just
a demo on how these work, and

3
00:00:06.777 --> 00:00:12.453
then I'm gonna set you free to pseudocode
and code them out through lunch.

4
00:00:12.453 --> 00:00:16.942
And then we'll come back and we'll
talk about solutions, your solutions,

5
00:00:16.942 --> 00:00:20.271
better solutions,
optimizing our solutions, maybe.

6
00:00:20.271 --> 00:00:23.310
And we'll come and
talk about our recursive.

7
00:00:23.310 --> 00:00:29.894
We'll introduce the recursive
sorting algorithms,okay?

8
00:00:29.894 --> 00:00:32.621
So selection sort, what does it do?

9
00:00:32.621 --> 00:00:37.885
It selects the smallest element in
an array and pushes it into a new array.

10
00:00:37.885 --> 00:00:41.870
So pretend I'm a computer, a robot.

11
00:00:41.870 --> 00:00:48.382
I will loop through it, my array,
look for the smallest one.

12
00:00:48.382 --> 00:00:54.844
It's one, I will take it,
pass it in to my new array.

13
00:00:54.844 --> 00:00:57.093
So for space complexity,
this is not good, right?

14
00:00:57.093 --> 00:00:58.450
Because we're making a new array.

15
00:00:58.450 --> 00:01:01.045
This is not an in place sort.

16
00:01:01.045 --> 00:01:04.195
So then we look through,
find the next smallest one,

17
00:01:04.195 --> 00:01:06.693
it's two.
&gt;&gt; Bianca Gandolfo: And

18
00:01:06.693 --> 00:01:10.004
then five.
&gt;&gt; Bianca Gandolfo: And

19
00:01:10.004 --> 00:01:13.171
then six, and then eight.

20
00:01:13.171 --> 00:01:14.331
So this is Selection Sort.

21
00:01:14.331 --> 00:01:18.189
We're literally going through the list,

22
00:01:18.189 --> 00:01:24.415
selecting the smallest one,
pushing it on to a new array, awesome.

23
00:01:24.415 --> 00:01:28.285
Here's a diagram,
&gt;&gt; Bianca Gandolfo: Of it in place,

24
00:01:28.285 --> 00:01:32.065
selection sort, where we're swapping it.

25
00:01:38.077 --> 00:01:39.113
&gt;&gt; Bianca Gandolfo: Cool, so,

26
00:01:39.113 --> 00:01:43.783
first selection sort in place,
we're gonna look for

27
00:01:43.783 --> 00:01:48.162
the largest one We're going
to swap it to the end.

28
00:01:48.162 --> 00:01:49.971
So, eight is our largest one.

29
00:01:49.971 --> 00:01:53.161
We're going to swap it and put five.

30
00:01:53.161 --> 00:01:59.826
Six, the largest one,
swap it with the two.

31
00:01:59.826 --> 00:02:04.373
Two is our next largest one,
swap it with itself.

32
00:02:04.373 --> 00:02:07.384
One, swap it with itself.

33
00:02:07.384 --> 00:02:11.330
Or perhaps we can optimize there,
that would be optimizing for

34
00:02:11.330 --> 00:02:16.160
adaptability.
&gt;&gt; Bianca Gandolfo: All right?

35
00:02:16.160 --> 00:02:21.218
Selection sort, not in place, in place,
&gt;&gt; Bianca Gandolfo: Which

36
00:02:21.218 --> 00:02:24.814
is better, one takes less space.

37
00:02:24.814 --> 00:02:27.553
If that matters to you,
you probably wanna have the in place one.

38
00:02:27.553 --> 00:02:32.471
If it doesn't and,
&gt;&gt; Bianca Gandolfo: Then do the easier

39
00:02:32.471 --> 00:02:33.620
one.
&gt;&gt; Speaker 2: Is the time complexity

40
00:02:33.620 --> 00:02:34.275
the same?
&gt;&gt; Bianca Gandolfo: Was

41
00:02:34.275 --> 00:02:37.284
the time complexity the same?

42
00:02:37.284 --> 00:02:45.663
Yeah, the time complexity of all of these
are the same basically, yeah, and squared.

43
00:02:45.663 --> 00:02:49.658
So Insertion Sort is another elementary
sort, and this is the third and last sort.

44
00:02:49.658 --> 00:02:54.049
And you're gonna implement all of these
and get super familiar with them.

45
00:02:54.049 --> 00:02:56.330
So you're gonna select
the first element in the array,

46
00:02:56.330 --> 00:02:57.941
you're gonna push it into a new array.

47
00:02:57.941 --> 00:03:02.519
And as you go through the original array,
you're going to

48
00:03:02.519 --> 00:03:07.481
either put it before or after,
in order, in the second array.

49
00:03:07.481 --> 00:03:10.132
Are you guys seeing
the difference between these?

50
00:03:10.132 --> 00:03:11.512
&gt;&gt; Speaker 2: So then in selection you

51
00:03:11.512 --> 00:03:15.583
would grab one and then you would grab
two and this you would grab one and

52
00:03:15.583 --> 00:03:19.126
then you would grab six.
&gt;&gt; Bianca Gandolfo: Yep, so we do one and

53
00:03:19.126 --> 00:03:21.846
then we take it out right.

54
00:03:21.846 --> 00:03:23.752
So pretend that's gone.

55
00:03:23.752 --> 00:03:26.983
Then we have six.
Six is are greater, so we put it after.

56
00:03:26.983 --> 00:03:28.669
And we have eight.

57
00:03:28.669 --> 00:03:32.663
Eight greater than one yes,
greater than six yes.

58
00:03:32.663 --> 00:03:37.317
And we'll put it after eight,
two, two greater than one, yes,

59
00:03:37.317 --> 00:03:39.610
greater than six no, awesome.

60
00:03:39.610 --> 00:03:42.330
Five greater than one yes,
greater than two,

61
00:03:42.330 --> 00:03:47.057
greater than six no.
&gt;&gt; Bianca Gandolfo: That's insertion sort.

62
00:03:49.166 --> 00:03:49.906
&gt;&gt; Bianca Gandolfo: Cool?

63
00:03:52.221 --> 00:03:53.446
&gt;&gt; Bianca Gandolfo: Questions about this?

64
00:03:55.628 --> 00:03:56.406
&gt;&gt; Bianca Gandolfo: Here's another

65
00:03:56.406 --> 00:04:03.749
diagram.
&gt;&gt; Bianca Gandolfo: Insertion Sort

66
00:04:03.749 --> 00:04:07.095
in place,
how do you think this is gonna happen?

67
00:04:07.095 --> 00:04:08.791
Don't read it.

68
00:04:08.791 --> 00:04:11.809
Of course, [CROSSTALK].

69
00:04:11.809 --> 00:04:15.780
Someone to read it to me?

70
00:04:15.780 --> 00:04:20.684
Suddenly I forgot how to read.
&gt;&gt; Speaker 2: Selects the first

71
00:04:20.684 --> 00:04:24.857
element in an array, considers
that our sorted list of size one.

72
00:04:24.857 --> 00:04:29.397
As each new element is added, insert
the new element in the correct order

73
00:04:29.397 --> 00:04:31.427
by swapping in.
&gt;&gt; Bianca Gandolfo: Yeah, so

74
00:04:31.427 --> 00:04:33.028
we start here.

75
00:04:33.028 --> 00:04:36.645
We have our sorted list of one.

76
00:04:36.645 --> 00:04:38.070
We add six.

77
00:04:38.070 --> 00:04:42.082
We say, is six greater than
our original sorted list?

78
00:04:42.082 --> 00:04:44.230
Yes, so we'll just keep it there.

79
00:04:44.230 --> 00:04:45.222
Then we add eight.

80
00:04:45.222 --> 00:04:47.320
And we say, is eight greater than one?

81
00:04:47.320 --> 00:04:48.690
Yes, is eight greater than six?

82
00:04:48.690 --> 00:04:52.557
Yes, and then we put it in
our sorted list of three.

83
00:04:52.557 --> 00:04:56.495
Etc, just like in other one,
except that there will be swapping.

84
00:05:00.230 --> 00:05:03.018
&gt;&gt; Bianca Gandolfo: Yes, clear?

85
00:05:03.018 --> 00:05:07.167
Because you're gonna have to be coding
this in a second, literally a second.

86
00:05:07.167 --> 00:05:09.688
&gt;&gt; Bianca Gandolfo: Cool.

87
00:05:11.648 --> 00:05:12.565
&gt;&gt; Bianca Gandolfo: So Christine is

88
00:05:12.565 --> 00:05:17.158
asking, what's the time complexity of
Insertion Sort and Selection Sort?

89
00:05:17.158 --> 00:05:22.540
I wanna tell you and I kinda hinted at it,
but I want you to code it out and

90
00:05:22.540 --> 00:05:26.142
calculate it yourself.
&gt;&gt; Speaker 3: Pseudo code first, right?

91
00:05:26.142 --> 00:05:27.567
&gt;&gt; Bianca Gandolfo: Yep, pseudo code it,

92
00:05:27.567 --> 00:05:29.820
and then you're gonna code it out.

93
00:05:29.820 --> 00:05:33.866
And that's gonna be in the exercises here.
&gt;&gt; Bianca Gandolfo: But

94
00:05:33.866 --> 00:05:34.620
do we have any other

95
00:05:34.620 --> 00:05:39.284
questions before we hop to the exercises?
&gt;&gt; Bianca Gandolfo: No.

96
00:05:39.284 --> 00:05:42.011
&gt;&gt; Speaker 4: Can you repeat one more the,

97
00:05:42.011 --> 00:05:46.213
kind of we put one more the,
the first step,

98
00:05:46.213 --> 00:05:51.054
this acoustic examples you gave us.
&gt;&gt; Bianca Gandolfo: Which example?

99
00:05:51.054 --> 00:05:53.976
&gt;&gt; Speaker 4: Five can be in.

100
00:05:53.976 --> 00:05:54.878
&gt;&gt; Bianca Gandolfo: Which one?

101
00:05:54.878 --> 00:05:56.697
You have to talk a little bit louder.
&gt;&gt; Speaker 4: Sorry,

102
00:05:56.697 --> 00:06:02.744
that example using Bike A, Bike C,
&gt;&gt; Speaker 4: At

103
00:06:02.744 --> 00:06:07.621
the beginning.
&gt;&gt; Bianca Gandolfo: Tell me when,

104
00:06:09.300 --> 00:06:09.888
&gt;&gt; Bianca Gandolfo: This one?

105
00:06:09.888 --> 00:06:12.117
&gt;&gt; Speaker 4: This one, Stability.

106
00:06:12.117 --> 00:06:13.340
&gt;&gt; Bianca Gandolfo: What's your question?

107
00:06:13.340 --> 00:06:14.357
&gt;&gt; Speaker 4: My question

108
00:06:14.357 --> 00:06:15.986
is the second one.

109
00:06:15.986 --> 00:06:19.625
Give equal price, I want lighter option.

110
00:06:19.625 --> 00:06:22.632
It's the idea.
&gt;&gt; Bianca Gandolfo: So you have to talk

111
00:06:22.632 --> 00:06:27.162
a lot louder, I can't hear you.
&gt;&gt; Speaker 4: Given equal price,

112
00:06:27.162 --> 00:06:30.259
just that last,

113
00:06:30.259 --> 00:06:34.702
I want our option to be first that idea.
&gt;&gt; Bianca Gandolfo: Which one do

114
00:06:34.702 --> 00:06:37.924
you want to be first?
&gt;&gt; Speaker 4: Just kindly would

115
00:06:37.924 --> 00:06:40.302
repeat again, your explanation?
&gt;&gt; Bianca Gandolfo: Yeah,

116
00:06:40.302 --> 00:06:41.721
sure, I can reexplain it for sure.

117
00:06:41.721 --> 00:06:46.357
So, this is an example of stability which
is something you might consider when

118
00:06:46.357 --> 00:06:48.255
choosing a sorting algorithm or

119
00:06:48.255 --> 00:06:52.421
you might consider adding this to
an algorithm that you're writing.

120
00:06:52.421 --> 00:06:58.258
And it's important when you want to
preserve the original order of a list.

121
00:06:58.258 --> 00:07:06.946
So say for example, trying to think of a
different example other than these bikes.

122
00:07:06.946 --> 00:07:12.629
But let's say, for example,
you first sort your hotels on Kayak.com.

123
00:07:12.629 --> 00:07:15.530
You sort it first by rating.

124
00:07:15.530 --> 00:07:18.229
And so we have the top rating first.

125
00:07:18.229 --> 00:07:19.882
And then, you want to sort it by price.

126
00:07:19.882 --> 00:07:25.401
And so, what you want is,
at the end of the day is to have the first

127
00:07:25.401 --> 00:07:30.424
one to be the highest rating,
maybe for the lowest price.

128
00:07:30.424 --> 00:07:31.056
Does that make sense?

129
00:07:31.056 --> 00:07:35.696
And so that would be an example of why
you'd want stability in your search,

130
00:07:35.696 --> 00:07:40.190
is when you have it in a certain order
that you wanna preserve even when you

131
00:07:40.190 --> 00:07:42.785
resort it, when the prices are the same.

132
00:07:42.785 --> 00:07:47.284
Or when the sum value is the same.

133
00:07:47.284 --> 00:07:52.996
So for this example of the bikes,
BIke B and Bike C are both $500.

134
00:07:52.996 --> 00:07:55.965
It's originally sorted here, right.

135
00:07:55.965 --> 00:07:58.728
So it's sorted by weight
in ascending over.

136
00:07:58.728 --> 00:08:05.044
So heavier is at the bottom,
with lighter at the top.

137
00:08:05.044 --> 00:08:10.146
When we resort it for price, this is
the original sorted order for weight.

138
00:08:10.146 --> 00:08:14.446
This is the new sorted order for
price where when

139
00:08:14.446 --> 00:08:19.510
the price is the same,
it's gonna keep the same order.

140
00:08:19.510 --> 00:08:22.316
So if you notice Bike B
comes before Bike C here.

141
00:08:24.387 --> 00:08:25.259
&gt;&gt; Bianca Gandolfo: When here it's also

142
00:08:25.259 --> 00:08:26.085
the same, right?

143
00:08:26.085 --> 00:08:30.500
Bike B also comes before Bike C,
that's useful.

144
00:08:30.500 --> 00:08:35.055
But that's not always guaranteed in all
of our source that this is gonna happen.

145
00:08:35.055 --> 00:08:38.305
Does that make sense?
&gt;&gt; Speaker 3: That's because

146
00:08:38.305 --> 00:08:42.118
Bike B is less than,
I mean weighs less than Bike C, right?

147
00:08:42.118 --> 00:08:42.649
&gt;&gt; Bianca Gandolfo: Yes, but

148
00:08:42.649 --> 00:08:45.240
the point here is,
maybe where we take this for

149
00:08:45.240 --> 00:08:47.977
granted when we're sorting
things in our mind.

150
00:08:47.977 --> 00:08:51.185
But you might have to explicatively
tell your algorithm to do this.

151
00:08:51.185 --> 00:08:53.906
Or it might just do it in whatever order.

152
00:08:53.906 --> 00:08:55.982
It might swap them.

153
00:08:55.982 --> 00:09:00.396
So just be mindful of your swaps.
&gt;&gt; Speaker 5: On Kayak if you don't do it,

154
00:09:00.396 --> 00:09:07.308
you'll get all the lower priced hotels
that [INAUDIBLE] grading, so you might be

155
00:09:07.308 --> 00:09:12.159
in a flea-bitten, best western somewhere.
&gt;&gt; Bianca Gandolfo: Yeah.

156
00:09:12.159 --> 00:09:12.901
&gt;&gt; Group: [LAUGH].

157
00:09:12.901 --> 00:09:13.744
&gt;&gt; Bianca Gandolfo: Best eastern.

158
00:09:13.744 --> 00:09:15.645
&gt;&gt; Speaker 5: Best eastern [LAUGH].

159
00:09:15.645 --> 00:09:16.478
&gt;&gt; Bianca Gandolfo: Yeah, so

160
00:09:16.478 --> 00:09:21.903
the next question is,
how can we make an algorithm adaptive?

161
00:09:21.903 --> 00:09:25.710
So I mentioned before that
it depends on the algorithm.

162
00:09:25.710 --> 00:09:30.379
And some of them are adaptive,
and some of them aren't.

163
00:09:30.379 --> 00:09:37.114
And some of them you can put breaks and
things, to make it more adaptive.

164
00:09:37.114 --> 00:09:40.370
So we'll talk about it
specific case by case.

165
00:09:40.370 --> 00:09:43.401
How to make a specific
algorithm more adaptive or not.

166
00:09:43.401 --> 00:09:48.144
And you can think about it as
you're writing out your procedures.

167
00:09:48.144 --> 00:09:52.346
What if, you know, what if we only
get half way through sorting this and

168
00:09:52.346 --> 00:09:54.530
its already sorted, what happens?

169
00:09:54.530 --> 00:09:56.995
How do we know that?

170
00:09:56.995 --> 00:10:01.749
So for some of them you might be able to
track if you're swapping like maybe if

171
00:10:01.749 --> 00:10:06.076
you loop through entire list and
you don't swap, you can flag that.

172
00:10:06.076 --> 00:10:07.802
That means it's sorting.

173
00:10:07.802 --> 00:10:11.370
That's one example, but
it depends on the algorithm, yeah.

