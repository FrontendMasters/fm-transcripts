WEBVTT

1
00:00:00.180 --> 00:00:03.980
&gt;&gt; Bianca Gandolfo: We're gonna talk
about some other things to think about

2
00:00:03.980 --> 00:00:05.360
in terms of our sorting algorithm.

3
00:00:05.360 --> 00:00:08.730
So right now, when we're thinking about,
is our algorithm good,

4
00:00:08.730 --> 00:00:12.040
we're only thinking about,
is our algorithm fast?

5
00:00:12.040 --> 00:00:14.190
And in sorting, there is another thing
that we want to think about, and

6
00:00:14.190 --> 00:00:18.570
that's the stability, and the stability
preserves the order of equal items.

7
00:00:20.820 --> 00:00:25.866
And most or all comparison
sorts can be stable if you have

8
00:00:25.866 --> 00:00:31.690
an order or
position as part of the comparison.

9
00:00:33.290 --> 00:00:34.780
So here's just a quick example.

10
00:00:36.530 --> 00:00:42.060
So if you wanted to sort this by price,
but you wanted the lighter ones to

11
00:00:42.060 --> 00:00:48.520
be first and so this right now,
this list is sorted by weight.

12
00:00:48.520 --> 00:00:54.220
However, if we wanted to then sort if
by price, but preserve that the weight,

13
00:00:54.220 --> 00:00:57.270
the lighter one will be first.

14
00:00:57.270 --> 00:00:58.258
Am I making sense?

15
00:00:58.258 --> 00:01:00.098
I"m like [SOUND].

16
00:01:00.098 --> 00:01:05.150
We want to have a stable sorting
algorithm, this will be an example.

17
00:01:05.150 --> 00:01:07.350
So here we are we have it sorted.

18
00:01:07.350 --> 00:01:12.110
So we can see bike B is 500 pounds or
$500 and

19
00:01:12.110 --> 00:01:14.690
30 pounds and is lighter and
it's the least expensive.

20
00:01:14.690 --> 00:01:20.580
So maybe if you are optimizing for more
bang for your buck, in terms of the weight

21
00:01:20.580 --> 00:01:24.760
of your bike, will be faster bike
probably, then you probably want bike B.

22
00:01:24.760 --> 00:01:30.720
So this is an example of why you'd
wanna use a stable sorting algorithm.

23
00:01:30.720 --> 00:01:36.230
If you don't have a secondary property, or
if it doesn't matter the initial order,

24
00:01:36.230 --> 00:01:40.490
then the stability of your
algorithm doesn't matter.

25
00:01:40.490 --> 00:01:45.125
But it's something to keep in mind
when you're presented with different

26
00:01:45.125 --> 00:01:47.003
needs when you're sorting.

27
00:01:47.003 --> 00:01:50.459
You're going to be sorting all kinds of
things probably in the day to day, so

28
00:01:50.459 --> 00:01:52.940
maybe you will need a stable,
maybe you won't.

29
00:01:52.940 --> 00:01:54.050
It's just something to consider.

30
00:01:55.310 --> 00:02:00.984
Any questions about stability?
&gt;&gt; Bianca Gandolfo: Okay.

31
00:02:03.990 --> 00:02:04.805
&gt;&gt; Bianca Gandolfo: All right, so

32
00:02:04.805 --> 00:02:08.490
adaptability is another
thing to think about.

33
00:02:08.490 --> 00:02:15.540
This is the question of, if your list
is almost sorted Is it more efficient?

34
00:02:15.540 --> 00:02:20.080
Or is it just as inefficient
whether it's sorted or not?

35
00:02:20.080 --> 00:02:24.580
So if you have data that might be almost
sorted, and that's something that

36
00:02:24.580 --> 00:02:28.000
is important to your use case,
then you want to think about adaptability.

37
00:02:29.850 --> 00:02:30.350
Yeah?

38
00:02:31.660 --> 00:02:35.180
Does that all make sense?
&gt;&gt; Speaker 2: It seemed like with

39
00:02:35.180 --> 00:02:39.730
the bubble sort at the right
half of it is sorted.

40
00:02:39.730 --> 00:02:43.790
So if you had a way of keeping
track which part is sorted,

41
00:02:43.790 --> 00:02:46.674
then you wouldn't have to
compare all the way to the end.

42
00:02:46.674 --> 00:02:49.042
Or is that you could,

43
00:02:49.042 --> 00:02:52.275
[INAUDIBLE] Never mind.
&gt;&gt; Bianca Gandolfo: Yeah,

44
00:02:52.275 --> 00:02:55.367
there are different ways to
make an algorithm adaptive.

45
00:02:55.367 --> 00:02:59.096
So for example,
we'll talk about it when we get there, but

46
00:02:59.096 --> 00:03:00.811
there are ways to measure,

47
00:03:00.811 --> 00:03:06.270
there are different strategies to make it
adapt depending on which one you're using.

48
00:03:07.810 --> 00:03:11.430
Cool, so Lindsey asked, so stability means
retaining the original sorted order?

49
00:03:12.520 --> 00:03:16.560
Stability means retaining
the original sorted order for

50
00:03:17.640 --> 00:03:20.050
elements that have the same value.

51
00:03:20.050 --> 00:03:26.540
So in the example of our bicycles,
since both of them were $500,

52
00:03:26.540 --> 00:03:31.820
we retained the original order
that bike B becomes before

53
00:03:31.820 --> 00:03:37.961
bike C.
&gt;&gt; Bianca Gandolfo: So

54
00:03:37.961 --> 00:03:43.275
it preserves some elements
of the original order for

55
00:03:43.275 --> 00:03:47.390
the case where they have the same price.

