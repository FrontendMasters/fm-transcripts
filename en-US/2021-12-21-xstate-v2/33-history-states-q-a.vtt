WEBVTT

1
00:00:00.230 --> 00:00:04.587
Somebody asks, so this is like when
we want async work going on and

2
00:00:04.587 --> 00:00:07.580
then coming back to a machine?

3
00:00:07.580 --> 00:00:11.113
And yes, this is exactly how
you could think about it, and

4
00:00:11.113 --> 00:00:15.190
this is what we're doing
exactly here in this exercise.

5
00:00:15.190 --> 00:00:20.238
We have this async work of loading a song,
and then once that's done,

6
00:00:20.238 --> 00:00:25.373
and we come back to our ready states,
we remember what the previous, or

7
00:00:25.373 --> 00:00:31.860
not the previous, but we remember what the
child state that that ready state was in.

8
00:00:31.860 --> 00:00:36.590
Is there a way to set some default data
when we trigger an action by clicking

9
00:00:36.590 --> 00:00:41.440
events in the inspector to avoid
typing the events data each time?

10
00:00:41.440 --> 00:00:46.023
So this refers to the visualizer and
in the visualizer,

11
00:00:46.023 --> 00:00:49.835
you can send in events
with payload over here.

12
00:00:49.835 --> 00:00:54.734
So I could send some events and
I could add some payload,

13
00:00:56.072 --> 00:00:59.968
Hello, and then I could go ahead and
send that events.

14
00:00:59.968 --> 00:01:03.675
Right now,
there is no way to have defaults data,

15
00:01:03.675 --> 00:01:08.600
but that is coming as a future
feature inside the visualizer.

16
00:01:08.600 --> 00:01:11.280
Does history work for parallel states?

17
00:01:11.280 --> 00:01:15.524
So each region returns to its
previously selected state?

18
00:01:15.524 --> 00:01:20.085
And the answer is yes,
because each region is most of the time,

19
00:01:20.085 --> 00:01:25.607
unless you don't have any child states,
every region is a compound state.

20
00:01:25.607 --> 00:01:29.490
So you can specify a region
that has child states and

21
00:01:29.490 --> 00:01:33.743
also has a sibling history
state that you could go into.

22
00:01:33.743 --> 00:01:38.090
What makes an infinite or
a recursive machine?

23
00:01:38.090 --> 00:01:40.665
So, we have finite state machines,

24
00:01:40.665 --> 00:01:45.991
which the finite means the finite number
of states events and transitions.

25
00:01:45.991 --> 00:01:49.795
An infinite state machine
doesn't really make sense.

26
00:01:49.795 --> 00:01:54.671
So you could think of an infinite state
machine as a finite state machine that

27
00:01:54.671 --> 00:01:59.548
just can have infinite data, and that
actually sort of is already like these

28
00:01:59.548 --> 00:02:02.918
state machines and
state charts that have context.

29
00:02:02.918 --> 00:02:05.445
So you might imagine, for example,

30
00:02:05.445 --> 00:02:10.594
a machine that has a count value that
could count all the way up to infinity.

31
00:02:10.594 --> 00:02:16.453
Then if you represent each one of the
aggregate states as including the count,

32
00:02:16.453 --> 00:02:21.889
then, of course, this state machine
has an infinite number of states.

33
00:02:21.889 --> 00:02:25.360
However, if you just
consider the behaviors,

34
00:02:25.360 --> 00:02:28.145
then the behaviors should be finite.

35
00:02:28.145 --> 00:02:33.327
And even though you might have an infinite
amount of combinations of data, which is

36
00:02:33.327 --> 00:02:38.599
definitely the case for most applications,
the behaviors themselves are finite.

37
00:02:38.599 --> 00:02:41.750
So that's what the finite means
in finite state machines.

