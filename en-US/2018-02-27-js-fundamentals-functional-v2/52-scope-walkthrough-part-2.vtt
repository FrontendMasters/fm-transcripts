WEBVTT

1
00:00:00.350 --> 00:00:05.135
So this one says a function's locals scope
variables are not available anywhere

2
00:00:05.135 --> 00:00:09.670
outside that function regardless
of the context it's called in.

3
00:00:09.670 --> 00:00:11.580
Tim over here do you wanna start?

4
00:00:11.580 --> 00:00:15.580
&gt;&gt; No, that's boring, yeah,
we're declaring first fin,

5
00:00:15.580 --> 00:00:19.140
which is a function and
not running it immediately.

6
00:00:19.140 --> 00:00:22.819
&gt;&gt; Okay, so
we'e defining this function and

7
00:00:22.819 --> 00:00:27.940
we have the function body here,
we're not running it yet.

8
00:00:29.250 --> 00:00:31.060
Okay, Dan.

9
00:00:31.060 --> 00:00:33.070
&gt;&gt; We're declaring second.

10
00:00:33.070 --> 00:00:34.870
&gt;&gt; Yeah,
we're creating the second function.

11
00:00:37.430 --> 00:00:38.400
Skipping over it.

12
00:00:39.520 --> 00:00:42.043
&gt;&gt; We're calling expect.

13
00:00:45.803 --> 00:00:50.800
Using as a parameter this function.

14
00:00:50.800 --> 00:00:51.310
&gt;&gt; Yeah.

15
00:00:51.310 --> 00:00:55.400
&gt;&gt; And we don't know that it's
necessarily going to be executed.

16
00:00:55.400 --> 00:00:58.790
&gt;&gt; Yeah, but I'll tell you that, yes,
it is actually gonna be executed.

17
00:00:58.790 --> 00:01:01.283
But it doesn't,
there's nothing here telling us for

18
00:01:01.283 --> 00:01:02.810
sure that it's being executed.

19
00:01:03.820 --> 00:01:07.641
But I'll let you know that
inside that expect function,

20
00:01:07.641 --> 00:01:09.800
it will execute this function.

21
00:01:13.190 --> 00:01:18.172
So, Jimmy, so this function is
being called what happens next?

22
00:01:21.507 --> 00:01:27.230
&gt;&gt; I don't know all that where
the to throw brings it to.

23
00:01:27.230 --> 00:01:31.700
&gt;&gt; While we're still actually running
this function, so we call this function.

24
00:01:31.700 --> 00:01:36.058
But when we call a function, we first need
to enter into the body of the function and

25
00:01:36.058 --> 00:01:37.462
execute what's inside.

26
00:01:37.462 --> 00:01:42.640
&gt;&gt; Okay, so then it's calling the second
function or second Fn within there.

27
00:01:42.640 --> 00:01:45.239
&gt;&gt; Yeah, so it's gonna call
that function and then Josh.

28
00:01:47.183 --> 00:01:51.272
&gt;&gt; Goes back up to the second
function declaration and

29
00:01:51.272 --> 00:01:55.830
executes the code,
which will deal with the problem.

30
00:01:55.830 --> 00:01:58.600
&gt;&gt; And then ultimately what happens?

31
00:01:58.600 --> 00:02:02.778
So, we're executing this, so what happens?

32
00:02:05.712 --> 00:02:08.830
&gt;&gt; That then fall for the throw error?

33
00:02:10.110 --> 00:02:17.888
&gt;&gt; Yeah, so this is probably our error
because local the first function is,

34
00:02:17.888 --> 00:02:22.410
excuse me,
[COUGH] is in a different scope.

35
00:02:23.720 --> 00:02:26.880
So we don't have access
to localToFirst function.

36
00:02:26.880 --> 00:02:29.460
So we're trying to assign
something that doesn't exist.

37
00:02:29.460 --> 00:02:30.541
It's gonna throw an error.

38
00:02:32.713 --> 00:02:37.375
So that's where this to.throw comes from,
okay?

39
00:02:37.375 --> 00:02:40.153
Any questions for that one, okay?

40
00:02:44.208 --> 00:02:46.221
Aisha, do you wanna do the next expect?

41
00:02:49.568 --> 00:02:54.510
&gt;&gt; Functions defined and
declared the first function.

42
00:02:54.510 --> 00:02:57.108
&gt;&gt; So we define this
function expect somewhere in

43
00:02:57.108 --> 00:02:58.910
the internals is gonna call it.

44
00:03:00.240 --> 00:03:04.702
And then Cameron,
what happens once it's called?

45
00:03:07.868 --> 00:03:10.250
&gt;&gt; It calls first function.

46
00:03:10.250 --> 00:03:14.880
&gt;&gt; It's gonna call the first function and
Eddie, what happens next?

47
00:03:16.380 --> 00:03:21.897
&gt;&gt; So inside the first
function up on line 64 for

48
00:03:21.897 --> 00:03:28.940
localToFirst function is
set to the string first.

49
00:03:28.940 --> 00:03:31.500
&gt;&gt; Yep, okay, Chris, what happens next?

50
00:03:31.500 --> 00:03:36.134
&gt;&gt; And
then it calls the second function again.

51
00:03:36.134 --> 00:03:39.100
&gt;&gt; Yeah, and then Abdi, what happens next?

52
00:03:41.180 --> 00:03:44.714
&gt;&gt; Run second function and assigns

53
00:03:47.778 --> 00:03:52.080
The localToFirst string to be
first assigns that to actual.

54
00:03:53.490 --> 00:04:01.070
&gt;&gt; Well, This is in a different scope,
though, than this one still.

55
00:04:03.100 --> 00:04:06.500
So as you would read it, it first looks.

56
00:04:07.720 --> 00:04:09.540
Is this variable in this scope?

57
00:04:09.540 --> 00:04:10.960
No it's not.

58
00:04:10.960 --> 00:04:15.570
As you would read it,
not necessarily how it's executed.

59
00:04:16.930 --> 00:04:19.580
You look then to the parents scope,
which is not this one.

60
00:04:19.580 --> 00:04:21.100
This one is not in the same scope.

61
00:04:21.100 --> 00:04:25.227
You can even see when you collapse
them there, there are siblings.

62
00:04:27.873 --> 00:04:36.040
So it will look out into this scope here,
And then it will look out into this one.

63
00:04:37.730 --> 00:04:45.240
And nowhere have we defined the
localToFirst function, that makes sense?

64
00:04:45.240 --> 00:04:48.220
&gt;&gt; So the hierarchies are sort
of defined statically.

65
00:04:48.220 --> 00:04:49.372
&gt;&gt; Yeah.

66
00:04:49.372 --> 00:04:51.560
&gt;&gt; All right.

67
00:04:51.560 --> 00:04:53.650
&gt;&gt; Yeah, it's called lexical scope.

68
00:04:53.650 --> 00:04:58.675
If you want the Wikipedia word for
it, but it's as you would read it,

69
00:04:58.675 --> 00:05:01.720
to like where it's visually on the page.

70
00:05:03.230 --> 00:05:08.870
Yeah, okay, so
we don't have access to this.

71
00:05:09.920 --> 00:05:14.658
It's gonna throw an error
&gt;&gt; And then expect

72
00:05:14.658 --> 00:05:19.665
it's called with actual equal to null.

73
00:05:19.665 --> 00:05:25.073
&gt;&gt; Awesome, so actual is null again,
because before

74
00:05:25.073 --> 00:05:31.127
each it we are resetting our null or
actual value to null.

75
00:05:34.538 --> 00:05:35.572
Great.

76
00:05:38.966 --> 00:05:40.640
Next one, it's a little bit longer.

77
00:05:40.640 --> 00:05:42.420
&gt;&gt; Can I ask you about the last one too?

78
00:05:42.420 --> 00:05:42.920
&gt;&gt; Yeah.

79
00:05:44.560 --> 00:05:46.940
&gt;&gt; Is it by any chance a matter of order?

80
00:05:46.940 --> 00:05:54.200
Like if second fun was declared for the
first time, would you be call it there?

81
00:05:54.200 --> 00:05:58.580
&gt;&gt; If we, for example,
put this function above.

82
00:05:58.580 --> 00:06:00.280
&gt;&gt; Just above it, it's.

83
00:06:00.280 --> 00:06:05.260
&gt;&gt; No, it still wouldn't work cuz
it's about the block that it's in,

84
00:06:07.000 --> 00:06:10.210
&gt;&gt; I guess I'm confused because when I

85
00:06:10.210 --> 00:06:15.239
write a big page code or
something, and I'll have other

86
00:06:15.239 --> 00:06:20.054
functions on that same level
that I call side there and

87
00:06:20.054 --> 00:06:26.030
I'm missing why they're
outside of scope in that case.

88
00:06:26.030 --> 00:06:30.080
I think you said it pretty, pretty
clearly there and it's just not clicking.

89
00:06:30.080 --> 00:06:33.072
&gt;&gt; Yeah, so when you put
a variable inside of a function,

90
00:06:33.072 --> 00:06:34.770
it's local to that function.

91
00:06:36.130 --> 00:06:40.690
And when you do a look up, for
example, this is a creation, right?

92
00:06:40.690 --> 00:06:43.210
We're declaring this, and
this is a lookup, right?

93
00:06:43.210 --> 00:06:45.040
We're looking at the value
of that function.

94
00:06:45.040 --> 00:06:48.050
It's first gonna check in its own block.

95
00:06:49.190 --> 00:06:51.410
Okay, and
we haven't declared anything here.

96
00:06:51.410 --> 00:06:53.280
We haven't assigned anything.

97
00:06:53.280 --> 00:06:55.470
So it's not there and
then it's gonna look up.

98
00:06:57.170 --> 00:07:01.153
Okay, and so up is in this function and

99
00:07:01.153 --> 00:07:06.379
when I say up,
I don't mean like up the lines, but

100
00:07:06.379 --> 00:07:12.800
up the scope tree to up into
the next parent function.

101
00:07:12.800 --> 00:07:15.813
&gt;&gt; Sure, so if I can,
like if we're at this step here,

102
00:07:15.813 --> 00:07:19.870
when we're calling it from
the perspective of the first one, right?

103
00:07:21.830 --> 00:07:23.960
Okay, I want to assign this variable,
okay?

104
00:07:23.960 --> 00:07:27.106
I did that,
now I'm calling a second function.

105
00:07:27.106 --> 00:07:28.960
What is second function?

106
00:07:28.960 --> 00:07:30.010
I don't have that.

107
00:07:30.010 --> 00:07:34.655
Let me go up a level, but
then why doesn't it see, the function,

108
00:07:34.655 --> 00:07:36.695
right there var second fun.

109
00:07:38.749 --> 00:07:40.204
&gt;&gt; It does see this?

110
00:07:40.204 --> 00:07:42.124
&gt;&gt; Does.
&gt;&gt; Yes.

111
00:07:42.124 --> 00:07:49.000
&gt;&gt; Yeah, because second font is
being declared a parent scope.

112
00:07:49.000 --> 00:07:52.527
&gt;&gt; Wait, yeah, why would it throw an error
because you're actually looking for

113
00:07:52.527 --> 00:07:54.350
the variable name and not the function?

114
00:07:55.880 --> 00:08:02.363
&gt;&gt; So localToFirst function is the thing
that's throwing the error This one.

115
00:08:03.409 --> 00:08:04.980
&gt;&gt; Wait.

116
00:08:04.980 --> 00:08:08.343
&gt;&gt; Well, actually, this one,
sorry, that was thrown in there.

117
00:08:12.997 --> 00:08:15.416
Because it's first looking in here for

118
00:08:15.416 --> 00:08:19.742
something called localToFirst function and
it's not there.

119
00:08:19.742 --> 00:08:23.050
&gt;&gt; Okay.
&gt;&gt; Then it looks here, and it's not there.

120
00:08:23.050 --> 00:08:25.067
&gt;&gt; Okay,
&gt;&gt; And then it let's keep going up until

121
00:08:25.067 --> 00:08:27.414
it says, well, it's not it's not there.

122
00:08:27.414 --> 00:08:30.917
&gt;&gt; Okay, so I think, the reason that
the second test there that we were looking

123
00:08:30.917 --> 00:08:34.618
at fails, is because it calls first
function which goes into second function.

124
00:08:34.618 --> 00:08:38.057
And then second function still does
not have access to localToFirst

125
00:08:38.057 --> 00:08:39.280
function, okay.

126
00:08:39.280 --> 00:08:41.222
&gt;&gt; But
I see what you mean about the order.

127
00:08:41.222 --> 00:08:44.580
And I think that's something
important to point out is the order.

128
00:08:45.740 --> 00:08:50.130
Because it seems like, this wouldn't have
access because this is underneath, right?

129
00:08:50.130 --> 00:08:52.888
That's what your assumption was,
something to do with that?

130
00:08:52.888 --> 00:08:54.137
&gt;&gt; Yeah, there are so
new situations that comes in.

131
00:08:54.137 --> 00:09:01.780
&gt;&gt; Yeah, and so, that's an another part
of sculpt that comes into play which is,

132
00:09:01.780 --> 00:09:08.070
when things are defined in the order
in which things are defined.

133
00:09:08.070 --> 00:09:13.307
So, because first function
isn't run until down here,

134
00:09:13.307 --> 00:09:17.680
we actually have executed all of this,
right?

135
00:09:17.680 --> 00:09:20.160
We declared all of this, right?

136
00:09:20.160 --> 00:09:20.690
You remember that?
And

137
00:09:20.690 --> 00:09:25.840
then we called first
function when we go up here.

138
00:09:25.840 --> 00:09:29.760
So, the second function
has already been defined.

139
00:09:31.240 --> 00:09:32.840
Yeah, that's why that works.

140
00:09:34.610 --> 00:09:35.390
&gt;&gt; Thank you.

141
00:09:35.390 --> 00:09:36.600
&gt;&gt; Yeah, no, that's a good question.

142
00:09:38.020 --> 00:09:39.317
Awesome.

143
00:09:39.317 --> 00:09:44.368
Okay, so the next one is, if an inner and
outer variable share the same name,

144
00:09:44.368 --> 00:09:47.494
and that name is referenced
in the inner scope.

145
00:09:47.494 --> 00:09:51.971
The inner scope variable masks
the variable from the outer scope with

146
00:09:51.971 --> 00:09:52.980
the same name.

147
00:09:54.220 --> 00:09:59.253
This renders the outer scope
variables inaccessible

148
00:09:59.253 --> 00:10:04.405
from anywhere within the inner
function block [LAUGH].

149
00:10:04.405 --> 00:10:07.488
Where did we leave off actually?

150
00:10:07.488 --> 00:10:10.896
Okay, Michael.

151
00:10:10.896 --> 00:10:14.610
&gt;&gt; We're making anonymous function.

152
00:10:14.610 --> 00:10:16.770
&gt;&gt; Well, actually we start here.

153
00:10:16.770 --> 00:10:17.440
&gt;&gt; Okay, cool.

154
00:10:17.440 --> 00:10:21.945
We are defining a variable same name,
setting it to outer.

155
00:10:21.945 --> 00:10:27.640
&gt;&gt; Yep, so we're defining the variable
same name, setting it to outer.

156
00:10:27.640 --> 00:10:28.890
What's the next thing that happens?

157
00:10:29.910 --> 00:10:30.410
Who's next?

158
00:10:32.020 --> 00:10:33.010
Did you just go?

159
00:10:33.010 --> 00:10:34.560
&gt;&gt; Yeah, I did, but I can go again.

160
00:10:34.560 --> 00:10:35.710
&gt;&gt; No it's okay.

161
00:10:35.710 --> 00:10:38.105
So, it's either Vin or Aisha.

162
00:10:41.911 --> 00:10:45.211
&gt;&gt; I'll go, a functions to find.

163
00:10:45.211 --> 00:10:49.775
&gt;&gt; You define a function,
okay, ultimately.

164
00:10:52.461 --> 00:10:55.320
&gt;&gt; I was just reading the description
trying to understand.

165
00:10:55.320 --> 00:10:55.900
&gt;&gt; Yeah.

166
00:10:55.900 --> 00:10:59.290
&gt;&gt; Okay, so we defined a function,
then we called it.

167
00:11:00.370 --> 00:11:03.430
&gt;&gt; Yep.
And then we call the function, Josh.

168
00:11:05.070 --> 00:11:08.971
&gt;&gt; Evaluate the function body.

169
00:11:08.971 --> 00:11:15.046
So, setting it to enter places,
same names are used.

170
00:11:15.046 --> 00:11:16.805
&gt;&gt; Yeah.

171
00:11:16.805 --> 00:11:21.970
So, we declare a variable with the exact
name as this variable same name.

172
00:11:21.970 --> 00:11:23.216
We reassign the value here.

173
00:11:23.216 --> 00:11:25.452
And then, Jimmy.

174
00:11:25.452 --> 00:11:28.809
&gt;&gt; Is it a matter that
you're redeclaring it?

175
00:11:30.320 --> 00:11:30.960
&gt;&gt; Not really.

176
00:11:33.980 --> 00:11:36.250
&gt;&gt; And it's gonna jump down to 91.

177
00:11:36.250 --> 00:11:37.849
&gt;&gt; Well, we have this one here first.

178
00:11:40.572 --> 00:11:42.690
What setting actual, it's the same name.

179
00:11:42.690 --> 00:11:44.240
&gt;&gt; And what is same name?

180
00:11:44.240 --> 00:11:44.810
&gt;&gt; Inner.

181
00:11:44.810 --> 00:11:47.822
&gt;&gt; Okay, and then, Ryan.

182
00:11:47.822 --> 00:11:51.630
&gt;&gt; Expect, is called
&gt;&gt; Okay, so

183
00:11:51.630 --> 00:11:55.103
we exit this function and go to expect.

184
00:11:58.032 --> 00:11:59.390
You wanna take a stab?

185
00:11:59.390 --> 00:12:07.866
&gt;&gt; Sure,
actual at this point is still inner.

186
00:12:07.866 --> 00:12:17.420
&gt;&gt; So, actual is enter You
have a question about that?

187
00:12:17.420 --> 00:12:22.568
&gt;&gt; So, would that be a case
where if you don't want that

188
00:12:22.568 --> 00:12:27.252
behavior we'd use let to
create a block scope?

189
00:12:27.252 --> 00:12:30.031
&gt;&gt; This is similar to
the example with let.

190
00:12:30.031 --> 00:12:33.724
So, instead of creating the block scope
we're creating a function scope, and

191
00:12:33.724 --> 00:12:35.555
we're doing what's called masking.

192
00:12:35.555 --> 00:12:40.499
So, we're masking the value, because
remember you first look at your most

193
00:12:40.499 --> 00:12:44.763
local scope to get the value,
if you don't have it then you go up.

194
00:12:44.763 --> 00:12:49.320
But if you have it, and you also have on
your parents scope, you only find the one

195
00:12:49.320 --> 00:12:52.740
on your scope because you don't
look up if you find a value.

196
00:12:52.740 --> 00:12:55.280
Does that make sense?

197
00:12:55.280 --> 00:12:57.620
So it's like, what is this?

198
00:12:57.620 --> 00:13:02.435
Head, shoulders, knees and
toes, just like that,

199
00:13:02.435 --> 00:13:07.415
okay, That makes sense to everyone?

200
00:13:11.646 --> 00:13:12.852
What if we did this?

201
00:13:17.327 --> 00:13:19.897
Wait.
&gt;&gt; You copied the next example.

202
00:13:19.897 --> 00:13:20.970
&gt;&gt; Yeah, [LAUGH].

203
00:13:20.970 --> 00:13:24.070
Oops, maybe I've done this too many times.

204
00:13:25.260 --> 00:13:28.015
Okay, or you have a question?

205
00:13:28.015 --> 00:13:28.515
&gt;&gt; Yeah.

206
00:13:29.550 --> 00:13:30.645
Sean's saying,

207
00:13:30.645 --> 00:13:36.270
he's just checking his understanding
if line 87 was declared with a let.

208
00:13:36.270 --> 00:13:40.444
Would we still get the same result
because it's scoped to the block?

209
00:13:40.444 --> 00:13:43.420
&gt;&gt; Yeah, it would still be the same.

210
00:13:43.420 --> 00:13:47.264
Let in this case, doesn't matter.

211
00:13:47.264 --> 00:13:53.935
Let in this case doesn't change anything,
because we have a function scope.

212
00:13:53.935 --> 00:14:00.150
And the let keyword only creates
what's called block scope,

213
00:14:00.150 --> 00:14:05.060
which is something that
we didn't have before.

214
00:14:05.060 --> 00:14:10.418
So, for if else statements we could
have a scope for that, now with let.

215
00:14:10.418 --> 00:14:15.913
Before that, if else statements,
if you declared a variable in a loop,

216
00:14:15.913 --> 00:14:19.336
or in brackets, or
in a switch statement, or

217
00:14:19.336 --> 00:14:23.409
anything like that,
it wasn't local to that block.

218
00:14:23.409 --> 00:14:27.393
And so that would cause kind of some weird
behavior especially if you had like a lot

219
00:14:27.393 --> 00:14:30.750
of FL statements, and
reassigning variables and stuff like that.

220
00:14:30.750 --> 00:14:33.710
And there's also hoisting that happens,
which we'll talk about.

221
00:14:35.890 --> 00:14:38.080
And so it can be misleading.

222
00:14:38.080 --> 00:14:43.477
And so we introduce let by we,
not me at all, I was not involved in that.

223
00:14:43.477 --> 00:14:48.409
Let was introduced into the language which
creates block scope, which enables us to

224
00:14:48.409 --> 00:14:52.452
have variables that are private to
something other than a function.

225
00:14:52.452 --> 00:14:55.610
Before that,
all we had was private function scope.

226
00:14:57.070 --> 00:14:59.310
Any more questions about this one?

227
00:14:59.310 --> 00:15:00.887
&gt;&gt; I'm still not quite getting it.

228
00:15:00.887 --> 00:15:03.891
Because it's looking at actual array.

229
00:15:03.891 --> 00:15:09.446
And actual was defined
as no before this test.

230
00:15:09.446 --> 00:15:16.690
Is that function returning
actual to the outer scope?

231
00:15:16.690 --> 00:15:21.128
&gt;&gt; So, this variable lives in the variable
&gt;&gt; Because it's a global

232
00:15:21.128 --> 00:15:23.220
variable in this kind of context.

233
00:15:23.220 --> 00:15:23.840
&gt;&gt; Yeah.

234
00:15:23.840 --> 00:15:26.570
&gt;&gt; What we change it inside,
it's changed outside.

235
00:15:26.570 --> 00:15:28.430
Okay, no matter
&gt;&gt; Exactly.

236
00:15:28.430 --> 00:15:34.393
So, it's reaching up,
changing it up there so it will be except,

237
00:15:34.393 --> 00:15:38.980
access to anywhere else it
would be the same value.

238
00:15:38.980 --> 00:15:40.892
Yeah, cool.

239
00:15:40.892 --> 00:15:46.833
So, line 94, if an inner and
in array variable share the same name and

240
00:15:46.833 --> 00:15:50.850
the name is referenced in the outer scope.

241
00:15:50.850 --> 00:15:53.890
The outer value binding will be used.

242
00:15:53.890 --> 00:15:55.910
So, this is kind of the opposite
of what we just did.

243
00:15:57.190 --> 00:16:00.390
&gt;&gt; And where we leave on?

244
00:16:03.435 --> 00:16:04.197
What are we trying to move?

245
00:16:04.197 --> 00:16:04.802
95.

246
00:16:04.802 --> 00:16:05.539
&gt;&gt; 95.

247
00:16:05.539 --> 00:16:07.473
&gt;&gt; That's something we just did.

248
00:16:07.473 --> 00:16:11.160
&gt;&gt; Looks very similar, doesn't it?

249
00:16:11.160 --> 00:16:13.360
&gt;&gt; So declaring a variable, same name?

250
00:16:13.360 --> 00:16:17.800
&gt;&gt; Yep, so we declare the variable,
same name, we assign it to outer.

251
00:16:17.800 --> 00:16:21.275
I'll skip ahead,
we are defining a function and

252
00:16:21.275 --> 00:16:25.910
then we call the function,
and then what happens?

253
00:16:25.910 --> 00:16:27.610
&gt;&gt; Thanks for giving me fun stuff.

254
00:16:27.610 --> 00:16:32.499
So inside the function body,
we declare the same name variable and

255
00:16:32.499 --> 00:16:34.940
we give it the value inner?

256
00:16:34.940 --> 00:16:39.310
&gt;&gt; Yep, so same name,
we assign it to inner and then it exits.

257
00:16:40.874 --> 00:16:47.620
Let's see, what happens next?

258
00:16:47.620 --> 00:16:49.824
So we were just here, we just run this.

259
00:16:49.824 --> 00:16:56.942
&gt;&gt; Line 100, set actual equal
to the value sameName which is.

260
00:17:02.392 --> 00:17:03.163
Outer.

261
00:17:03.163 --> 00:17:04.847
&gt;&gt; Yep, which is outer.

262
00:17:04.847 --> 00:17:08.715
And then we should expect actual to equal?

263
00:17:08.715 --> 00:17:09.994
&gt;&gt; Outer.

264
00:17:09.994 --> 00:17:11.209
&gt;&gt; Outer.

265
00:17:15.712 --> 00:17:16.346
Cool.

266
00:17:20.174 --> 00:17:20.850
All right.

267
00:17:27.044 --> 00:17:30.714
So this one a new variable
scope is created for

268
00:17:30.714 --> 00:17:35.261
every call to a function as
exemplified with a counter.

269
00:17:35.261 --> 00:17:37.585
So let's check this out.

270
00:17:37.585 --> 00:17:40.599
Christina you wanna start?

271
00:17:40.599 --> 00:17:47.710
&gt;&gt; Sure, there's a variable
created fn which is a function.

272
00:17:47.710 --> 00:17:52.126
&gt;&gt; We create this function save it in
a variable, and then what happens?

273
00:17:52.126 --> 00:17:54.060
&gt;&gt; Then we run that function?

274
00:17:54.060 --> 00:17:57.240
&gt;&gt; We ran the function, so
we jump into that function body.

275
00:17:57.240 --> 00:17:58.656
And Jamie
&gt;&gt; And

276
00:17:58.656 --> 00:18:01.961
then we're setting inner counter to.

277
00:18:04.868 --> 00:18:06.436
10, basically.

278
00:18:06.436 --> 00:18:11.373
&gt;&gt; Yeah, so we're setting inner
counter to 10 because at this point

279
00:18:11.373 --> 00:18:13.550
inner counter is undefined.

280
00:18:13.550 --> 00:18:16.050
And then Michael, what happens next?

281
00:18:16.050 --> 00:18:21.815
&gt;&gt; We are taking inner counter,
send it to an account of plus one.

282
00:18:21.815 --> 00:18:24.290
&gt;&gt; To inner counter.

283
00:18:24.290 --> 00:18:26.950
&gt;&gt; Yeah I can read it by itself
in the same line, right?

284
00:18:26.950 --> 00:18:28.420
So that would make it 11.

285
00:18:28.420 --> 00:18:29.218
&gt;&gt; Yep.

286
00:18:29.218 --> 00:18:31.474
&gt;&gt; Actual to be set to 11.

287
00:18:31.474 --> 00:18:32.779
&gt;&gt; Yap.

288
00:18:32.779 --> 00:18:36.281
And then so
we exit the body of this function,

289
00:18:36.281 --> 00:18:41.583
we find ourselves on line 113
&gt;&gt; So we expect that to be 11.

290
00:18:41.583 --> 00:18:45.750
&gt;&gt; Yeah, we'll expect that to be 11.

291
00:18:45.750 --> 00:18:51.460
Okay, this is gonna seem repetitive but
it's actually very important.

292
00:18:51.460 --> 00:18:53.986
I should keep going.

293
00:18:53.986 --> 00:18:58.767
I'm like, do you want to but
really what I'm saying is, you have to,

294
00:18:58.767 --> 00:19:03.003
all right, you don't have to,
strongly encouraged [LAUGH].

295
00:19:03.003 --> 00:19:07.998
&gt;&gt; The function is declared again.

296
00:19:07.998 --> 00:19:12.065
&gt;&gt; [CROSSTALK]
&gt;&gt; It's being invoked, yes.

297
00:19:12.065 --> 00:19:16.448
So we call the function and
then we hop back into the function body,

298
00:19:16.448 --> 00:19:17.840
what happens next?

299
00:19:17.840 --> 00:19:24.650
&gt;&gt; So
now we are dealing with inner counters 11.

300
00:19:24.650 --> 00:19:27.260
&gt;&gt; So, what is this line doing?

301
00:19:31.650 --> 00:19:37.118
&gt;&gt; So we say the inner counter
is actually inner counter or 10.

302
00:19:37.118 --> 00:19:38.344
&gt;&gt; So what is inner counter?

303
00:19:38.344 --> 00:19:39.442
&gt;&gt; 11.

304
00:19:39.442 --> 00:19:42.416
&gt;&gt; Where does it say
that we're defining 11?

305
00:19:42.416 --> 00:19:47.849
&gt;&gt; When we define on

306
00:19:47.849 --> 00:19:52.510
line 113.

307
00:19:52.510 --> 00:19:55.156
&gt;&gt; Yeah, so that's a common misconception.

308
00:19:55.156 --> 00:19:59.599
But what happens is whenever you call
a function you create a brand new function

309
00:19:59.599 --> 00:20:00.683
scope every time.

310
00:20:04.429 --> 00:20:05.661
&gt;&gt; So then it's ten?

311
00:20:05.661 --> 00:20:06.807
&gt;&gt; It's ten.

312
00:20:12.364 --> 00:20:17.730
&gt;&gt; So then we say inner counter to b
itself plus one, so that's 211 again.

313
00:20:17.730 --> 00:20:19.962
&gt;&gt; It'd be 11, actual visa to 11.

314
00:20:19.962 --> 00:20:23.860
And we expect actual to equal 11, awesome.

315
00:20:26.270 --> 00:20:27.140
Any questions about that?

316
00:20:28.620 --> 00:20:32.858
So this is another like kind of gotcha,
but very important.

317
00:20:32.858 --> 00:20:37.044
Every time we call a function and
when we get to closures,

318
00:20:37.044 --> 00:20:40.545
this is gonna be really
drilled into your head.

319
00:20:40.545 --> 00:20:44.305
Every time we call a function
with the parentheses,

320
00:20:44.305 --> 00:20:48.160
invocation operator,
a brand new scope is created.

321
00:20:48.160 --> 00:20:52.694
Some people call an execution context,
and so

322
00:20:52.694 --> 00:20:57.234
you can think all
the variables in that scope.

323
00:20:57.234 --> 00:21:01.455
When the function is called, it's gonna
be initialized as whatever they are,

324
00:21:01.455 --> 00:21:02.465
in this case 10.

325
00:21:02.465 --> 00:21:06.180
And then you do it again,
it'll be initialized again.

326
00:21:08.060 --> 00:21:11.970
So they're separate,
they don't talk to each other.

327
00:21:11.970 --> 00:21:16.570
Do just two different worlds of scope.

328
00:21:16.570 --> 00:21:21.880
So next one is a new variable scope is
created for each call to a function

329
00:21:21.880 --> 00:21:26.650
as exemplified with uninitialized
string variables, okay?

330
00:21:27.850 --> 00:21:35.163
So I think we left off with you Ryan
&gt;&gt; Function is named and declared.

331
00:21:35.163 --> 00:21:39.935
&gt;&gt; Yeah, function is named and
declared and then it's called,

332
00:21:39.935 --> 00:21:44.266
we execute the function body,
then what happens next?

333
00:21:50.181 --> 00:21:51.790
&gt;&gt; We're executing function body, sorry.

334
00:21:51.790 --> 00:21:53.900
&gt;&gt; Yeah,
we're executing the function body.

335
00:21:53.900 --> 00:21:56.710
&gt;&gt; Declaring local variable
not giving it ability.

336
00:21:56.710 --> 00:21:59.004
&gt;&gt; Yep, we're declaring this variable,

337
00:21:59.004 --> 00:22:02.110
when it's not declared it
holds the value undefined.

338
00:22:04.310 --> 00:22:06.140
And then we check if it's undefined.

339
00:22:07.880 --> 00:22:12.437
&gt;&gt; Since it is undefined, that'll return
true and we'll execute that statements and

340
00:22:12.437 --> 00:22:15.218
so we'll set actual to this
text the string alpha.

341
00:22:15.218 --> 00:22:17.750
&gt;&gt; Exactly.

342
00:22:17.750 --> 00:22:23.668
And then since we entered into this if
block we will not enter into this else

343
00:22:23.668 --> 00:22:30.070
if so this gets skipped and we go down to
the next line what happens here Cameron?

344
00:22:31.350 --> 00:22:33.690
&gt;&gt; Variable is set to initialized.

345
00:22:33.690 --> 00:22:34.190
&gt;&gt; Yep.

346
00:22:35.530 --> 00:22:37.289
And then Eddie what happens?

347
00:22:37.289 --> 00:22:43.060
&gt;&gt; Then we're going into the expect and

348
00:22:43.060 --> 00:22:46.229
actual will equal.

349
00:22:52.907 --> 00:22:53.589
Alpha.

350
00:22:53.589 --> 00:22:54.336
&gt;&gt; Yep.

351
00:22:58.237 --> 00:23:01.298
Then we're gonna call
the function one more time,

352
00:23:01.298 --> 00:23:03.932
we're gonna enter into the function body,

353
00:23:03.932 --> 00:23:08.506
we're going to initialize this local
variable, what happens next Chris?

354
00:23:08.506 --> 00:23:11.600
&gt;&gt; The local variable is initialized so

355
00:23:11.600 --> 00:23:16.103
it will call the else
statement actual equals omega.

356
00:23:19.683 --> 00:23:20.441
&gt;&gt; So, we actually read.

357
00:23:23.100 --> 00:23:26.720
&gt;&gt; So when we call the new function,
it's gonna create a brand new scope.

358
00:23:28.430 --> 00:23:30.135
&gt;&gt; So it will be undefined again?

359
00:23:30.135 --> 00:23:32.170
&gt;&gt; Yeah, it's okay.

360
00:23:34.270 --> 00:23:37.490
So then what will happen, Audy?

361
00:23:37.490 --> 00:23:41.458
&gt;&gt; Once it's undefined,
we'll set actual to equal alpha.

362
00:23:41.458 --> 00:23:46.240
[INAUDIBLE]
&gt;&gt; And then we go down here,

363
00:23:46.240 --> 00:23:51.680
we set localVariable to initialized,
but this is still alpha.

