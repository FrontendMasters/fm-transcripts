WEBVTT

1
00:00:00.210 --> 00:00:01.750
&gt;&gt; Brian Holt: So welcome back.

2
00:00:01.750 --> 00:00:05.020
Hopefully you're able to
feel your brain a little bit

3
00:00:06.340 --> 00:00:07.830
before we start melting it again.

4
00:00:07.830 --> 00:00:13.870
[LAUGH]
We talked about pathfinding last time.

5
00:00:13.870 --> 00:00:18.466
We gave you the exercise and so what we're
gonna do now is we're gonna go through and

6
00:00:18.466 --> 00:00:21.235
write it together so
we can see what it looks like.

7
00:00:27.344 --> 00:00:33.110
&gt;&gt; Brian Holt: Let's go ahead and
get started.

8
00:00:33.110 --> 00:00:36.860
So the first thing that I'm
gonna do is I'm just gonna make

9
00:00:38.290 --> 00:00:41.070
three different flags of

10
00:00:44.570 --> 00:00:50.140
has this particular note been opened by
no one, has it been opened by someone and

11
00:00:50.140 --> 00:00:54.450
like which person has been opened by or
which origin point rather.

12
00:00:54.450 --> 00:01:00.089
So no one,
&gt;&gt; Brian Holt: Equals

13
00:01:00.089 --> 00:01:05.043
zero Const by A equals 1,

14
00:01:05.043 --> 00:01:09.780
and const by B equals 2.

15
00:01:09.780 --> 00:01:12.710
Now, I could just put those
numbers directly in there, but

16
00:01:12.710 --> 00:01:16.150
the reason why I like doing this is so it
makes my code a little bit more readable.

17
00:01:16.150 --> 00:01:20.430
So if these two aren't equal to each
other it means something's up and

18
00:01:20.430 --> 00:01:23.290
we should investigate.

19
00:01:24.550 --> 00:01:29.680
Wonder why my, well,
it's different, it is what it is.

20
00:01:29.680 --> 00:01:30.540
Okay.

21
00:01:30.540 --> 00:01:34.070
So, we're gonna start by doing that.

22
00:01:34.070 --> 00:01:37.750
Next, we're gonna go start
writing our algorithm.

23
00:01:39.630 --> 00:01:44.270
Actually, lets go ahead and
write Get neighbors as well.

24
00:01:44.270 --> 00:01:46.320
Because this is going to
be a useful function.

25
00:01:46.320 --> 00:01:48.940
Like helper function for
us that we talked about.

26
00:01:48.940 --> 00:01:54.310
The basic idea being if I have
one part of the graph, I'm going

27
00:01:54.310 --> 00:01:59.190
to investigate above it, to the right
of it, below it, and to the left of it.

28
00:02:04.320 --> 00:02:07.612
[COUGH] This will be useful because we
can contain all the logic in therefore,

29
00:02:07.612 --> 00:02:08.744
checking if it's a wall,

30
00:02:08.744 --> 00:02:11.430
checking if it's like all those
various checks we have to do.

31
00:02:13.350 --> 00:02:16.110
That will be useful to kind
of contain in one place.

32
00:02:16.110 --> 00:02:19.880
It will make it testable and
those, you know kind of idea.

33
00:02:19.880 --> 00:02:23.750
So I'm gonna call it getNeighbors and and

34
00:02:23.750 --> 00:02:27.800
it's gonna take in visited,
which is what I'm calling my graph.

35
00:02:29.060 --> 00:02:32.631
And it's gonna take in a point, okay?

36
00:02:38.835 --> 00:02:42.780
&gt;&gt; Brian Holt: So this neighbors
array is gonna be valid neighbors.

37
00:02:42.780 --> 00:02:46.420
This is eventually what I'm
going to return at the bottom.

38
00:02:46.420 --> 00:02:49.571
And then I'm just gonna
go check all the sides.

39
00:02:51.851 --> 00:02:55.974
&gt;&gt; Brian Holt: So
the first thing I'm gonna say is,

40
00:02:55.974 --> 00:03:02.228
if y minus 1,
&gt;&gt; Brian Holt: Is greater than or

41
00:03:02.228 --> 00:03:09.890
equal to 0, again, this is a ligature that
combines those two things together, right?

42
00:03:09.890 --> 00:03:13.880
If I put a space between those
it's less than equal to, but

43
00:03:13.880 --> 00:03:16.550
if I put them together,
that's just my font, right?

44
00:03:18.080 --> 00:03:19.083
Sometimes that confuses people.

45
00:03:22.439 --> 00:03:27.528
&gt;&gt; Brian Holt: And If it's not closed, so

46
00:03:27.528 --> 00:03:33.292
visited y minus 1 x.closed.

47
00:03:33.292 --> 00:03:39.410
This is going to the left, right?

48
00:03:41.010 --> 00:03:44.460
I think so yeah, it's going to the left.

49
00:03:44.460 --> 00:03:48.343
Then we're going to say,

50
00:03:48.343 --> 00:03:53.287
neighbors.push visited y minus

51
00:03:53.287 --> 00:03:58.070
1 of x, this confuses people.

52
00:03:58.070 --> 00:04:03.290
You're used to see X Y, right?

53
00:04:03.290 --> 00:04:07.310
But if you think about it as this
is an array of arrays, right?

54
00:04:07.310 --> 00:04:08.430
This is an array of arrays, right?

55
00:04:08.430 --> 00:04:13.710
So actually the Y column is
represented by the first array and

56
00:04:13.710 --> 00:04:15.640
the X column is represented
by the second array.

57
00:04:15.640 --> 00:04:19.050
Which is why you're gonna do
Y is the first accessor and

58
00:04:19.050 --> 00:04:22.650
X is the second accessor
does that make sense to you?

59
00:04:22.650 --> 00:04:27.430
You can do a bunch of backwards thinking
to get it to go the other way but

60
00:04:27.430 --> 00:04:30.470
just don't [LAUGH] I
promise this is easier.

61
00:04:33.090 --> 00:04:37.840
Okay, so does this make sense
what we're doing right here?

62
00:04:37.840 --> 00:04:42.950
We're just saying If this is
not out of bounds, right,

63
00:04:42.950 --> 00:04:47.260
so if it's not below zero and
it's not closed.

64
00:04:47.260 --> 00:04:50.520
We're going to make this data structure
that's going to make this true later.

65
00:04:50.520 --> 00:04:52.120
But closed just means that it's not a one.

66
00:04:52.120 --> 00:04:55.700
You could have just as easily said,
triple equals one, here, right?

67
00:04:57.240 --> 00:04:59.980
Then put that into a valid neighbor.

68
00:04:59.980 --> 00:05:01.530
And we're gonna do that for
each one of these.

69
00:05:01.530 --> 00:05:05.480
In fact I'm just gonna copy and paste
'cuz we all know that I'm good at that.

70
00:05:08.940 --> 00:05:13.770
So this one we're gonna go right.

71
00:05:13.770 --> 00:05:18.853
So this is gonna be y plus

72
00:05:18.853 --> 00:05:23.683
1 is less than visited

73
00:05:23.683 --> 00:05:28.547
0.length, right?

74
00:05:28.547 --> 00:05:34.570
Again, to the graph that
I'm giving you is a square,

75
00:05:34.570 --> 00:05:40.820
right, so you can just check the row
of the first, the first row's length.

76
00:05:40.820 --> 00:05:45.130
And say is this outside of the bounds
of that particular row, right?

77
00:05:45.130 --> 00:05:45.630
Does that make sense?

78
00:05:47.557 --> 00:05:50.835
&gt;&gt; Brian Holt: And then here,
and it's not closed.

79
00:05:55.700 --> 00:05:57.470
&gt;&gt; Brian Holt: Then push that in, right?

80
00:05:59.990 --> 00:06:03.935
And this is gonna check to the right,
so far so good?

81
00:06:06.212 --> 00:06:10.029
&gt;&gt; Brian Holt: Okay,
let's go ahead and do up.

82
00:06:16.046 --> 00:06:20.546
&gt;&gt; Brian Holt: So now,
we're gonna do x plus 1 is

83
00:06:20.546 --> 00:06:25.214
greater than visited 0.length.

84
00:06:27.663 --> 00:06:29.200
&gt;&gt; Brian Holt: Did I,
I did mess this up, didn't I?

85
00:06:29.200 --> 00:06:35.120
It actually doesn't matter because so
this should be, right?

86
00:06:35.120 --> 00:06:36.780
Yep, that is.

87
00:06:36.780 --> 00:06:40.070
This wasn't a bug because everything
I gave you was a square, too.

88
00:06:40.070 --> 00:06:41.292
Which may not always be true.

89
00:06:41.292 --> 00:06:46.183
But nonetheless,
x plus 1 is less than visited 0.length.

90
00:06:46.183 --> 00:06:50.397
And visited y of x plus 1.

91
00:06:50.397 --> 00:06:56.449
y plus 1.

92
00:06:59.364 --> 00:07:01.038
&gt;&gt; Brian Holt: Then we're
gonna push in neighbors.

93
00:07:03.943 --> 00:07:06.277
&gt;&gt; Brian Holt: Of yx plus1.

94
00:07:09.452 --> 00:07:10.843
&gt;&gt; Brian Holt: Okay?
That was up.

95
00:07:16.637 --> 00:07:17.834
&gt;&gt; Brian Holt: And lastly,
we're gonna go down.

96
00:07:19.095 --> 00:07:22.170
&gt;&gt; Brian Holt: Down, down.

97
00:07:23.410 --> 00:07:25.230
Now, we're doing the get
neighbors function.

98
00:07:25.230 --> 00:07:28.730
We're gonna use that inside of our
function that we're about to write up.

99
00:07:28.730 --> 00:07:32.300
If we were gonna do diagonals as well,
if that was gonna be a valid move,

100
00:07:32.300 --> 00:07:35.080
we would just put some more function or
more checks in here.

101
00:07:35.080 --> 00:07:39.350
To say can I go northeast, can I go
northwest, southeast, southwest, right?

102
00:07:39.350 --> 00:07:43.403
And that's all you would have to do to
add diagonals functionality to this code,

103
00:07:43.403 --> 00:07:44.902
which is pretty cool I think.

104
00:07:49.091 --> 00:07:51.760
&gt;&gt; Brian Holt: So
this is actually down, I believe.

105
00:07:57.146 --> 00:07:58.270
&gt;&gt; Brian Holt: Yeah, it's down.

106
00:08:01.050 --> 00:08:02.036
&gt;&gt; Brian Holt: Cardinality
is a weird thing.

107
00:08:02.036 --> 00:08:08.392
[LAUGH] It all depends on what
perspective you're taking on it.

108
00:08:08.392 --> 00:08:12.290
x + 1, so we're gonna do x- 1 &gt; 0.

109
00:08:24.300 --> 00:08:27.389
&gt;&gt; Brian Holt: Greater than or
equal to cuz you can go to 0.

110
00:08:27.389 --> 00:08:30.760
And this is going to be x- 1.

111
00:08:36.650 --> 00:08:39.631
&gt;&gt; Brian Holt: And the new approach, x- 1.

112
00:08:39.631 --> 00:08:43.810
There we go, okay.

113
00:08:43.810 --> 00:08:47.420
So far, you're just gonna get
all of the valid neighbors.

114
00:08:47.420 --> 00:08:48.610
So that's all this function's gonna do for
you.

115
00:08:48.610 --> 00:08:50.669
And that makes it really easy for

116
00:08:50.669 --> 00:08:55.320
us in the above function to be able
to go through each one of those.

117
00:08:55.320 --> 00:09:00.700
And check if we've intersected and
all that kind of stuff.

118
00:09:00.700 --> 00:09:05.364
So now that we've done that,
let's go back up to our

119
00:09:05.364 --> 00:09:09.610
findShortestPath function and
start on that.

120
00:09:16.955 --> 00:09:20.621
&gt;&gt; Brian Holt: So the first thing what
we're going to do is massage this

121
00:09:20.621 --> 00:09:24.690
maze data structure into something
a little bit more useful.

122
00:09:26.690 --> 00:09:29.508
So I'm gonna call this visited.

123
00:09:29.508 --> 00:09:34.470
And we're gonna do maze.map.

124
00:09:34.470 --> 00:09:40.120
If your not familiar with map, again,
I suggest you check out the first course.

125
00:09:40.120 --> 00:09:43.273
There's a whole section on what is map.

126
00:09:43.273 --> 00:09:47.583
There's also plenty of stuff on
Frontend Masters from Brian Lonsdorf and

127
00:09:47.583 --> 00:09:50.930
Kyle Simpson about functional
programming in general.

128
00:09:50.930 --> 00:09:54.955
But the too long didn't read
version of what map is,

129
00:09:54.955 --> 00:09:58.990
is it's a function that
takes in another function.

130
00:09:58.990 --> 00:10:02.620
And it's going to apply that function
to every item in your array.

131
00:10:02.620 --> 00:10:06.881
Whatever that function returns on that
individual item is going to be the new

132
00:10:06.881 --> 00:10:08.682
value in the array.

133
00:10:08.682 --> 00:10:13.360
So just to give you a really quick
demo of that, if I do 1,2,3.

134
00:10:13.360 --> 00:10:17.666
So an array of 1,2,3 and I say .map.

135
00:10:17.666 --> 00:10:22.183
And now I'm gonna give it a function
that all I want it to do is double

136
00:10:22.183 --> 00:10:24.920
the numbers in the array.

137
00:10:24.920 --> 00:10:28.004
So it's gonna be function, oops, num.

138
00:10:28.004 --> 00:10:34.800
And that's just going to return x x 2,
or num x 2 rather.

139
00:10:38.890 --> 00:10:43.420
&gt;&gt; Brian Holt: So what I would expect
back is to get 2, 4, 6, right?

140
00:10:43.420 --> 00:10:47.320
2, 4, 6, so that's what map does.

141
00:10:47.320 --> 00:10:51.130
Whatever this function does, it's going
to be run on every item in the array.

142
00:10:51.130 --> 00:10:54.370
And then whatever is returned there
is going to be the new array.

143
00:10:54.370 --> 00:10:55.659
So it's a very, very valuable function.

144
00:10:55.659 --> 00:11:00.060
If you're not familiar with it,
I definitely suggest deep diving.

145
00:11:00.060 --> 00:11:02.980
I use this dozens of time a day.

146
00:11:02.980 --> 00:11:06.237
Probably not exaggerating,
probably a dozen times a day.

147
00:11:06.237 --> 00:11:08.000
So that's what we're doing here.

148
00:11:09.460 --> 00:11:10.905
What I showed you here
is a simple example.

149
00:11:10.905 --> 00:11:13.934
But, please go away.

150
00:11:13.934 --> 00:11:16.572
Okay, there we go.

151
00:11:16.572 --> 00:11:21.538
[COUGH] The times that you're gonna
use map are the times that you say,

152
00:11:21.538 --> 00:11:26.860
I have this one array of things and
I want another array of things, right?

153
00:11:26.860 --> 00:11:30.010
I wanna transform this set of things
into this set of things, right?

154
00:11:30.010 --> 00:11:35.170
So in this case,
I have this array of arrays, right?

155
00:11:35.170 --> 00:11:37.739
And what I wanna get back is
an array of array of objects, right?

156
00:11:37.739 --> 00:11:41.530
Because I wanna be able to mark this
has been visited, this is the value.

157
00:11:41.530 --> 00:11:42.438
This is how far away,

158
00:11:42.438 --> 00:11:45.220
I wanna be able to associate some
metadata associated with that.

159
00:11:45.220 --> 00:11:47.500
So that's what I'm gonna
do up here in this map.

160
00:11:49.276 --> 00:11:52.230
&gt;&gt; Brian Holt: So I'm gonna say row map,
and I'm gonna say,

161
00:11:53.860 --> 00:11:57.578
&gt;&gt; Brian Holt: row, y, right?

162
00:11:57.578 --> 00:11:59.809
The second item that you
get in there is the index.

163
00:12:01.570 --> 00:12:04.495
So this is gonna represent wherever
I am in the array on the y axis.

164
00:12:07.336 --> 00:12:07.836
&gt;&gt; Brian Holt: Okay?

165
00:12:10.266 --> 00:12:14.361
&gt;&gt; Brian Holt: Then you have to
keep in mind that row is what?

166
00:12:14.361 --> 00:12:17.230
Row is an array of numbers, right?

167
00:12:17.230 --> 00:12:19.830
Because working with an array
of an array of numbers.

168
00:12:19.830 --> 00:12:21.610
It's a 2D array.

169
00:12:21.610 --> 00:12:24.813
So row is gonna be an array, so

170
00:12:24.813 --> 00:12:29.568
what I wanna do is I
want to return row.map.

171
00:12:29.568 --> 00:12:32.030
So we're going to do
another map inside of here.

172
00:12:32.030 --> 00:12:35.053
So row.map and
this is going to be some point.

173
00:12:35.053 --> 00:12:40.760
Well, we can call it a point or
a cell or whatever you wanna call it.

174
00:12:40.760 --> 00:12:42.160
I think I called it origin.

175
00:12:42.160 --> 00:12:46.580
But let's go with point.

176
00:12:46.580 --> 00:12:47.205
That might make more sense.

177
00:12:47.205 --> 00:12:48.960
It's one point on the graph.

178
00:12:50.390 --> 00:12:54.550
And the index that here is gonna
be represented as the x axis.

179
00:12:54.550 --> 00:12:56.030
Cool, do we follow so far?

180
00:12:59.740 --> 00:13:04.140
&gt;&gt; Brian Holt: Now you could
definitely do this without map.

181
00:13:04.140 --> 00:13:11.190
I just find this to be, it simplifies
the mental model for me, okay?

182
00:13:11.190 --> 00:13:17.440
Now what we're going to do here is
we're going to return an object.

183
00:13:20.150 --> 00:13:22.880
The first thing that I want it
keeping track of, is it closed, right?

184
00:13:23.880 --> 00:13:31.206
We know if a thing is closed if the point
===, again, people find that weird.

185
00:13:31.206 --> 00:13:34.141
That's my ===, right?

186
00:13:34.141 --> 00:13:39.545
So if I say ===, so if you see
the three lines that's what that is.

187
00:13:43.282 --> 00:13:46.300
&gt;&gt; Brian Holt: 1,
then we know that that point is closed.

188
00:13:46.300 --> 00:13:49.030
It's a wall,
you can't go through it, okay?

189
00:13:49.030 --> 00:13:52.500
The length at time of creation is 0,
right?

190
00:13:52.500 --> 00:13:53.806
Because we haven't touched it yet.

191
00:13:53.806 --> 00:13:56.956
openedBy, openedBy,

192
00:13:56.956 --> 00:14:02.250
it's been opened by NO_ONE, right?

193
00:14:02.250 --> 00:14:03.702
Remember this up here?

194
00:14:03.702 --> 00:14:04.788
So that's what that represents.

195
00:14:07.943 --> 00:14:10.792
&gt;&gt; Brian Holt: And then lastly,
we wanna put in the x y value for

196
00:14:10.792 --> 00:14:12.510
every one of these, right?

197
00:14:13.580 --> 00:14:15.850
So you can put x: x.

198
00:14:15.850 --> 00:14:17.700
Because we're using modern JavaScript,
you can just put x and y.

199
00:14:17.700 --> 00:14:21.255
It's the same thing, right?

200
00:14:21.255 --> 00:14:22.901
x: x, or just x.

201
00:14:25.441 --> 00:14:25.941
&gt;&gt; Brian Holt: Cool.

202
00:14:28.390 --> 00:14:32.690
&gt;&gt; Brian Holt: So now I have this really
useful data structure that I can start

203
00:14:32.690 --> 00:14:34.353
working the grid with.

204
00:14:38.880 --> 00:14:41.529
&gt;&gt; Brian Holt: So the first thing I'm
gonna do is I'm going to go mark.

205
00:14:46.254 --> 00:14:54.346
&gt;&gt; Brian Holt: visited [yA] and
[xA] as being visited by itself, right?

206
00:14:54.346 --> 00:14:54.855
That follows.

207
00:14:57.830 --> 00:15:02.638
&gt;&gt; Brian Holt: So openedBy

208
00:15:02.638 --> 00:15:06.968
= BY_A.

209
00:15:06.968 --> 00:15:07.976
Same thing down here for B.

210
00:15:07.976 --> 00:15:11.552
&gt;&gt; [COUGH]
&gt;&gt; Brian Holt: Bless you.

211
00:15:14.420 --> 00:15:18.250
&gt;&gt; Brian Holt: Then after that, we're
going to go mark B as being marked by B.

212
00:15:20.560 --> 00:15:22.030
&gt;&gt; Brian Holt: We still follow?

213
00:15:22.030 --> 00:15:24.260
Right, makes sense that something,
the origin has been opened by itself.

214
00:15:28.585 --> 00:15:34.160
&gt;&gt; Brian Holt: Now we're gonna go and
do two depth first traversals with these.

215
00:15:34.160 --> 00:15:35.910
Or sorry, not depth first, breadth first.

216
00:15:35.910 --> 00:15:37.592
I don't know what I'm talking about.

217
00:15:37.592 --> 00:15:42.050
Keep up, okay, so
just kidding, that's terrible.

218
00:15:43.060 --> 00:15:46.606
let, we're gonna have an aQueue and
a bQueue.

219
00:15:46.606 --> 00:15:50.950
let aQueue, I know it's weird terminology.

220
00:15:52.870 --> 00:15:54.670
So what we're gonna put,
we're gonna put one item in this.

221
00:15:54.670 --> 00:15:55.210
We're gonna put the origin, right?

222
00:15:55.210 --> 00:15:56.860
Cuz that's where we're gonna start.

223
00:15:56.860 --> 00:16:04.249
So we're gonna put Visited yA xA, right?

224
00:16:04.249 --> 00:16:09.545
It's gonna be an array, right,
because when you keep continuing

225
00:16:09.545 --> 00:16:14.950
putting things in there and
take out there, and same thing with pQ.

226
00:16:16.190 --> 00:16:19.490
This is what I was saying, that you could
be clever and do this with one queue,

227
00:16:19.490 --> 00:16:21.070
well, you can't do it with one queue.

228
00:16:21.070 --> 00:16:23.790
But you could do it with one function,
but don't.

229
00:16:23.790 --> 00:16:26.090
This is just a lot clearer
to write this way,

230
00:16:26.090 --> 00:16:31.153
even if it is a little repeating yourself.

231
00:16:35.220 --> 00:16:35.761
&gt;&gt; Brian Holt: Okay, and

232
00:16:35.761 --> 00:16:39.340
then we also have to keep track
of the iteration that we are on.

233
00:16:39.340 --> 00:16:47.900
So let iteration equal zero
because we have to mark.

234
00:16:47.900 --> 00:16:51.580
This is one away, two away, and three
away for the iteration to keep track of.

235
00:16:55.540 --> 00:17:03.574
So now,
down here we are going to have a Y loop,

236
00:17:03.574 --> 00:17:11.615
while aqueue.length &amp;&amp; bqueue.length.

237
00:17:11.615 --> 00:17:15.026
Right, because if we have
a maze that's unsolvable,

238
00:17:15.026 --> 00:17:17.630
eventually one of these is gonna run out.

239
00:17:17.630 --> 00:17:19.710
And if one of them runs out,
you'll instantly know.

240
00:17:19.710 --> 00:17:21.530
It doesn't matter what
the other one is gonna do,

241
00:17:21.530 --> 00:17:23.450
there's no way to get to the other one.

242
00:17:23.450 --> 00:17:27.640
So if that's true, then you're going to
return negative 1 down here at the bottom.

243
00:17:28.870 --> 00:17:32.300
Because, if it's not case,

244
00:17:32.300 --> 00:17:36.209
then we'll know somewhere in the loop
here, we'll just return that number.

245
00:17:41.242 --> 00:17:45.761
&gt;&gt; Brian Holt: Cool, so first thing we're
gonna do is we're gonna start out by going

246
00:17:45.761 --> 00:17:49.370
iteration, plus plus,
cuz it's the next iteration.

247
00:17:50.920 --> 00:17:52.490
And we're going to set.

248
00:17:56.087 --> 00:17:59.160
&gt;&gt; Brian Holt: First thing we're gonna
do is we're gonna go get As neighbors.

249
00:17:59.160 --> 00:18:03.660
So we're gonna say ,const aNeighbors.

250
00:18:11.040 --> 00:18:14.670
So what you need to do is you need to go
through everything that's currently in

251
00:18:14.670 --> 00:18:15.730
the a queue.

252
00:18:15.730 --> 00:18:18.460
I mean, you need to go get
all its neighbors, right?

253
00:18:19.480 --> 00:18:23.880
So if I have four things in the aQueue,
I need to go get all of the neighbors for

254
00:18:23.880 --> 00:18:24.580
all of those, right?

255
00:18:24.580 --> 00:18:29.210
So that could end up being, four times
four, it could be quite a few neighbors.

256
00:18:29.210 --> 00:18:33.300
And as you get further and further out,
you have the potential to have lots and

257
00:18:33.300 --> 00:18:34.359
lots and lots of neighbors.

258
00:18:37.276 --> 00:18:41.426
&gt;&gt; Brian Holt: So you can, however you
want to do this is totally up to you,

259
00:18:41.426 --> 00:18:42.310
right?

260
00:18:42.310 --> 00:18:44.890
You can have a for
loop that keeps them all together.

261
00:18:44.890 --> 00:18:48.600
Me being someone that likes a little
bit more functional approach to things,

262
00:18:48.600 --> 00:18:51.490
you can implement this
fairly easy as a reduce.

263
00:18:52.610 --> 00:18:58.160
So just to give you
the five second version,

264
00:18:58.160 --> 00:19:00.110
maybe 15 second version
of what it reduces.

265
00:19:00.110 --> 00:19:03.240
One, two, three, right, and I say reduce.

266
00:19:03.240 --> 00:19:06.440
This is going to take in a function, but

267
00:19:06.440 --> 00:19:11.420
it's reducing an array of things
down to another something.

268
00:19:11.420 --> 00:19:16.360
So in this particular case, I'm gonna have
usually it's called acc for accumulator.

269
00:19:16.360 --> 00:19:21.530
I did not invent that so and
it's gonna be some number.

270
00:19:21.530 --> 00:19:25.090
And let's just I want to add all
those numbers together, right?

271
00:19:25.090 --> 00:19:30.040
So what I'm going to do is it's
going to return acc plus number.

272
00:19:34.921 --> 00:19:37.870
&gt;&gt; Brian Holt: And this should
just add them all together, right?

273
00:19:37.870 --> 00:19:38.910
So I get six, right?

274
00:19:38.910 --> 00:19:40.760
Which is all of them added together,
right?

275
00:19:40.760 --> 00:19:44.030
So what acc is the result
of the previous iteration.

276
00:19:44.030 --> 00:19:48.910
So it starts out with one because it just
pulls the first item off the list, right?

277
00:19:48.910 --> 00:19:53.180
And then it goes through
[COUGH] it returns that.

278
00:19:53.180 --> 00:19:57.710
So this is going to be one, and
then it's going to add two to it and

279
00:19:57.710 --> 00:19:59.870
then it's gonna add three to it and
then we end up with six, right?

280
00:19:59.870 --> 00:20:01.790
Do we understand more or
less what reduce is?

281
00:20:01.790 --> 00:20:04.800
So the times we wanna use reduce is
when you have an array of something and

282
00:20:04.800 --> 00:20:09.650
you want to basically in some way combine
it with the other elements in the array.

283
00:20:12.222 --> 00:20:16.960
&gt;&gt; Brian Holt: Not quite as useful as map,
but I still use it quite frequently.

284
00:20:16.960 --> 00:20:20.450
Like if I use math 50% of the time,
I use reduce 10% of the time, or

285
00:20:20.450 --> 00:20:21.330
something like that.

286
00:20:25.040 --> 00:20:25.540
Okay.

287
00:20:30.402 --> 00:20:34.075
&gt;&gt; Brian Holt: So
what I'm going to do is, aQueue,

288
00:20:34.075 --> 00:20:37.750
it's going to be a reduce function.

289
00:20:40.605 --> 00:20:43.550
&gt;&gt; Brian Holt: So
it's gonna be that accumulator, right?

290
00:20:43.550 --> 00:20:48.240
Now in this particular case, I have
an array of these various items, right?

291
00:20:50.250 --> 00:20:54.730
What I want to do is I wanna have
an array of all its neighbors.

292
00:20:54.730 --> 00:20:57.140
So that's what I'm gonna
write in terms of a reduce.

293
00:20:57.140 --> 00:21:03.640
So neighbor, and
what I am going to return.

294
00:21:03.640 --> 00:21:11.010
I want to return acc which
is going to be an array.

295
00:21:11.010 --> 00:21:18.039
I'm going to call concat which is,
I'm gonna add another array to it.

296
00:21:19.040 --> 00:21:23.953
That's gonna be a result of

297
00:21:23.953 --> 00:21:29.296
getNeighbors with visited,

298
00:21:29.296 --> 00:21:36.360
neighbor.x and neighbor.y, okay?

299
00:21:36.360 --> 00:21:37.760
You follow so far?

300
00:21:38.910 --> 00:21:43.520
I will also say that this also could be
implemented as a map and flatten, but

301
00:21:43.520 --> 00:21:45.000
we don't have flatten yet.

302
00:21:45.000 --> 00:21:47.420
In fact, if you've been following
the Twitter drama this week,

303
00:21:47.420 --> 00:21:49.810
they're debating if they wanna
call it smush or flatten.

304
00:21:53.293 --> 00:21:55.150
&gt;&gt; Brian Holt: JavaScript is weird.

305
00:21:55.150 --> 00:21:56.270
That's all I'm gonna say.

306
00:21:56.270 --> 00:21:57.460
It's a ridiculous argument.

307
00:21:59.020 --> 00:22:01.328
I'm not upset, okay, let's keep going.

308
00:22:01.328 --> 00:22:06.808
So that's there,
if you don't provide reduced

309
00:22:06.808 --> 00:22:13.090
seed value it just pulls
the first time off the array.

310
00:22:13.090 --> 00:22:16.000
We don't actually want it to be the first
time in the array we want it to be

311
00:22:16.000 --> 00:22:16.540
an empty array.

312
00:22:16.540 --> 00:22:19.130
So that's going to be the first acc,
right?

313
00:22:19.130 --> 00:22:23.884
So the first acc, we want it to be
an array, so that's what we provided here.

314
00:22:30.780 --> 00:22:34.402
&gt;&gt; Brian Holt: So even if this is
a little bit difficult to read for

315
00:22:34.402 --> 00:22:38.644
those of you that are not more
functionally oriented yet.

316
00:22:38.644 --> 00:22:44.312
One, I have faith in you, and, two,
what this does is I have an array of

317
00:22:44.312 --> 00:22:50.140
next notes to process and this just
gets me all of the neighbors of that.

318
00:22:50.140 --> 00:22:54.090
That's what this blob of code does, cool?

319
00:22:55.500 --> 00:22:56.000
Okay.

320
00:22:58.951 --> 00:23:01.692
&gt;&gt; Brian Holt: So next thing I'm gonna do
here is I'm gonna go through every item in

321
00:23:01.692 --> 00:23:03.870
this particular list, and
I'm going to process it.

322
00:23:04.980 --> 00:23:09.390
So I'm gonna say, for

323
00:23:09.390 --> 00:23:12.871
let i equal to 0,

324
00:23:12.871 --> 00:23:18.211
i less than any neighbors,

325
00:23:18.211 --> 00:23:24.490
rather, .length i plus plus.

326
00:23:26.050 --> 00:23:27.130
The typical full loop.

327
00:23:28.870 --> 00:23:32.989
So the current neighbor I'm on.

328
00:23:32.989 --> 00:23:34.790
Let's just put some space there so
you can see.

329
00:23:38.260 --> 00:23:43.900
&gt;&gt; Brian Holt: neighbor equals
aNeighbors of i, right?

330
00:23:43.900 --> 00:23:46.320
That's the current thing that
we're on at this moment in time.

331
00:23:51.760 --> 00:23:56.706
&gt;&gt; Brian Holt: Then, The first thing that

332
00:23:56.706 --> 00:23:59.291
we're going to check
because we're processing a.

333
00:23:59.291 --> 00:24:04.075
If the current neighbor that
we're on has been processed by b,

334
00:24:04.075 --> 00:24:06.280
we've solved it, right?

335
00:24:06.280 --> 00:24:07.990
We've intersected with the other one so
we've found the answer.

336
00:24:07.990 --> 00:24:09.840
So that's the first thing
that we're gonna check.

337
00:24:11.286 --> 00:24:17.362
&gt;&gt; Brian Holt: So
if (neighbor.openedBy === BY_B),

338
00:24:17.362 --> 00:24:22.820
then we have solved the problem, right?

339
00:24:25.450 --> 00:24:29.556
&gt;&gt; Brian Holt: So what you're
gonna do is you're gonna return

340
00:24:29.556 --> 00:24:33.266
neighbor.length + iteration, right?

341
00:24:33.266 --> 00:24:36.227
So that basically means whereever we

342
00:24:36.227 --> 00:24:41.009
are in their currents file plus
the length of the neighbor.

343
00:24:41.009 --> 00:24:45.710
Those added together is gonna be
the correct answer of how far away I was.

344
00:24:45.710 --> 00:24:46.210
Does that make sense?

345
00:24:48.412 --> 00:24:51.730
&gt;&gt; off screen male: What's
neighbor going [INAUDIBLE]

346
00:24:51.730 --> 00:24:52.961
&gt;&gt; Brian Holt: neighbor.length,

347
00:24:52.961 --> 00:24:56.250
if we go up here into this data
structure that we created.

348
00:24:57.500 --> 00:25:00.728
It's how far away it is from its origin,
right?

349
00:25:00.728 --> 00:25:04.773
So if it's opened by b,
it's 10 away from b, right?

350
00:25:04.773 --> 00:25:09.714
So it's going to be the length
of the current node

351
00:25:09.714 --> 00:25:14.304
plus the length of the neighbor node,
yeah?

352
00:25:16.191 --> 00:25:20.728
&gt;&gt; Brian Holt: It is, I assure you, but
let's understand why that is, right?

353
00:25:20.728 --> 00:25:24.844
So can I just,
let's see if I can bring this up, four.

354
00:25:27.324 --> 00:25:34.717
&gt;&gt; Brian Holt: If we're going
out to Pathfinding, right?

355
00:25:34.717 --> 00:25:39.580
So if I meet here, so here.

356
00:25:40.860 --> 00:25:42.795
Iteration is let's say I'm on
this node at the time, right?

357
00:25:42.795 --> 00:25:45.600
The one that I've highlighted there.

358
00:25:45.600 --> 00:25:47.090
If I'm on that node at the time,

359
00:25:47.090 --> 00:25:50.194
iteration is going to be where I am
right now at this moment in time.

360
00:25:50.194 --> 00:25:52.700
So that's going to be 3, right?

361
00:25:52.700 --> 00:25:53.986
And then I find this one,

362
00:25:53.986 --> 00:25:57.241
it's going to be plus the length
that that one is away, right?

363
00:25:57.241 --> 00:26:01.773
So those are the two numbers that we're
adding together to get the correct

364
00:26:01.773 --> 00:26:02.818
answer, yeah?

365
00:26:02.818 --> 00:26:04.750
&gt;&gt; off screen female: Are we
updating the length somewhere?

366
00:26:04.750 --> 00:26:07.400
&gt;&gt; Brian Holt: Yeah, we'll get there.

367
00:26:07.400 --> 00:26:08.219
&gt;&gt; off screen female: Okay, we're not-
&gt;&gt; Brian Holt: Yeah,

368
00:26:08.219 --> 00:26:09.740
we haven't gotten there yet.

369
00:26:09.740 --> 00:26:11.088
&gt;&gt; off screen female: That's
probably why it doesn't make sense.

370
00:26:11.088 --> 00:26:12.421
&gt;&gt; Brian Holt: It's magical.

371
00:26:12.421 --> 00:26:13.429
[LAUGH]
&gt;&gt; off screen female: [LAUGH] I was gonna

372
00:26:13.429 --> 00:26:16.970
say, cuz I'm pretty sure all
the lengths are 0 right now.

373
00:26:16.970 --> 00:26:20.185
&gt;&gt; Brian Holt: Yeah no, I'm gonna call
the sprinkle fairy dust function next.

374
00:26:20.185 --> 00:26:24.351
&gt;&gt; off screen female: [LAUGH]
&gt;&gt; Brian Holt: Yeah, that's a good point.

375
00:26:24.351 --> 00:26:26.340
Fair point, okay.

376
00:26:26.340 --> 00:26:31.012
So if it hasn't been opened by anyone,
then you update the length, so else.

377
00:26:33.708 --> 00:26:35.341
&gt;&gt; Brian Holt: else if,

378
00:26:37.983 --> 00:26:42.512
&gt;&gt; Brian Holt: (neighbor.openedBy

379
00:26:42.512 --> 00:26:46.362
=== NO_ONE).

380
00:26:46.362 --> 00:26:50.989
Then we're gonna do all this updating
that we were talking about, right?

381
00:26:52.290 --> 00:26:54.330
Now there's one more case
that we haven't provided for.

382
00:26:54.330 --> 00:26:56.910
What if it's opened by A?

383
00:26:56.910 --> 00:26:59.420
Just ignore it,
it's already been processed, right?

384
00:27:01.090 --> 00:27:04.204
So a good example of that going back here.

385
00:27:04.204 --> 00:27:07.190
If I'm, let's say, here.

386
00:27:07.190 --> 00:27:08.610
I'm processing this node right here.

387
00:27:08.610 --> 00:27:11.910
It's going to see this node and
it's gonna see this node, right?

388
00:27:11.910 --> 00:27:14.180
Because those are valid neighbors, right?

389
00:27:14.180 --> 00:27:17.020
That's gonna see those
have been open by A.

390
00:27:17.020 --> 00:27:17.850
I'm not gonna check those, right?

391
00:27:17.850 --> 00:27:20.220
They have been checked.

392
00:27:20.220 --> 00:27:22.450
So that's why you're just
ignoring the opened by A case.

393
00:27:22.450 --> 00:27:24.158
Does that make some sense?

394
00:27:24.158 --> 00:27:24.768
Cool.

395
00:27:29.725 --> 00:27:35.970
&gt;&gt; Brian Holt: So first thing we're gonna
say is neighbor.length = iteration.

396
00:27:35.970 --> 00:27:40.491
neighbor.openedBy = BY_A, right?

397
00:27:40.491 --> 00:27:43.390
Cuz it's been opened by A.

398
00:27:43.390 --> 00:27:51.520
And then what we're going to do is we're
going to push it on the aQueue, right?

399
00:27:51.520 --> 00:27:54.309
So that on the next iteration,
up here, it's gonna go okay,

400
00:27:54.309 --> 00:27:57.272
all of its neighbors and
then process all the neighbors, right?

401
00:27:57.272 --> 00:28:00.381
So that's why you push itself on there.

402
00:28:04.758 --> 00:28:06.480
&gt;&gt; Brian Holt: And that's it.

403
00:28:06.480 --> 00:28:08.260
That's how you process the A part.

404
00:28:08.260 --> 00:28:11.815
Now what we're gonna do is
we're just going to copy and

405
00:28:11.815 --> 00:28:13.990
paste this little block of code.

406
00:28:15.494 --> 00:28:16.361
The one thing I did miss.

407
00:28:21.290 --> 00:28:23.030
&gt;&gt; Brian Holt: You could do this
by queueing and dequeuing, right?

408
00:28:23.030 --> 00:28:28.024
So I could have been shifting these things
off instead of saying neighbor.length,

409
00:28:28.024 --> 00:28:29.510
whatever.

410
00:28:29.510 --> 00:28:31.749
What I'm just gonna do here is once
I've processed all the neighbors and

411
00:28:31.749 --> 00:28:32.380
I have them up here.

412
00:28:32.380 --> 00:28:36.490
I'm just gonna say aQueue = new array,
right?

413
00:28:36.490 --> 00:28:38.300
Because you don't wanna
process those things again.

414
00:28:38.300 --> 00:28:39.050
Somehow you have to get
them out of the array.

415
00:28:39.050 --> 00:28:42.156
If you wanna do that by shifting or
whatever,

416
00:28:42.156 --> 00:28:45.690
be destructive on the other array,
that's fine.

417
00:28:45.690 --> 00:28:47.124
Up to you.

418
00:28:47.124 --> 00:28:50.010
Some of the stories each
iteration you need a new queue.

419
00:28:52.110 --> 00:28:54.540
Well, rather it needs to be
cleared out by this point.

420
00:28:54.540 --> 00:28:57.080
In fact, that's actually why
you have to do it this way.

421
00:28:57.080 --> 00:28:59.671
Scratch that, listen to me,
only do it this way.

422
00:28:59.671 --> 00:29:04.485
[LAUGH] Once I've grabbed all
the neighbors, I'm gonna start pushing

423
00:29:04.485 --> 00:29:08.670
things into the new queue to
be processed next time, right?

424
00:29:08.670 --> 00:29:10.302
So that's why I got get all
the neighbors and I reset the queue.

425
00:29:10.302 --> 00:29:12.990
So that I can have a new
queue to work with.

426
00:29:12.990 --> 00:29:14.770
Does that make sense?

427
00:29:14.770 --> 00:29:15.410
Okay.

428
00:29:18.288 --> 00:29:19.900
&gt;&gt; Brian Holt: Sometimes I have
to work through my own problems.

429
00:29:19.900 --> 00:29:23.210
That's what my therapist tells me,
just kidding.

430
00:29:26.670 --> 00:29:30.013
&gt;&gt; Brian Holt: Cool, so
we're gonna do the same thing.

431
00:29:30.013 --> 00:29:33.001
We're just gonna grab
everything like this and

432
00:29:33.001 --> 00:29:36.070
we're just gonna change
everything from a to b.

433
00:29:41.122 --> 00:29:48.570
&gt;&gt; Brian Holt: So bNeighbors = bQueue.

434
00:29:48.570 --> 00:29:49.191
This is all fine.

435
00:29:49.191 --> 00:29:51.458
bQueue= blank.

436
00:29:51.458 --> 00:29:56.248
aNeighbors, bNeighbors, BY_A.

437
00:30:00.810 --> 00:30:07.100
&gt;&gt; Brian Holt: This has been opened BY_B,
and aQueue.

438
00:30:07.100 --> 00:30:08.420
Did I miss any?

439
00:30:13.415 --> 00:30:16.590
&gt;&gt; Brian Holt: Again, you could be
more clever and drive out this.

440
00:30:16.590 --> 00:30:18.980
What's annoying about this is
if you modify anything in here,

441
00:30:18.980 --> 00:30:20.860
you're gonna have to
modify it in two places.

442
00:30:20.860 --> 00:30:21.430
It is annoying.

443
00:30:23.250 --> 00:30:27.340
Just like my personal kind of
mantra of Web development is

444
00:30:27.340 --> 00:30:28.700
only abstract things when you have to.

445
00:30:28.700 --> 00:30:33.020
Because abstractions just make
things tougher in general, right?

446
00:30:33.020 --> 00:30:38.110
Something like this, I would typically
leave in my code, just personally.

447
00:30:38.110 --> 00:30:40.600
But I know this would greatly offend
some people and they're wrong.

448
00:30:40.600 --> 00:30:43.710
So don't listen to them,
[LAUGH] listen to me.

449
00:30:43.710 --> 00:30:45.030
No, I'm just kidding.

450
00:30:45.030 --> 00:30:47.240
Yeah, listen to me at your own risk.

451
00:30:47.240 --> 00:30:48.100
That's a good idea.

452
00:30:48.100 --> 00:30:50.610
Okay, so I think this should work now.

453
00:30:53.292 --> 00:30:59.946
&gt;&gt; Brian Holt: Let's give it a shot,
see what happens, fingers crossed.

454
00:31:03.532 --> 00:31:04.959
&gt;&gt; Brian Holt: First time.

455
00:31:04.959 --> 00:31:11.290
[LAUGH] So let's see what happens
if we go for the other two as well.

456
00:31:11.290 --> 00:31:13.830
So the extra credit ones.

457
00:31:17.850 --> 00:31:19.460
&gt;&gt; Brian Holt: And it does solve.

458
00:31:19.460 --> 00:31:20.656
What happens if there's
no possible path and

459
00:31:20.656 --> 00:31:22.110
it does solve it if they're
next to each other as well?

460
00:31:25.202 --> 00:31:27.740
&gt;&gt; Brian Holt: Any questions,
or rather, what questions?

461
00:31:27.740 --> 00:31:29.789
There's gotta be questions about this.

462
00:31:39.322 --> 00:31:41.372
&gt;&gt; Brian Holt: Either I taught it
perfectly and everyone gets it or

463
00:31:41.372 --> 00:31:43.555
everyone's like no just shut up and
move on, Brian.

464
00:31:43.555 --> 00:31:46.290
[LAUGH] Okay, it's the latter.

465
00:31:46.290 --> 00:31:49.235
I was not expecting that.

466
00:31:49.235 --> 00:31:55.362
[LAUGH]
&gt;&gt; Brian Holt: Conceptually,

467
00:31:55.362 --> 00:31:56.610
does this make sense?

468
00:31:58.510 --> 00:31:59.490
That's the important thing.

469
00:31:59.490 --> 00:32:02.690
Whether or not you actually got the
correct syntax on the page, I'm confident

470
00:32:02.690 --> 00:32:06.850
that if I gave you enough time and you
spent enough hours debugging and crying,

471
00:32:06.850 --> 00:32:08.460
like I did when I was writing this,

472
00:32:08.460 --> 00:32:10.560
that you would come to the correct answer,
right?

473
00:32:12.260 --> 00:32:13.750
Given time we can solve these problems,

474
00:32:13.750 --> 00:32:16.440
but what's important is that you
grasp these conceptually, right?

475
00:32:16.440 --> 00:32:20.940
Cuz later, at some point, it might not
be solving a maze, but maybe it's like

476
00:32:20.940 --> 00:32:24.950
finding the closest edge network in
your CDN or something like that, right?

477
00:32:26.050 --> 00:32:26.820
That's what's important.

478
00:32:26.820 --> 00:32:28.440
Because eventually you're gonna
have this problem that's like,

479
00:32:28.440 --> 00:32:32.690
that looks like a graph that I'm gonna
have to do a breadth-first traversal on.

480
00:32:32.690 --> 00:32:35.010
Those are the kind of patterns
that I want you to recognize.

481
00:32:35.010 --> 00:32:37.770
This is like pathfinding, right?

482
00:32:37.770 --> 00:32:40.890
Cuz this is useful for more than just
finding from point a to point b,

483
00:32:40.890 --> 00:32:43.430
not everyone's gonna look at Google Maps.

484
00:32:43.430 --> 00:32:46.600
But there are a lot of us
have to work with CDNs and

485
00:32:46.600 --> 00:32:48.370
that's just traversing things, right?

486
00:32:48.370 --> 00:32:51.620
So that's what's important about this,

487
00:32:51.620 --> 00:32:53.760
that's what I would really would
like you to get out of this.

488
00:32:55.800 --> 00:32:58.602
All right,
that said is there any questions?

489
00:32:58.602 --> 00:33:00.933
&gt;&gt; off screen female: I have a question?

490
00:33:00.933 --> 00:33:01.522
&gt;&gt; Brian Holt: Yeah.

491
00:33:01.522 --> 00:33:04.446
&gt;&gt; off screen female: So if you go
back to where you're looping through

492
00:33:04.446 --> 00:33:08.795
the neighbors, in the else if statement
for either the b cue or the a cue,

493
00:33:08.795 --> 00:33:13.576
when you're pushing the neighbor back
onto the b cue, that's because you're

494
00:33:13.576 --> 00:33:17.840
gonna come back and reduce again and
get the neighbors of that node.

495
00:33:17.840 --> 00:33:19.430
&gt;&gt; Brian Holt: Yep.
&gt;&gt; off screen female: Okay, okay,

496
00:33:19.430 --> 00:33:21.580
that's the part that just connected.

497
00:33:21.580 --> 00:33:24.440
&gt;&gt; Brian Holt: Yeah, it's a little weird.

498
00:33:24.440 --> 00:33:28.304
So I don't blame you for
having to reason through that out loud.

499
00:33:28.304 --> 00:33:29.260
&gt;&gt; off screen female: Okay [LAUGH].

500
00:33:29.260 --> 00:33:31.550
&gt;&gt; Brian Holt: I talk to myself,
but mostly I just talk to my dog.

501
00:33:31.550 --> 00:33:32.400
She just looks at me.

502
00:33:32.400 --> 00:33:34.430
It's like, I don't care about this.

503
00:33:34.430 --> 00:33:35.280
Just give me treats.

504
00:33:37.830 --> 00:33:42.827
Yes, so you are kind of re-populating so
the next the iteration through then you

505
00:33:42.827 --> 00:33:46.374
can process them again,
right, yep that's accurate.

506
00:33:46.374 --> 00:33:48.260
Okay, cool.

507
00:33:48.260 --> 00:33:51.320
We all get it, this is all perfect,
everyone's really happy about this.

508
00:33:52.630 --> 00:33:53.850
&gt;&gt; off screen male: The question is

509
00:33:55.010 --> 00:33:59.482
she didn't understand why you
would need to clear the aQueue.

510
00:33:59.482 --> 00:34:05.134
&gt;&gt; Brian Holt: Sure let's take
a look at that really quick.

511
00:34:09.696 --> 00:34:14.537
&gt;&gt; Brian Holt: So,
&gt;&gt; Brian Holt: I'm

512
00:34:14.537 --> 00:34:16.080
gonna get aNeighbors, right?

513
00:34:16.080 --> 00:34:17.780
aNeighbors is going to be.

514
00:34:17.780 --> 00:34:22.740
All of the neighbors,
all the valid neighbors for

515
00:34:22.740 --> 00:34:25.036
everything that's currently in my queue,
right?

516
00:34:25.036 --> 00:34:29.130
Why are we clearing out
a queue every single time?

517
00:34:29.130 --> 00:34:35.610
aNeighbors, after we do this line 39
right here, is going to be full of all

518
00:34:35.610 --> 00:34:40.150
of the valid neighbors that we're going
to process on this particular iteration.

519
00:34:40.150 --> 00:34:43.770
What we need to do is aq for the next
iteration, after we finish with this

520
00:34:43.770 --> 00:34:48.770
entire iteration, it needs to be full of
the next set of neighbors to process.

521
00:34:48.770 --> 00:34:53.190
So, after we do this aNeighbors thing,

522
00:34:53.190 --> 00:34:57.330
aq is still going to be full of
the previous neighbors, right?

523
00:34:57.330 --> 00:34:59.340
But we've gotten all the information
that we'd need out of them, so

524
00:34:59.340 --> 00:35:02.310
we don't need to worry about them anymore.

525
00:35:02.310 --> 00:35:05.020
And if we don't clear it out,
we're just going to be adding more and

526
00:35:05.020 --> 00:35:07.880
more things to the queue that we're going
to keep processing over and over and

527
00:35:07.880 --> 00:35:10.080
over and over again,
which we don't need to do.

528
00:35:10.080 --> 00:35:11.890
It would be totally pointless.

529
00:35:11.890 --> 00:35:13.630
So that's why we cleared out.

530
00:35:13.630 --> 00:35:16.620
And then down here we can end queue
a bunch of new things that need to be

531
00:35:16.620 --> 00:35:18.810
processed on the next iteration.

532
00:35:20.480 --> 00:35:22.460
&gt;&gt; Brian Holt: Does that make sense?

533
00:35:25.370 --> 00:35:28.599
&gt;&gt; Brian Holt: I see blank stares so
no, that does not make any sense.

534
00:35:28.599 --> 00:35:32.833
So,
&gt;&gt; Brian Holt: Let's see.

535
00:35:34.963 --> 00:35:37.170
&gt;&gt; Brian Holt: Let's see
if I can show you this way.

536
00:35:37.170 --> 00:35:40.470
All right so, come on.

537
00:35:40.470 --> 00:35:40.970
There we go.

538
00:35:45.063 --> 00:35:47.290
&gt;&gt; Brian Holt: Let's go
all the way to the top.

539
00:35:47.290 --> 00:35:51.190
Make this just a tiny bit smaller so
I can get everything on the page.

540
00:35:51.190 --> 00:35:51.810
Okay.

541
00:35:51.810 --> 00:35:57.060
So, and then make this a little bit
bigger so you can see the code.

542
00:36:00.950 --> 00:36:06.920
&gt;&gt; Brian Holt: So if I'm processing,
let's go with just a queue right now.

543
00:36:06.920 --> 00:36:09.990
So everything that's here
that's marked as two, right?

544
00:36:09.990 --> 00:36:14.480
Would be processing the next
iteration on top of that.

545
00:36:14.480 --> 00:36:19.120
What I need when I process it this time,
is this needs to be enqueued,

546
00:36:19.120 --> 00:36:23.170
this one, this one,
this one and that one, right?

547
00:36:23.170 --> 00:36:26.140
Those all need to be added so
I can process those on the next one.

548
00:36:26.140 --> 00:36:28.240
However, the problem that we have,

549
00:36:28.240 --> 00:36:33.010
particularly with AQ is it's still
full of everything that has two on it.

550
00:36:33.010 --> 00:36:36.040
We have to remove everything that all
those two's because if you don't want to

551
00:36:36.040 --> 00:36:36.640
process them again.

552
00:36:36.640 --> 00:36:39.610
We want to process the three's, and
then the four's, and then the five's.

553
00:36:39.610 --> 00:36:43.020
So that's what we do here is we cleared
out so that there's no more two's and

554
00:36:43.020 --> 00:36:45.770
it's just gonna be full of three's
after this current iteration.

555
00:36:46.800 --> 00:36:48.320
That's why we clear it out.

556
00:36:49.700 --> 00:36:51.560
Does that make more sense?

557
00:36:51.560 --> 00:36:54.280
&gt;&gt; off screen female: So
it is kind of like how we unshifted

558
00:36:54.280 --> 00:36:58.320
the element in our breadth-first search?

559
00:36:58.320 --> 00:37:03.088
But this time, instead of unshifting one
thing, we're unshifting many things.

560
00:37:03.088 --> 00:37:04.660
&gt;&gt; Brian Holt: The whole thing.

561
00:37:04.660 --> 00:37:05.960
That's a very good way of putting it.

562
00:37:05.960 --> 00:37:09.340
That you're basically dequeuing
everything all at once.

563
00:37:09.340 --> 00:37:11.210
Whereas before we had been
doing it one at a time,

564
00:37:11.210 --> 00:37:12.820
we're just doing it a batch at a time.

565
00:37:13.920 --> 00:37:14.420
Yeah.

566
00:37:15.700 --> 00:37:17.500
Do you want to teach?

567
00:37:17.500 --> 00:37:18.200
[LAUGH]
&gt;&gt; off screen female: No, that was my

568
00:37:18.200 --> 00:37:18.720
contribution.

569
00:37:18.720 --> 00:37:19.380
I'm done now.

570
00:37:19.380 --> 00:37:20.950
&gt;&gt; Brian Holt: Okay, well thank you,
that was very valuable.

571
00:37:23.750 --> 00:37:24.250
Cool.

