WEBVTT

1
00:00:00.000 --> 00:00:03.290
&gt;&gt; Bianca Gandolfo: Here are some things
that you usually do as linked lists.

2
00:00:04.530 --> 00:00:07.590
So we talked about deleting
a little bit earlier.

3
00:00:07.590 --> 00:00:09.680
So delete a node in
the middle of a linked list.

4
00:00:09.680 --> 00:00:12.660
So the question here is, how do you
find the middle of a linked list?

5
00:00:12.660 --> 00:00:18.020
How you do this is basically you need
to get the length of the linked list.

6
00:00:18.020 --> 00:00:19.930
You can keep track of this.

7
00:00:19.930 --> 00:00:28.180
So this concept of doing it ahead of time,
or doing it like when you need it.

8
00:00:28.180 --> 00:00:32.580
So if you, for example,
as you add in those into your linked list,

9
00:00:32.580 --> 00:00:34.040
you kept the size, right?

10
00:00:34.040 --> 00:00:37.540
The middle would be easy cuz
you could just use subtraction.

11
00:00:37.540 --> 00:00:43.754
But if you don't then you
would need to calculate that.

12
00:00:43.754 --> 00:00:46.205
So, how do you calculate
the length of a link list?

13
00:00:46.205 --> 00:00:49.391
Is you just have to loop through it,
that while loop that I showed you,

14
00:00:49.391 --> 00:00:51.930
that's the typical way of
looping through a link list.

15
00:00:53.024 --> 00:00:56.220
And then you would find the length,
you would divide that by two, and

16
00:00:56.220 --> 00:00:59.610
then you would loop again
to get to the middle.

17
00:00:59.610 --> 00:01:04.703
And so that's how you get to
the middle of a link list.

18
00:01:04.703 --> 00:01:09.954
So if you wanna delete a duplicate
you need to track duplicates, if you

19
00:01:09.954 --> 00:01:15.751
use an auxiliary data structure like
hash table, that would be pretty easy.

20
00:01:15.751 --> 00:01:21.964
And you could also duplicate, so
when you're deleting a duplicate,

21
00:01:21.964 --> 00:01:26.910
a rule of thumb,
depending on the data structure is, so

22
00:01:26.910 --> 00:01:29.880
there are a few ways you can do it.

23
00:01:29.880 --> 00:01:34.260
Using a hash table's easy cuz
you just loop through and

24
00:01:34.260 --> 00:01:35.880
you save everything
through the hash table.

25
00:01:35.880 --> 00:01:39.880
If it's already saved in the hash table,
the you know you've already seen it.

26
00:01:39.880 --> 00:01:44.290
The other thing you can do is you can
sort the data structure with a link list,

27
00:01:44.290 --> 00:01:47.630
it's kind of a hard
data structure to sort.

28
00:01:47.630 --> 00:01:51.720
It is possible, but it's not a typical
question you will see in an interview.

29
00:01:51.720 --> 00:01:54.690
If it is something, it would be like
a very hard interview I would say.

30
00:01:54.690 --> 00:01:59.882
But you could like merge,
sort and link list.

31
00:01:59.882 --> 00:02:03.961
Or you can ask, is this already sorted?

32
00:02:03.961 --> 00:02:08.581
If it's duplicate question is already
sorted, great, that's easy because then

33
00:02:08.581 --> 00:02:12.290
it's just a linear time thing
where you just loop through.

34
00:02:12.290 --> 00:02:17.110
If there are two values next to each other
that are the same, you just delete one.

35
00:02:17.110 --> 00:02:21.240
If you're going to sort it, whenever
you're sorting automatically think,

36
00:02:21.240 --> 00:02:21.900
and n/logn.

37
00:02:21.900 --> 00:02:26.850
Because sorting on average is gonna be
n/logn, with like the job script dot

38
00:02:26.850 --> 00:02:31.990
sort method,
you can assume that would be the time

39
00:02:31.990 --> 00:02:37.030
complexity of that algorithm.

40
00:02:38.360 --> 00:02:45.346
So there's that, otherwise,
&gt;&gt; Bianca Gandolfo: Yeah,

41
00:02:45.346 --> 00:02:48.770
those are the things I think
about when deleting duplicates.

42
00:02:48.770 --> 00:02:51.760
It's not just gonna be on
a link list there's duplicates.

43
00:02:51.760 --> 00:02:56.568
And erase those duplicates and yeah,

44
00:02:56.568 --> 00:03:00.783
those are the main ones strings.

45
00:03:00.783 --> 00:03:03.920
Strings and Arrays, and Linked List,
and duplicates are the main ones.

46
00:03:03.920 --> 00:03:07.697
Hash Tables you won't
ever have a duplicate.

47
00:03:07.697 --> 00:03:11.252
Stack / Queue you don't really
do a lot of traversing and

48
00:03:11.252 --> 00:03:14.600
searching inside of stack and
a queue you can.

49
00:03:14.600 --> 00:03:18.920
But it's not like the main reason you
would even use that data structure.

50
00:03:18.920 --> 00:03:21.140
So you would see that more
with an array question.

51
00:03:23.530 --> 00:03:27.360
Cool, so reversing a link list.

52
00:03:28.780 --> 00:03:34.090
Basically, you need to remember how
we deleted the second to last node?

53
00:03:34.090 --> 00:03:38.530
That technique is really similar
to reversing a link list,

54
00:03:38.530 --> 00:03:44.380
is that you need to get the one
before each one, if that makes sense.

55
00:03:44.380 --> 00:03:49.020
Or what you can do is you can have
two pointers, and then you can swap.

56
00:03:49.020 --> 00:03:52.720
So a lot of these link list questions
assume that you have two pointers.

57
00:03:54.480 --> 00:03:58.010
One being a slow pointer and
one being a fast pointer.

58
00:03:58.010 --> 00:04:02.820
So the fast pointer goes twice as fast
than the slow pointer, typically.

59
00:04:02.820 --> 00:04:06.840
And so, this one is for kth to
the last node in the linked list cycle

60
00:04:06.840 --> 00:04:09.900
is like the classic problems for
a two pointer linked list.

61
00:04:09.900 --> 00:04:13.200
So if you wanna see if a linked
list contains a cycle,

62
00:04:13.200 --> 00:04:15.970
what you do is you start your pointer.

63
00:04:17.510 --> 00:04:19.010
Let's go to a picture.

64
00:04:19.010 --> 00:04:23.640
You start your pointer, your slow pointer,

65
00:04:23.640 --> 00:04:27.460
would just move one, and
your fast pointer moves two.

66
00:04:27.460 --> 00:04:33.610
So slow pointer starts here, and then
fast pointer starts here, it goes two.

67
00:04:33.610 --> 00:04:35.402
This is a w length and so
it's not that helpful.

68
00:04:35.402 --> 00:04:40.574
But essentially, if the fast pointer and
the slow pointer ever are in

69
00:04:40.574 --> 00:04:46.800
the same node, that means that you have
cycle so that's the trick for that.

70
00:04:46.800 --> 00:04:51.255
And then, for the kth to the last node,

71
00:04:51.255 --> 00:04:56.520
assuming you don't
already know the length,

72
00:04:56.520 --> 00:05:03.278
what you can do is you can have
your first pointer be at zero.

73
00:05:03.278 --> 00:05:10.953
Or at the head, and then your second
pointer be at the head plus k.

74
00:05:10.953 --> 00:05:15.300
And then,
you loop both of them at the same pace.

75
00:05:15.300 --> 00:05:19.746
When your second pointer
gets to the last one,

76
00:05:19.746 --> 00:05:24.317
your first pointer is at
the kth to the last one.

77
00:05:24.317 --> 00:05:28.090
Does that make sense, kind of?
&gt;&gt; Speaker 2: Yeah,

78
00:05:28.090 --> 00:05:32.220
inner outer, kinda like-
&gt;&gt; Bianca Gandolfo: No, it's actually

79
00:05:32.220 --> 00:05:36.750
linear, so every time you loop you're
just moving them at the same time.

80
00:05:36.750 --> 00:05:39.027
So it's always like, i + 1, i+ 1.

81
00:05:39.027 --> 00:05:43.593
Once one hits null, you know that
this one is going to be k places

82
00:05:43.593 --> 00:05:48.970
behind because you're just
looping them at the same speed.

83
00:05:48.970 --> 00:05:51.490
If there's only one loop,
so it's a linear solution.

84
00:05:51.490 --> 00:05:52.090
So it's pretty good.

