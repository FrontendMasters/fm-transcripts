WEBVTT

1
00:00:00.140 --> 00:00:04.020
&gt;&gt; Bianca Gandolfo: So we went over
what to expect at an interview.

2
00:00:04.020 --> 00:00:06.010
What does the process look like.

3
00:00:06.010 --> 00:00:07.900
What are some ways to do well?

4
00:00:07.900 --> 00:00:10.850
What are some ways that you
might have messed up, so

5
00:00:10.850 --> 00:00:14.530
that you can keep these in
mind during your interview?

6
00:00:14.530 --> 00:00:20.550
So once you're actually sitting in
the seat on your on-site or maybe at your

7
00:00:20.550 --> 00:00:25.770
kitchen table, if it's a phone screen,
and you're asked a specific question.

8
00:00:28.400 --> 00:00:33.220
One technique that you can use
to solve it is to think about,

9
00:00:34.640 --> 00:00:39.990
what intuition do I have
about interview questions and

10
00:00:39.990 --> 00:00:43.214
data structures can help
me solve this problem?

11
00:00:43.214 --> 00:00:49.394
So if you're asked a,
&gt;&gt; Bianca Gandolfo: You might be asked for

12
00:00:49.394 --> 00:00:52.342
specific data structure like
reversing a linked list.

13
00:00:52.342 --> 00:00:53.946
That's a classic one.

14
00:00:53.946 --> 00:00:58.770
If you don't know how to do it, we'll do
it today, so that's one you need to know.

15
00:00:58.770 --> 00:01:02.910
But there are other ones where,
another one we'll do today, which is,

16
00:01:02.910 --> 00:01:09.546
how do you keep track of a minimum
value in a stack in constant time?

17
00:01:09.546 --> 00:01:12.324
So you need to think about, okay, so

18
00:01:12.324 --> 00:01:17.793
how can I reason about this problem
based on the data structures I know and

19
00:01:17.793 --> 00:01:21.753
the operations I could do
on these data structures?

20
00:01:21.753 --> 00:01:26.844
And so that's why we're gonna be focusing
on data structures all day today,

21
00:01:26.844 --> 00:01:30.302
part of the day next time,
when we talk about trees.

22
00:01:30.302 --> 00:01:34.016
So we'll do a half day of the tree data
structure, and the rest of it is just,

23
00:01:34.016 --> 00:01:36.933
okay, let's do everything you
could think of with a tree.

24
00:01:36.933 --> 00:01:41.840
Balance it, flip it upside down,
put in a blender, all kinds of stuff and

25
00:01:41.840 --> 00:01:44.863
then the same thing with
graphs the next day.

26
00:01:44.863 --> 00:01:47.807
And so
that's what we're gonna be focusing on, so

27
00:01:47.807 --> 00:01:51.850
what does it, that's why you should care,
what is a data structure?

28
00:01:51.850 --> 00:01:54.668
You guys should probably know
what a data structure is but

29
00:01:54.668 --> 00:01:56.436
it's just an arrangement of data.

30
00:01:56.436 --> 00:01:59.658
You can define a way that you
interact with this data and

31
00:01:59.658 --> 00:02:02.430
the way that it's arranged in memory.

32
00:02:02.430 --> 00:02:08.630
So some data structures are in
contiguous blocks of memory.

33
00:02:08.630 --> 00:02:12.610
Which means they're located
next to each other.

34
00:02:12.610 --> 00:02:15.940
When you think about that,
you often think about an array.

35
00:02:15.940 --> 00:02:18.130
However, JavaScript don't
really work like that, but

36
00:02:18.130 --> 00:02:19.100
you can think about it like that.

37
00:02:19.100 --> 00:02:19.750
That's fine.

38
00:02:23.070 --> 00:02:23.737
What else?

39
00:02:23.737 --> 00:02:25.995
Yeah, so
then you have ordered data structures,

40
00:02:25.995 --> 00:02:28.126
so data structures that
come with some order.

41
00:02:28.126 --> 00:02:33.020
You have hierarchical data structures
that have parent child relationships, and

42
00:02:33.020 --> 00:02:35.700
then you have complex relationships, and

43
00:02:35.700 --> 00:02:40.610
so we need to represent this
somehow in our applications.

44
00:02:40.610 --> 00:02:45.240
And so we can model all kinds of
real-world things using data, but

45
00:02:45.240 --> 00:02:49.510
we just need to structure it
appropriately so that we can do

46
00:02:49.510 --> 00:02:54.210
the particular operations on that data
structure in less than a billion years.

47
00:02:54.210 --> 00:02:58.680
So searching things, sorting things,

48
00:02:58.680 --> 00:03:03.640
getting particular values, these are all
kinds of things that you wanna do

49
00:03:03.640 --> 00:03:07.440
all the time, but
in different scenarios, right?

50
00:03:07.440 --> 00:03:10.310
You can use data structures

51
00:03:12.410 --> 00:03:16.840
to model real world systems,
which we'll do a lot in the graph class.

52
00:03:19.110 --> 00:03:24.380
Or even just, the DOM is a tree.

53
00:03:24.380 --> 00:03:28.214
So you're traversing the DOM all the time
and you need to understand how that works,

54
00:03:28.214 --> 00:03:29.480
so that you know.

55
00:03:29.480 --> 00:03:36.070
Maybe you're traversing a lot of data and
you have a lot of DOM nodes.

56
00:03:36.070 --> 00:03:39.060
And you have a performance bottleneck and
you want to figure out what that is.

57
00:03:39.060 --> 00:03:43.410
Understanding the time complexity and how

58
00:03:45.170 --> 00:03:50.890
traversing something like a tree
works will help you with that.

59
00:03:52.290 --> 00:03:54.370
Here's some common interview
data structures and

60
00:03:54.370 --> 00:03:55.430
kinda what they're used for.

61
00:03:55.430 --> 00:03:56.620
This is very general.

62
00:03:58.430 --> 00:04:02.430
So arrays and strings, you can use
them for any kind of ordered data.

63
00:04:02.430 --> 00:04:05.970
Obviously, strings, we use them for
words and text, things like that.

64
00:04:07.570 --> 00:04:13.620
Hash tables we tend to use
to optimize other things.

65
00:04:16.020 --> 00:04:19.274
We use to optimize,
typically lookup, quick lookup,

66
00:04:19.274 --> 00:04:21.290
that's what hash tables are for.

67
00:04:21.290 --> 00:04:24.340
You're gonna say that
a million times today.

68
00:04:24.340 --> 00:04:28.790
Linked lists, so linked lists, we use
a lot to build other data structures.

69
00:04:28.790 --> 00:04:31.320
So you can use, so under the hood,

70
00:04:31.320 --> 00:04:35.900
you can think of a JavScript array as
a linked list, stacks and queues are often

71
00:04:35.900 --> 00:04:40.180
implemented as a linked list, hash table
collisions are handled with a linked list.

72
00:04:40.180 --> 00:04:45.270
So there's a lot of linked lists
underlying other data structures.

73
00:04:46.500 --> 00:04:51.750
And stacks and queues, we use stacks and
queues in a lot of creative ways,

74
00:04:51.750 --> 00:04:54.650
to keep track of things as
an auxiliary data structure,

75
00:04:54.650 --> 00:04:59.590
when we're solving problems,
so keep that in mind.

76
00:04:59.590 --> 00:05:01.400
And so these are the things
that we're gonna cover today.

77
00:05:02.700 --> 00:05:07.661
And next time we're gonna do trees and
heaps, and we're gonna talk

78
00:05:07.661 --> 00:05:12.536
about arranging data in a hierarchical,
learn how to say that word

79
00:05:12.536 --> 00:05:17.632
before that time, hierarchical way,
and how we can work with that.

80
00:05:17.632 --> 00:05:24.608
And graphs, we're going to be modeling
complex relationships like the Internet or

81
00:05:24.608 --> 00:05:28.551
the world as a map, or
all of the sand on a beach.

82
00:05:28.551 --> 00:05:30.670
Things like that, simple things.

