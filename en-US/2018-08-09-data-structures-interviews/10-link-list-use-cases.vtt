WEBVTT

1
00:00:00.610 --> 00:00:04.100
&gt;&gt; Bianca Gandolfo: A common example for
a linked list in real life is the least

2
00:00:04.100 --> 00:00:11.480
recently used cache, which means that,
it's used for recent searches,

3
00:00:11.480 --> 00:00:16.360
anything that says popular videos,
things like that.

4
00:00:16.360 --> 00:00:22.011
That's a least recently used cache,
which means that it's keeping track of,

5
00:00:22.011 --> 00:00:24.978
you have some amount of space allocated.

6
00:00:24.978 --> 00:00:33.020
And as you add new searches, for example,
you're adding into this data structure.

7
00:00:33.020 --> 00:00:36.620
Once you reach capacity,
it needs to have an exit, right?

8
00:00:36.620 --> 00:00:42.510
This is just like classic caching kind of
process, like you put everything in and

9
00:00:42.510 --> 00:00:49.210
then you have to have a way to take things
out, and these are different strategies.

10
00:00:49.210 --> 00:00:53.000
So the least recently used
will take out the oldest one.

11
00:00:53.000 --> 00:00:56.405
So you could say, it's like a common one.

12
00:00:56.405 --> 00:01:00.236
And there's also a most recently used,
which is D1,

13
00:01:00.236 --> 00:01:05.496
that was the newest one that will be
exited, so we'll keep the older ones.

14
00:01:07.588 --> 00:01:09.320
&gt;&gt; Bianca Gandolfo: So
use a linked list for that.

15
00:01:10.320 --> 00:01:12.273
Like I mentioned, hash tables,

16
00:01:12.273 --> 00:01:15.493
they're gonna use a linked
list underneath the hood.

17
00:01:18.547 --> 00:01:21.197
&gt;&gt; Bianca Gandolfo: Yeah, cool.

18
00:01:21.197 --> 00:01:22.073
Any questions?

19
00:01:23.810 --> 00:01:25.380
Yeah?
&gt;&gt; Speaker 2: So on the screen,

20
00:01:25.380 --> 00:01:27.990
that's a singly linked list?

21
00:01:27.990 --> 00:01:30.070
&gt;&gt; Bianca Gandolfo: Yes.
&gt;&gt; Speaker 2: Right there, okay.

22
00:01:30.070 --> 00:01:35.491
Is it quick or easy to show us what
a doubly linked list would look like?

23
00:01:35.491 --> 00:01:35.991
&gt;&gt; Bianca Gandolfo: Yep.

24
00:01:37.998 --> 00:01:38.998
&gt;&gt; Bianca Gandolfo: Definitely.

25
00:01:40.779 --> 00:01:49.494
&gt;&gt; Bianca Gandolfo: So,
&gt;&gt; Bianca Gandolfo: So

26
00:01:49.494 --> 00:01:52.010
here's a singly linked lists.

27
00:01:52.010 --> 00:01:53.980
A doubly linked list.

28
00:01:53.980 --> 00:01:57.080
So each node looks something like this.

29
00:01:57.080 --> 00:02:00.180
So we have the value,
right, in this case, 1.

30
00:02:00.180 --> 00:02:05.843
We have the next, that if some pointer,
&gt;&gt; Bianca Gandolfo: This

31
00:02:05.843 --> 00:02:07.010
is pseudo code, by the way.

32
00:02:07.010 --> 00:02:08.760
This is not real valid JavaScript.

33
00:02:08.760 --> 00:02:11.290
And then, so
this is a regular linked list.

34
00:02:11.290 --> 00:02:16.660
Every node has these two values or
these two properties, a value and a next.

35
00:02:16.660 --> 00:02:21.460
The next points to the next object,
which also follows this format.

36
00:02:21.460 --> 00:02:24.890
If we are gonna have a doubly linked list,

37
00:02:24.890 --> 00:02:28.817
we just have a previous
that's also a pointer.

38
00:02:28.817 --> 00:02:33.646
It will just point, so the one,
the next points to the two,

39
00:02:33.646 --> 00:02:38.378
the previous often we just
initialize as a no just like this

40
00:02:38.378 --> 00:02:43.229
tail's next is null,
that means there's nothing there.

41
00:02:43.229 --> 00:02:47.972
We need to initialize null instead
of undefined because we want

42
00:02:47.972 --> 00:02:52.536
other programmers to know that
we explicitly set that versus

43
00:02:52.536 --> 00:02:55.140
undefined is set by your runtime.

44
00:02:58.032 --> 00:03:01.730
&gt;&gt; Bianca Gandolfo: Cool,
so this, so if we had this,

45
00:03:01.730 --> 00:03:05.940
then this previous would point to two,

46
00:03:05.940 --> 00:03:10.661
except we can't really draw that here, but

47
00:03:10.661 --> 00:03:14.253
this would point to this object.

48
00:03:18.175 --> 00:03:20.560
&gt;&gt; Speaker 3: Why are you using
the spread operator there?

49
00:03:20.560 --> 00:03:21.790
&gt;&gt; Bianca Gandolfo: That's ellipsis,
sorry.

50
00:03:21.790 --> 00:03:22.300
&gt;&gt; Speaker 3: Okay.

51
00:03:22.300 --> 00:03:22.800
&gt;&gt; Bianca Gandolfo: Yeah.

52
00:03:30.040 --> 00:03:32.100
&gt;&gt; Bianca Gandolfo: Does that help any?

53
00:03:32.100 --> 00:03:34.600
Any other questions?

54
00:03:34.600 --> 00:03:39.070
&gt;&gt; Speaker 3: And the pointer is just
basically just the next value, right?

55
00:03:39.070 --> 00:03:39.629
&gt;&gt; Bianca Gandolfo: Yep, yep.

56
00:03:39.629 --> 00:03:42.070
&gt;&gt; Speaker 3: It's not
like a cryptic code.

57
00:03:42.070 --> 00:03:44.140
It is just like, hey, next value in this?

58
00:03:44.140 --> 00:03:44.700
&gt;&gt; Bianca Gandolfo: Yeah.

59
00:03:44.700 --> 00:03:46.770
&gt;&gt; Speaker 3: Structure is that?

60
00:03:46.770 --> 00:03:48.760
&gt;&gt; Bianca Gandolfo: Well,
it's actually the next node.

61
00:03:48.760 --> 00:03:49.922
So it points to an object.

62
00:03:49.922 --> 00:03:52.046
It doesn't point to the value.

63
00:03:52.046 --> 00:03:53.080
&gt;&gt; Speaker 3: Okay.

64
00:03:53.080 --> 00:03:53.580
&gt;&gt; Bianca Gandolfo: Yeah.

65
00:03:55.150 --> 00:03:57.480
So that's because, so
since it points to the object,

66
00:03:57.480 --> 00:04:01.340
if we change this value,
it would still point to that node.

67
00:04:01.340 --> 00:04:02.363
&gt;&gt; Speaker 3: If it doesn't match,
so you can replace the value?

68
00:04:02.363 --> 00:04:05.131
&gt;&gt; Bianca Gandolfo: Mm-hm, yeah, exactly.

