WEBVTT

1
00:00:00.610 --> 00:00:04.100
&gt;&gt; Bianca Gandolfo: A common example for
a linked list in real life is the least

2
00:00:04.100 --> 00:00:11.480
recently used cache, which means that,
it's used for recent searches,

3
00:00:11.480 --> 00:00:16.360
anything that says popular videos,
things like that.

4
00:00:16.360 --> 00:00:22.011
That's a least recently used cache,
which means that it's keeping track of,

5
00:00:22.011 --> 00:00:24.978
you have some amount of space allocated.

6
00:00:24.978 --> 00:00:33.020
And as you add new searches, for example,
you're adding into this data structure.

7
00:00:33.020 --> 00:00:36.620
Once you reach capacity,
it needs to have an exit, right?

8
00:00:36.620 --> 00:00:42.510
This is just like classic caching kind of
process, like you put everything in and

9
00:00:42.510 --> 00:00:49.210
then you have to have a way to take things
out, and these are different strategies.

10
00:00:49.210 --> 00:00:53.000
So the least recently used
will take out the oldest one.

11
00:00:53.000 --> 00:00:56.405
So you could say, it's like a common one.

12
00:00:56.405 --> 00:00:59.237
And there's also a most recently used,

13
00:00:59.237 --> 00:01:03.483
which is D1, that was the newest
one that will be exited, so

14
00:01:03.483 --> 00:01:07.726
we'll keep the older ones.
&gt;&gt; Bianca Gandolfo: So

15
00:01:07.726 --> 00:01:09.320
use a linked list for that.

16
00:01:10.320 --> 00:01:14.856
Like I mentioned, hash tables,
they're gonna use a linked list underneath

17
00:01:14.856 --> 00:01:21.197
the hood.
&gt;&gt; Bianca Gandolfo: Yeah, cool.

18
00:01:21.197 --> 00:01:22.073
Any questions?

19
00:01:23.810 --> 00:01:25.380
Yeah?
&gt;&gt; Speaker 2: So on the screen,

20
00:01:25.380 --> 00:01:28.330
that's a singly linked list?
&gt;&gt; Bianca Gandolfo: Yes.

21
00:01:28.330 --> 00:01:30.070
&gt;&gt; Speaker 2: Right there, okay.

22
00:01:30.070 --> 00:01:34.564
Is it quick or easy to show us
what a doubly linked list would

23
00:01:34.564 --> 00:01:35.522
look like?
&gt;&gt; Bianca Gandolfo: Yep.

24
00:01:37.998 --> 00:01:38.998
&gt;&gt; Bianca Gandolfo: Definitely.

25
00:01:40.779 --> 00:01:41.375
&gt;&gt; Bianca Gandolfo: So,

26
00:01:49.362 --> 00:01:49.956
&gt;&gt; Bianca Gandolfo: So here's

27
00:01:49.956 --> 00:01:52.010
a singly linked lists.

28
00:01:52.010 --> 00:01:53.980
A doubly linked list.

29
00:01:53.980 --> 00:01:57.080
So each node looks something like this.

30
00:01:57.080 --> 00:02:00.180
So we have the value,
right, in this case, 1.

31
00:02:00.180 --> 00:02:05.843
We have the next, that if some pointer,
&gt;&gt; Bianca Gandolfo: This

32
00:02:05.843 --> 00:02:07.010
is pseudo code, by the way.

33
00:02:07.010 --> 00:02:08.760
This is not real valid JavaScript.

34
00:02:08.760 --> 00:02:11.290
And then, so
this is a regular linked list.

35
00:02:11.290 --> 00:02:16.660
Every node has these two values or
these two properties, a value and a next.

36
00:02:16.660 --> 00:02:21.460
The next points to the next object,
which also follows this format.

37
00:02:21.460 --> 00:02:24.890
If we are gonna have a doubly linked list,

38
00:02:24.890 --> 00:02:28.817
we just have a previous
that's also a pointer.

39
00:02:28.817 --> 00:02:33.646
It will just point, so the one,
the next points to the two,

40
00:02:33.646 --> 00:02:38.378
the previous often we just
initialize as a no just like this

41
00:02:38.378 --> 00:02:43.229
tail's next is null,
that means there's nothing there.

42
00:02:43.229 --> 00:02:48.419
We need to initialize null instead
of undefined because we want other

43
00:02:48.419 --> 00:02:53.521
programmers to know that we explicitly
set that versus undefined is

44
00:02:53.521 --> 00:02:58.797
set by your runtime.
&gt;&gt; Bianca Gandolfo: Cool,

45
00:02:58.797 --> 00:03:05.940
so this, so if we had this,
then this previous would point to two,

46
00:03:05.940 --> 00:03:10.661
except we can't really draw that here, but

47
00:03:10.661 --> 00:03:18.285
this would point to this object.
&gt;&gt; Speaker 3: Why

48
00:03:18.285 --> 00:03:20.910
are you using the spread operator there?
&gt;&gt; Bianca Gandolfo: That's

49
00:03:20.910 --> 00:03:21.790
ellipsis, sorry.

50
00:03:21.790 --> 00:03:22.689
&gt;&gt; Speaker 3: Okay.
&gt;&gt; Bianca Gandolfo: Yeah.

51
00:03:30.040 --> 00:03:32.100
&gt;&gt; Bianca Gandolfo: Does that help any?

52
00:03:32.100 --> 00:03:36.201
Any other questions?
&gt;&gt; Speaker 3: And the pointer is just

53
00:03:36.201 --> 00:03:39.629
basically just the next value, right?
&gt;&gt; Bianca Gandolfo: Yep, yep.

54
00:03:39.629 --> 00:03:40.754
&gt;&gt; Speaker 3: It's not like

55
00:03:40.754 --> 00:03:42.070
a cryptic code.

56
00:03:42.070 --> 00:03:44.700
It is just like, hey, next value in this?
&gt;&gt; Bianca Gandolfo: Yeah.

57
00:03:44.700 --> 00:03:46.770
&gt;&gt; Speaker 3: Structure is that?

58
00:03:46.770 --> 00:03:47.570
&gt;&gt; Bianca Gandolfo: Well, it's actually

59
00:03:47.570 --> 00:03:48.760
the next node.

60
00:03:48.760 --> 00:03:49.922
So it points to an object.

61
00:03:49.922 --> 00:03:52.046
It doesn't point to the value.

62
00:03:52.046 --> 00:03:53.330
&gt;&gt; Speaker 3: Okay.
&gt;&gt; Bianca Gandolfo: Yeah.

63
00:03:55.150 --> 00:03:59.560
So that's because, so since it points
to the object, if we change this value,

64
00:03:59.560 --> 00:04:01.826
it would still point to that node.
&gt;&gt; Speaker 3: If it doesn't match, so

65
00:04:01.826 --> 00:04:05.131
you can replace the value?
&gt;&gt; Bianca Gandolfo: Mm-hm, yeah, exactly.

