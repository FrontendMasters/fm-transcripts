WEBVTT

1
00:00:00.170 --> 00:00:02.100
&gt;&gt; Bianca Gandolfo: Okay so,
if I was learning linked list for

2
00:00:02.100 --> 00:00:06.140
the first time and
you wanted to give me some key advice,

3
00:00:06.140 --> 00:00:09.520
what would it be?
&gt;&gt; Speaker 2: Being able to reference

4
00:00:09.520 --> 00:00:12.145
your head and your tail as vital
to your survival of the linked

5
00:00:12.145 --> 00:00:13.670
list?
&gt;&gt; Bianca Gandolfo: Yeah.

6
00:00:13.670 --> 00:00:18.670
Holding those references, super key.
&gt;&gt; Bianca Gandolfo: What else?

7
00:00:18.670 --> 00:00:20.600
What about when you iterate through it?

8
00:00:20.600 --> 00:00:25.774
What about iterating backwards?
&gt;&gt; Bianca Gandolfo: Can you

9
00:00:25.774 --> 00:00:32.780
do that?
&gt;&gt; Bianca Gandolfo: Why not?

10
00:00:32.780 --> 00:00:33.768
&gt;&gt; Speaker 2: Only if it's a w.

11
00:00:33.768 --> 00:00:34.520
&gt;&gt; Bianca Gandolfo: Only if it's a w.

12
00:00:34.520 --> 00:00:35.024
&gt;&gt; Speaker 2: Then it's going back

13
00:00:35.024 --> 00:00:35.598
and forth.
&gt;&gt; Bianca Gandolfo: Yep,

14
00:00:35.598 --> 00:00:42.145
absolutely.
&gt;&gt; Bianca Gandolfo: Or

15
00:00:42.145 --> 00:00:46.881
you can't usually do it, at least.
&gt;&gt; Speaker 3: Yes,

16
00:00:46.881 --> 00:00:49.877
I have a question that I think maybe
pertains to my misunderstanding of how

17
00:00:49.877 --> 00:00:51.502
memory actually works.
&gt;&gt; Bianca Gandolfo: Sure.

18
00:00:51.502 --> 00:00:52.152
&gt;&gt; Speaker 3: But we said

19
00:00:52.152 --> 00:00:57.006
earlier on that linked list are often
used to compose of their data structures.

20
00:00:57.006 --> 00:00:57.798
&gt;&gt; Bianca Gandolfo: Mm-hm.

21
00:00:57.798 --> 00:00:58.792
&gt;&gt; Speaker 3: But they seemed so

22
00:00:58.792 --> 00:01:02.120
much scarier and
more complex than other data structures.

23
00:01:02.120 --> 00:01:06.382
I mean is there something like overhead
for attaching these extra properties or

24
00:01:06.382 --> 00:01:07.716
is it just like yeah, for

25
00:01:07.716 --> 00:01:12.108
implementation it's actually memory clutch
application is so different that it

26
00:01:12.108 --> 00:01:14.720
doesn't matter or it's the.
&gt;&gt; Bianca Gandolfo: So I'm hearing two

27
00:01:14.720 --> 00:01:19.010
things, I'm hearing that seems a lot more
complicated than other data structures and

28
00:01:19.010 --> 00:01:22.710
also is it actually faster?
&gt;&gt; Speaker 3: Yeah,

29
00:01:22.710 --> 00:01:25.330
yeah.
&gt;&gt; Bianca Gandolfo: And so I think for

30
00:01:25.330 --> 00:01:28.500
the computer they don't
care about complexity.

31
00:01:28.500 --> 00:01:33.160
They just care about in terms of what we
think reasoning about something might be

32
00:01:33.160 --> 00:01:39.033
difficult for us, a computer doesn't care.
&gt;&gt; Bianca Gandolfo: The things

33
00:01:39.033 --> 00:01:43.421
that are complex are the things

34
00:01:43.421 --> 00:01:48.430
that are slow on a linked list.

35
00:01:48.430 --> 00:01:56.516
It really just,
&gt;&gt; Bianca Gandolfo: Basically,

36
00:01:56.516 --> 00:02:01.720
if you don't want to, if you're.

37
00:02:03.590 --> 00:02:07.100
If you are trying to operate on
the ends of a data structure,

38
00:02:07.100 --> 00:02:11.130
either the beginning or the end,
the linked list is gonna be fast for that.

39
00:02:11.130 --> 00:02:14.670
It's not gonna be the answer for
everything.

40
00:02:14.670 --> 00:02:18.610
As you can see, if we're trying to remove
a node without a reference to the previous

41
00:02:18.610 --> 00:02:20.470
node, we actually have to loop through it.

42
00:02:20.470 --> 00:02:23.220
However, if you have the reference
to the previous node,

43
00:02:23.220 --> 00:02:26.010
you can delete the next node
very easily in constant time.

44
00:02:26.010 --> 00:02:31.540
So these are details that kind of make or
break the data structure.

45
00:02:31.540 --> 00:02:36.400
And so the fact that they're
being implemented under the hood

46
00:02:36.400 --> 00:02:38.110
of other data structures.

47
00:02:38.110 --> 00:02:42.464
The people who are writing the spec for
the language and

48
00:02:42.464 --> 00:02:48.626
the implementation of it are the ones
who are deciding what's best for this.

49
00:02:48.626 --> 00:02:53.843
What technical remove
method would we use if we

50
00:02:53.843 --> 00:02:59.230
are talking about
collisions on a hash table.

51
00:02:59.230 --> 00:03:02.580
So I know that answers your question.

52
00:03:02.580 --> 00:03:03.290
Kind of hand wavy.

53
00:03:03.290 --> 00:03:07.400
But it really depends and
you probably won't be

54
00:03:09.620 --> 00:03:12.860
necessarily like in an interview,
you're not gonna sit down.

55
00:03:12.860 --> 00:03:14.710
They're not gonna sit down and like okay.

56
00:03:14.710 --> 00:03:19.529
Write a hash table from scratch,
handle detections, use a linked list or

57
00:03:19.529 --> 00:03:23.080
handle collision,
use a linked list to remediate that.

58
00:03:23.080 --> 00:03:27.000
That's probably not a question
you're gonna get, but

59
00:03:27.000 --> 00:03:32.290
underneath the hood when
you are creating an object.

60
00:03:32.290 --> 00:03:36.210
Maybe one of your keys does have a
collision and underneath the hood, someone

61
00:03:36.210 --> 00:03:41.210
took the time to implement a linked
list because that made sense for them.

62
00:03:41.210 --> 00:03:43.790
That is not the only way to handle
collisions, it is just one example.

63
00:03:44.930 --> 00:03:51.160
I don't actually know what the job script
implementation uses to handle collisions.

