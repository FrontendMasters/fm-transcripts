WEBVTT

1
00:00:00.000 --> 00:00:02.716
&gt;&gt; Spencer Schneidenbach: Let's
switch on to operators.

2
00:00:02.716 --> 00:00:06.100
Just like in javascript, just like
in pretty much every other language,

3
00:00:06.100 --> 00:00:07.684
there are things that you can use,

4
00:00:07.684 --> 00:00:11.034
operators that you can use to create
what are called binary statements.

5
00:00:11.034 --> 00:00:15.956
And those binary statements can do a whole
lot of things, they can compare values,

6
00:00:15.956 --> 00:00:18.718
they can change values,
they can add values.

7
00:00:18.718 --> 00:00:21.680
And you've got all of the usual
suspects here, of course,

8
00:00:21.680 --> 00:00:25.723
we've already seen that for our add
numbers method, we've already seen that.

9
00:00:25.723 --> 00:00:29.478
We know how to add integer here, a plus b.

10
00:00:29.478 --> 00:00:33.698
We also have a minus b if we
wanna subtract multiplication and

11
00:00:33.698 --> 00:00:38.267
division, all handled by an asterisk and
a slash respectively.

12
00:00:38.267 --> 00:00:43.334
We also saw modulus, which is checking,
the is basically doing,

13
00:00:43.334 --> 00:00:48.051
what is the remainder of two
integers that are being divided?

14
00:00:48.051 --> 00:00:50.939
What is the remaining value?

15
00:00:50.939 --> 00:00:56.034
I've only really seen that used in
context of checking to see if something

16
00:00:56.034 --> 00:01:00.480
is equal to is even, but
that operator does exist if you need it.

17
00:01:00.480 --> 00:01:03.717
Now here's an interesting one,

18
00:01:03.717 --> 00:01:09.497
there's the increment operator,
which will, in place,

19
00:01:09.497 --> 00:01:14.709
increment the value of an integer or
very or a number.

20
00:01:14.709 --> 00:01:19.632
So let's take, for example, this is a,
this is kind of a weird behavior,

21
00:01:19.632 --> 00:01:21.439
so you have to bear with me.

22
00:01:21.439 --> 00:01:24.339
So if you have the ++ on
the right side of the variable,

23
00:01:24.339 --> 00:01:28.690
it will increment that variable, but it's
not gonna do it before it returns this.

24
00:01:28.690 --> 00:01:33.517
So if you set b to the value of a++,
it's going to set b to 5 and

25
00:01:33.517 --> 00:01:38.907
then a to 6, which is kinda goofy and
a little bit counter intuitive.

26
00:01:38.907 --> 00:01:40.697
And the opposite is.

27
00:01:40.697 --> 00:01:44.411
Yes, the opposite is true, which is,
if you put the ++ at the beginning of

28
00:01:44.411 --> 00:01:48.475
the a it will increment it before it does
anything else, then return the value, and

29
00:01:48.475 --> 00:01:50.296
then they would have the same value.

30
00:01:50.296 --> 00:01:55.860
So most of the time I see, if I'm
seeing this, it's value equals zero,

31
00:01:55.860 --> 00:02:00.344
I just see value++,
typically I see it standing alone.

32
00:02:00.344 --> 00:02:04.769
And the reason I see it standing alone is
because I think that the other way is just

33
00:02:04.769 --> 00:02:09.214
a little bit confusing, but it's very
common to just increment a number by 1.

34
00:02:09.214 --> 00:02:12.089
The decrement operator is the same thing,
but

35
00:02:12.089 --> 00:02:15.194
actually subtracting 1
from the value instead.

36
00:02:15.194 --> 00:02:18.684
So this particular web page,

37
00:02:18.684 --> 00:02:24.137
has a ton of examples of
that you can look over.

38
00:02:24.137 --> 00:02:26.783
We've seen some of
the relational operators, so

39
00:02:26.783 --> 00:02:30.374
we've seen double equals again,
this is a strict double equal, so

40
00:02:30.374 --> 00:02:34.926
it will not work on variables of different
types, it will not attempt type coercion.

41
00:02:34.926 --> 00:02:38.827
It's very strict and
safe like that, which I like, and

42
00:02:38.827 --> 00:02:41.815
the not equal to is exactly, the same way.

43
00:02:41.815 --> 00:02:48.323
So string name equals go
Marc now if value does not

44
00:02:48.323 --> 00:02:53.411
equal name, we won't even compile.

45
00:02:53.411 --> 00:02:56.374
It won't even it wouldn't even
try to compare the values, and

46
00:02:56.374 --> 00:02:57.954
that's done very purposely.

47
00:02:57.954 --> 00:03:02.047
There's some things that
are surprises in some languages, but

48
00:03:02.047 --> 00:03:06.063
c sharp is very good about trying
to minimize those surprises so

49
00:03:06.063 --> 00:03:09.730
it definitely respects
the types that are established.

50
00:03:09.730 --> 00:03:14.896
Let's see greater than, less than greater
than or equal to and less than or

51
00:03:14.896 --> 00:03:19.995
equal to, which, again, are usual
suspects in the programming world.

52
00:03:19.995 --> 00:03:25.897
So this is another binary operator where
we say, if this value is greater than or

53
00:03:25.897 --> 00:03:31.641
equal to seven, we wanna run some code
Console.WriteLine run this code.

54
00:03:31.641 --> 00:03:36.501
As you can imagine, this will not
execute because this value of 0 is not

55
00:03:36.501 --> 00:03:41.121
greater than or equal to seven, and
we can see that, and we just go.

56
00:03:41.121 --> 00:03:45.872
Go, kill that run this boom, go.

57
00:03:45.872 --> 00:03:51.093
But if we invert this value,you'll
see that the code does get run and

58
00:03:51.093 --> 00:03:56.494
that the statement is printed to
the console.This returns a boolean,

59
00:03:56.494 --> 00:04:01.010
so that means that you can declare
this as a boolean as well.

60
00:04:01.010 --> 00:04:04.858
Is less than or equal to seven,

61
00:04:04.858 --> 00:04:09.594
you can see that that declares a bool,

62
00:04:09.594 --> 00:04:13.445
is less than or equal to seven.

63
00:04:13.445 --> 00:04:17.962
I'm gonna anticipate the question, do I
really spell out my variables like this?

64
00:04:17.962 --> 00:04:21.949
Bet you're behind, I do,
I very much, am a fan of explicit,

65
00:04:21.949 --> 00:04:24.579
easy to read, reads like English code.

66
00:04:24.579 --> 00:04:28.628
I don't like a lot of magic in my
software, I don't like a lot of magic in

67
00:04:28.628 --> 00:04:32.290
my coding platform, and
I don't like a lot of magic in general.

68
00:04:32.290 --> 00:04:36.923
I like to be as explicit
as I possibly can be.

69
00:04:36.923 --> 00:04:41.860
Let's see, yes, this one,
I definitely want to cover the logical,

70
00:04:41.860 --> 00:04:46.212
the conditional "and", the logical "and",
conditional logical "or"

71
00:04:46.212 --> 00:04:50.331
logical "or". I call them the double "and"
or the single "and".

72
00:04:50.331 --> 00:04:54.860
And I almost never use single and,
so let's take a,

73
00:04:54.860 --> 00:04:58.283
let's declare this as a another bool and

74
00:04:58.283 --> 00:05:03.335
we say is equal to zero, and
that's value is equal to zero.

75
00:05:03.335 --> 00:05:10.894
So, as I mentioned, is less than or
equal to seven, if we do is equal to zero.

76
00:05:10.894 --> 00:05:13.737
No matter what because this is an "or"

77
00:05:13.737 --> 00:05:19.129
this will basically return true
if either side of this equation,

78
00:05:19.129 --> 00:05:24.340
or either side of the,
this binary operation is equal to true.

79
00:05:24.340 --> 00:05:30.238
The important difference between that and
the double "or" is that this will not run,

80
00:05:30.238 --> 00:05:34.868
this will not be checked if this
executes and this returns true.

81
00:05:34.868 --> 00:05:39.586
It's called short circuiting and it's
a very important feature to understand.

82
00:05:39.586 --> 00:05:45.153
And this has implications, because
the implications being that in addition to

83
00:05:45.153 --> 00:05:50.470
doing variables, you could absolutely
have a method that's public bool,

84
00:05:50.470 --> 00:05:52.730
static bool IsSpencerAround.

85
00:05:56.363 --> 00:06:01.868
&gt;&gt; Spencer Schneidenbach: String,
name, return

86
00:06:01.868 --> 00:06:07.653
name.Equals("Spencer").

87
00:06:07.653 --> 00:06:12.537
This has implications because you might
have an operation inside of this that does

88
00:06:12.537 --> 00:06:14.247
something to the database.

89
00:06:14.247 --> 00:06:17.914
That does something that does some kind
of operation, some kind of mutation,

90
00:06:17.914 --> 00:06:19.758
some kind of change to another system.

91
00:06:19.758 --> 00:06:21.593
There may be a very Important,

92
00:06:21.593 --> 00:06:25.557
there may be a situation where you
don't wanna execute this code.

93
00:06:25.557 --> 00:06:29.510
There may be a situation where you
don't wanna execute this code, but

94
00:06:29.510 --> 00:06:31.794
you wanna do an "and" comparison instead.

95
00:06:31.794 --> 00:06:36.715
So in this case, if this is true or
if this is false, excuse me, this will

96
00:06:36.715 --> 00:06:41.737
not execute because it says, well,
both of those things have to be true.

97
00:06:41.737 --> 00:06:46.184
And if this is false, I know this
statement is not false, whereas a single

98
00:06:46.184 --> 00:06:50.729
ampersand a single "and" will execute
both sides of this code no matter what.

99
00:06:50.729 --> 00:06:55.521
Again, I think this is really important
to kind of understand, and because of

100
00:06:55.521 --> 00:06:59.803
what can happen in the real world in
terms of when you call this method,

101
00:06:59.803 --> 00:07:01.784
it may do some kind of mutation.

102
00:07:01.784 --> 00:07:05.470
It may make a database call that you just
don't want it or need it to make in this

103
00:07:05.470 --> 00:07:09.009
context, last operator that I will
mention is the assignment operator.

104
00:07:09.009 --> 00:07:13.231
We have seen that a bunch of times
as we've declared variables,

105
00:07:13.231 --> 00:07:16.211
anything where we assign
this is assign any.

106
00:07:16.211 --> 00:07:20.133
Anytime we see a single equals
we should think assignment, and

107
00:07:20.133 --> 00:07:24.650
that's exactly what we get here,
this is also an assignment operator.

108
00:07:24.650 --> 00:07:29.871
If we change this value to three,
there are instances

109
00:07:29.871 --> 00:07:35.093
where you may want to do
some additional assignment,

110
00:07:35.093 --> 00:07:40.100
maybe you want to do a plus equals or
a minus equals.

111
00:07:40.100 --> 00:07:44.755
And I don't think I've ever written
a multiply or divide equals or

112
00:07:44.755 --> 00:07:50.667
a modulus equals, but those operations
will essentially perform will translate.

113
00:07:50.667 --> 00:07:55.375
So if you do a plus equals b, it basically

114
00:07:55.375 --> 00:08:00.776
translates to assign
the value of a to a plus b,

115
00:08:00.776 --> 00:08:06.592
and we can see that here
is that if we value +=7,

116
00:08:06.592 --> 00:08:11.321
that if we Console.WriteLine(value).

117
00:08:11.321 --> 00:08:15.913
We can see that it will write 10 to this,
because what it's doing is

118
00:08:15.913 --> 00:08:20.839
taking seven and adding it to 3, so
useful for addition, subtraction.

119
00:08:20.839 --> 00:08:25.311
Sometimes multiplication and division,
but not statements that I write a ton of.

