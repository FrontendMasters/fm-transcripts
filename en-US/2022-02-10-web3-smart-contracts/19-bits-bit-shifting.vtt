WEBVTT

1
00:00:00.433 --> 00:00:04.217
Okay, so I know for a lot of people,
some of this code makes no sense but

2
00:00:04.217 --> 00:00:08.208
the general idea hopefully makes a ton
of sense, you can see the outline.

3
00:00:08.208 --> 00:00:12.234
The real only thing that makes probably
no sense to most people is this one right

4
00:00:12.234 --> 00:00:14.615
here, so
I'm going to start going over bits.

5
00:00:14.615 --> 00:00:17.880
And this is where I kind of
wanted that have that whiteboard,

6
00:00:17.880 --> 00:00:20.312
but we're going to use
my favorite program,

7
00:00:20.312 --> 00:00:24.039
of course, the GNU Image Manipulation
Program, or GIMP for short.

8
00:00:24.039 --> 00:00:27.123
All right, fantastic,
look at that I even have this, so

9
00:00:27.123 --> 00:00:31.647
the first question I'm gonna ask everybody
is, can somebody name this function?

10
00:00:31.647 --> 00:00:32.168
&gt;&gt; Is equal.

11
00:00:32.168 --> 00:00:34.353
&gt;&gt; It does have an equal sign in it.

12
00:00:34.353 --> 00:00:35.349
&gt;&gt; Is divisible.

13
00:00:35.349 --> 00:00:39.925
&gt;&gt; Close, is divisible, I wouldn't go
with that one, good try though Lancebe,

14
00:00:39.925 --> 00:00:41.236
I appreciate the try.

15
00:00:41.236 --> 00:00:42.961
&gt;&gt; Is it a union?

16
00:00:42.961 --> 00:00:46.273
&gt;&gt; I wouldn't call it a union,
all right, excellent but

17
00:00:46.273 --> 00:00:51.242
this is really good that means we you know
we have some things we need to learn here.

18
00:00:51.242 --> 00:00:56.519
And this is gonna be one of the most
quintessential parts to interacting with

19
00:00:56.519 --> 00:01:01.714
the blockchain because once again
especially when it comes to eatherium,

20
00:01:01.714 --> 00:01:03.125
storage is in bits.

21
00:01:03.125 --> 00:01:07.033
So is it Myelin or
Milon correctly have named the function,

22
00:01:07.033 --> 00:01:12.601
I want to give it away ,I'm not gonna
tell any, don't, hey, don't look at chat.

23
00:01:12.601 --> 00:01:16.231
Alright, so
first let's talk boolean logic alright, so

24
00:01:16.231 --> 00:01:20.613
I think everybody here is probably
familiar with the ampersand sign.

25
00:01:20.613 --> 00:01:25.515
So if I did two ampersand signs,
everyone knows what that means, so

26
00:01:25.515 --> 00:01:27.585
A ampersand B, the output.

27
00:01:27.585 --> 00:01:32.600
Let's pretend that while I'm writing this,
that A is either zero or

28
00:01:32.600 --> 00:01:36.749
one, which is false or true and
B is either zero or one, so

29
00:01:36.749 --> 00:01:40.739
what is the output to zero and
zero, just shout it out.

30
00:01:40.739 --> 00:01:41.265
&gt;&gt; Zero.

31
00:01:41.265 --> 00:01:43.745
&gt;&gt; Correct, what is the output of 0 and 1?

32
00:01:43.745 --> 00:01:46.853
&gt;&gt; Zero.

33
00:01:46.853 --> 00:01:49.519
&gt;&gt; Zero, correct,
what is the output of 1 and 0?

34
00:01:49.519 --> 00:01:51.138
&gt;&gt; Zero.

35
00:01:51.138 --> 00:01:54.363
&gt;&gt; Correct, what is the output to 1 and 1?

36
00:01:54.363 --> 00:01:55.439
&gt;&gt; 1.

37
00:01:55.439 --> 00:01:59.736
&gt;&gt; Yes, awesome, okay,
I know this is very trivial but

38
00:01:59.736 --> 00:02:02.697
trust me, it helps make the bridge,

39
00:02:02.697 --> 00:02:07.773
let's do the exact same thing with A or
B output straight over.

40
00:02:07.773 --> 00:02:13.334
Let's just do this quickly,
I'm gonna start yelling it, alright,

41
00:02:13.334 --> 00:02:18.820
zero or zero is 00 or one is one one or
zero is one and one or one is one.

42
00:02:18.820 --> 00:02:24.266
This makes sense because ors are either or
has to be true and have to be true or

43
00:02:24.266 --> 00:02:28.854
it's false, alright,
these are very important operators.

44
00:02:28.854 --> 00:02:34.199
I think everyone understands these
that kind of like an essential level,

45
00:02:34.199 --> 00:02:37.471
let's also talk about not,
so if I had not A,

46
00:02:37.471 --> 00:02:42.747
the output of course is going to be
0 becomes 1, 1 becomes 0, right?

47
00:02:42.747 --> 00:02:45.019
False becomes true, true becomes false,

48
00:02:45.019 --> 00:02:48.692
that's why people convert boolean
into JavaScript with two bangs.

49
00:02:48.692 --> 00:02:52.453
Because it coerces it into a boolean,
flips it's value,

50
00:02:52.453 --> 00:02:55.753
reflips its value back to either true or
false, for

51
00:02:55.753 --> 00:03:00.529
good or for worse, that is a real thing
that happens out in the real world.

52
00:03:00.529 --> 00:03:05.317
So now, let's talk about one other
operation that you probably have never

53
00:03:05.317 --> 00:03:10.567
seen, I'm going to put two symbols here
just so it makes more sense, two carats.

54
00:03:10.567 --> 00:03:15.431
It's called exclusive or it is my
favorite, it's just my favorite thing in

55
00:03:15.431 --> 00:03:20.530
the universe, it, I'm right now already
feeling all warm and fuzzy about it.

56
00:03:20.530 --> 00:03:25.875
So exclusive or simply means that
something is either true like or let me

57
00:03:25.875 --> 00:03:31.682
save this one, it simply means that either
A or B has to be true, but not both.

58
00:03:31.682 --> 00:03:36.380
So that means if both are false,
it is clearly false, if one is true,

59
00:03:36.380 --> 00:03:38.972
it is clearly true, if both are true,

60
00:03:38.972 --> 00:03:42.617
it is false, so
there you go that's its truth table.

61
00:03:42.617 --> 00:03:46.361
So I think we all understand
these truth tables, right,

62
00:03:46.361 --> 00:03:50.729
nothing in here feels confusing,
we all get this fundamentally,

63
00:03:50.729 --> 00:03:54.321
this actually works in C
because zero was truly false.

64
00:03:54.321 --> 00:03:58.409
And one or any nonzero was true and
that is why, by the way,

65
00:03:58.409 --> 00:04:02.413
you see that funny trick that
people will use every now and

66
00:04:02.413 --> 00:04:06.690
then in JavaScript where they'll
do an index of operation.

67
00:04:06.690 --> 00:04:10.457
And when that returns negative 1,
meaning it's not found,

68
00:04:10.457 --> 00:04:13.790
they do a ~ because the opposite
of negative 1 is 0 and

69
00:04:13.790 --> 00:04:17.430
we'll explain why, and
the opposite of 0 is negative 1.

70
00:04:17.430 --> 00:04:20.923
Therefore, negative one becomes the only
false value in all other values

71
00:04:20.923 --> 00:04:21.606
become true.

72
00:04:21.606 --> 00:04:24.507
So you don't have to do that
whole like greater than or

73
00:04:24.507 --> 00:04:27.740
equal to zero thing,
instead you just hit them with the DD.

74
00:04:27.740 --> 00:04:30.853
Now we'll explain that in a little bit,
but you'll see that in JavaScript and

75
00:04:30.853 --> 00:04:33.940
people always hate it, all right, so,
we've talked about boolean logic.

76
00:04:33.940 --> 00:04:39.125
Next, let's talk about basis bases
are very important to understand,

77
00:04:39.125 --> 00:04:42.529
so I'm going to create
a new little board here.

78
00:04:42.529 --> 00:04:47.294
And we're going to do this is we
count in something called base 10,

79
00:04:47.294 --> 00:04:50.594
make sense 10 thingies, base 10, right?

80
00:04:50.594 --> 00:04:53.390
And so when I type in the number say 69,

81
00:04:53.390 --> 00:04:58.090
classic main number from Lord Ilan,
what does this actually mean?

82
00:04:58.090 --> 00:05:02.879
Well, this actually means I take 10
to the power of one multiplied by

83
00:05:02.879 --> 00:05:06.531
six plus 10 to the power
of zero multiplied by nine,

84
00:05:06.531 --> 00:05:10.772
I add those two numbers together,
right that is 60 plus 9.

85
00:05:10.772 --> 00:05:14.600
And so that is how we do that, so
if I were to add a 1 right here,

86
00:05:14.600 --> 00:05:19.243
that's 10 to the power of 2,
multiplied by 1 plus 10 to the power of 1

87
00:05:19.243 --> 00:05:23.256
multiplied by 6 plus 10 to
the power of 0 multiplied by nine.

88
00:05:23.256 --> 00:05:28.358
For those that don't know, any thing
taken to the power of 0 equals 1 and so

89
00:05:28.358 --> 00:05:33.969
our accounting system is literally 10
to the 0, ten to 1, ten to 2, ten to 3.

90
00:05:33.969 --> 00:05:38.319
And that makes sense, because when
you multiply by 10, what do you do,

91
00:05:38.319 --> 00:05:43.182
you add a 0, right, when you divide by 10,
you remove a 0, that makes sense.

92
00:05:43.182 --> 00:05:46.598
We're just literally shifting it left or
right by multiplying by 10,

93
00:05:46.598 --> 00:05:49.398
that is why multiplying or
dividing by 10 was everyone's

94
00:05:49.398 --> 00:05:53.094
favorite thing that happened in grade
school math because it was the easiest.

95
00:05:53.094 --> 00:05:56.130
It was the most exciting,
so that is a base 10 thing,

96
00:05:56.130 --> 00:06:00.618
that is how we think you probably have
never thought about thinking about numbers

97
00:06:00.618 --> 00:06:03.396
that way but
that's actually what is happening.

98
00:06:03.396 --> 00:06:07.967
So let's talk about a different base,
you've seen this a bunch of times,

99
00:06:07.967 --> 00:06:12.321
you've just never put it into words,
have you ever seen hexadecimal,

100
00:06:12.321 --> 00:06:14.588
the zero through nine, A through F?

101
00:06:14.588 --> 00:06:19.047
Hexadecimal is simply base 16, so
if we were to look at say the number

102
00:06:19.047 --> 00:06:22.525
hexadecimal, hexadecimal
is always denoted by 0x,

103
00:06:22.525 --> 00:06:26.090
a leading 0x, so
let's say we look at the number 45.

104
00:06:26.090 --> 00:06:31.252
Well, what's happening in hexadecimal and
now it's not our 45, it's a different

105
00:06:31.252 --> 00:06:36.287
value, well, that's the same thing as
doing four multiplied by 16 to 1 plus 5.

106
00:06:36.287 --> 00:06:41.005
I did this backwards for whatever reason,
mirroring it, or I didn't do it,

107
00:06:41.005 --> 00:06:45.883
I guess it mirrored from the previous
example, multiplied by 16 to the zero.

108
00:06:45.883 --> 00:06:50.858
So that's the same thing as 4 multiplied
by 16 plus 5 multiplied by 1, or

109
00:06:50.858 --> 00:06:54.683
2 to the 2 multiplied by 2 to the 6,
which is to the 8, so

110
00:06:54.683 --> 00:06:57.381
that's 250 way up, I did that wrong.

111
00:06:57.381 --> 00:07:01.410
That's not to the 8,
I did the totally wrong anyways,

112
00:07:01.410 --> 00:07:05.868
that's 64 plus 5, right,
which thus equals 69, bam,

113
00:07:05.868 --> 00:07:10.011
quick math, so
you can see how I got that number, right?

114
00:07:10.011 --> 00:07:14.887
Is that I simply just did the exact
same base walking, except for

115
00:07:14.887 --> 00:07:20.321
I did it with 16s instead of 10s,
now, why do we choose A through F?

116
00:07:20.321 --> 00:07:26.006
Well, think about it when we count with
base 10, we use 10 symbols to represent

117
00:07:26.006 --> 00:07:31.308
our language, which is 0 through 9,
we need 6 more symbols for base 16.

118
00:07:31.308 --> 00:07:35.268
So it makes perfect sense why it's A
through F, right, I mean, that just makes

119
00:07:35.268 --> 00:07:39.423
perfect sense, so there we go, we have
16 symbols, 0 through 9, A through F.

120
00:07:39.423 --> 00:07:44.275
That means f = 15, F equals,
we'll put it there, 15, right,

121
00:07:44.275 --> 00:07:46.714
just like 9 is 9 in our language.

122
00:07:46.714 --> 00:07:51.866
So if you had a base 16 or
a hexadecimal number, and you had base or

123
00:07:51.866 --> 00:07:56.098
a hexadecimal one,
how would you multiply it by 10,

124
00:07:56.098 --> 00:07:59.140
if you will, you'd multiply by 16.

125
00:07:59.140 --> 00:08:02.531
Multiplying by 16 produces 0,
multiply by another 16,

126
00:08:02.531 --> 00:08:05.986
produces a 0, this is kind of
very important stuff to know, so

127
00:08:05.986 --> 00:08:09.399
we're gonna do the exact same
thing except for one more time.

128
00:08:09.399 --> 00:08:13.233
We're gonna do with base 2,
base to only as two symbols,

129
00:08:13.233 --> 00:08:18.009
you want to guess what those two
symbols are, 0 and 1 that's right, so

130
00:08:18.009 --> 00:08:21.167
base 2, 0 and 1, this makes perfect sense.

131
00:08:21.167 --> 00:08:26.375
This is binary, binary is a base 2
counting language, which means if you

132
00:08:26.375 --> 00:08:31.428
had four binaries, right here,
this is two to the zero, which is one.

133
00:08:31.428 --> 00:08:35.639
Two to the two, or one which is two,
two to the two, which is four,

134
00:08:35.639 --> 00:08:39.850
two to the three, which is eight,
so this number is simply eight,

135
00:08:39.850 --> 00:08:43.565
right, if I were to add one to it,
I'd add one right here.

136
00:08:43.565 --> 00:08:47.923
If I were to add one again,
I wouldn't just call this thing to know,

137
00:08:47.923 --> 00:08:52.205
I'd have to roll it over just like
if you add one to nine, you don't

138
00:08:52.205 --> 00:08:57.123
write 10 in place, you actually write
a zero here and put a one right here.

139
00:08:57.123 --> 00:09:01.097
So that is counting in binary,
right and so you can keep on going,

140
00:09:01.097 --> 00:09:05.960
I could keep on counting, because that's
how it works, does that make sense?

141
00:09:05.960 --> 00:09:10.969
For the most part, and the reason why I
chose four is because two to the three or

142
00:09:10.969 --> 00:09:12.757
eight is the same thing or.

143
00:09:12.757 --> 00:09:17.804
Yeah, two to the three plus two
to the two plus two to the one

144
00:09:17.804 --> 00:09:23.986
plus two to the zero is the same
thing as hexadecimal, so hexadecimal,

145
00:09:23.986 --> 00:09:29.366
f is represented by for
binary numbers or refer to as a nibble.

146
00:09:29.366 --> 00:09:35.040
So 1111 or 15, 1 plus 2 is 3,
2 plus 4 is 7, 7 plus 8 is 15,

147
00:09:35.040 --> 00:09:39.541
so that means two numbers
are required to represent a bit.

148
00:09:39.541 --> 00:09:43.949
So in hexadecimal, it's two of these
symbols in base two or binary,

149
00:09:43.949 --> 00:09:46.458
it is eight numbers to represent a bit.

150
00:09:46.458 --> 00:09:47.494
That makes sense,

151
00:09:47.494 --> 00:09:51.713
because these are bits or the fundamental
unit of the computer effectively.

152
00:09:51.713 --> 00:09:56.177
So eight bits makes a byte so everyone
kind of tracking with this does this all

153
00:09:56.177 --> 00:09:59.271
make sense this is just basis
I needed to cover this.

154
00:09:59.271 --> 00:10:02.907
Because it just is really hard
to think about it unless you

155
00:10:02.907 --> 00:10:07.456
understand that hexadecimal and
binary are no different and decimal,

156
00:10:07.456 --> 00:10:10.132
they just have different ways you count.

157
00:10:10.132 --> 00:10:14.519
All right, so we don't have any questions,
so we've already done some conversion,

158
00:10:14.519 --> 00:10:16.214
we can do some more conversions.

159
00:10:16.214 --> 00:10:20.018
I'll do one more conversion,
let's convert, let's see,

160
00:10:20.018 --> 00:10:24.129
let's do a new one, can someone
shout out a easy two digit number?

161
00:10:24.129 --> 00:10:25.643
&gt;&gt; 23.

162
00:10:25.643 --> 00:10:30.147
&gt;&gt; 23, perfect, all right 23,
let's convert this to binary, so

163
00:10:30.147 --> 00:10:33.720
remember, you start with
what is the largest number,

164
00:10:33.720 --> 00:10:38.242
that is, what is the largest power
of two that this number contains?

165
00:10:38.242 --> 00:10:41.034
&gt;&gt; 16.
&gt;&gt; 16 perfect, so we're gonna say this one

166
00:10:41.034 --> 00:10:45.998
represents 16, which means we should
have eight, four, two, one left.

167
00:10:45.998 --> 00:10:50.832
All right, so 23 minus 16 is going
to equal a number that I'm currently

168
00:10:50.832 --> 00:10:54.609
coming up with right now which is seven,
correct, okay.

169
00:10:54.609 --> 00:11:00.420
It's a joke, anyways never, so what's
the largest number that this one contains?

170
00:11:00.420 --> 00:11:02.933
&gt;&gt; 4.
&gt;&gt; 4 perfect, so we write in four because

171
00:11:02.933 --> 00:11:07.810
remember this one's 8, this one's 16,
this one is 4, so now we do it again, so

172
00:11:07.810 --> 00:11:11.697
now we have 3, so what's the largest
one that this one contains?

173
00:11:11.697 --> 00:11:17.454
&gt;&gt; 2 which now becomes 1, what's the
largest power of 2 that this one contains,

174
00:11:17.454 --> 00:11:21.768
1 which is power of two to zero,
which is one, there you go,

175
00:11:21.768 --> 00:11:23.817
this number is binary 23.

176
00:11:23.817 --> 00:11:25.708
So we just did that live on the fly, so

177
00:11:25.708 --> 00:11:28.453
you can kind of see how these
things are represented,

178
00:11:28.453 --> 00:11:32.550
this is what's happening underneath
the hood when you use a unsigned integer.

179
00:11:32.550 --> 00:11:37.844
This I can think about it, there's this
whole concept of endianness, we're not

180
00:11:37.844 --> 00:11:43.385
gonna even think or worry about that,
don't worry about it, also, enjoy perfect.

181
00:11:43.385 --> 00:11:48.996
All right, so just like in base 10,
when we multiply by 10, we get a 0,

182
00:11:48.996 --> 00:11:53.994
in base 2, when we multiply by 2,
we get the exact same effect, so

183
00:11:53.994 --> 00:11:59.027
this number, 23 times two or
46 is represented just like that.

184
00:11:59.027 --> 00:12:04.032
I just simply added a zero,
let's prove it out, that is 2,

185
00:12:04.032 --> 00:12:09.330
4, 8, 1, 6, 32, 32,
that is 40, that is 646,

186
00:12:09.330 --> 00:12:15.240
right, we just walked through and
we just did that exact same concept.

187
00:12:15.240 --> 00:12:19.921
Except you multiply by 2,
you get yourself a 0 and so of course,

188
00:12:19.921 --> 00:12:22.901
since we use binary so much in computers,

189
00:12:22.901 --> 00:12:28.463
we instead of doing something like this,
I want to shift it over three times.

190
00:12:28.463 --> 00:12:32.908
You don't do that, right, instead,
you use this operator, which is

191
00:12:32.908 --> 00:12:37.520
an operator I just got done using,
I want to shift this thing three times.

192
00:12:37.520 --> 00:12:40.589
Or I want to multiply this number by two,
three times,

193
00:12:40.589 --> 00:12:44.594
which will produce three leading zeros,
alright, so this is good, so

194
00:12:44.594 --> 00:12:47.155
that's good knowing about binary, right?

195
00:12:47.155 --> 00:12:51.031
You're starting to understand why this is,
everyone kind of get this concept,

196
00:12:51.031 --> 00:12:52.863
it's just like multiplying by 10.

197
00:12:52.863 --> 00:12:56.967
Alright, so this is called a left shift,
because we're shifting our binary to

198
00:12:56.967 --> 00:13:00.884
the left, a right shift is dividing by 2,
so show you right shift this way,

199
00:13:00.884 --> 00:13:03.913
that is why when you right
shift an integer, it floors it.

200
00:13:03.913 --> 00:13:07.881
Because a it's a non floating type
which is represented differently but

201
00:13:07.881 --> 00:13:11.717
also the remainder is shifted off of
the edge, when you divide by two,

202
00:13:11.717 --> 00:13:14.010
you just don't get that number anymore.

