WEBVTT

1
00:00:00.040 --> 00:00:02.480
So let's work through
some logic operations.

2
00:00:02.480 --> 00:00:05.570
So just like how I did Boolean logic,
right?

3
00:00:05.570 --> 00:00:12.355
With 2 ampersand signs, doing bitwise
logic is simply a single ampersand sign,

4
00:00:12.355 --> 00:00:19.720
just like the double or is a Boolean or a
single or is a Boolean or is a bitwise or.

5
00:00:19.720 --> 00:00:26.830
Just like doing a bang is a not,
a tilde is a bitwise not.

6
00:00:26.830 --> 00:00:31.664
And just like doing, I did this,
even though this symbol doesn't exist,

7
00:00:31.664 --> 00:00:35.080
doing a single hat is an exclusive or.

8
00:00:35.080 --> 00:00:37.326
So let's kind of go through
a couple of those operations.

9
00:00:37.326 --> 00:00:38.347
Let's go like this.

10
00:00:38.347 --> 00:00:43.127
a=1001 in binary,

11
00:00:43.127 --> 00:00:47.909
b = 0101 in binary.

12
00:00:47.909 --> 00:00:53.077
If we were to end these two numbers
together, we'd go 1 and 1, 1,

13
00:00:53.077 --> 00:00:59.958
0 and 0, 0, 0 and 1, 0, 1 and 0, 0, just
like our truth table that we did before.

14
00:00:59.958 --> 00:01:05.544
So the answer of 9 and
what is this, 5, the answer is 1,

15
00:01:05.544 --> 00:01:12.843
it's because there's only one common,
1, notice that what does ans do?

16
00:01:12.843 --> 00:01:16.403
Everything that has 1s on both
sides becomes a 1 in the solution.

17
00:01:16.403 --> 00:01:19.457
Everything else becomes a 0.

18
00:01:19.457 --> 00:01:24.860
This is very important because we
use ans for selecting out values.

19
00:01:24.860 --> 00:01:28.270
Say you wanted only the first
two bits to a number.

20
00:01:28.270 --> 00:01:31.706
Well, what would you do say a is a very,

21
00:01:31.706 --> 00:01:36.510
very long number,
we'd simply make b equal to 0x3.

22
00:01:37.950 --> 00:01:41.676
Because 3 is represented
by 2 to the 0 + 2 to the 1.

23
00:01:41.676 --> 00:01:43.363
So it's 2 1.

24
00:01:43.363 --> 00:01:46.971
You could translate that into binary, 1 1.

25
00:01:46.971 --> 00:01:52.640
And so then if we ended that with a, all
of the bits over here would all become 0.

26
00:01:52.640 --> 00:01:55.765
But only the first 2 bits
would be either a 0 or 1,

27
00:01:55.765 --> 00:01:58.630
because we already have 1s right here.

28
00:01:58.630 --> 00:02:01.550
So if they happen to be both 0s,
the answer would be both 0s.

29
00:02:01.550 --> 00:02:04.332
If they happen to be 1 of them's 1,
1 of them would be 1.

30
00:02:04.332 --> 00:02:06.200
Do you see where this is going?

31
00:02:06.200 --> 00:02:09.793
This makes a lot of sense,
I would say, ans are used for

32
00:02:09.793 --> 00:02:11.757
selecting out information.

33
00:02:11.757 --> 00:02:16.311
That is why if you ever see Boolean flags
where binary hat or a number has flags in

34
00:02:16.311 --> 00:02:20.451
it, you will always see that single
end is because that flag represents

35
00:02:20.451 --> 00:02:25.008
a single binary number that's on and
you have your flag set that's coming in.

36
00:02:25.008 --> 00:02:27.130
And we're just seeing is this non 0.

37
00:02:27.130 --> 00:02:30.306
If it's nonzero, that means we
both have the same bits on or

38
00:02:30.306 --> 00:02:33.850
at least the same bit in
the second that is in the first.

39
00:02:33.850 --> 00:02:40.590
So let's do it again with or, or
just like before, only one has to be true.

40
00:02:40.590 --> 00:02:46.238
So if we have the value 001,
and of course 0101.

41
00:02:46.238 --> 00:02:53.287
And we or it, we get 1011 because
this one of these are 1s so

42
00:02:53.287 --> 00:02:58.350
ors is how you write into a number, right?

43
00:02:58.350 --> 00:03:02.620
So if I wanted to write in 2 bits into
the first two positions of a number,

44
00:03:02.620 --> 00:03:04.020
what would I do?

45
00:03:04.020 --> 00:03:06.265
So a is a big long, long number.

46
00:03:06.265 --> 00:03:12.764
I would simply make b equal to 0x3,
and I would order them together.

47
00:03:12.764 --> 00:03:14.950
I would write the 3 into it.

48
00:03:14.950 --> 00:03:17.946
It wouldn't matter what
a has in that position,

49
00:03:17.946 --> 00:03:22.030
they're one at the end of this operation,
right?

50
00:03:22.030 --> 00:03:22.557
Right, so

51
00:03:22.557 --> 00:03:26.830
hopefully everyone feels like they've
been paying attention to understand this.

52
00:03:26.830 --> 00:03:28.480
I'm gonna give a quick formula.

53
00:03:28.480 --> 00:03:31.640
If you know the answer chat,
please do not type it.

54
00:03:31.640 --> 00:03:37.237
Everyone needs to experience this in their
own hearts cuz it is one of the most

55
00:03:37.237 --> 00:03:42.747
magical things that you'll ever have,
all right, so I'm gonna do this,

56
00:03:42.747 --> 00:03:48.186
classic a, being it's 0 or 1001,
classic b being it's 0101.

57
00:03:48.186 --> 00:03:52.227
I want you to apply these three
operations to it in order.

58
00:03:52.227 --> 00:03:59.512
I want a to equal a, exclusive or
remember only one can be true at a time.

59
00:03:59.512 --> 00:04:05.691
b, I want b to equal a exclusive or b.

60
00:04:05.691 --> 00:04:11.188
I want a to equal a exclusive or b.

61
00:04:11.188 --> 00:04:13.010
Work this out.

62
00:04:13.010 --> 00:04:16.630
Walk through it if you have like
a drawing program, go through it.

63
00:04:16.630 --> 00:04:19.290
This is a very magical experience.

64
00:04:19.290 --> 00:04:20.910
Please don't type the answer.

65
00:04:20.910 --> 00:04:24.630
It's a very great example and
I'll go through it in just a moment.

66
00:04:24.630 --> 00:04:26.640
All right, so
let's work through what happens.

67
00:04:26.640 --> 00:04:28.180
I don't wanna give anything away.

68
00:04:28.180 --> 00:04:30.210
Let's work through what happens here.

69
00:04:30.210 --> 00:04:33.627
So, a equals this, b equals this.

70
00:04:33.627 --> 00:04:36.023
Let's take the x or
of that and assign it to a.

71
00:04:36.023 --> 00:04:37.742
So a is gonna equal this.

72
00:04:37.742 --> 00:04:39.984
What is 1x over 1?

73
00:04:39.984 --> 00:04:41.203
That's 0.

74
00:04:41.203 --> 00:04:43.903
What is 0x or 0, 0.

75
00:04:43.903 --> 00:04:48.327
What is 1x or 0x or 1 1?

76
00:04:48.327 --> 00:04:51.446
What is 1x or 0 1.

77
00:04:51.446 --> 00:04:52.327
Awesome.

78
00:04:52.327 --> 00:04:57.975
b equals what is 1x or 0 1.

79
00:04:57.975 --> 00:05:00.614
What is 0x or 0?

80
00:05:00.614 --> 00:05:02.621
Yes, here's some excitement.

81
00:05:02.621 --> 00:05:05.328
What is 1x or 1 0.

82
00:05:05.328 --> 00:05:08.089
What is 0x or 1, 1?

83
00:05:08.089 --> 00:05:09.851
Alright, let's do a again.

84
00:05:09.851 --> 00:05:18.020
Alright, 011000011110, look at that.

85
00:05:18.020 --> 00:05:22.000
Now take a quick moment,
what the heck just happened to a and b?

86
00:05:22.000 --> 00:05:24.150
Is your mind not just blown?

87
00:05:24.150 --> 00:05:31.080
We swapped the values of a and
b without creating a temporary value.

88
00:05:31.080 --> 00:05:35.478
Come on, tell me that is not just like
incredible that has to at least make you

89
00:05:35.478 --> 00:05:40.390
kind of like, my goodness XR has some
fundamental property of memory in it.

90
00:05:40.390 --> 00:05:45.102
It's why raid and a lot of the basis of
raid use XR as a way cuz you can restore

91
00:05:45.102 --> 00:05:48.752
a disk by having an x or
copy of something else somewhere.

92
00:05:48.752 --> 00:05:51.250
And you can actually bring
things back to life cuz of this.

93
00:05:51.250 --> 00:05:54.830
This is just like,
just like mind blowingly awesome.

94
00:05:54.830 --> 00:05:58.874
I wanted to show this because I really
wanted to make sure you understood bits,

95
00:05:58.874 --> 00:06:03.800
you understand the operation, you know
that end is for selecting something out.

96
00:06:03.800 --> 00:06:10.060
Or is for putting something in XOR you can
obviously do some really neat stuff here.

97
00:06:10.060 --> 00:06:13.350
I'm just hoping someone got XOR,
I feel like no one I just see smiles.

98
00:06:13.350 --> 00:06:16.460
I think they're just mostly think I'm
awkward cuz of how excited I am at this.

99
00:06:16.460 --> 00:06:17.876
But this is fantastic.

100
00:06:17.876 --> 00:06:18.967
So there you go.

101
00:06:18.967 --> 00:06:21.837
Your mind is blown, right?

102
00:06:21.837 --> 00:06:22.800
It's fantastic.

103
00:06:22.800 --> 00:06:25.062
So let's rename this function,

104
00:06:25.062 --> 00:06:29.160
now that we have all of
the brains in the world for this.

105
00:06:29.160 --> 00:06:31.790
What should the name b of this?

106
00:06:35.250 --> 00:06:39.353
So first, a and b, let's write that out.

107
00:06:39.353 --> 00:06:43.420
So I'm gonna jump back to here and
I'm gonna go like this.

108
00:06:43.420 --> 00:06:49.631
So we have a and b equals b, right?

109
00:06:49.631 --> 00:06:50.300
There we go.

110
00:06:50.300 --> 00:06:54.633
So let's just say a classic 1001.

111
00:06:54.633 --> 00:06:59.004
Let's say b classic 0101.

112
00:06:59.004 --> 00:07:05.290
The answer to this would be 1 1 as 1,
0 0, 0, 0 1 0 0 or 1 0 is 0.

113
00:07:05.290 --> 00:07:07.400
Does this equal b?

114
00:07:08.740 --> 00:07:10.590
No, it does not equal b.

115
00:07:10.590 --> 00:07:17.240
Let's say a equals this and b equals this.

116
00:07:17.240 --> 00:07:22.340
It's 1 1 1, 0 0 0, 1 1 1, 1 0 0.

117
00:07:22.340 --> 00:07:23.919
Does this equal b?

118
00:07:23.919 --> 00:07:28.539
Yes it does, look b is that value,
b is this value,

119
00:07:28.539 --> 00:07:32.409
that function should be called contains,

120
00:07:32.409 --> 00:07:37.674
does a contain b,
it does contain b completely within it,

121
00:07:37.674 --> 00:07:42.628
[SOUND] how great is that,
that was fantastic, right?

122
00:07:42.628 --> 00:07:44.770
This is also just flag checking, right?

123
00:07:44.770 --> 00:07:48.974
So if you had a that had a bunch
of a bunch of 1s in it, and

124
00:07:48.974 --> 00:07:52.530
you wanna see is the third bit true.

125
00:07:52.530 --> 00:07:53.790
All you'd have to do is go like this.

126
00:07:53.790 --> 00:07:58.110
Okay, I need the third bit,
which that would be 0x4.

127
00:07:58.110 --> 00:08:00.810
Does that equal a right?

128
00:08:00.810 --> 00:08:02.053
And 0x4.

129
00:08:02.053 --> 00:08:04.526
I wrote that a little bit terrible,
but you get the idea.

130
00:08:04.526 --> 00:08:09.460
You're just seeing, does this one
exist within this bigger pool?

131
00:08:09.460 --> 00:08:12.160
It's actually a pretty neat
little function right here.

132
00:08:12.160 --> 00:08:13.700
And so there you go.

133
00:08:13.700 --> 00:08:17.100
You now hopefully at least
get what's happening there.

