[00:00:00]
>> Next, we want to actually style things up a little bit. We don't have, this header is kinda janky, just everything smashed on top of itself. We want that to look like an actual header bar. We want the content to not be smashed against the side of the page.

[00:00:20]
So let's style our layout. And for the layout styles, I want to be able to write the styles without fear of collision later on. So one of the hot topics in CSS, and one of the big frustrations that a lot of people run into when doing styling, is how do you avoid really complex naming structures or just a lot of rules in the way that you write CSS, without running into this problem where the cascade in CSS becomes a big footgun.

[00:00:54]
We don't want it to be a trap, right? We want it to be something where when you write styles, you can take advantage of the CSS cascade, you can just write CSS. And it's it's very powerful. It gives you a lot of opportunities. But it doesn't become cumbersome, right?

[00:01:11]
We don't want CSS to be, CSS should be fun. And I think that by using CSS with a few guardrails, it can be funny. It doesn't need to be this thing that is terrifying, and stressful, and hard to scale, and all this stuff, right? And so, that's why in this workshop, we're actually just going to write CSS.

[00:01:31]
There are a million options out there. You could introduce CSS and JS one of the tools like emotion. You could introduce tailwind or chakra. Those are all good solutions and if that's what your team wants to do, 100% do it. They're great ways to handle styles. I like a, less is more kind of approach.

[00:01:49]
So I'm gonna be using CSS modules, which is not exactly a CSS spec, but it allows us to not add any additional libraries for writing our styles. I also really like CSS modules, because they're more or less built into all the frameworks now. So you can use CSS modules with Gatsby with, Next with knucks.

[00:02:11]
There's a bunch of different frameworks out there now, that will just give you out of the box support for CSS modules. Which means you get to write CSS, you don't have to learn Less or Sass or Stylus or Tailwind or Chakra or Emotion or any of the CSS and JS stuff.

[00:02:26]
You can just write the CSS you already know, imported as a module, and it just works. So let's do that. I'll show you how it works. So we created this one as global.css. For a scoped CSS or CSS module, we just have to do module.css. So by adding this layout.modulecss, I have now indicated to Gatsby that I want to use this as a CSS module.

[00:02:51]
So inside of it, I can just start writing css. So I wanna have some styles for the header. So I'm gonna use that black color for the background and then I want the regular color needs to be high contrast for accessibility. So we'll make it white. I want to use display flex ,so that I can get the header link ,like the home link to be on one side and the nav to be on the other side.

[00:03:19]
I want them to be spread. So I'm gonna use display flex, and then justify content space between. Which the way that I remember this is every time I look at the CSS role, I think about that Dave Matthews song, the space between and it gets stuck in my head.

[00:03:36]
Now it gets to get stuck in your head too. So then we're gonna add a little bit of padding around the header. About 1rem if you're not familiar with rems, rems are the the original, font size. So when we look at the global css and I set font size of 18 here, now I've basically said 1rem is 18 pix.

[00:03:59]
And the reason I use rems is that I can now make my whole layout relative to that base font size. So it's a nice little pattern makes my life easier. And you don't have to stress about it now. So inside of this I'm gonna use just regular old CSS selectors.

[00:04:17]
I wanna get any link inside of the header. And I want to make it whatever the color of the header is. I also want to make it inline-block. So that we can apply some padding around it. And so, we're gonna set the padding to be 0.5 rem, and then I wanna take off the the underline.

[00:04:39]
But because I just took off the underline that would cause an accessibility issue, if I didn't add something back. So we're gonna go to the focus, and hover states. And we're going to say that when it's hovered, we're gonna set the background to be a white, and the color to be black.

[00:05:02]
All right. And then the last thing that I wanna do here is I just wanna set a little bit of space around the content. So we're gonna create a class called content. This will go on our main tag, and I want to give it a margin of 3rem on the top and bottom and auto on the left and right, that'll center it.

[00:05:20]
And then I wanna put a max-width of, we're gonna use a little trick that I like of using the character. So what this means is, when you look at the legibility of text, one of the things that we found is that a line length has a bigger impact than the actual width.

[00:05:39]
So depending on the number of characters per line, you actually wanna adjust the width of the screen. So 54 characters wide it gives you a pretty legible reading for tracking of text. You can adjust this. There's really good research you can read on the way that works, but I like this in CSS is kind of setting that whatever we do with the font sizes, let's make sure that our line length is good, and adjust the width accordingly.

[00:06:07]
So I think that's good enough. Let's stop there. So these are the styles that will give us a header and content. But notice I use some pretty risky class names here like .header, .content. As this codebase scales, there's a near 100% chance that somebody else would create a .content class unless we implemented some kind of naming scheme like bam or something where you have to do like the component name__, content_ whatever.

[00:06:42]
There's these tricky things you have to do to avoid naming collisions. But because we're using CSS modules, we don't have to care about that. We can not worry about that and instead, just write class names that we like. Because the way that we're actually gonna use this is we are going to import it as if it was a JavaScript package.

[00:07:04]
So, down here in our our layout, I'm gonna import header and content from the module. So from styles and layout.module.css, they were just JavaScript classes or objects. And then I can use these as class names. So on my header, I'm gonna set a class name of header. And on my main, I'm gonna set a class name of content, all right?

[00:07:35]
And once I have saved this, Look at that. We've got ourselves a site. But here's what's really cool about these, let me make this a little bit bigger so we can see what's going on here. When I select this header, note that it's not using header as the class.

[00:07:57]
It automatically generated all of that scoping for me. So that these styles are actually going to correctly respect inheritance. Now, there're some things that I can do to make this hard on myself. I targeted a every a inside of a header without any restrictions. So, if we add a nav component, and had a nav.module.css that had its own link styles, I can still get collisions.

[00:08:29]
So you can still make this hard. You can still, there are things that you need to think about. I chose not to worry about that because this site is not gonna grow beyond the couple of pages we're making here. But it's a consideration. If you wanna be absolutely sure, instead of using header a, we probably would have wanted to do something like header link, right?

[00:08:57]
It doesn't matter. You can do it whichever way you want. Using named classes for everything is probably the safest solution. But if you are sure that your header is gonna to always have links that should always look the same, then you can make that choice.

