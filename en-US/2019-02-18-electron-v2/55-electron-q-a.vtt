WEBVTT

1
00:00:00.060 --> 00:00:02.985
&gt;&gt; Steve Kinney: Questions, comments,
concerns, cries of outrage?

2
00:00:07.008 --> 00:00:10.513
&gt;&gt; Speaker 2: You've covered some of,
and the website shows the big use cases,

3
00:00:10.513 --> 00:00:11.485
the famous ones.

4
00:00:11.485 --> 00:00:12.660
&gt;&gt; Steve Kinney: Mm-hm
&gt;&gt; Speaker 2: Is the slacks and

5
00:00:12.660 --> 00:00:14.020
the VS codes and so forth.

6
00:00:16.690 --> 00:00:21.960
On just a more local or
grass roots-y professional level,

7
00:00:21.960 --> 00:00:27.570
what do you see being valid use cases for
desktop software as opposed to

8
00:00:27.570 --> 00:00:30.560
web software that you're actually,
maybe, seeing?

9
00:00:30.560 --> 00:00:35.429
&gt;&gt; Steve Kinney: Yeah, one of the ones
that we use internally is just, mostly,

10
00:00:35.429 --> 00:00:39.870
internal because, you ever have one
of those projects where it takes 20%

11
00:00:39.870 --> 00:00:43.040
of the effort to have a thing that you
can share with your friends, and 80% of

12
00:00:43.040 --> 00:00:46.250
the effort to polish it up the rest of the
way to actually distribute to the world?

13
00:00:46.250 --> 00:00:47.120
That's a few of them.

14
00:00:47.120 --> 00:00:50.240
So, we have one internal that we all use.

15
00:00:50.240 --> 00:00:55.092
And effectively, when you're writing
markdown files you want to include

16
00:00:55.092 --> 00:00:58.260
an image,
well do you put that in the directory?

17
00:00:58.260 --> 00:00:59.510
So on and so forth, right?

18
00:00:59.510 --> 00:01:01.620
It's a pain in the butt, so
we have one we just drag an image,

19
00:01:01.620 --> 00:01:04.870
you put in your own S3 key and stuff
like that, it goes up to your bucket and

20
00:01:04.870 --> 00:01:08.180
then you get a URL back that you just
paste right into a markdown file.

21
00:01:08.180 --> 00:01:10.940
I think a lot of,
there are these big ones, but

22
00:01:10.940 --> 00:01:13.930
I think the number of small
tools that you can just build,

23
00:01:13.930 --> 00:01:19.690
I have one we have a far too elaborate
system of labels of poll requests, right?

24
00:01:19.690 --> 00:01:23.490
So, one of the ones I'm working on right
now is simply a way to, as I move cars

25
00:01:23.490 --> 00:01:28.400
across a Trello board to, okay, this is
now code reviewed but needs comments.

26
00:01:28.400 --> 00:01:33.420
Because you know in GitHub, how request
changes and how mean it is so nobody uses

27
00:01:33.420 --> 00:01:37.160
it, so it doesn't do anything because it's
red, and the big X, and stuff like that.

28
00:01:37.160 --> 00:01:40.030
So it can be like, more feedback needed,
or work in progress, so

29
00:01:40.030 --> 00:01:43.370
hooking up to the GitHub API, and,
just, having a user interface, so

30
00:01:43.370 --> 00:01:46.630
everyone can just basically throw in
their cues and do something with, right?

31
00:01:46.630 --> 00:01:53.130
There's a lot of times, not having to
actually, have, just using the AWS CLI or

32
00:01:53.130 --> 00:01:57.920
libraries cuz they're is a Node
1 under the hood, right?

33
00:01:57.920 --> 00:02:00.700
Just makes it easier to automate
a lot of things, right?

34
00:02:00.700 --> 00:02:04.650
Especially internal things where getting,
I can run these things from

35
00:02:04.650 --> 00:02:08.120
the command line, I just need a easier
user interface for these things.

36
00:02:08.120 --> 00:02:10.785
I don't want to spin up an entire web
app that I have to get through infosec.

37
00:02:10.785 --> 00:02:12.090
[LAUGH] Right?

38
00:02:12.090 --> 00:02:15.940
I just wanna, the same way I'd run this on
the command line, I just want a slightly

39
00:02:15.940 --> 00:02:19.240
better tool, cuz I think a lot of those,
I think are really useful.

40
00:02:19.240 --> 00:02:22.709
One of one I really love is
this from a few years ago,

41
00:02:22.709 --> 00:02:28.446
my friend was working on this Kickstarter
project called The Public Radio,

42
00:02:28.446 --> 00:02:33.371
which is a mason jar with a little
Arduino in it, and it's effectively,

43
00:02:33.371 --> 00:02:36.480
you can tune it to one radio station,
right?

44
00:02:36.480 --> 00:02:39.910
I assume that if you have a mason
jar radio, it's tuned to NPR.

45
00:02:39.910 --> 00:02:44.920
But thing is, NPR is a different
station wherever you are, right?

46
00:02:44.920 --> 00:02:50.580
And so, it was a node bot thing
with Arduino and no JS power in it.

47
00:02:50.580 --> 00:02:56.410
But asking someone to plug it into the USB
of their computer and have node installed,

48
00:02:56.410 --> 00:02:59.320
and run these commands in
the terminal was unacceptable, right?

49
00:02:59.320 --> 00:03:02.360
So it was a lot easier to just make
a quick Electron app that did this,

50
00:03:02.360 --> 00:03:05.660
ran the same node commands and
did all of the same stuff, but

51
00:03:05.660 --> 00:03:08.570
with a user interface where someone could
just download the app and double click it.

52
00:03:08.570 --> 00:03:11.600
I'm, personally,
I think the big apps make a lot of sense.

53
00:03:11.600 --> 00:03:15.340
And if I was starting a startup,
obviously, I wouldn't have the team for

54
00:03:15.340 --> 00:03:20.140
a Mac app, a Linux team,
and a Windows team, right?

55
00:03:20.140 --> 00:03:22.880
We'd be writing, probably,
an Electron app.

56
00:03:22.880 --> 00:03:26.870
But what I'm more interested in
is the small bespoke ones, right?

57
00:03:26.870 --> 00:03:30.120
There was an emoji picker, right, where
you can just type all the GitHub ones and

58
00:03:30.120 --> 00:03:32.280
get them as Unicode things.

59
00:03:32.280 --> 00:03:35.070
There is a bunch of really
small applications that,

60
00:03:35.070 --> 00:03:38.620
I'm more interested in the little
mini ones that kinda spring up.

61
00:03:38.620 --> 00:03:42.200
Again the, I have this idea for
an app that I could totally build, right?

62
00:03:42.200 --> 00:03:44.830
Again, maybe you don't take it all
the way to the fact that we're

63
00:03:44.830 --> 00:03:46.340
distributing on the app store, right?

64
00:03:46.340 --> 00:03:50.200
But it is a thing that you use or
your team uses or stuff along those lines.

65
00:03:50.200 --> 00:03:53.640
I think that's a really interesting
use case that's more inspiring for

66
00:03:53.640 --> 00:03:57.630
me than the next ID that we're all
gonna build or something like that.

67
00:03:57.630 --> 00:04:00.050
I think all the smaller, for us,

68
00:04:00.050 --> 00:04:02.136
we're used to being able to build
whatever tools we need, right?

69
00:04:02.136 --> 00:04:06.590
We have, a lot of us have front-end jobs,
most of us can get around in Node or

70
00:04:06.590 --> 00:04:08.980
something like that or
at least write a bash script.

71
00:04:08.980 --> 00:04:12.085
But if we need it, a desktop user
interface, we're kinda out of luck.

72
00:04:12.085 --> 00:04:13.520
[LAUGH] Right?

73
00:04:13.520 --> 00:04:17.420
It was just, learn Swift or
C sharp or whatever.

74
00:04:17.420 --> 00:04:21.470
But now the fact that I can just spin
up a thing, opens that last door for

75
00:04:21.470 --> 00:04:24.000
internal tools, which is where
I'm the most interested in it.

76
00:04:25.520 --> 00:04:28.590
&gt;&gt; Speaker 2: How is pushing updates
handled, then, at that point?

77
00:04:28.590 --> 00:04:32.940
If you do updates to your code, how do you
push that out to the rest of your users?

78
00:04:32.940 --> 00:04:37.880
&gt;&gt; Steve Kinney: So,
really nicely is, that is

79
00:04:37.880 --> 00:04:42.217
not a web browser,
despite what one might think,

80
00:04:42.217 --> 00:04:46.640
is this is a, just like we saw crash
reporter, the only reason we didn't

81
00:04:46.640 --> 00:04:51.040
dig deeper into autoUpdater is
because it does involve code setting.

82
00:04:51.040 --> 00:04:55.690
AutoUpdater, basically, is, again, you
spin up another server, and every time it

83
00:04:55.690 --> 00:05:01.150
starts up, it pings that server with
its current version, and depending on

84
00:05:01.150 --> 00:05:06.070
the status code it gets, it will go ahead
and try to download the new version.

85
00:05:06.070 --> 00:05:09.440
I think a 200, don't quote me on this.

86
00:05:10.540 --> 00:05:15.260
The 200 will be like okay, we have
the conversion of 204 as a new version.

87
00:05:15.260 --> 00:05:16.660
I could have that backwards.

88
00:05:16.660 --> 00:05:20.260
But basically it will check that
every time and go ahead and

89
00:05:20.260 --> 00:05:22.550
pull down that application and install it.

90
00:05:22.550 --> 00:05:26.650
And in fact, just a month or two ago,

91
00:05:26.650 --> 00:05:31.830
if it is an open source app, and
you're willing to use GitHub releases,

92
00:05:32.960 --> 00:05:36.130
they actually have a full
auto-update service.

93
00:05:36.130 --> 00:05:38.390
So you don't even have
to run your own server.

94
00:05:38.390 --> 00:05:40.718
Let me see if I can find it real quick.

95
00:05:40.718 --> 00:05:43.410
Yep.
Easier auto-updating for

96
00:05:43.410 --> 00:05:48.280
apps here is basically,
I believe it's update.electronjs.org,

97
00:05:48.280 --> 00:05:51.600
or something along those,
Yeah, update.electronjs.org.

98
00:05:51.600 --> 00:05:56.600
And so you can pull in this MPM module
[INAUDIBLE] Electron update app.

99
00:05:56.600 --> 00:05:58.210
You basically use it, and

100
00:05:58.210 --> 00:06:01.480
it uses their service to handle
all the pushing updates for you.

101
00:06:01.480 --> 00:06:04.520
So you don't have to worry about that.

102
00:06:04.520 --> 00:06:08.080
If it's closed source and

103
00:06:08.080 --> 00:06:12.480
pushing your code to another party is
not going to really work, however,

104
00:06:12.480 --> 00:06:17.310
it's private you gotta figure that
stuff out yourself, but I have,

105
00:06:17.310 --> 00:06:22.420
the the amount of servers I'd code
to push out updates is pretty tiny.

106
00:06:22.420 --> 00:06:25.090
It's, again, this status code.

107
00:06:25.090 --> 00:06:27.480
And then you know the URL for

108
00:06:27.480 --> 00:06:30.760
where I should pull the newest
archive from, right?

109
00:06:30.760 --> 00:06:36.590
And it'll pull that down,
it'll un-zip, it will use Squirrel to

110
00:06:36.590 --> 00:06:42.010
basically, this is saying, scroll and
then Sparkle, I think is the Mac OS one.

111
00:06:42.010 --> 00:06:43.570
Please don't quote me on this.

112
00:06:43.570 --> 00:06:47.180
Basically, that same annoying, there's
an update from this app that you see from

113
00:06:47.180 --> 00:06:49.270
every app, that is an open source tool.

114
00:06:49.270 --> 00:06:51.040
And it is built into Electron.

115
00:06:51.040 --> 00:06:53.690
And, basically,
it does the switch in place.

116
00:06:53.690 --> 00:06:55.460
So it's like, install and restart.

117
00:06:55.460 --> 00:06:58.430
And you install and restart and
you get the newest version of the box.

118
00:06:59.520 --> 00:07:01.370
Slack obviously uses the Mac App Store.

119
00:07:01.370 --> 00:07:02.760
So it's another way to do it.

120
00:07:02.760 --> 00:07:06.940
I don't know how they do it on Windows and
Linux, but

121
00:07:06.940 --> 00:07:12.110
I'm sure they either use Squirrel,
slash, Sparkle and stuff like that.

122
00:07:12.110 --> 00:07:14.320
So there's a bunch of options out there.

123
00:07:14.320 --> 00:07:17.310
Most of them are either open source,
or so proprietary,

124
00:07:17.310 --> 00:07:22.770
like the Mac app store, it's taken
care of for you in that sense as well.

125
00:07:22.770 --> 00:07:27.830
But yeah, you just need to like do all
the certificate stuff and code sign it.

126
00:07:27.830 --> 00:07:29.210
&gt;&gt; Speaker 2: It will
just take some research.

127
00:07:29.210 --> 00:07:29.770
&gt;&gt; Steve Kinney: Yeah.

128
00:07:29.770 --> 00:07:33.580
And like ideally with
Electron Forge they're like,

129
00:07:33.580 --> 00:07:34.610
there's a little bit of hand-waving.

130
00:07:34.610 --> 00:07:38.920
They're like, set up CI that runs the
build process on a Windows, on a Linux,

131
00:07:38.920 --> 00:07:41.310
and a Mac machine and
code signs it for you, right?

132
00:07:41.310 --> 00:07:45.580
I am most experienced doing
the code signing on Mac OS.

133
00:07:45.580 --> 00:07:50.738
Once you've done the code signing,
basically in Electron-packager,

134
00:07:50.738 --> 00:07:54.340
you go in and you do, once you set up
[INAUDIBLE] That's running on that

135
00:07:54.340 --> 00:07:59.290
computer, you do OSX-sign, and
that will code sign them on built.

136
00:07:59.290 --> 00:08:02.790
I think it's a little trick here on
trick here when it's in Linux and

137
00:08:02.790 --> 00:08:07.230
I don't have that enough memorized
to speak and go, it's super easy.

138
00:08:07.230 --> 00:08:09.526
It's a thing, so yeah.

139
00:08:12.553 --> 00:08:16.617
&gt;&gt; Speaker 2: One of the other questions I
had, I was just reading a Reddit thread,

140
00:08:16.617 --> 00:08:19.130
which is dangerous, I suppose, but-
&gt;&gt; Steve Kinney: Mm-hm.

141
00:08:19.130 --> 00:08:22.880
&gt;&gt; Speaker 2: They were just saying that
one of the things about natives apps

142
00:08:22.880 --> 00:08:26.550
versus, maybe, Electron apps is
that they're very memory intensive.

143
00:08:26.550 --> 00:08:27.200
&gt;&gt; Steve Kinney: Yeah.

144
00:08:27.200 --> 00:08:30.070
&gt;&gt; Speaker 2: I'm just wondering
if that's just because they're not

145
00:08:30.070 --> 00:08:34.210
running on multiple cores, if it's just,
there are multiple threads, but-

146
00:08:34.210 --> 00:08:35.130
&gt;&gt; Steve Kinney: I mean, Chrome,

147
00:08:35.130 --> 00:08:39.060
itself, is not known for

148
00:08:39.060 --> 00:08:43.370
being polite to your battery, so
now imagine running four Chromes.

149
00:08:43.370 --> 00:08:43.970
&gt;&gt; Speaker 2: Yeah.
&gt;&gt; Steve Kinney: Right?

150
00:08:43.970 --> 00:08:51.400
It's not like Slack, and Adam, and Visual
Studio code share the same Electron heart.

151
00:08:51.400 --> 00:08:54.230
They are all their own
individual versions, right?

152
00:08:54.230 --> 00:08:58.470
So they're pretty large files cuz
you're shipping all of Chromium, and

153
00:08:58.470 --> 00:09:00.220
all of Node, right?

154
00:09:00.220 --> 00:09:04.170
They are not particularly memory happy,
right?

155
00:09:04.170 --> 00:09:07.360
Slack is usually the app
that is pegging my CPU.

156
00:09:07.360 --> 00:09:08.710
Now, I don't know.

157
00:09:08.710 --> 00:09:12.180
Visual Studio Code feels great to me,
but I know that for a while, and

158
00:09:12.180 --> 00:09:13.950
this might not be true,
I don't use Atom anymore.

159
00:09:13.950 --> 00:09:17.320
But for
a while Atom was a little rough, right?

160
00:09:17.320 --> 00:09:19.420
And so, yeah, there are tradeoffs, right?

161
00:09:19.420 --> 00:09:23.240
Yes, you can write web technologies
to ship on multiple platforms, but

162
00:09:23.240 --> 00:09:25.850
it's not gonna be as small as
a Swift bundle is going to be.

163
00:09:25.850 --> 00:09:28.260
It's not going to be as memory efficient,
either, right?

164
00:09:28.260 --> 00:09:30.720
And that is, unfortunately,
computer science.

165
00:09:30.720 --> 00:09:34.950
We make these trade offs, and you got
to make a choice is the productivity or

166
00:09:34.950 --> 00:09:37.440
the fact that,
especially if it's an internal tool,

167
00:09:37.440 --> 00:09:41.110
you are never gonna sit down and
learn C sharp today, right?

168
00:09:41.110 --> 00:09:43.150
This app either didn't exist or

169
00:09:43.150 --> 00:09:46.660
it exists on Electron and
maybe it's not super memory efficient.

170
00:09:46.660 --> 00:09:50.780
This is really,
I'm gonna get angry tweets.

171
00:09:50.780 --> 00:09:54.570
I am of the philosophy,

172
00:09:55.590 --> 00:09:59.510
JavaScript was slow until we made it fast,
right?

173
00:09:59.510 --> 00:10:05.520
Generally speaking, that if we all move,

174
00:10:05.520 --> 00:10:11.670
in the same way when JavaScript became
popular then it became fast, right?

175
00:10:11.670 --> 00:10:16.890
If Electron apps really took off,
and a lot of them are, right?

176
00:10:16.890 --> 00:10:18.750
My suspicion is that in a year or

177
00:10:18.750 --> 00:10:21.870
two years,
a lot of that stuff will get handled.

178
00:10:21.870 --> 00:10:24.630
I'm sure the Chromium team doesn't
like the fact that they're

179
00:10:24.630 --> 00:10:26.970
using a lot of memory, right,
and stuff along those lines.

180
00:10:26.970 --> 00:10:30.980
It's like, generally speaking
we optimize for popularity.

181
00:10:30.980 --> 00:10:34.010
It's not that optimized
things become popular, right?

182
00:10:34.010 --> 00:10:36.820
So my general thing is,
what makes you the most efficient?

183
00:10:36.820 --> 00:10:38.460
And this is kind of the rails philosophy.

184
00:10:38.460 --> 00:10:42.590
Like rails is not the fastest framework in
the world, but the idea that developers

185
00:10:42.590 --> 00:10:46.880
are more expensive than more servers,
I think makes sense.

186
00:10:46.880 --> 00:10:48.870
In a certain sense.

187
00:10:48.870 --> 00:10:53.670
Yeah, I'm not gonna lie to you and
say they're particular memory efficient or

188
00:10:53.670 --> 00:10:54.448
small in size.

189
00:10:54.448 --> 00:10:56.460
They're not, right?

190
00:10:56.460 --> 00:10:58.960
But the application might not exist.

191
00:10:58.960 --> 00:10:59.650
Now, we should argue,

192
00:10:59.650 --> 00:11:03.680
should Microsoft be linking bespoke
versions of VS code for every platform?

193
00:11:03.680 --> 00:11:05.584
Yeah, they're Microsoft, sure, right?

194
00:11:05.584 --> 00:11:06.122
Slack, maybe, too.

195
00:11:06.122 --> 00:11:06.872
I don't know.
But for

196
00:11:06.872 --> 00:11:09.463
the internal application
you're gonna build, or

197
00:11:09.463 --> 00:11:11.460
something along those lines, right?

198
00:11:11.460 --> 00:11:15.858
It was either probably not going to
happen or is gonna happen in Electron.

199
00:11:15.858 --> 00:11:20.821
That's my view on that.

200
00:11:20.821 --> 00:11:23.850
And that's it.

201
00:11:23.850 --> 00:11:27.095
Thank you so much.

202
00:11:27.095 --> 00:11:27.962
&gt;&gt; [APPLAUSE]

