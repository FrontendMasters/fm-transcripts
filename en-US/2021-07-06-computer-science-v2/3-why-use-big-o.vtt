WEBVTT

1
00:00:00.000 --> 00:00:03.607
So, why is this useful to one?

2
00:00:03.607 --> 00:00:07.443
Again, this is gonna be really useful when
you go interview at tech companies because

3
00:00:07.443 --> 00:00:10.658
they love to ask you, what's the Big O
of the algorithm you just wrote?

4
00:00:10.658 --> 00:00:15.648
And I kinda gave you some tricks, which
is like look for four loops, but also you

5
00:00:15.648 --> 00:00:20.343
need to have a bit more critical eye in
terms of just think about in general,

6
00:00:20.343 --> 00:00:25.138
the more items I add to this array,
how much longer is it gonna take, right?

7
00:00:25.138 --> 00:00:28.453
The more inputs I give
it does it take longer?

8
00:00:28.453 --> 00:00:33.066
So, that four loop trick doesn't
always work in the sense that there

9
00:00:33.066 --> 00:00:37.933
can be other things that can contribute
to it, but just be aware of that.

10
00:00:37.933 --> 00:00:41.294
Let's talk about why you would
use this actually in a day job.

11
00:00:41.294 --> 00:00:46.657
So I gave an example here, which is like
let's say you're writing a comment system

12
00:00:46.657 --> 00:00:51.652
for a website, and that comment system
had a sorting and filtering ability.

13
00:00:51.652 --> 00:00:55.019
What's the appropriate Big O for
assorting and

14
00:00:55.019 --> 00:00:58.145
filtering algorithm for a comment system?

15
00:01:00.448 --> 00:01:05.596
Now, the response I want you
to have to that question is,

16
00:01:05.596 --> 00:01:11.298
you didn't give me enough information,
it depends, right.

17
00:01:11.298 --> 00:01:15.172
That's why whenever you ask
a computer scientist a question,

18
00:01:15.172 --> 00:01:20.443
their answer is like 99 times out of 100,
it depends, I need more information.

19
00:01:20.443 --> 00:01:25.536
So, I know it annoys people to say it
depends, give me more information,

20
00:01:25.536 --> 00:01:29.493
but it's actually the correct
answer to that question.

21
00:01:29.493 --> 00:01:34.058
Because, if you're sorting and
filtering for comments on a,

22
00:01:34.058 --> 00:01:39.057
like a small colleges or site any
given article there's only three or

23
00:01:39.057 --> 00:01:44.589
four different comments, the answer
is it doesn't matter, [LAUGH] right.

24
00:01:44.589 --> 00:01:49.957
It doesn't matter if you have
complexity of Big O of n cubed.

25
00:01:49.957 --> 00:01:55.028
Because if you're only sorting and
filtering three or four comments at

26
00:01:55.028 --> 00:02:00.942
a time, it really just profoundly doesn't
matter how fast that algorithm takes,

27
00:02:00.942 --> 00:02:04.914
because the difference between
three milliseconds and

28
00:02:04.914 --> 00:02:09.837
15 milliseconds is basically
negligible to an end user, mostly.

29
00:02:09.837 --> 00:02:13.012
But if you can write better code,
more understandable,

30
00:02:13.012 --> 00:02:16.189
more maintainable code, so
that people can come back and

31
00:02:16.189 --> 00:02:20.308
maintain your code later and better,
that's what you wanna do, right.

32
00:02:20.308 --> 00:02:21.811
That's the correct
answer of that question.

33
00:02:21.811 --> 00:02:23.487
It's not write the fastest sorting and

34
00:02:23.487 --> 00:02:26.446
filtering algorithm because it
just doesn't make any difference.

35
00:02:26.446 --> 00:02:32.969
My point here is, don't spend time
on things that don't matter, right.

36
00:02:32.969 --> 00:02:38.451
But I used to work at Reddit,
right, and if Reddit had a sort and

37
00:02:38.451 --> 00:02:44.139
filtering algorithm of n cubed,
you would never see reddit.com

38
00:02:44.139 --> 00:02:48.811
ever again because it gets so
many comments, right.

39
00:02:48.811 --> 00:02:54.323
So the Big O of that sorting
algorithm makes a massive difference.

40
00:02:55.944 --> 00:03:00.853
It's something that was unscrapable
probably crashed the site consistently.

41
00:03:00.853 --> 00:03:05.166
So this is why Big O is necessary in
the sense of like, it's a tool, right.

42
00:03:05.166 --> 00:03:09.631
I didn't give you the way to judge this
algorithm is better than this algorithm,

43
00:03:09.631 --> 00:03:11.611
that was not my intention, right.

44
00:03:11.611 --> 00:03:14.826
That's like saying that like
if I gave you a 12 inch ruler,

45
00:03:14.826 --> 00:03:17.233
you would never need a tape measure,
right.

46
00:03:17.233 --> 00:03:21.099
It's just one tool in your toolbox for
measuring algorithms, but

47
00:03:21.099 --> 00:03:24.491
you need to compare things
across multiple axes, right.

48
00:03:24.491 --> 00:03:29.122
This is where I'm getting back to,
this is the science of trade offs, right.

49
00:03:29.122 --> 00:03:34.738
And I'm giving you one of the measurement
sticks here to measure your algorithms.

50
00:03:37.512 --> 00:03:41.885
Yeah, the question is always got to be,
it depends give me more information,

51
00:03:41.885 --> 00:03:43.293
what do you need me to do?

52
00:03:43.293 --> 00:03:46.494
And like again, this is kind of
a pro tip for interviewing as well.

53
00:03:46.494 --> 00:03:50.366
Pull as much information out of the
interviewer that you possibly can, right.

54
00:03:50.366 --> 00:03:54.052
If they just say, Hey, we're writing
a sorting for these comments,

55
00:03:54.052 --> 00:03:57.988
don't just pop in there and start
writing a sorting algorithm right away,

56
00:03:57.988 --> 00:03:59.692
that's the incorrect answer.

57
00:03:59.692 --> 00:04:01.157
You wanna say, what am I doing?

58
00:04:01.157 --> 00:04:02.616
Who's the end user?

59
00:04:02.616 --> 00:04:03.894
What's my constraints?

60
00:04:03.894 --> 00:04:05.564
What devices am I running on?

61
00:04:05.564 --> 00:04:07.569
Am I running on 5G?

62
00:04:07.569 --> 00:04:09.205
Am I running on 2G, right?

63
00:04:09.205 --> 00:04:11.467
These are the kinda questions that
you need to be thinking about.

64
00:04:11.467 --> 00:04:16.160
You need to paint a complete picture
of what the actual requirements are.

