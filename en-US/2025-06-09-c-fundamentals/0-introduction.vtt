WEBVTT

1
00:00:00.077 --> 00:00:01.797
&gt;&gt; Richard Feldman: All right,
welcome to C Fundamentals.

2
00:00:01.797 --> 00:00:02.705
I'm Richard Feldman.

3
00:00:02.705 --> 00:00:04.143
Thanks for coming everybody.

4
00:00:04.143 --> 00:00:06.588
Yeah, we've got some here to get set up.

5
00:00:06.588 --> 00:00:08.506
This is just instructions for
the exercises, so

6
00:00:08.506 --> 00:00:10.629
don't worry if you don't
have that set up right now.

7
00:00:10.629 --> 00:00:13.869
You can totally follow along in
the slides if you don't have this set up.

8
00:00:13.869 --> 00:00:18.221
Hopefully every machine you're on, if you
are using a macOS or Windows Subsystem for

9
00:00:18.221 --> 00:00:22.166
Linux or actual Linux, you should already
have a C compiler on your machine.

10
00:00:22.166 --> 00:00:25.285
[LAUGH] So you won't need anything
else to be able to do the exercises.

11
00:00:25.285 --> 00:00:26.495
So it shouldn't be much of a set up.

12
00:00:26.495 --> 00:00:29.289
So, we're gonna go through a couple
of different sections here.

13
00:00:29.289 --> 00:00:32.716
So the first is we're just gonna have
a little introduction section right here.

14
00:00:32.716 --> 00:00:36.244
And in this section we're just
gonna talk about what is C,

15
00:00:36.244 --> 00:00:41.226
why is C still popular today, and why is
there no windows version for this course?

16
00:00:41.226 --> 00:00:43.587
And finally,
just a little bit of a course overview.

17
00:00:43.587 --> 00:00:47.059
So I'll start off by just answering
the basic question, what is C?

18
00:00:47.059 --> 00:00:50.500
So C is one of the top 10 most
popular programming languages today,

19
00:00:50.500 --> 00:00:53.484
right now in 2025, and
this has been true for decades.

20
00:00:53.484 --> 00:00:56.056
It is not only a very
popular language today, but

21
00:00:56.056 --> 00:00:59.020
it has been a very popular language for
a very long time.

22
00:00:59.020 --> 00:01:03.966
C was originally designed to build UNIX or
for building the UNIX operating system.

23
00:01:03.966 --> 00:01:05.823
Today, there's a whole
lot of spin offs of UNIX.

24
00:01:05.823 --> 00:01:10.776
So macOS is based on the BSD
flavor of UNIX, as is iOS.

25
00:01:10.776 --> 00:01:14.885
Linux is its own flavor of UNIX that's
separate from BSD, and actually,

26
00:01:14.885 --> 00:01:19.591
later on in the workshop, we're gonna see
a relevant distinction between Linux and

27
00:01:19.591 --> 00:01:21.599
BSD when it comes to writing C code.

28
00:01:21.599 --> 00:01:23.871
Android, also based on UNIX.

29
00:01:23.871 --> 00:01:27.777
Windows is not based on UNIX,
but it is also written in C.

30
00:01:27.777 --> 00:01:31.119
Other things that are not operating
systems that are written in C include

31
00:01:31.119 --> 00:01:35.229
PostgreSQL, MySQL, redis, probably every
database you've ever used there's a very

32
00:01:35.229 --> 00:01:36.960
good chance that it was written in C.

33
00:01:36.960 --> 00:01:40.271
Python, like programming languages,
yeah, php, Ruby.

34
00:01:40.271 --> 00:01:44.368
This might surprise you that so
many things today are written in C.

35
00:01:44.368 --> 00:01:48.460
Considering that it's a language that
was originally released in 1972,

36
00:01:48.460 --> 00:01:50.695
which is over 50 years ago at this point.

37
00:01:50.695 --> 00:01:54.826
So to say that C has had a lot of staying
power is really, really an understatement.

38
00:01:54.826 --> 00:01:58.663
To put this in perspective, 1972,
the year that the C came out,

39
00:01:58.663 --> 00:02:02.435
this was Stevie Wonder released
the song Superstition, and ABBA,

40
00:02:02.435 --> 00:02:04.901
the band [LAUGH] was
first initially formed.

41
00:02:04.901 --> 00:02:06.530
So this was a long time ago.

42
00:02:06.530 --> 00:02:07.811
The world looked very different,

43
00:02:07.811 --> 00:02:10.338
and the world of programming
especially it looked very different.

44
00:02:10.338 --> 00:02:14.214
So when they were building C this
was literally the machine they were

45
00:02:14.214 --> 00:02:15.171
building it on.

46
00:02:15.171 --> 00:02:16.596
This is a PDP-11.

47
00:02:16.596 --> 00:02:18.933
Now, this is not quite back
in the punch card era, so

48
00:02:18.933 --> 00:02:20.485
I actually brought a little prop.

49
00:02:20.485 --> 00:02:23.253
If you ever wonder what a punch card was,
I bought this on eBay for

50
00:02:23.253 --> 00:02:24.809
about a dollar 50 plus shipping.

51
00:02:24.809 --> 00:02:26.047
[LAUGH] You can still get these things.

52
00:02:26.047 --> 00:02:27.913
So back in the way, back in the day,

53
00:02:27.913 --> 00:02:31.734
you would actually physically punch
holes in a card and that was your UI.

54
00:02:31.734 --> 00:02:35.783
That was your UX,
this is your feedback loop.

55
00:02:35.783 --> 00:02:37.143
They had a slightly
different feedback loop.

56
00:02:37.143 --> 00:02:40.243
It was significantly improved over
punch cards on this machine here.

57
00:02:40.243 --> 00:02:44.565
This is Dennis Ritchie, who created C,
and Ken Thompson, who designed UNIX.

58
00:02:44.565 --> 00:02:48.426
And actually we were talking a little
bit about Go earlier, Ken Thompson,

59
00:02:48.426 --> 00:02:50.339
also one of the designers of Golang.

60
00:02:50.339 --> 00:02:53.671
And this machine that they're
working on is called the PDP-11.

61
00:02:53.671 --> 00:02:57.587
So the PDP-11, [COUGH] you might notice,
does not have a monitor.

62
00:02:57.587 --> 00:03:00.145
And if you look at their eyesight,
what are they actually looking at?

63
00:03:00.145 --> 00:03:02.578
They're looking down at this thing
that's right above the keyboard.

64
00:03:02.578 --> 00:03:04.940
So what is that thing?

65
00:03:04.940 --> 00:03:07.738
That thing is a teletype.

66
00:03:07.738 --> 00:03:10.435
So a teletype, for
those who are not familiar,

67
00:03:10.435 --> 00:03:13.411
this is a little video of
a [LAUGH] teletype in action.

68
00:03:13.411 --> 00:03:17.907
A teletype is an old, essentially
combination keyboard/typewriter.

69
00:03:17.907 --> 00:03:20.098
So a typewriter, you press a key and

70
00:03:20.098 --> 00:03:24.343
it immediately puts a character onto
a piece of paper, it prints it.

71
00:03:24.343 --> 00:03:27.070
Now what they're doing is,
at first they're doing that, but

72
00:03:27.070 --> 00:03:30.518
then when they press Enter, you might
notice that it starts typing without them

73
00:03:30.518 --> 00:03:32.023
actually pressing the keys more.

74
00:03:32.023 --> 00:03:35.263
So the idea behind a teletype is you
can use it as both input and output.

75
00:03:35.263 --> 00:03:39.212
So, they are now running a computer
program, and the output of that computer

76
00:03:39.212 --> 00:03:42.699
program is being physically printed
onto the page by the teletype.

77
00:03:42.699 --> 00:03:46.842
So if you've ever wondered why
computers use the term print for

78
00:03:46.842 --> 00:03:49.275
writing to the screen, this is why.

79
00:03:49.275 --> 00:03:52.440
Back then it was a very intuitive
name cuz it's, well, yeah,

80
00:03:52.440 --> 00:03:56.472
you're gonna print now [LAUGH] you're
printing characters onto the teletype.

81
00:03:56.472 --> 00:04:00.018
And sure enough, as we're gonna see, C
uses the term print because literally this

82
00:04:00.018 --> 00:04:03.783
was the machine that they were originally
doing it on, was a PDP-11 with a teletype.

83
00:04:03.783 --> 00:04:06.307
I mentioned this because
this context is relevant for

84
00:04:06.307 --> 00:04:08.886
a lot of the design decisions and
some of the things that

85
00:04:08.886 --> 00:04:12.923
maybe today don't feel super ergonomic
that we're gonna encounter in this course,

86
00:04:12.923 --> 00:04:16.311
such as really short kind of weird
variable names and things like that.

87
00:04:16.311 --> 00:04:20.473
You can imagine, if you were working on
one of these things where you literally

88
00:04:20.473 --> 00:04:24.131
have a physical piece of paper
constraining the width of the output,

89
00:04:24.131 --> 00:04:27.302
having short variable names is
kind of an important thing.

90
00:04:27.302 --> 00:04:30.626
It's not you have somebody who's really
dogmatic about their formatting and

91
00:04:30.626 --> 00:04:33.845
saying, you must stick to 80 character
width as a matter of our formatting

92
00:04:33.845 --> 00:04:34.611
configuration.

93
00:04:34.611 --> 00:04:38.488
It's no, no, no, 80 characters is
literally all you get, and that's it.

94
00:04:38.488 --> 00:04:41.567
The physical printer does not
go past 80 characters [LAUGH] so

95
00:04:41.567 --> 00:04:43.232
that's all you got to work with.

96
00:04:43.232 --> 00:04:44.442
That type of thing.

97
00:04:44.442 --> 00:04:46.483
Also, they had a lot of
performance constraints.

98
00:04:46.483 --> 00:04:50.485
So the PDP-11 had a whopping
256 kilobytes of memory.

99
00:04:50.485 --> 00:04:52.472
It had 1-core single CPU.

100
00:04:52.472 --> 00:04:56.092
So no multi-core anything,
no parallel processing of any kind.

101
00:04:56.092 --> 00:04:59.458
It ran at a blistering 125
kilohertz on that 1-core.

102
00:04:59.458 --> 00:05:04.878
So not only was it 110 of a megahertz,
not even close to a gigahertz.

103
00:05:04.878 --> 00:05:09.549
So this is essentially the world that they
were living in when they designed and

104
00:05:09.549 --> 00:05:10.413
developed C.

105
00:05:10.413 --> 00:05:13.122
Despite that they were able
to build a language that

106
00:05:13.122 --> 00:05:16.466
supported building all of these
tools that we still use today.

107
00:05:16.466 --> 00:05:20.643
Which then leads to the question, if this
was the language that they were building

108
00:05:20.643 --> 00:05:24.456
for this kind of hardware, why would
people still use it on modern hardware

109
00:05:24.456 --> 00:05:26.651
when modern hardware runs so much faster?

110
00:05:26.651 --> 00:05:29.843
Well, one of the things you might notice
about all of these pieces of software on

111
00:05:29.843 --> 00:05:32.132
the screen here is that they're
all things that really,

112
00:05:32.132 --> 00:05:33.482
really care about performance.

113
00:05:33.482 --> 00:05:38.300
They're things where if you can get
something to run acceptably fast on this

114
00:05:38.300 --> 00:05:43.193
kind of hardware, imagine what you
can do with something that has 3264,

115
00:05:43.193 --> 00:05:47.354
gigabytes of memory and
16-core CPU and multiple gigahertz.

116
00:05:47.354 --> 00:05:51.962
Yeah, you can get something that runs
very, very fast on modern hardware.

117
00:05:51.962 --> 00:05:55.062
So fundamentally,
what people sort of jokingly,

118
00:05:55.062 --> 00:05:58.607
kind of half seriously refer
to C as is portable assembly.

119
00:05:58.607 --> 00:06:03.194
And assembly language is essentially one
very thin layer of abstraction on top of

120
00:06:03.194 --> 00:06:06.575
hardware machine instructions
that the CPU understands.

121
00:06:06.575 --> 00:06:10.015
So it's instead of ones and
zeros, you have some actual text.

122
00:06:10.015 --> 00:06:12.830
So it's a programming language.

123
00:06:12.830 --> 00:06:16.898
It's not an actual writing bits and
bytes by hand.

124
00:06:16.898 --> 00:06:20.747
But the level of abstraction that it
adds on top of that is very, very thin.

125
00:06:20.747 --> 00:06:22.699
And it's also very machine-specific.

126
00:06:22.699 --> 00:06:25.488
So when you're writing assembly,
you're writing assembly for

127
00:06:25.488 --> 00:06:26.918
a particular CPU architecture.

128
00:06:26.918 --> 00:06:30.257
So C is portable in the sense that it's
not technically coupled to any one

129
00:06:30.257 --> 00:06:33.761
particular CPU architecture, although
as we will see later in the course,

130
00:06:33.761 --> 00:06:37.156
you do have the option of doing some
more sort of targeted things depending

131
00:06:37.156 --> 00:06:38.607
on what you're building for.

132
00:06:38.607 --> 00:06:42.933
So it's not 100% portable, but
it is way more portable than assembly,

133
00:06:42.933 --> 00:06:44.026
that's for sure.

134
00:06:44.026 --> 00:06:47.720
And the reason that all of these programs
are still using C today is fundamentally,

135
00:06:47.720 --> 00:06:50.378
it lets you write software
that runs really, really fast.

136
00:06:50.378 --> 00:06:53.709
And the way that it does this is not
because it has some sort of magical

137
00:06:53.709 --> 00:06:58.036
optimizer, although they do have very nice
optimizers these days, but mainly because

138
00:06:58.036 --> 00:07:02.011
C offers you the ability to essentially
do zero-overhead programming or very,

139
00:07:02.011 --> 00:07:02.897
very close to it.

140
00:07:02.897 --> 00:07:05.622
About as close as you can get
without a little assembly.

141
00:07:05.622 --> 00:07:09.465
And actually, C includes inline assembly
in case you wanna drop down and

142
00:07:09.465 --> 00:07:13.309
do actual zero-overhead programming
in the middle of your C program and

143
00:07:13.309 --> 00:07:16.534
just talk directly to the hardware
that you're targeting.

144
00:07:16.534 --> 00:07:19.008
And this is a very powerful
way to get performance.

145
00:07:19.008 --> 00:07:21.996
Sometimes it's pretty manual,
sometimes it's pretty unsafe.

146
00:07:21.996 --> 00:07:25.211
I would say that C is also almost
zero-safety programming in addition to

147
00:07:25.211 --> 00:07:28.282
being zero-overhead, and
this is one of C's major shortcomings.

148
00:07:28.282 --> 00:07:30.989
Is that you can really not only
shoot yourself in the foot, but

149
00:07:30.989 --> 00:07:32.723
really blow your whole foot off with C.

150
00:07:32.723 --> 00:07:35.388
And don't worry, in the exercises
we're gonna see how to do that.

151
00:07:35.388 --> 00:07:38.496
So, [LAUGH], we'll have some fun with that
in a kind of constrained non-production

152
00:07:38.496 --> 00:07:39.079
environment.

153
00:07:39.079 --> 00:07:39.976
Yeah?

154
00:07:39.976 --> 00:07:44.411
&gt;&gt; Speaker 2: So by overhead, do you mean
that just translation that it takes to get

155
00:07:44.411 --> 00:07:47.705
from the layer above machine
code to machine code?

156
00:07:47.705 --> 00:07:48.441
&gt;&gt; Richard Feldman: Yeah, great question.

157
00:07:48.441 --> 00:07:52.292
So to be more specific about
what I mean about zero-overhead,

158
00:07:52.292 --> 00:07:54.688
really what I mean is things, I guess,

159
00:07:54.688 --> 00:07:58.994
the biggest example of overhead I
can think of is garbage collection.

160
00:07:58.994 --> 00:08:02.050
So any programming language that has
a garbage collector, that's a big

161
00:08:02.050 --> 00:08:05.419
convenience and it's a big boost for
safety, but it's also a lot of overhead.

162
00:08:05.419 --> 00:08:08.968
You have GC pauses now, and
also there's just a lot of book keeping.

163
00:08:08.968 --> 00:08:12.408
The amount of memory that your program is
gonna use is gonna go up significantly if

164
00:08:12.408 --> 00:08:13.731
you have a garbage collector.

165
00:08:13.731 --> 00:08:15.622
A lot of things are gonna run more slowly.

166
00:08:15.622 --> 00:08:17.478
C doesn't have a garbage collector.

167
00:08:17.478 --> 00:08:20.633
And you can take that example and
apply it to a number of other things.

168
00:08:20.633 --> 00:08:24.452
It's really basic stuff like if I'm in
Java or JavaScript, and I make an object

169
00:08:24.452 --> 00:08:28.621
that's gonna do a heap allocation, there's
gonna be some metadata on it at runtime.

170
00:08:28.621 --> 00:08:31.204
In C, it's no, there's no metadata,
there's no allocation.

171
00:08:31.204 --> 00:08:35.254
There's just the bare ones and zeros
that are required to store the info, and

172
00:08:35.254 --> 00:08:37.008
that's nothing else in memory.

173
00:08:37.008 --> 00:08:40.322
And you take that and
you apply that to the whole language, and

174
00:08:40.322 --> 00:08:41.807
it really starts to add up.

175
00:08:41.807 --> 00:08:42.853
The gap gets bigger and

176
00:08:42.853 --> 00:08:45.781
bigger between C and
languages that have more overhead than C.

177
00:08:45.781 --> 00:08:46.681
And also, finally,

178
00:08:46.681 --> 00:08:50.086
C is the language that other languages use
to talk to each other in the modern day.

179
00:08:50.086 --> 00:08:54.244
So pretty much any programming
language you can think of today,

180
00:08:54.244 --> 00:08:59.481
there is a almost 100% chance that that
language has some way of talking to C.

181
00:08:59.481 --> 00:09:03.119
Because it's just sort of the lingua
franca that's sort of emerged, and

182
00:09:03.119 --> 00:09:04.887
in part because of its popularity.

183
00:09:04.887 --> 00:09:08.586
So if you want to do, for example,
interop between Node.js and

184
00:09:08.586 --> 00:09:11.403
other language,
Node.js supports C interop.

185
00:09:11.403 --> 00:09:14.148
Haskell, which we talked about earlier,
has C interop.

186
00:09:14.148 --> 00:09:15.276
Rust has C interop.

187
00:09:15.276 --> 00:09:17.877
Pretty much every language
has some sort of C interop.

188
00:09:17.877 --> 00:09:20.962
Really, one of the only
exceptions to this, technically,

189
00:09:20.962 --> 00:09:25.375
would have been JavaScript in the browser,
which, for a long time, had absolutely no

190
00:09:25.375 --> 00:09:29.442
way to talk to C, although now through
WebAssembly, that is kind of possible.

191
00:09:29.442 --> 00:09:35.035
But it's really taken off as this way to
have one language talk to another one.

192
00:09:35.035 --> 00:09:39.059
If you've got Python embedded in Rust,
or something like that.

193
00:09:39.059 --> 00:09:42.745
The way that Python and Rust are
interacting and talking to each other is

194
00:09:42.745 --> 00:09:46.308
using C as an intermediary or
at least the C ABI, which is essentially

195
00:09:46.308 --> 00:09:50.376
the way that C represents things in
memory even if it's not literal.c files.

196
00:09:50.376 --> 00:09:52.986
&gt;&gt; Speaker 3: When people
say portable assembly or

197
00:09:52.986 --> 00:09:56.100
they can see assembly
through their C code,

198
00:09:56.100 --> 00:10:01.164
do they mean this because they know
how the language works internally?

199
00:10:01.164 --> 00:10:03.259
&gt;&gt; Richard Feldman: So
when people say portable assembly,

200
00:10:03.259 --> 00:10:07.702
the main thing that they're talking about
is that C offers you essentially the same

201
00:10:07.702 --> 00:10:10.701
benefits as assembly in terms
of minimizing overhead.

202
00:10:10.701 --> 00:10:11.522
It's not quite true.

203
00:10:11.522 --> 00:10:15.666
Assembly does give you a little bit more
control over things like CPU registers

204
00:10:15.666 --> 00:10:16.366
than C does.

205
00:10:16.366 --> 00:10:20.619
But the portability part really refers
to the fact that I can write a .c file,

206
00:10:20.619 --> 00:10:22.196
I can write my C source code.

207
00:10:22.196 --> 00:10:26.910
And then without changing that
code at all, compile it for, for

208
00:10:26.910 --> 00:10:30.944
example, this MacBook here
is an ARM64 processor.

209
00:10:30.944 --> 00:10:34.263
My desktop computer at home
is an Intel x64 processor.

210
00:10:34.263 --> 00:10:36.100
These are different CPU architectures.

211
00:10:36.100 --> 00:10:41.077
If I were doing assembly programming for
this MacBook versus that desktop

212
00:10:41.077 --> 00:10:46.307
Intel that I have at home, those would
just be different assembly programs.

213
00:10:46.307 --> 00:10:48.353
The source code files would
have to be different.

214
00:10:48.353 --> 00:10:52.028
In contrast, if I'm writing C,
I can write one C program and

215
00:10:52.028 --> 00:10:56.854
then just tell the compiler to build one
for ARM64 and build one for x64, and

216
00:10:56.854 --> 00:11:01.465
the same exact C code will work and
give me two different runnable binaries,

217
00:11:01.465 --> 00:11:05.597
executables, that I can run one on
the MacBook and one on the Intel.

218
00:11:05.597 --> 00:11:06.293
So that's the difference.

219
00:11:06.293 --> 00:11:10.607
It's portability in terms of being able
to write your source code once and

220
00:11:10.607 --> 00:11:14.305
then compile it to multiple
different target architectures.

221
00:11:14.305 --> 00:11:16.986
A lot of other languages will do
this by having a virtual machine or

222
00:11:16.986 --> 00:11:18.463
something that's like a runtime.

223
00:11:18.463 --> 00:11:20.515
So the Java virtual machine
is a very popular one.

224
00:11:20.515 --> 00:11:23.966
Obviously browsers have
JavaScript virtual machines.

225
00:11:23.966 --> 00:11:26.553
But that's a much higher
overhead version of things.

226
00:11:26.553 --> 00:11:29.736
You notice if you actually go to download
a browser, you go to download the Java

227
00:11:29.736 --> 00:11:31.970
virtual machine,
which is just a binary executable.

228
00:11:31.970 --> 00:11:35.823
On the download page, they'll say,
download this for ARM64 Mac or

229
00:11:35.823 --> 00:11:38.059
for Intel Linux or something like that.

230
00:11:38.059 --> 00:11:42.304
So that's what they mean by portability
is across operating systems and

231
00:11:42.304 --> 00:11:43.563
CPU architectures.

232
00:11:43.636 --> 00:11:45.697
So first we're gonna talk
about strings and numbers.

233
00:11:45.697 --> 00:11:48.080
We're gonna get into some file I/O.

234
00:11:48.080 --> 00:11:53.250
We're gonna get into building an actual
static webserver using that stuff.

235
00:11:53.250 --> 00:11:57.253
And then the very end, we're gonna talk
a little bit about basically how you would

236
00:11:57.253 --> 00:12:00.749
use the things you've learned if you
wanted to make a Node.js C addon.

237
00:12:00.749 --> 00:12:02.115
For time constraints, we're not actually
gonna build the Node.js C addon, but

238
00:12:02.115 --> 00:12:06.209
I did wanna mention it at
the very end of the course,

249
00:12:06.209 --> 00:12:09.525
just if you wanted to take these concepts
and apply them in the JavaScript world,

250
00:12:09.525 --> 00:12:11.668
this is how you would
actually go about doing that.
