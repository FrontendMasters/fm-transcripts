WEBVTT

1
00:00:00.008 --> 00:00:05.593
&gt;&gt; Brian Lonsdorf: The voyage [LAUGH] so
I love how big it

2
00:00:05.593 --> 00:00:12.017
sounds [LAUGH] okay, I'm gonna start-
&gt;&gt; Speaker 2: I

3
00:00:12.017 --> 00:00:16.441
can fall in love with that.
&gt;&gt; Brian Lonsdorf: [LAUGH] The voyage.

4
00:00:16.441 --> 00:00:23.990
So the point, the point is that If I
add one to one, I get another number.

5
00:00:23.990 --> 00:00:25.000
That's two.

6
00:00:25.000 --> 00:00:27.820
And everybody should know exactly
what that does even though you don't

7
00:00:27.820 --> 00:00:31.800
know what the implementation is, because
it's bigger than what I came up with.

8
00:00:31.800 --> 00:00:35.760
Somebody else came up
with it a long time ago.

9
00:00:35.760 --> 00:00:40.610
And it's got some properties and
laws with it.

10
00:00:40.610 --> 00:00:42.560
So we know it's associative.

11
00:00:42.560 --> 00:00:43.980
That means it doesn't
matter how it's grouped.

12
00:00:43.980 --> 00:00:45.990
It's always just gonna end
up with the same result.

13
00:00:45.990 --> 00:00:47.510
It's commutative.

14
00:00:47.510 --> 00:00:50.070
We've got identity and down at the bottom,

15
00:00:50.070 --> 00:00:52.580
we even know how it works
with other functions.

16
00:00:52.580 --> 00:00:53.370
This is incredible.

17
00:00:53.370 --> 00:00:58.590
Could you imagine if all of your functions
had this book of, you can do this with it?

18
00:00:58.590 --> 00:01:03.960
And you can always guarantee,
we've got these theorems and formulas.

19
00:01:03.960 --> 00:01:06.960
You're basically,
you don't have to know it.

20
00:01:06.960 --> 00:01:08.360
You can just add without that.

21
00:01:08.360 --> 00:01:13.030
But, if you want to, boom,
an ocean of knowledge, right?

22
00:01:13.030 --> 00:01:14.460
So that's pretty beneficial.

23
00:01:15.610 --> 00:01:18.690
And with other,
another cool thing about add,

24
00:01:18.690 --> 00:01:23.960
I'm basically regurgitating my fluent talk
right now, but I'll get in other stuff.

25
00:01:23.960 --> 00:01:28.670
This, right here is,
you've got an intuition behind it.

26
00:01:28.670 --> 00:01:29.600
And it's polymorphic.

27
00:01:30.950 --> 00:01:34.440
So we can add strings together,
we can add floats together.

28
00:01:34.440 --> 00:01:36.890
I mean, floats are still numbers but
in other languages it still works,

29
00:01:36.890 --> 00:01:38.270
big nums, whatever.

30
00:01:38.270 --> 00:01:40.890
Down at the bottom we're
adding arrays together.

31
00:01:40.890 --> 00:01:44.620
There's an intuition behind add,
and those laws will still hold.

32
00:01:45.670 --> 00:01:49.000
Maybe not for this particular crazy add.

33
00:01:49.000 --> 00:01:52.630
But when you work with these other
functions that have these laws with them,

34
00:01:52.630 --> 00:01:54.220
they'll always hold for every type.

35
00:01:54.220 --> 00:01:55.140
Which is really cool.

36
00:01:55.140 --> 00:01:57.090
So you have an intuition and
laws attached.

37
00:01:58.860 --> 00:02:01.230
Hey, guess what compose is?

38
00:02:01.230 --> 00:02:01.960
[LAUGH] It's like add.

39
00:02:03.290 --> 00:02:10.610
It's got laws and it's got properties,
and it's actually polymorphic.

40
00:02:10.610 --> 00:02:13.600
You can use it on other things
besides just functions.

41
00:02:13.600 --> 00:02:14.670
It's incredible.

42
00:02:14.670 --> 00:02:16.313
It's just like add.

43
00:02:16.313 --> 00:02:18.040
So we're gonna go into category theory.

44
00:02:19.250 --> 00:02:21.710
Probably weeping at this point,
like, what I did sign up for?

45
00:02:23.420 --> 00:02:26.692
But if nobody understands
this type signature,

46
00:02:26.692 --> 00:02:27.972
cuz I just threw it up on the screen.

47
00:02:27.972 --> 00:02:34.730
The (b -&gt; c) is a function that takes
any variable, any type b to any type c.

48
00:02:34.730 --> 00:02:38.770
Second one's any function that takes
a to b or returning a function a to c.

49
00:02:38.770 --> 00:02:43.150
So basically it runs the middle one,
and then the first one,

50
00:02:43.150 --> 00:02:44.900
and ends up with the last one.

51
00:02:44.900 --> 00:02:48.170
But you guys know what compose does and
we'll see a lot more type signatures,

52
00:02:48.170 --> 00:02:49.594
it's not real important.
&gt;&gt; Speaker 3: Is that a Haskell?

53
00:02:49.594 --> 00:02:50.189
&gt;&gt; Brian Lonsdorf: That's a Haskell.

54
00:02:50.189 --> 00:02:51.300
&gt;&gt; Speaker 3: [CROSSTALK] That's a Haskell

55
00:02:51.300 --> 00:02:51.971
set.
&gt;&gt; Brian Lonsdorf: That's

56
00:02:51.971 --> 00:02:53.234
a Henry Milner, yeah.

57
00:02:53.234 --> 00:02:55.213
There's no big deal with it.

58
00:02:55.213 --> 00:02:57.370
This is kind of a complicated one.

59
00:02:57.370 --> 00:02:59.060
I'll walk through them as we see them.

60
00:02:59.060 --> 00:03:02.745
And you don't really
need to know this one,

61
00:03:02.745 --> 00:03:07.128
but the important part about
category theory is that

62
00:03:07.128 --> 00:03:12.630
you need a composition and
an identity to form a category.

63
00:03:12.630 --> 00:03:15.650
And we're working with the function
category when we're dealing with

64
00:03:15.650 --> 00:03:18.500
just normal compose and
identity on functions.

65
00:03:18.500 --> 00:03:20.860
Does everybody know what
the identity function is?

66
00:03:22.000 --> 00:03:25.480
Basically you give it a value and
it just spits it right back out at you.

67
00:03:25.480 --> 00:03:28.730
[LAUGH] So you're like,
why would I need that?

68
00:03:28.730 --> 00:03:32.511
It's pretty valuable when you're
doing point-free programming,

69
00:03:32.511 --> 00:03:35.340
you could do filter ID to
refer to the thing going in.

70
00:03:35.340 --> 00:03:39.372
It's kind of weird, so, but the point
is you need an identity function and

71
00:03:39.372 --> 00:03:42.450
a composition function and
you can have the categories.

72
00:03:42.450 --> 00:03:44.510
So, it's kind of a design pattern
we're gonna use in our programs.

73
00:03:45.790 --> 00:03:48.780
So here, there's laws associated with it.

74
00:03:48.780 --> 00:03:51.663
That means if I compose the left and
right identity,

75
00:03:51.663 --> 00:03:55.345
it's always just gonna be just
like running the normal function.

76
00:03:55.345 --> 00:03:58.036
Cuz if identity just spits
the argument right back out at you,

77
00:03:58.036 --> 00:03:59.540
I mean what's the point?

78
00:03:59.540 --> 00:04:01.010
It's always just gonna work.

79
00:04:01.010 --> 00:04:02.660
Down at the bottom is associative.

80
00:04:02.660 --> 00:04:06.340
That's why we've been able to
compose x amount of arguments.

81
00:04:06.340 --> 00:04:08.280
It doesn't matter how they're grouped.

82
00:04:08.280 --> 00:04:11.510
It's also why we're able to
just grab any subcomposition

83
00:04:11.510 --> 00:04:15.940
any two functions in a row in our compose,
and pull it out into its own function.

84
00:04:15.940 --> 00:04:20.186
So this isn't Haskell syntax, no.

85
00:04:20.186 --> 00:04:22.150
Whoa, my mouse is all crazy.

86
00:04:23.440 --> 00:04:25.530
That's weird, it's like a delay, okay.

87
00:04:27.510 --> 00:04:33.320
So like we saw over in this over here,
we could grab out any two.

88
00:04:33.320 --> 00:04:38.450
If I had F and G and H right here,
I could just be like, these go together.

89
00:04:38.450 --> 00:04:45.215
Boom, and I'll make a new one called J
that is the subcomposition of these.

90
00:04:45.215 --> 00:04:50.316
And the reason for that is that compose
is associated so it doesn't matter how

91
00:04:50.316 --> 00:04:55.430
these are grouped together, so you can
pull them out in their own functions.

92
00:04:55.430 --> 00:04:56.450
So that's really neat.

93
00:04:56.450 --> 00:04:57.502
It's just like add.

94
00:04:57.502 --> 00:05:01.630
It doesn't matter if you add 1 and
2 or 2 and 3.

95
00:05:01.630 --> 00:05:02.940
They always end up in the same result.

