WEBVTT

1
00:00:00.040 --> 00:00:01.980
Moral of the story, don't use reg X's.

2
00:00:01.980 --> 00:00:05.005
All right, I think we should
probably continue on from here,

3
00:00:05.005 --> 00:00:07.331
reg x's are just graphs
underneath the hood and

4
00:00:07.331 --> 00:00:10.080
traversing is the characters
in which go through that.

5
00:00:10.080 --> 00:00:12.935
So, there you go,
graphs are literally there.

6
00:00:12.935 --> 00:00:16.773
All right, so we're kind of getting
into the next part of Recursion.

7
00:00:16.773 --> 00:00:19.399
If you don't understand recursion,
you can always Google it,

8
00:00:19.399 --> 00:00:20.910
though I did find a bug in recursion.

9
00:00:20.910 --> 00:00:21.861
Are you ready for this?

10
00:00:21.861 --> 00:00:24.887
So if you don't get the joke,
if you type in recursion and

11
00:00:24.887 --> 00:00:27.992
you hit Enter, Google will say,
did you mean recursion?

12
00:00:27.992 --> 00:00:31.868
And, my goodness, I can't see my mouse
through the 4K, and if you click it,

13
00:00:31.868 --> 00:00:33.641
it'll say, do you mean recursion?

14
00:00:33.641 --> 00:00:35.970
And you keep on asking it,
does it forever.

15
00:00:35.970 --> 00:00:36.992
That's the joke, right?

16
00:00:36.992 --> 00:00:41.553
But if you misspell it and it says,
search results for recursion,

17
00:00:41.553 --> 00:00:44.655
it actually doesn't do the recursion joke.

18
00:00:44.655 --> 00:00:46.642
Look at that, I've busted Google.

19
00:00:46.642 --> 00:00:49.332
Anyways, I thought that was kinda funny.

20
00:00:49.332 --> 00:00:52.370
I discovered it two days ago
cuz I mistyped recursion.

21
00:00:52.370 --> 00:00:56.430
Anyway, so that is the most visual
way you can look at recursion.

22
00:00:56.430 --> 00:00:59.390
It's something that keeps on
calling itself over and over again.

23
00:00:59.390 --> 00:01:01.595
In this room, how many of you
are familiar with recursion?

24
00:01:04.706 --> 00:01:07.052
Okay we got a couple no's, couple yeses.

25
00:01:07.052 --> 00:01:09.914
I even had a hand back in the production
staff, they said, yeah, I got it.

26
00:01:09.914 --> 00:01:11.277
That was awesome.

27
00:01:11.277 --> 00:01:15.310
How about tweet chat, all the chats, or
hot chats and masters chats, how are they?

28
00:01:15.310 --> 00:01:18.576
Pretty good one, if you don't know
recursion, two if you know it.

29
00:01:18.576 --> 00:01:21.443
Cuz I'm just curious how much,

30
00:01:21.443 --> 00:01:26.761
I don't even know what the average
understanding of it is.

31
00:01:26.761 --> 00:01:29.130
&gt;&gt; I would say it's split.

32
00:01:29.130 --> 00:01:29.845
&gt;&gt; Split, okay,

33
00:01:29.845 --> 00:01:33.630
recursion is one of these topics where
you literally just it's super hard.

34
00:01:33.630 --> 00:01:36.680
&gt;&gt; Definitely more twos than ones but-
&gt;&gt; Okay.

35
00:01:36.680 --> 00:01:38.440
&gt;&gt; There are quite a few ones.

36
00:01:38.440 --> 00:01:41.415
&gt;&gt; So we're gonna go over it either way
even if everyone in here understood it,

37
00:01:41.415 --> 00:01:42.766
someone doesn't understand it.

38
00:01:42.766 --> 00:01:45.610
Recursion was my personal hardest one.

39
00:01:45.610 --> 00:01:47.736
&gt;&gt; [INAUDIBLE] 1.5.

40
00:01:47.736 --> 00:01:49.956
&gt;&gt; 1.5, really?

41
00:01:49.956 --> 00:01:53.210
I've met very few 1.5 understanders,
right?

42
00:01:53.210 --> 00:01:55.403
Because either you get it or
you don't get,

43
00:01:55.403 --> 00:01:57.486
it is how I've generally kinda found it.

44
00:01:57.486 --> 00:02:00.400
So the simplest way is a function
that calls itself, and

45
00:02:00.400 --> 00:02:04.340
this keeps happening until it reaches
something known as a base case.

46
00:02:04.340 --> 00:02:07.590
At that point the function
no longer calls itself, and

47
00:02:07.590 --> 00:02:13.040
it's able to return out some value, or
do some operation, or do something, right?

48
00:02:13.040 --> 00:02:16.260
And so that depends on what
you're doing with recursion.

49
00:02:16.260 --> 00:02:18.605
In JavaScript, you'll also do
things like async recursion,

50
00:02:18.605 --> 00:02:21.170
where you call a function that needs
to do something, it comes back,

51
00:02:21.170 --> 00:02:23.850
then you can call a function that
needs to do something, and come back.

52
00:02:23.850 --> 00:02:27.410
You can think of walking a file
tree with async functions,

53
00:02:27.410 --> 00:02:30.140
would be an example of async recursion.

54
00:02:30.140 --> 00:02:33.050
Very, very similar,
though it's not quite recursion.

55
00:02:33.050 --> 00:02:33.940
Recursion is hard.

56
00:02:33.940 --> 00:02:36.590
It's honestly the hardest topic for
me to get over.

57
00:02:36.590 --> 00:02:38.268
I found it to be extremely difficult.

58
00:02:38.268 --> 00:02:41.213
So we're gonna go over to
things with recursion.

59
00:02:41.213 --> 00:02:43.454
And what I'm hoping is
that by the end of this,

60
00:02:43.454 --> 00:02:46.103
you will be you'll feel very
natural with recursion.

61
00:02:46.103 --> 00:02:48.790
You'll feel like, okay,
this actually isn't all that hard,

62
00:02:48.790 --> 00:02:52.040
it's actually pretty straightforward
don't feel bad if you don't get it.

63
00:02:52.040 --> 00:02:56.173
It's just one of those things that it
feels trivial when you understand,

64
00:02:56.173 --> 00:02:58.945
exceptionally complex when you don't.

65
00:02:58.945 --> 00:03:02.095
And it's just it's hard,
so we're just gonna do it.

66
00:03:02.095 --> 00:03:05.175
So the simplest form of
recursion is this right here.

67
00:03:05.175 --> 00:03:07.625
You would know this as a sum, right?

68
00:03:07.625 --> 00:03:10.705
So if I said sum the numbers
between zero or from one to 100,

69
00:03:10.705 --> 00:03:13.209
you'd be like Gauss and
say, well, [INAUDIBLE].

70
00:03:13.209 --> 00:03:16.180
And I'll say, no, sum it,
and that's what we do.

71
00:03:16.180 --> 00:03:18.910
And so
this would be an example of summing it.

72
00:03:18.910 --> 00:03:19.929
What's exactly happening here,

73
00:03:19.929 --> 00:03:22.170
we're gonna also write out
everything that's happening here.

74
00:03:22.170 --> 00:03:25.230
But you can see, I have a function,
foo, that takes in a number.

75
00:03:25.230 --> 00:03:28.390
The base case, of course,
is when we're equal to 1.

76
00:03:28.390 --> 00:03:31.044
The sum of 1 is 1, right?

77
00:03:31.044 --> 00:03:34.207
We know it, we could technically extend
the base case for as long as we know

78
00:03:34.207 --> 00:03:37.125
the sums, but this is just the generally
easiest way to think of it.

79
00:03:37.125 --> 00:03:41.731
So when the number is not one,
we are going to add the number

80
00:03:41.731 --> 00:03:46.625
itself plus recall foo with one
less than its current number.

81
00:03:46.625 --> 00:03:50.723
So it'd be five to four, to three,
to two, to one, and there we go.

82
00:03:50.723 --> 00:03:54.825
Now, we're gonna draw what's happening
here because there is this whole problem.

83
00:03:54.825 --> 00:03:58.269
Now, one thing I really did wanna
highlight, I'm gonna say this five more

84
00:03:58.269 --> 00:04:01.330
times, I'm positive I have it my
slides like five more times, but

85
00:04:01.330 --> 00:04:02.990
base case is extremely important.

86
00:04:02.990 --> 00:04:05.730
Always think clearly
what your base case is.

87
00:04:05.730 --> 00:04:08.770
If you don't know your base case,
recursion is extremely hard.

88
00:04:08.770 --> 00:04:11.201
If you know your base case and
you can make it clever,

89
00:04:11.201 --> 00:04:13.640
recursion becomes exceptionally simple.

90
00:04:13.640 --> 00:04:15.261
So, good thing's to understand.

91
00:04:15.261 --> 00:04:20.591
So, let's go over to here and
let's create this beautiful,

92
00:04:20.591 --> 00:04:24.703
let's just walk through
exactly how it works.

93
00:04:24.703 --> 00:04:28.130
So in our function, I'm just gonna jump
back here for a second, we have this.

94
00:04:28.130 --> 00:04:30.995
So I'm just gonna write it in some
pseudocode, make it really simple, and

95
00:04:30.995 --> 00:04:33.546
then we're gonna actually go
through exactly what is happening.

96
00:04:33.546 --> 00:04:35.640
All right, so
it's gonna look something like this.

97
00:04:35.640 --> 00:04:38.591
We have foo(n), which is a number.

98
00:04:38.591 --> 00:04:44.998
And if n=1, then we're gonna return one,

99
00:04:44.998 --> 00:04:51.748
else, we're gonna return n+foo9n-1).

100
00:04:51.748 --> 00:04:54.980
Now for all the Q A's out there,
all the feeling of QA you're like,

101
00:04:54.980 --> 00:04:56.984
well, what will happen if I pass in zero?

102
00:04:56.984 --> 00:05:00.216
We're not gonna, we're only
concerned with ones or higher, okay?

103
00:05:00.216 --> 00:05:02.427
Don't do that, don't break this code.

104
00:05:02.427 --> 00:05:05.384
So you can see right here
that it's pretty simple code.

105
00:05:05.384 --> 00:05:07.347
So let's write out
exactly what's happening.

106
00:05:07.347 --> 00:05:11.680
There's something that's very important
to understand about recursion and

107
00:05:11.680 --> 00:05:13.526
really about function calling.

108
00:05:13.526 --> 00:05:17.053
There's three values you can kind
of really help to visualize this.

109
00:05:17.053 --> 00:05:19.140
There is something
called a return address.

110
00:05:19.140 --> 00:05:23.940
Every single time a function is called,
it needs to know how it got here, right?

111
00:05:23.940 --> 00:05:27.049
Cuz when the function is done,
it needs to literally go back and

112
00:05:27.049 --> 00:05:29.090
hand back out its value, right?

113
00:05:29.090 --> 00:05:31.650
And so
it needs to know where that value goes to.

114
00:05:31.650 --> 00:05:35.169
Another important part, of course,
is the actual return value, right?

115
00:05:35.169 --> 00:05:37.241
I need a value that I could return.

116
00:05:37.241 --> 00:05:39.637
Now in more traditional languages,
they compile a lot of these things,

117
00:05:39.637 --> 00:05:42.248
in there's a lot of sweet optimizations,
blah, blah, blah, blah, blah.

118
00:05:42.248 --> 00:05:47.378
But what matters is that they have to
make kind of a space for it, right?

119
00:05:47.378 --> 00:05:49.921
And then lastly we have our arguments,
right?

120
00:05:49.921 --> 00:05:52.723
That makes sense,
we have to pass things into the function.

121
00:05:52.723 --> 00:05:54.818
So every time you call a function,

122
00:05:54.818 --> 00:05:59.527
this is kind of roughly some memory
that is put into your system, we'll see.

123
00:05:59.527 --> 00:06:03.995
So when I call foo5, what happens?

124
00:06:03.995 --> 00:06:06.817
Well, our return address is
whoever called foo5, right?

125
00:06:06.817 --> 00:06:09.629
We don't know who it is,
doesn't matter for this case,

126
00:06:09.629 --> 00:06:11.160
someone called us with foo5.

127
00:06:12.910 --> 00:06:14.241
Our return value is, well,

128
00:06:14.241 --> 00:06:18.030
we don't actually know our return
value at this moment, do we?

129
00:06:18.030 --> 00:06:24.570
No, we know that it's 5+, but
we don't know what it completely is.

130
00:06:24.570 --> 00:06:27.350
And then lastly,
we have an argument of 5, right?

131
00:06:27.350 --> 00:06:28.876
This all makes sense.

132
00:06:28.876 --> 00:06:32.251
So then again, foo5, what does it do?

133
00:06:32.251 --> 00:06:34.387
Well, let's look at
the code really quickly.

134
00:06:34.387 --> 00:06:35.419
Is it one?

135
00:06:35.419 --> 00:06:36.812
No it's not.

136
00:06:36.812 --> 00:06:40.344
Let's take five,
let's take the argument and

137
00:06:40.344 --> 00:06:43.794
add it to argument minus
one from the next one.

138
00:06:43.794 --> 00:06:46.276
So, foo4.

139
00:06:46.276 --> 00:06:48.316
Well, what is foo4 pointing to?

140
00:06:48.316 --> 00:06:49.790
It's pointing to five, right?

141
00:06:49.790 --> 00:06:52.571
It points five, that's where I'm
gonna return when I am done.

142
00:06:52.571 --> 00:06:57.148
And so now we're gonna have 4+ and
our argument, of course, is 4.

143
00:06:57.148 --> 00:07:03.314
Now, we do it again because again,
it's not one, therefore, we recurs, foo 3.

144
00:07:03.314 --> 00:07:08.355
Well, our return address it's 4,
our return value is three plus.

145
00:07:08.355 --> 00:07:15.981
We still don't even know it yet, so, 3.

146
00:07:15.981 --> 00:07:21.560
Foo2, our return values is 2,
oops, I just gave away the game.

147
00:07:21.560 --> 00:07:23.811
2+ and our argument is 2.

148
00:07:23.811 --> 00:07:26.890
Again, lastly, finally get to foo1.

149
00:07:26.890 --> 00:07:28.600
What happens at foo1?

150
00:07:28.600 --> 00:07:32.860
Well, we get into here,
we execute is foo or is n1?

151
00:07:32.860 --> 00:07:34.870
Yes it is, return a 1.

152
00:07:34.870 --> 00:07:36.900
We finally have stopped recursing.

153
00:07:36.900 --> 00:07:40.162
We've hit a base case, we no longer
need to keep calling functions.

154
00:07:40.162 --> 00:07:44.130
Now, if instead we had
throw error right here,

155
00:07:44.130 --> 00:07:47.219
that is where a stack trace comes in.

156
00:07:47.219 --> 00:07:50.081
You've seen the stack traces,
you've seen error stacks,

157
00:07:50.081 --> 00:07:53.064
it's literally the stack of
functions that have been called.

158
00:07:53.064 --> 00:07:58.056
You would see something like,
let's pretend this is line two,

159
00:07:58.056 --> 00:08:01.762
you'd see something like
error at foo line 2.

160
00:08:01.762 --> 00:08:06.111
And then you'd see somewhere below,
this would be say, three, right?

161
00:08:06.111 --> 00:08:10.249
Then you'd see something like foo3 foo3,
right?

162
00:08:10.249 --> 00:08:12.811
Because each one of these ones
we're aware occurs from, so

163
00:08:12.811 --> 00:08:14.975
that's how you can help
visualize these things.

164
00:08:14.975 --> 00:08:17.278
And we've learned about a stack before, so

165
00:08:17.278 --> 00:08:21.520
this should make more sense of what is
literally happening underneath the hood.

166
00:08:22.930 --> 00:08:27.360
All right, so for one, it returns 1,
argument was 1, it returns to 2.

167
00:08:27.360 --> 00:08:28.420
Sorry, I forgot to put that.

168
00:08:28.420 --> 00:08:31.560
So when it returns to 2,
we now actually can do something.

169
00:08:31.560 --> 00:08:34.190
So the return value is put right here.

170
00:08:34.190 --> 00:08:36.822
We've now completed this,
now we can return again.

171
00:08:36.822 --> 00:08:38.980
That value is put right here, which is 3.

172
00:08:38.980 --> 00:08:43.920
Now this thing returns again,
which is now 6.

173
00:08:43.920 --> 00:08:44.970
Sorry, I did bad math.

174
00:08:44.970 --> 00:08:46.266
I gonna just undo that.

175
00:08:46.266 --> 00:08:50.036
It's very unpleasant to the eyes
to look at, 6, awesome.

176
00:08:50.036 --> 00:08:54.962
And then this is 10, and
then five plus 10 is returned out or 15.

177
00:08:54.962 --> 00:09:00.185
You can see that it goes down the stack,
then up the stack.

178
00:09:00.185 --> 00:09:02.358
And that's really,
really important to see,

179
00:09:02.358 --> 00:09:05.741
because it also opens up some properties
to us that we need to think about.

180
00:09:05.741 --> 00:09:09.538
So, if we look at this code,
I told you that there's two steps, right?

181
00:09:09.538 --> 00:09:12.383
One, base case.

182
00:09:12.383 --> 00:09:16.649
And then two, recurse.

183
00:09:16.649 --> 00:09:18.250
Click that writing, it's beautiful.

184
00:09:18.250 --> 00:09:20.660
So this is obviously the recurse,
this is the base case.

185
00:09:20.660 --> 00:09:24.633
Eventually we hit the base case, we stop
recursing, we undo our function stack,

186
00:09:24.633 --> 00:09:28.100
as we showed right here with the return
value slash the return address.

187
00:09:29.280 --> 00:09:32.400
All right, but there's something
very interesting about this.

188
00:09:32.400 --> 00:09:35.666
Notice that for a while,
we kept going downwards, right?

189
00:09:35.666 --> 00:09:39.066
We kept going downwards, we eventually
hit some sort of bottom, and then we went

190
00:09:39.066 --> 00:09:42.470
upwards, which means that our recurse
can actually be broken into three steps.

191
00:09:42.470 --> 00:09:46.030
And this becomes exceedingly
important in later data structures,

192
00:09:46.030 --> 00:09:48.974
especially when it comes to
something called pathing.

193
00:09:48.974 --> 00:09:51.412
You're gonna really want
to understand this.

194
00:09:51.412 --> 00:09:53.216
Is that recursion can
actually be broken down or

195
00:09:53.216 --> 00:09:55.845
the recurse can actually be broke
down into three steps, all right?

196
00:09:55.845 --> 00:09:59.122
So the recurse thing can
be into three steps.

197
00:09:59.122 --> 00:10:04.628
You have a pre, which means you can
do something before you recurse.

198
00:10:04.628 --> 00:10:08.998
In our case this was literally n+, right?

199
00:10:08.998 --> 00:10:13.761
We took n and we added it and
then we did the recursion part.

200
00:10:13.761 --> 00:10:15.388
So this is kind of a pre thing.

201
00:10:15.388 --> 00:10:20.513
Now then, we recurse, which actually
does the calling of the function, right?

202
00:10:20.513 --> 00:10:25.736
And then there's actually an availability
for some sort of post operation.

203
00:10:25.736 --> 00:10:26.620
Does that make sort of sense?

204
00:10:26.620 --> 00:10:29.648
We can do something else after recursing.

205
00:10:29.648 --> 00:10:32.075
So we didn't actually have to return here,
right?

206
00:10:32.075 --> 00:10:38.073
We don't have to return,
we could have said, hey, out equals this,

207
00:10:38.073 --> 00:10:43.682
then console logged something,
and then returned out, right?

208
00:10:43.682 --> 00:10:47.377
Which would have actually, let's say
we console logged, ley's just say we,

209
00:10:47.377 --> 00:10:49.044
here I'll just break the word log.

210
00:10:49.044 --> 00:10:56.291
If we would have logged out in what
we would have seen logged is, 12345.

211
00:10:56.291 --> 00:10:58.557
That makes sense because we did it post.

212
00:10:58.557 --> 00:11:02.680
Meaning that as we recurse we did
the pre of adding, we went into foo4,

213
00:11:02.680 --> 00:11:06.664
we did the pre of adding,
we went into foo3, and we went into foo2,

214
00:11:06.664 --> 00:11:11.129
we di the pre of adding, we went into
foo1, we did the post of logging which is

215
00:11:11.129 --> 00:11:13.789
logging out one,
we returned it back out 2.

216
00:11:13.789 --> 00:11:17.209
2 did the post of login have 2, retuned
it back up to 3, 3 did the post login,

217
00:11:17.209 --> 00:11:20.118
3 turn it back on 4, 4 to the post
of login 4, 4 return five, and

218
00:11:20.118 --> 00:11:23.009
five logging and then, boom,
we're out, we're done, right?

219
00:11:23.009 --> 00:11:26.694
So you can see these three actual
breakdowns and you may not actually use

220
00:11:26.694 --> 00:11:31.060
them, but they are extremely important to
have in your head because they're very,

221
00:11:31.060 --> 00:11:33.166
very valuable when it comes to pathing.

222
00:11:33.166 --> 00:11:36.570
And so I wanted to really make sure we hit
home on this cuz I do feel like this is

223
00:11:36.570 --> 00:11:38.373
something that can be a bit confusing.

224
00:11:38.373 --> 00:11:42.542
You may not even realize you have
that tool in your toolbox and

225
00:11:42.542 --> 00:11:44.269
you could be recursing.

226
00:11:44.269 --> 00:11:46.901
Friends don't let friends
recur without the toolbox,

227
00:11:46.901 --> 00:11:49.830
it's just a phrase we've all
said at least once in our life.

228
00:11:49.830 --> 00:11:50.850
Does that feel pretty good?

229
00:11:50.850 --> 00:11:53.272
Everyone feels like recursion
is a bit more clear,

230
00:11:53.272 --> 00:11:55.029
though you may not know how to use it?

231
00:11:55.029 --> 00:11:58.000
You can kind of hopefully
see it a little bit clear.

232
00:11:58.000 --> 00:12:00.240
We're gonna rely a lot on
recursion coming up here.

233
00:12:00.240 --> 00:12:02.402
And so that's why I wanted to do this,

234
00:12:02.402 --> 00:12:06.780
Is it's really hard to do a tree
without some knowledge of recursion.

235
00:12:06.780 --> 00:12:09.810
It's hard to do graph algorithms
without some knowledge of recursion.

236
00:12:09.810 --> 00:12:13.291
You don't have to do not all
algorithms on graphs require recursion,

237
00:12:13.291 --> 00:12:16.700
take the shortest path,
you don't have to do recursion, right?

238
00:12:16.700 --> 00:12:21.187
You can find the shortest path in
a graph with non negative weights,

239
00:12:21.187 --> 00:12:25.910
without using recursion ever, so
it is possible, but it's hard.

240
00:12:25.910 --> 00:12:30.579
Anyway, so this was the simplest way to
do recursion, but it never helped me.

241
00:12:30.579 --> 00:12:35.633
I genuinely felt like I never was really
able to grok recursion, seeing this.

242
00:12:35.633 --> 00:12:39.836
It feels too simple, cuz part of my
lizard brain says, this is too simple,

243
00:12:39.836 --> 00:12:41.388
why not a For Loop, right?

244
00:12:41.388 --> 00:12:45.341
I can't understand why you wouldn't use
a For Loop or can't rock the need of it,

245
00:12:45.341 --> 00:12:48.204
I can't really see it,
it just was really, really hard.

246
00:12:48.204 --> 00:12:52.182
So big mistake of recursion,
solid base case then recurse,

247
00:12:52.182 --> 00:12:56.478
just remember that that please,
it's so important, Holy Cow.

248
00:12:56.478 --> 00:13:01.125
All right ,so we're gonna walk through the
problem that truly helped me understand

249
00:13:01.125 --> 00:13:01.849
recursion.

250
00:13:01.849 --> 00:13:04.714
And this is actually a pathfinding
algorithm on a graph, but

251
00:13:04.714 --> 00:13:08.533
don't worry we're not gonna do all that
fancy stuff, we're gonna break it into

252
00:13:08.533 --> 00:13:11.866
something that's really digestible and
really easy to understand.

253
00:13:11.866 --> 00:13:14.050
So is everyone ready?

254
00:13:14.050 --> 00:13:14.680
Very, very excited?

255
00:13:14.680 --> 00:13:18.220
I'm very, very excited,
whoa, I can't wait.

