WEBVTT

1
00:00:00.000 --> 00:00:01.648
All right, so
we're gonna keep on going here.

2
00:00:01.648 --> 00:00:03.121
And this is the part of the list or

3
00:00:03.121 --> 00:00:06.953
a part of the class where we're gonna do
a little bit of comparing and contrasting.

4
00:00:06.953 --> 00:00:10.432
So let's think about the usability
of an array versus a linked list.

5
00:00:10.432 --> 00:00:13.493
Something that's really nice
about an array is you get in

6
00:00:13.493 --> 00:00:14.974
to see accessing, right?

7
00:00:14.974 --> 00:00:16.500
0,1, 2, it's fast, right?

8
00:00:16.500 --> 00:00:18.518
You're able to just set any value.

9
00:00:18.518 --> 00:00:22.436
The understanding of what is actually
happening underneath the hood is also

10
00:00:22.436 --> 00:00:26.857
pretty straightforward, right, you just
allocate the memory, however you do it.

11
00:00:26.857 --> 00:00:29.376
And then you can just access that and
you set those values.

12
00:00:29.376 --> 00:00:32.569
The memory is understood based on
the type that you have casted to.

13
00:00:32.569 --> 00:00:34.677
There you go, very simple.

14
00:00:34.677 --> 00:00:38.343
Obviously, some of the problems with
it is that there is no literal insert,

15
00:00:38.343 --> 00:00:39.445
there's only right.

16
00:00:39.445 --> 00:00:40.644
And so that causes problems.

17
00:00:40.644 --> 00:00:44.685
You can't really insert a value into
an array without actually writing

18
00:00:44.685 --> 00:00:48.925
the four loops manually to shift
everything over, then put in your value or

19
00:00:48.925 --> 00:00:52.782
unshift everything and write over
your value if you were to delete.

20
00:00:52.782 --> 00:00:55.740
And so it does cause it to
be a bit more difficult.

21
00:00:55.740 --> 00:00:58.336
At timelines, arrays are really nice.

22
00:00:58.336 --> 00:01:00.016
It's over one, everything, right?

23
00:01:00.016 --> 00:01:02.904
If you want to write over a value,
it's over one.

24
00:01:02.904 --> 00:01:05.097
If you want to get a value, it's over one.

25
00:01:05.097 --> 00:01:06.881
It's fantastic, but, again,

26
00:01:06.881 --> 00:01:10.140
there's a bit of a problem just
with the usability of it all.

27
00:01:10.140 --> 00:01:14.243
So I did wanna kind of point this out
which is it which is interesting.

28
00:01:14.243 --> 00:01:18.754
So one thing that's unique about an array
is that you obviously allocate this all

29
00:01:18.754 --> 00:01:19.362
upfront.

30
00:01:19.362 --> 00:01:23.980
Meaning that if you want to
potentially to store up to 1000 items

31
00:01:23.980 --> 00:01:28.445
you're gonna have to allocate
all that memory upfront, right?

32
00:01:28.445 --> 00:01:33.134
Yeah, so you're gonna have to have
1000 items worth of memory created and

33
00:01:33.134 --> 00:01:36.130
then you may use however
much you are going to use.

34
00:01:36.130 --> 00:01:39.452
Maybe you'll use all thousand, maybe
you'll only use a few of them, right?

35
00:01:39.452 --> 00:01:40.190
It's a little bit different.

36
00:01:40.190 --> 00:01:44.364
Whereas a linked list, if you do allocate,
or if you create a length list,

37
00:01:44.364 --> 00:01:46.037
it has nothing to begin with.

38
00:01:46.037 --> 00:01:49.855
When you insert something,
it only creates a single containing node.

39
00:01:49.855 --> 00:01:52.859
If you insert two things it
has to containing nodes and

40
00:01:52.859 --> 00:01:55.996
that's it, so
the memory usage is more optimized, but

41
00:01:55.996 --> 00:01:59.030
there is a difference of
runtime cost there, right?

42
00:01:59.030 --> 00:02:03.075
With an array the memory has already
been retrieved, it is already there, so

43
00:02:03.075 --> 00:02:04.828
you can easily use what you have.

44
00:02:04.828 --> 00:02:08.551
So it tends to have really great
performance, the constancy that is there,

45
00:02:08.551 --> 00:02:12.216
just as smaller now, you could obviously
create some sort of object pool,

46
00:02:12.216 --> 00:02:13.864
hold on to all the deleted nodes.

47
00:02:13.864 --> 00:02:17.199
So that way you're not creating a bunch
of new ones ways to speed up a list.

48
00:02:17.199 --> 00:02:20.418
But still, you are creating a containing
node, you're setting up links,

49
00:02:20.418 --> 00:02:22.695
it's a little bit more
cumbersome than say an array.

50
00:02:22.695 --> 00:02:27.293
One thing that's nice about an array or
a linked list, though, is just always will

51
00:02:27.293 --> 00:02:31.710
use less memory, but the usability of
a list is a little bit different, right?

52
00:02:31.710 --> 00:02:34.210
If you wanted to get
an item out of the list,

53
00:02:34.210 --> 00:02:37.766
you have to traverse each item
in the list until a you find it.

54
00:02:37.766 --> 00:02:39.642
So it's like always a linear search.

55
00:02:39.642 --> 00:02:42.440
There is no such thing as
a binary search on a linked list.

56
00:02:42.440 --> 00:02:46.706
You can't hop into the middle,
you have to walk the whole thing.

57
00:02:46.706 --> 00:02:49.918
So linear search is really your only
option on the linked list, which does make

58
00:02:49.918 --> 00:02:53.190
it a bit unfortunate of a data structure
when it comes to that type of operation.

59
00:02:53.190 --> 00:02:57.677
So typically, if you need to scan a list
or hop into a list of random access,

60
00:02:57.677 --> 00:03:00.617
you'd want to use something
more like an array.

61
00:03:00.617 --> 00:03:04.095
If you want to be able to just push and
pop from either the head or the tail,

62
00:03:04.095 --> 00:03:06.741
you tend to want to be able
to use something like a list.

63
00:03:06.741 --> 00:03:07.628
There's a trade off,

64
00:03:07.628 --> 00:03:10.439
there's an intentional trade off
you should make when deciding this.

65
00:03:10.439 --> 00:03:13.680
So a good example of this is say
like an a sync request queue.

66
00:03:13.680 --> 00:03:14.658
Say on your front end,

67
00:03:14.658 --> 00:03:18.222
you don't want to have more than five
network operations happening at one point.

68
00:03:18.222 --> 00:03:20.623
For whatever reason,
you've decided this is the case, well,

69
00:03:20.623 --> 00:03:22.897
then you're gonna have these
promises that are generated.

70
00:03:22.897 --> 00:03:25.921
They go off, but you only want five
of them active at any one point,

71
00:03:25.921 --> 00:03:28.351
that means you're gonna have
to pull off the front and

72
00:03:28.351 --> 00:03:31.866
you're able to push onto the back as new
ones come in and as old ones complete.

73
00:03:31.866 --> 00:03:33.967
So you have this whole problem of a queue,
but

74
00:03:33.967 --> 00:03:37.617
you don't want to be using an array if
it's a really highly used one because now

75
00:03:37.617 --> 00:03:40.912
you're shifting all these indices
around using a JavaScript array.

76
00:03:40.912 --> 00:03:44.185
It's not gonna perform very good,
it seems like it's a bad idea.

77
00:03:44.185 --> 00:03:47.536
So it's good to know what you have and
when you want to use some something.

78
00:03:47.536 --> 00:03:49.073
Always play that over in your head.

79
00:03:49.073 --> 00:03:52.780
Is there any questions on usability of
these two maybe in JavaScript land it's

80
00:03:52.780 --> 00:03:56.330
a little bit less apparent just because
it's just you just have brackets?

81
00:03:56.330 --> 00:04:00.971
&gt;&gt; How would you traverse a linked list or
would you just not even try?

82
00:04:00.971 --> 00:04:02.802
[LAUGH]
&gt;&gt; So how would you traverse a linked

83
00:04:02.802 --> 00:04:03.394
list here?

84
00:04:03.394 --> 00:04:05.970
I'm gonna go back to the code and
we'll just, oopsies,

85
00:04:05.970 --> 00:04:08.933
I'm gonna go back to the code and
let's go to doubly linked list.

86
00:04:08.933 --> 00:04:12.108
So if I were to create this thing,
right, I'm just gonna go fast,

87
00:04:12.108 --> 00:04:14.220
you don't have to follow
along on this one.

88
00:04:14.220 --> 00:04:18.824
Let's just pretend we have this beautiful
thing right here that has a value T,

89
00:04:18.824 --> 00:04:19.953
do that and preve.

90
00:04:25.979 --> 00:04:26.883
What am I doing?

91
00:04:26.883 --> 00:04:28.459
There we go, awesome.

92
00:04:28.459 --> 00:04:31.070
So we have this thing that
would be our node, right?

93
00:04:34.097 --> 00:04:35.763
I hate that, I always hated that.

94
00:04:35.763 --> 00:04:38.968
And let's pretend we wanted
to do like say a get, right?

95
00:04:38.968 --> 00:04:43.729
Let's go like this,
a private head is a node team.

96
00:04:43.729 --> 00:04:48.915
So I won't implement all these
operations we'll just do

97
00:04:48.915 --> 00:04:54.000
you know we'll just do this
right just odd length = 0.

98
00:04:54.000 --> 00:04:55.668
Why not do all that stuff?

99
00:04:55.668 --> 00:04:59.868
So if we were wanna do a let's just say
a get operation on a linked list, well,

100
00:04:59.868 --> 00:05:01.043
what do we have to do?

101
00:05:01.043 --> 00:05:06.323
We'd have to first go,
let curr = this.head, right?

102
00:05:06.323 --> 00:05:07.646
We are now at our head, right?

103
00:05:07.646 --> 00:05:12.396
We have this item,
then we could go for (let i = 0.

104
00:05:12.396 --> 00:05:17.634
I have to be less than index, and
there has to be something there, right.

105
00:05:17.634 --> 00:05:20.012
So in case we tried to
grab outside of the array,

106
00:05:20.012 --> 00:05:23.163
we could do a length check right
here if we really wanted to, but

107
00:05:23.163 --> 00:05:27.281
again, it just makes it, it's just it
completes goofy for TypeScript, right.

108
00:05:27.281 --> 00:05:32.428
So now that we're here, we can just
go current=current.next, right?

109
00:05:32.428 --> 00:05:35.961
So we literally walk
forward one at a time.

110
00:05:35.961 --> 00:05:37.971
So there is no simple way to get there.

111
00:05:37.971 --> 00:05:40.024
We just literally have to walk it.

112
00:05:40.024 --> 00:05:43.246
That is why it's considered a linear
operation cuz you have to walk it.

113
00:05:43.246 --> 00:05:49.074
Then at that point,
we can just do the old curr value, right?

114
00:05:49.074 --> 00:05:54.103
Awesome, we have now successfully just
wrote git at a specific index for

115
00:05:54.103 --> 00:05:55.180
a linked list.

116
00:05:55.180 --> 00:05:57.267
So not too hard, but at the same time,

117
00:05:57.267 --> 00:06:00.474
you can see why this is like
a very inefficient operation.

118
00:06:00.474 --> 00:06:03.813
If you had a big list that would
obviously just destroy performance.

