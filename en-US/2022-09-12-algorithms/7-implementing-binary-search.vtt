WEBVTT

1
00:00:00.286 --> 00:00:03.290
And so since we did that, let's do
of course the greatest thing ever.

2
00:00:03.290 --> 00:00:07.663
Let's go over to our coding machine,
go back to day 1, and

3
00:00:07.663 --> 00:00:10.707
look for, what is it, binary search.

4
00:00:10.707 --> 00:00:12.070
Yeah, look at that.

5
00:00:12.070 --> 00:00:15.840
So, now we can implement binary
search right here right now.

6
00:00:15.840 --> 00:00:19.479
So, notice that we're given a haystack and
a needle, again.

7
00:00:19.479 --> 00:00:24.161
So, as always, let's start off of course,
with the lowest loop, a do while loop.

8
00:00:24.161 --> 00:00:26.450
You don't have to use this.

9
00:00:26.450 --> 00:00:30.700
And let's create a let lo=0,
put this, and a hi,

10
00:00:30.700 --> 00:00:36.120
I'll just keep them the same naming
convention as my pseudocode.

11
00:00:36.120 --> 00:00:40.245
A hi=haystack.length, awesome.

12
00:00:40.245 --> 00:00:43.145
So now again,
we need to grab the midpoint.

13
00:00:43.145 --> 00:00:47.342
So, let's go const m for
midpoint, math.floor.

14
00:00:49.577 --> 00:00:56.577
And we'll do lo+ hi- l divide by 2.

15
00:00:56.577 --> 00:00:59.680
I put that little note, don't forget
to divide by 2 because when I program

16
00:00:59.680 --> 00:01:02.995
this took me like three minutes to realize
I had a bug cuz I forgot to divide by 2.

17
00:01:02.995 --> 00:01:05.464
Don't forget to divide by 2,
it's very, very important.

18
00:01:05.464 --> 00:01:08.954
const value,
of course gonna be haystack m.

19
00:01:08.954 --> 00:01:12.268
You're gonna see this a lot in algorithms
that they use single letter variables to

20
00:01:12.268 --> 00:01:13.440
denote everything.

21
00:01:13.440 --> 00:01:16.667
I'm just kind of following
the pseudocode style so

22
00:01:16.667 --> 00:01:21.031
that way it's a fairly easy direct
translation from this into here.

23
00:01:21.031 --> 00:01:22.701
Normally, program with good names but

24
00:01:22.701 --> 00:01:25.291
in this case we're just gonna
keep it like that, all right?

25
00:01:25.291 --> 00:01:30.275
So if value is equivalent to the needle,
we have found it ,right?

26
00:01:30.275 --> 00:01:35.838
I'll take that down here and
do a little false, there we go.

27
00:01:35.838 --> 00:01:40.544
And we need to come up with a nice
condition right here as of course is

28
00:01:40.544 --> 00:01:42.320
while lo is less than hi.

29
00:01:42.320 --> 00:01:46.486
All right, so our three conditions
of course are gonna be when value is

30
00:01:46.486 --> 00:01:50.592
equivalent to needle, we found it,
awesome, let's return true.

31
00:01:50.592 --> 00:01:53.537
But if value is greater than needle,

32
00:01:53.537 --> 00:01:59.344
that means anything to the right hand
side, is gonna be greater than me.

33
00:01:59.344 --> 00:02:03.941
I'm already greater than at this current
point, so the rest of the right hand side,

34
00:02:03.941 --> 00:02:05.365
is gonna be greater than,

35
00:02:05.365 --> 00:02:09.405
so I want to reduce the high side,
to this point and exclude the midpoint.

36
00:02:09.405 --> 00:02:13.010
So, hi equals midpoint, cuz remember,

37
00:02:13.010 --> 00:02:17.032
hi as exclusive, lo is inclusive, awesome.

38
00:02:17.032 --> 00:02:19.043
Let's just cut and paste that.

39
00:02:19.043 --> 00:02:22.910
So, we can reverse the condition or
we can just do an else statement.

40
00:02:22.910 --> 00:02:24.778
We'll just do an else
statement to make it simple.

41
00:02:24.778 --> 00:02:30.538
Now remember, what this means now is
that our value is less than our needle.

42
00:02:30.538 --> 00:02:35.890
Which means that we need search
on the higher side, right?

43
00:02:35.890 --> 00:02:40.680
Our needle is greater than our value, that
means if we're gonna exist in this array,

44
00:02:40.680 --> 00:02:43.283
we're somewhere in
the greater side region.

45
00:02:43.283 --> 00:02:47.949
So, lo=m+1, cuz again, drop the midpoint.

46
00:02:47.949 --> 00:02:49.958
You don't want to look
at the midpoint again,

47
00:02:49.958 --> 00:02:52.288
it would be silly if you
looked at the midpoint again.

48
00:02:52.288 --> 00:02:56.174
Just having these conditions on your
brain long as I've done this all correct,

49
00:02:56.174 --> 00:02:57.920
we should be able to see this thing.

50
00:02:57.920 --> 00:02:59.040
Go first try it.

51
00:02:59.040 --> 00:03:03.830
Let me just make sure that I've actually
done this correct ,mpx just binary.

52
00:03:03.830 --> 00:03:05.113
That is not how you spell binary, is it?

53
00:03:07.718 --> 00:03:11.105
Come on, okay,
well we have two operations in there.

54
00:03:11.105 --> 00:03:13.169
Don't look at the second
one compare binary tree,

55
00:03:13.169 --> 00:03:15.331
you're not actually supposed
to see that quite yet.

56
00:03:15.331 --> 00:03:19.038
So, let's pretend the man behind
the curtain doesn't exist but yeah,

57
00:03:19.038 --> 00:03:21.368
binary search actually worked, first try.

58
00:03:21.368 --> 00:03:23.124
All right, there we go.

59
00:03:23.124 --> 00:03:26.118
So I don't think I put this
in my presentation, but

60
00:03:26.118 --> 00:03:31.147
one of my first interviews at Google, they
made me code binary search in Google Docs.

61
00:03:31.147 --> 00:03:35.678
It was terrible, and I had plus 1
minus 1 issues all over the place.

62
00:03:35.678 --> 00:03:40.800
I didn't come into it with a really clean
idea of exactly what needed to happen.

63
00:03:40.800 --> 00:03:42.524
This algorithm is actually pretty simple,
right?

64
00:03:42.524 --> 00:03:44.991
Like, that's not a hard
amount of code to do it.

65
00:03:44.991 --> 00:03:49.446
It's really only what,
seven lines of actual code,

66
00:03:49.446 --> 00:03:54.008
the rest is all spacing or
it's like nothing, right?

67
00:03:54.008 --> 00:03:57.611
Initialization spacing, so it's
actually a pretty simple piece of code,

68
00:03:57.611 --> 00:04:00.494
it's just being able to focus on this and
do this correctly.

69
00:04:00.494 --> 00:04:02.080
Do we have any questions?

70
00:04:02.080 --> 00:04:06.360
&gt;&gt; Just a quick thing in the repo,
I couldn't see the day 1 folder.

71
00:04:06.360 --> 00:04:07.630
Do we have it there?

72
00:04:07.630 --> 00:04:10.155
I just see the test folder in the repo.

73
00:04:10.155 --> 00:04:11.128
&gt;&gt; So it is.

74
00:04:11.128 --> 00:04:13.160
So, what editor are you?

75
00:04:13.160 --> 00:04:16.460
So the question was I can't
see the day 1 folder.

76
00:04:16.460 --> 00:04:18.285
What's happening?
What editor are using?

77
00:04:18.285 --> 00:04:19.546
&gt;&gt; I'm using Visual Studio code.

78
00:04:19.546 --> 00:04:23.195
&gt;&gt; Okay, so code, is it hiding,
get ignored folders?

79
00:04:24.405 --> 00:04:26.345
&gt;&gt; I'm not sure if what it
is that they're integrating.

80
00:04:26.345 --> 00:04:29.063
&gt;&gt; It's a get ignore it so that way
you can generate a lot of them and

81
00:04:29.063 --> 00:04:31.440
you don't have a huge amount
of uncommitted changes.

82
00:04:31.440 --> 00:04:34.188
So, if you're using visual code,
I don't use code.

83
00:04:34.188 --> 00:04:37.050
I didn't know that but
if it hides, ignored folders,

84
00:04:37.050 --> 00:04:39.115
you're not gonna be able to see day 1.

