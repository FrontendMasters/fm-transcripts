WEBVTT

1
00:00:00.100 --> 00:00:03.570
&gt;&gt; Kyle Simpson: So the point is that,
like every other operation,

2
00:00:03.570 --> 00:00:07.370
the real question you should be asking
yourself is, is the coercion helpful?

3
00:00:08.510 --> 00:00:11.300
Is it gonna be useful to
me at this point or not?

4
00:00:11.300 --> 00:00:12.858
It puts the onus on you.

5
00:00:12.858 --> 00:00:14.898
As you're learning to
be a better developer,

6
00:00:14.898 --> 00:00:18.340
you should be making critical
thinking decisions for yourself.

7
00:00:18.340 --> 00:00:22.264
Rather than relying upon what somebody
wrote in a tweet or a book somewhere,

8
00:00:22.264 --> 00:00:25.820
someday, ten years ago,
you should really be asking yourself, for

9
00:00:25.820 --> 00:00:29.160
this particular situation,
is it gonna be helpful to me or not?

10
00:00:32.094 --> 00:00:35.915
&gt;&gt; Kyle Simpson: My claim, my thought is
that the double equals is not really about

11
00:00:35.915 --> 00:00:38.400
comparisons with unknown types.

12
00:00:38.400 --> 00:00:41.634
That's sort of the the fear that
is often spread about this topic,

13
00:00:41.634 --> 00:00:44.637
is that the double equals is,
you have these unknown types and

14
00:00:44.637 --> 00:00:46.864
have all these weird corner cases and
stuff.

15
00:00:46.864 --> 00:00:50.866
That's not really what double equals is
about because the more important thing,

16
00:00:50.866 --> 00:00:53.535
the thing I want you to take
away from this discussion,

17
00:00:53.535 --> 00:00:57.790
is that you should be making your types
obvious when you make your comparisons.

18
00:00:57.790 --> 00:01:00.420
Make it clear that you've got a number and
a number.

19
00:01:00.420 --> 00:01:05.360
And if you know the types,
then double equals is entirely safe.

20
00:01:05.360 --> 00:01:08.240
You can use it in places where you
know the types, and then you can

21
00:01:08.240 --> 00:01:12.420
optionally decide to use it in places
where you wanna allow the coercion.

22
00:01:12.420 --> 00:01:15.208
For example, that null and
undefined case that I just listed.

23
00:01:17.534 --> 00:01:20.347
&gt;&gt; Kyle Simpson: JavaScript
has a dynamic type system, and

24
00:01:20.347 --> 00:01:23.709
it uses various forms of
coercion both implicit and

25
00:01:23.709 --> 00:01:29.550
explicit to handle those value type
conversions, including in our equality.

26
00:01:29.550 --> 00:01:31.750
This is a good thing.

27
00:01:31.750 --> 00:01:36.475
You simply cannot write quality JavaScript
programs without embracing that true fact,

28
00:01:36.475 --> 00:01:40.822
without knowing what the types are and
making sure that it's obvious in the code,

29
00:01:40.822 --> 00:01:43.288
what types are involved
in those operations.

