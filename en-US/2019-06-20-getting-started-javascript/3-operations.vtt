WEBVTT

1
00:00:00.040 --> 00:00:03.885
&gt;&gt; Kyle Simpson: So what are some of
these operations that we might want to do

2
00:00:03.885 --> 00:00:05.977
with our values?

3
00:00:05.977 --> 00:00:09.108
&gt;&gt; Kyle Simpson: Well, you notice here,
on line one, I've got a 3, and

4
00:00:09.108 --> 00:00:10.491
then a plus and then a 4.

5
00:00:10.491 --> 00:00:13.383
So I've got two numbers
that I wanna add together.

6
00:00:13.383 --> 00:00:17.571
Or I've got the number 43,
and a minus and a 1, and

7
00:00:17.571 --> 00:00:21.586
I wanna subtract one number
from the other, okay?

8
00:00:21.586 --> 00:00:24.520
So those are basic arithmetic,
if you will.

9
00:00:24.520 --> 00:00:27.120
You probably learned this back
in kindergarten, first grade.

10
00:00:27.120 --> 00:00:30.340
Basic arithmetic that you can
express in your programs.

11
00:00:30.340 --> 00:00:33.856
And you don't often write them
out literally, like 3 plus 4.

12
00:00:33.856 --> 00:00:36.588
Often, those values will
be inside of variables.

13
00:00:36.588 --> 00:00:38.570
And we'll talk about
that in just a moment.

14
00:00:38.570 --> 00:00:41.658
But it is possible for
you to just do straight up math, or

15
00:00:41.658 --> 00:00:44.090
any other sort of operation.

16
00:00:44.090 --> 00:00:47.790
For example, line four, you'll notice
that I also have a plus operator.

17
00:00:47.790 --> 00:00:50.412
But I don't have numbers here,
I have strings.

18
00:00:50.412 --> 00:00:56.052
And one of the peculiarities of JavaScript
is that it uses the plus operator to mean

19
00:00:56.052 --> 00:01:01.793
two different things depending on what
kind of values we've got in the operation.

20
00:01:01.793 --> 00:01:04.627
And so,
when we have string involved in the plus,

21
00:01:04.627 --> 00:01:07.258
we do what's called
a string concatenation,

22
00:01:07.258 --> 00:01:11.513
which is like just smooching two
strings together, that's all it means.

23
00:01:11.513 --> 00:01:15.000
And when there's two numbers involved,
that's math.

24
00:01:15.000 --> 00:01:18.130
So that plus operator, there's
a fancy term for this in programming,

25
00:01:18.130 --> 00:01:19.460
it's called overloaded.

26
00:01:19.460 --> 00:01:22.760
It means that it has more
than one kind of behavior,

27
00:01:22.760 --> 00:01:25.350
depending upon the values
that are involved in.

28
00:01:25.350 --> 00:01:27.290
By the way,
I keep talking about involve in.

29
00:01:27.290 --> 00:01:28.300
What do I mean here?

30
00:01:28.300 --> 00:01:32.340
Well, operators have
what are called operands.

31
00:01:32.340 --> 00:01:38.560
And an operand is the value that is
going to be operated on by the operator.

32
00:01:38.560 --> 00:01:43.341
So on line one, 3 plus 4,
the operator is plus, it's an addition,

33
00:01:43.341 --> 00:01:45.110
a numeric addition.

34
00:01:45.110 --> 00:01:48.883
And the two operands are 3 and 4.

35
00:01:48.883 --> 00:01:53.664
Oftentimes, we might refer to them as
the left operand, which would be 3,

36
00:01:53.664 --> 00:01:56.664
and then the right operand,
which would be 4.

37
00:01:56.664 --> 00:02:01.130
Those kinds of operators, ones that
have a left and a right in terms of

38
00:02:01.130 --> 00:02:05.907
their operands, those kinds of
operators are called binary operators.

39
00:02:05.907 --> 00:02:09.940
And binary is just a fancy term for
it means there's two involved.

40
00:02:09.940 --> 00:02:14.220
So we have binary operators,
like plus and minus.

41
00:02:14.220 --> 00:02:18.590
But you notice on line six, I've got
a special character, the exclamation mark.

42
00:02:18.590 --> 00:02:20.950
That's a different kind of operator.

43
00:02:20.950 --> 00:02:23.830
That's what we call a unary operator.

44
00:02:25.180 --> 00:02:30.010
Unary means one,
kind of like in Spanish uno means one,

45
00:02:30.010 --> 00:02:32.100
you can think unary means one.

46
00:02:32.100 --> 00:02:36.745
So unary means a single operand
involved in the operation.

47
00:02:36.745 --> 00:02:38.681
And here, we have the false,

48
00:02:38.681 --> 00:02:43.253
the exclamation mark does what we
call flipping of a Boolean value, or

49
00:02:43.253 --> 00:02:46.600
the negation or
the compliment of a Boolean value.

50
00:02:46.600 --> 00:02:50.340
So remember how I said Booleans
can only be false or true.

51
00:02:50.340 --> 00:02:53.472
So if we start out with false and
we wanna flip it to the other one,

52
00:02:53.472 --> 00:02:54.646
we're gonna get true.

53
00:02:54.646 --> 00:02:58.306
And if we were to start out with
the exclamation mark and true and flip it,

54
00:02:58.306 --> 00:03:00.430
we'd get false, right?

55
00:03:00.430 --> 00:03:03.970
Now, line eight shows
a different kind of operator.

56
00:03:03.970 --> 00:03:05.610
Still, that is a binary operator,

57
00:03:05.610 --> 00:03:10.020
but it's not actually producing
sort of a different kind of value.

58
00:03:10.020 --> 00:03:12.690
Here, it's doing what we call comparison.

59
00:03:12.690 --> 00:03:15.560
It's saying does the value
on the left-hand side and

60
00:03:15.560 --> 00:03:17.471
the value on the right- hand side,

61
00:03:17.471 --> 00:03:21.700
do they have some sort of relationship
that we can determine something about?

62
00:03:21.700 --> 00:03:26.568
In this case, we're using the double
equals operator, which is the equals or

63
00:03:26.568 --> 00:03:29.320
what we call the Lucy quality operator.

64
00:03:29.320 --> 00:03:32.328
It's saying,
are these two values equal to each other?

65
00:03:33.409 --> 00:03:35.435
&gt;&gt; Kyle Simpson: By the way,
you may have heard inequality, and

66
00:03:35.435 --> 00:03:37.335
we'll get into this in a little while.

67
00:03:37.335 --> 00:03:38.585
You may have heard inequality,

68
00:03:38.585 --> 00:03:42.715
in JavaScript that there's two different
equality comparison operators.

69
00:03:42.715 --> 00:03:47.685
There's this double equals one, and
then there's the triple equals one.

70
00:03:47.685 --> 00:03:52.750
And there's a lot of nuanced
distinction between the two.

71
00:03:52.750 --> 00:03:56.080
I'm gonna try to help you juggle some
of that later in our discussion in

72
00:03:56.080 --> 00:03:56.920
this course.

73
00:03:56.920 --> 00:04:00.020
But for right now, you should know
that in this particular case,

74
00:04:00.020 --> 00:04:01.870
they wouldn't have done
anything differently.

75
00:04:01.870 --> 00:04:05.320
We would have gotten the exact same
result between a double equals and

76
00:04:05.320 --> 00:04:08.250
a triple equals because both
of them are numbers, so

77
00:04:08.250 --> 00:04:11.260
no changing of value
types is even involved.

78
00:04:11.260 --> 00:04:14.170
Thy would have done
exactly the same thing.

79
00:04:14.170 --> 00:04:18.455
So 3.0 and 3, if you remember when I
talked about values a little while ago,

80
00:04:18.455 --> 00:04:20.660
3.0 and 3 are the same kind of value.

81
00:04:20.660 --> 00:04:23.470
They're both numbers, so
they're equal to each other.

82
00:04:23.470 --> 00:04:24.890
Even though in our programming code,

83
00:04:24.890 --> 00:04:28.640
they look slightly different, they're
actually basically the same number,

84
00:04:28.640 --> 00:04:31.440
so that comparison would
tell us that they are equal.

85
00:04:31.440 --> 00:04:35.430
It would return us actually
a Boolean that would say true.

86
00:04:35.430 --> 00:04:39.554
Line 10 is another kind of comparison,
which is less than.

87
00:04:39.554 --> 00:04:42.140
And we know that the number
3 is clearly less than 4.

88
00:04:42.140 --> 00:04:44.660
So again,
when we do that kind of comparison,

89
00:04:44.660 --> 00:04:47.850
we would've gotten a Boolean
true back as well.

90
00:04:47.850 --> 00:04:52.530
Now, line 12 shows us yet
still a different kind of operator.

91
00:04:52.530 --> 00:04:56.780
And these are sort of conditional
operators that are, I'm sorry,

92
00:04:56.780 --> 00:04:59.650
not conditional operators,
they're logical operators.

93
00:04:59.650 --> 00:05:02.778
They basically tried to
decide something for us.

94
00:05:02.778 --> 00:05:07.760
So the double vertical line there,
that's called the or operator.

95
00:05:07.760 --> 00:05:10.770
The single character is called
the pipe character on your keyboard,

96
00:05:10.770 --> 00:05:11.990
if you haven't seen that before.

97
00:05:11.990 --> 00:05:15.080
When we put two of them together,
that's called the or operator.

98
00:05:15.080 --> 00:05:19.150
And so,
it's basically saying tell me if one or

99
00:05:19.150 --> 00:05:24.320
the other of these results in something
that would be we would call Boolean true.

100
00:05:24.320 --> 00:05:28.330
If one or the other results in true,
then I wanna know about that.

101
00:05:28.330 --> 00:05:30.930
Otherwise, we won't do something.

102
00:05:30.930 --> 00:05:33.670
And when we talk about making
decisions in a little while,

103
00:05:33.670 --> 00:05:36.980
you'll get the sense of why you
might wanna do something if one or

104
00:05:36.980 --> 00:05:40.810
the other of these things is true, do it,
and if not, do something different.

105
00:05:40.810 --> 00:05:44.330
So the double pipe operator
is what we call or.

106
00:05:44.330 --> 00:05:47.300
And there's a complement to that
one called the double ampersand.

107
00:05:47.300 --> 00:05:50.920
That little squirrelly character
that nobody can ever write.

108
00:05:50.920 --> 00:05:55.630
That little double ampersand
operator is how we say and.

109
00:05:55.630 --> 00:05:59.130
So that would give us a true
only if both of the things,

110
00:05:59.130 --> 00:06:01.900
both of the operands, were true.

111
00:06:01.900 --> 00:06:06.530
So now, you're starting to get
a sense that there are things that we

112
00:06:06.530 --> 00:06:08.328
wanna do with our values.

113
00:06:08.328 --> 00:06:10.844
And the things that we wanna do
are the kind of operations that we're

114
00:06:10.844 --> 00:06:12.340
gonna perform.

115
00:06:12.340 --> 00:06:15.369
Before we move on, I wanna actually
let you see those expressions,

116
00:06:15.369 --> 00:06:18.945
those operations that we were just
talking about, actually being evaluated.

117
00:06:18.945 --> 00:06:23.436
So you can see here that 3 plus 4,
it evaluated to 7.

118
00:06:23.436 --> 00:06:26.800
And 43 minus 1 it evaluated to 42.

119
00:06:26.800 --> 00:06:31.490
And when I concatenated these two strings
together, you see the string Kyle Simpson.

120
00:06:31.490 --> 00:06:35.800
The negation of false, or the compliment
of false, it evaluates to true.

121
00:06:35.800 --> 00:06:38.556
And 3.0 equals 3.

122
00:06:38.556 --> 00:06:42.710
And by the way, even if I did
a triple equals, it's still true.

123
00:06:42.710 --> 00:06:44.924
Because it's not about type coercion,

124
00:06:44.924 --> 00:06:48.750
it's just that JavaScript treats
these numbers as the same.

125
00:06:48.750 --> 00:06:52.090
We can see that 3 less than
4 is evaluating to true.

126
00:06:52.090 --> 00:06:55.120
But if I were to flip that around and
say 4 less than 3, now,

127
00:06:55.120 --> 00:06:58.970
all of a sudden that one's gonna
change to evaluating to false.

128
00:06:58.970 --> 00:07:04.300
And finally, true or false, of course,
true or false is gonna evaluate the true.

129
00:07:04.300 --> 00:07:07.510
But if I changed it to
the double ampersand, now,

130
00:07:07.510 --> 00:07:10.260
of the sudden, that one was also false.

131
00:07:10.260 --> 00:07:14.640
So definitely, make sure you're familiar
with how these things are evaluating.

132
00:07:14.640 --> 00:07:16.930
It's not always so
great to do it in your head,

133
00:07:16.930 --> 00:07:19.930
sometimes it's great to just run it in
the JavaScript and see what you get.

