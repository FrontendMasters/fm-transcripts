WEBVTT

1
00:00:00.080 --> 00:00:00.640
&gt;&gt; Will Sentance: I heard some really

2
00:00:00.640 --> 00:00:02.760
interesting things that people
were talking through there.

3
00:00:02.760 --> 00:00:05.630
We're gonna save that out of
function we're going to call it

4
00:00:05.630 --> 00:00:09.380
we're going to return out the little baby
increment counter function from inside

5
00:00:09.380 --> 00:00:11.210
out into a new global label new function.

6
00:00:11.210 --> 00:00:13.680
And we're gonna call it by
its new global label and

7
00:00:13.680 --> 00:00:16.890
some really interesting
stuff is gonna happen.

8
00:00:16.890 --> 00:00:19.730
Stuff that's going to give
our functions superpowers.

9
00:00:19.730 --> 00:00:21.290
In a special way.

10
00:00:21.290 --> 00:00:26.200
So here we go line one Andrew you're
up what are we doing in line one?

11
00:00:26.200 --> 00:00:27.620
&gt;&gt; Andrew: Declaring a function.

12
00:00:27.620 --> 00:00:29.020
&gt;&gt; Will Sentance: Declaring a function.

13
00:00:29.020 --> 00:00:31.820
Technical communication means
total precision and completeness.

14
00:00:31.820 --> 00:00:32.790
Andrew take it away.

15
00:00:32.790 --> 00:00:33.850
Declaring?

16
00:00:33.850 --> 00:00:35.190
&gt;&gt; Andrew: A function to outer.

17
00:00:35.190 --> 00:00:37.790
&gt;&gt; Will Sentance: Exactly
declaring a function named outer.

18
00:00:37.790 --> 00:00:41.910
There it is, thank you to Andrew for
his patience with me.

19
00:00:41.910 --> 00:00:44.930
Sam, next line, left hand side first.

20
00:00:44.930 --> 00:00:47.360
&gt;&gt; Sam: Declaring a new label.

21
00:00:48.620 --> 00:00:51.440
&gt;&gt; Will Sentance: Yes well done,
new label, new function exactly.

22
00:00:51.440 --> 00:00:54.740
We do not know yet what to store in it,
because we've got to go ahead and

23
00:00:54.740 --> 00:00:55.820
run what Sam?

24
00:00:57.110 --> 00:00:59.491
&gt;&gt; Sam: We need to run outer.

25
00:00:59.491 --> 00:01:00.715
So-
&gt;&gt; Will Sentance: Perfect.

26
00:01:00.715 --> 00:01:01.442
&gt;&gt; Sam: New place.

27
00:01:01.442 --> 00:01:03.070
&gt;&gt; Will Sentance: Outer folk.

28
00:01:03.070 --> 00:01:05.110
Let's have our cool start going here.

29
00:01:05.110 --> 00:01:08.240
There it is global in
the bottom we add outer.

30
00:01:09.420 --> 00:01:10.030
Next.

31
00:01:12.160 --> 00:01:15.110
Bubenesh we're executing out so
we create a new?

32
00:01:15.110 --> 00:01:15.890
&gt;&gt; Bubanesh: Execution complex.

33
00:01:15.890 --> 00:01:18.815
&gt;&gt; Will Sentance: Execution complex
thank you Bubenesh we appreciate it.

34
00:01:18.815 --> 00:01:24.410
That's very on point.

35
00:01:24.410 --> 00:01:25.150
Into what we go.

36
00:01:26.800 --> 00:01:32.240
And we immediately,
no inputs no arguments.

37
00:01:32.240 --> 00:01:37.365
So instead in local memory, Jasmine,
we immediately assign what?

38
00:01:37.365 --> 00:01:38.294
&gt;&gt; Jasmine: Counter to zero.

39
00:01:38.294 --> 00:01:40.730
&gt;&gt; Will Sentance: Counter to zero,
excellent.

40
00:01:40.730 --> 00:01:45.240
Michael next line, I do this thing where
I give the same person the same question

41
00:01:45.240 --> 00:01:48.430
every single time without thinking
about it, Michael next line.

42
00:01:48.430 --> 00:01:50.860
&gt;&gt; Michael: We create a function
called the increment counter.

43
00:01:50.860 --> 00:01:51.990
&gt;&gt; Will Sentance: Increment counter.

44
00:01:51.990 --> 00:01:54.090
Jasmine, did I ask you for zero last time?

45
00:01:54.090 --> 00:01:56.830
I didn't ask you for
increment counter that's so interesting.

46
00:01:56.830 --> 00:01:57.550
What is it?

47
00:01:57.550 --> 00:02:01.510
What is going on in my mind
subconsciously that does that,

48
00:02:01.510 --> 00:02:05.480
that process probably,
what ever that means.

49
00:02:05.480 --> 00:02:11.760
All right, ignore encounter is saved,
we are not going to use it inside though.

50
00:02:11.760 --> 00:02:17.370
Instead, we are going to take its code or
if you remember

51
00:02:17.370 --> 00:02:23.080
from our heap piece we take the label
to its under the hood stored function.

52
00:02:24.305 --> 00:02:28.230
Wait sorry, address if it's under
the hood, stored function and table but

53
00:02:28.230 --> 00:02:30.790
with us for our purposes,
take the code of increment counter.

54
00:02:30.790 --> 00:02:33.770
We're going to see what,
what are we going to do Jasmine?

55
00:02:33.770 --> 00:02:34.490
We're not going to return.

56
00:02:34.490 --> 00:02:36.940
We're not going to run increment counter,
we're going to?

57
00:02:36.940 --> 00:02:38.268
&gt;&gt; Jasmine: Return increment count.

58
00:02:38.268 --> 00:02:38.950
&gt;&gt; Will Sentance: Return
increment counter.

59
00:02:38.950 --> 00:02:41.770
So it's going to say return increment

60
00:02:44.350 --> 00:02:49.850
counter we use that to look up increment
counter it's the code of increment counter

61
00:02:49.850 --> 00:02:54.240
without a label and we take it Jasmine and
we return it out into?

62
00:02:54.240 --> 00:02:54.770
&gt;&gt; Jasmine: New function.

63
00:02:54.770 --> 00:02:57.090
&gt;&gt; Will Sentance: Into new
function she's spot on.

64
00:02:57.090 --> 00:02:59.670
And it we used to be
called increment counter.

65
00:02:59.670 --> 00:03:01.300
It's not called that anymore.

66
00:03:01.300 --> 00:03:04.210
I'm just putting it here so
we know it used to be called that.

67
00:03:04.210 --> 00:03:08.702
And there it is, and
its only code is counter++.

68
00:03:08.702 --> 00:03:12.920
And our execution context here,
everybody, is what?

69
00:03:12.920 --> 00:03:13.730
&gt;&gt; Class: Gone.
&gt;&gt; Will Sentance: Bumped off the call

70
00:03:13.730 --> 00:03:15.410
stack, exactly, removed.

71
00:03:15.410 --> 00:03:19.492
We pop it off,
we pop it off the call stack.

72
00:03:21.572 --> 00:03:24.140
&gt;&gt; Will Sentance: There it is, gone.

73
00:03:25.740 --> 00:03:29.630
And we're out to global where our new
function is now our new global label for

74
00:03:29.630 --> 00:03:33.390
the function that was borne inside
of outer as increment counter.

75
00:03:33.390 --> 00:03:37.910
Let's run it people and
let's see what happens.

76
00:03:37.910 --> 00:03:42.431
New function is called brand, yeah,

77
00:03:42.431 --> 00:03:46.690
everyone together, brand-new?

78
00:03:46.690 --> 00:03:47.890
&gt;&gt; Class: Execution costs.

79
00:03:47.890 --> 00:03:50.540
&gt;&gt; Will Sentance: Thank you,
that energized me,

80
00:03:50.540 --> 00:03:54.100
after my silly lack of enthusiasm.

81
00:03:54.100 --> 00:03:55.540
There it is, it goes on the call stack.

82
00:03:57.080 --> 00:03:59.510
A new function is added on the call stack.

83
00:03:59.510 --> 00:04:03.490
We go into it,
nothing in local memory assigned.

84
00:04:03.490 --> 00:04:07.080
Instead, we hit immediately what line,
Jasmine?

85
00:04:08.350 --> 00:04:09.260
&gt;&gt; Jasmine: The counter plus plus.

86
00:04:09.260 --> 00:04:09.930
&gt;&gt; Will Sentance: Counter plus plus,

87
00:04:09.930 --> 00:04:12.790
cuz new function is a functionality
formerly known as increment counter.

88
00:04:14.020 --> 00:04:17.690
Where, Jasmine,
do I look for counter first?

89
00:04:18.830 --> 00:04:19.440
&gt;&gt; Jasmine: Local context.

90
00:04:19.440 --> 00:04:23.468
&gt;&gt; Will Sentance: Yes, excellent,
thank you, in the local execution context.

91
00:04:23.468 --> 00:04:28.185
Again, same question to you again,
anything there?

92
00:04:28.185 --> 00:04:28.939
&gt;&gt; Jasmine: No.
&gt;&gt; Will Sentance: No.

93
00:04:28.939 --> 00:04:33.411
Now, where would everything,
every intuition we've

94
00:04:33.411 --> 00:04:38.167
thought over the years suggest,
given we first check top of

95
00:04:38.167 --> 00:04:43.112
our call stack new function where
we would look next Jasmine,

96
00:04:43.112 --> 00:04:47.980
every sort of intuition we have
about I run my function here.

97
00:04:47.980 --> 00:04:51.490
I have access to stuff outside of
where it's running where would I say I

98
00:04:51.490 --> 00:04:53.180
can go and look for counter next?

99
00:04:53.180 --> 00:04:55.085
&gt;&gt; Jasmine: Maybe we
think to look in outer.

100
00:04:55.085 --> 00:04:58.508
&gt;&gt; Will Sentance: We might think
look in outer but outer's off the,

101
00:04:58.508 --> 00:05:01.124
that execution context is shut down.

102
00:05:01.124 --> 00:05:03.115
It's off that cool stat, therefore.

103
00:05:03.115 --> 00:05:07.960
[SOUND] We can't take our thread
back in there that's done our

104
00:05:07.960 --> 00:05:12.912
threat of execution went in,
came back out, and it's gone.

105
00:05:12.912 --> 00:05:14.410
And we're now inside of new function.

106
00:05:15.450 --> 00:05:17.120
So we're running a new function in global.

107
00:05:17.120 --> 00:05:19.670
So Jasmine,
where might we look for counter?

108
00:05:19.670 --> 00:05:22.043
&gt;&gt; Jasmine: Global.
&gt;&gt; Will Sentance: In global.

109
00:05:22.043 --> 00:05:23.740
In theory, sounds right to me.

110
00:05:27.511 --> 00:05:30.880
&gt;&gt; Will Sentance: This
line is not very good.

111
00:05:30.880 --> 00:05:32.760
Is countering global, Jasmine?

112
00:05:32.760 --> 00:05:34.050
It's definitely not.

113
00:05:37.273 --> 00:05:39.421
&gt;&gt; Will Sentance: It
kind of gets old [LAUGH].

114
00:05:39.421 --> 00:05:42.467
No, very sad!

115
00:05:42.467 --> 00:05:48.760
&gt;&gt; Class: [LAUGH]
&gt;&gt; Will Sentance: Very sad!

116
00:05:48.760 --> 00:05:51.570
By the way, what a problematic language
design that let's this happen.

117
00:05:51.570 --> 00:05:53.520
This feels like a bad
language design obviously.

118
00:05:55.130 --> 00:05:58.980
Given that this is not the core focus
of this talk, we wanna use this.

119
00:05:58.980 --> 00:06:02.030
For a very powerful feature,
I'm not gonna dwell on this,

120
00:06:02.030 --> 00:06:06.620
but I'm not gonna sort of
let us suffer for too long.

121
00:06:06.620 --> 00:06:12.015
Instead, I'm gonna tell you about
a powerful thing that happens

122
00:06:12.015 --> 00:06:20.450
when I return a function out of
the running of another function.

123
00:06:20.450 --> 00:06:24.020
Give it a global label and
run it by its new global label.

124
00:06:25.300 --> 00:06:27.050
Something very special happens.

125
00:06:28.910 --> 00:06:33.914
I do not just get the code
of the increment counter

126
00:06:33.914 --> 00:06:38.321
function returned out into new function.

127
00:06:38.321 --> 00:06:42.600
I bring with my function
code something else.

128
00:06:50.160 --> 00:06:55.200
On the back of this function comes,
&gt;&gt; Will Sentance: [LAUGH] On the back of

129
00:06:55.200 --> 00:07:00.259
this function comes,
its entire surrounding local memory as

130
00:07:00.259 --> 00:07:06.350
the function gets returned out,
gets returned out into new function.

131
00:07:06.350 --> 00:07:11.426
It brings with it attached on to
it on the back of the function.

132
00:07:11.426 --> 00:07:15.040
And here it is on the back of the function
it's a little backpack as the function

133
00:07:15.040 --> 00:07:18.700
gets pulled out,
it pulls with it on its back.

134
00:07:18.700 --> 00:07:26.062
The surrounding data from when
it was born and look at that.

135
00:07:26.062 --> 00:07:30.113
There is counter is zero attached to, and

136
00:07:30.113 --> 00:07:37.423
we'll talk about whether there's any
more official name than backpack.

137
00:07:37.423 --> 00:07:40.927
I will tell you this after
somebody saw this talk and

138
00:07:40.927 --> 00:07:44.433
wrote a blog post about
it has 50,000 likes,

139
00:07:44.433 --> 00:07:49.324
meaning this term is ever more popular
may into the spec of JavaScript,

140
00:07:49.324 --> 00:07:53.157
never, but maybe there it is
attached on the function,

141
00:07:53.157 --> 00:07:58.293
meaning Jasmine, take a shot after
not finding counter in new functions,

142
00:07:58.293 --> 00:08:04.540
immediate local execution context,
you rightly said the local memory there.

143
00:08:04.540 --> 00:08:10.530
Before I look to global, might there be
somewhere else and you can use the word.

144
00:08:10.530 --> 00:08:13.930
You can say the word it begins with b and
ends back.

145
00:08:15.012 --> 00:08:18.200
Jasmine is there somewhere else that
you think that JavaScript's going to

146
00:08:18.200 --> 00:08:22.480
take its lookup journey to before
it searches global for counter?

147
00:08:22.480 --> 00:08:24.270
&gt;&gt; Jasmine: You might look
in new functions back pack.

148
00:08:24.270 --> 00:08:26.370
&gt;&gt; Will Sentance: You would look
in new functions back pack.

149
00:08:26.370 --> 00:08:27.770
Thank you so much Jasmine.

150
00:08:27.770 --> 00:08:33.045
She is spot on, off we go into new

151
00:08:33.045 --> 00:08:37.670
functions back pack,

152
00:08:37.670 --> 00:08:42.790
here it is, and what do we find there,
Jasmine, we find counter is?

153
00:08:43.860 --> 00:08:44.420
&gt;&gt; Jasmine: Zero.

154
00:08:44.420 --> 00:08:47.750
&gt;&gt; Will Sentance: Counter is zero,
she's spot on,

155
00:08:47.750 --> 00:08:51.020
what do we do to it,
we increment it, Jasmine to?

156
00:08:51.020 --> 00:08:51.520
&gt;&gt; Jasmine: One.

157
00:08:55.058 --> 00:08:55.652
&gt;&gt; Will Sentance: To one.

158
00:08:55.652 --> 00:08:59.690
This execution context gone.

159
00:08:59.690 --> 00:09:02.030
We are not gonna erase it,

160
00:09:02.030 --> 00:09:05.310
we're gonna add it back on because
we're gonna run new function again.

161
00:09:05.310 --> 00:09:08.050
We're gonna talk all about this
backpack in a moment people.

162
00:09:08.050 --> 00:09:08.920
It's super powerful.

163
00:09:12.025 --> 00:09:14.640
&gt;&gt; Will Sentance: Everything in the local
memory there's nothing here but

164
00:09:14.640 --> 00:09:17.320
everything as always is deleted,
it's only temporary.

165
00:09:19.150 --> 00:09:20.820
Run new function again.

166
00:09:20.820 --> 00:09:22.394
Brand new Anna, brand new what?

167
00:09:22.394 --> 00:09:24.684
&gt;&gt; Class: Execution context.

168
00:09:24.684 --> 00:09:27.946
&gt;&gt; Will Sentance: Excellent everybody but
Anna as well.

169
00:09:27.946 --> 00:09:32.370
Excellent Anna into we go when
they turn up the audio for

170
00:09:32.370 --> 00:09:36.980
your mics and it's just Bubenesh
saying execution context.

171
00:09:36.980 --> 00:09:42.752
We find in as next call to new
function counter plus plus,

172
00:09:42.752 --> 00:09:49.727
Eric where do I look for counter first,
by the way, just to be clear,

173
00:09:49.727 --> 00:09:56.130
this is a new new function execution
context on the call stack.

174
00:09:56.130 --> 00:09:58.530
I erased it and put it back on again.

175
00:09:58.530 --> 00:10:00.434
And where do I look first, Eric?

176
00:10:00.434 --> 00:10:02.940
&gt;&gt; Eric: First we're going to look
in the local execution context.

177
00:10:02.940 --> 00:10:05.170
&gt;&gt; Will Sentance: Fantastic.
Do I find counter?

178
00:10:05.170 --> 00:10:05.940
&gt;&gt; Eric: No counter there?

179
00:10:05.940 --> 00:10:07.820
&gt;&gt; Will Sentance: Where do I look next?

180
00:10:07.820 --> 00:10:09.410
Don't use any fancy terms.

181
00:10:09.410 --> 00:10:10.600
&gt;&gt; Eric: We're gonna go to the backpack.

182
00:10:10.600 --> 00:10:14.080
&gt;&gt; Will Sentance: We're gonna go to
the backpack, where we find counter is?

183
00:10:14.080 --> 00:10:14.944
&gt;&gt; Eric: One.

184
00:10:14.944 --> 00:10:18.760
&gt;&gt; Will Sentance: Wow,
we find counter is 1.

185
00:10:18.760 --> 00:10:20.790
We increment it to?

186
00:10:20.790 --> 00:10:21.513
&gt;&gt; Eric: 2.

187
00:10:21.513 --> 00:10:25.836
&gt;&gt; Will Sentance: 2,
&gt;&gt; Will Sentance: Immediately, people,

188
00:10:25.836 --> 00:10:30.990
you might be able to see this
has supercharged our functions.

189
00:10:30.990 --> 00:10:33.110
Functions are just two things.

190
00:10:33.110 --> 00:10:36.550
Well, as for
now let's say two blocks of code,

191
00:10:36.550 --> 00:10:40.160
which when run, they get to walk
through the code, the thread and

192
00:10:40.160 --> 00:10:43.510
a temporary memory bundled up just for
the function of that time.

193
00:10:45.090 --> 00:10:51.240
This enables our functions to have
two types of place to store data,

194
00:10:51.240 --> 00:10:56.170
one temporary for their single execution,
the single running and

195
00:10:56.170 --> 00:11:01.960
one permanent persistent, that's there as
long as the code of the function is saved.

196
00:11:01.960 --> 00:11:06.400
Add function's not just code anymore,
it saves code under the label new function

197
00:11:06.400 --> 00:11:11.460
that was originally increment counters
code plus persistent data attached to it

198
00:11:12.550 --> 00:11:16.910
that we get access to by making
reference in new function

199
00:11:16.910 --> 00:11:20.290
borders increment counter to
something that's not in local memory.

200
00:11:21.640 --> 00:11:23.780
So we jump out and
look in the backpack and

201
00:11:23.780 --> 00:11:29.390
as long as when we birthed when we
created the now known as new function.

202
00:11:29.390 --> 00:11:32.112
Function originating from encounter.

203
00:11:32.112 --> 00:11:35.410
We had around it in local memory,
save counter is zero,

204
00:11:35.410 --> 00:11:41.210
that gets pulled out on the back
of the function into new function.

205
00:11:41.210 --> 00:11:44.070
And there it is attached,
there it is attached people.

206
00:11:45.630 --> 00:11:46.626
So I'm going to.

207
00:11:46.626 --> 00:11:53.506
[SOUND] I'll address this one more
time new function's definition,

208
00:11:53.506 --> 00:11:58.960
its code,
its saved code now has a hidden link.

209
00:11:58.960 --> 00:12:03.766
Hidden, well, that's why I got to tell
you a few few more important things about

210
00:12:03.766 --> 00:12:05.758
this before we move on to thumbs.

211
00:12:05.758 --> 00:12:11.990
How is this permanent data
here attached to the function?

212
00:12:11.990 --> 00:12:15.770
Well firstly, we can't get to it directly.

213
00:12:15.770 --> 00:12:17.985
I can't go new function in global,

214
00:12:17.985 --> 00:12:23.900
newfunction.backpack.counter, this
is not possible.

215
00:12:23.900 --> 00:12:25.890
I can't even go newfunction.

216
00:12:25.890 --> 00:12:31.650
Official name for it dot counter as they
were getting into it, it is absolutely

217
00:12:31.650 --> 00:12:36.810
they call it private to that increment
counter now known as new function.

218
00:12:38.090 --> 00:12:42.800
Function call, we can only get into it
by running new function, not finding

219
00:12:42.800 --> 00:12:46.730
something we reference in the local
memory and jumping out to the backpack.

220
00:12:46.730 --> 00:12:52.050
The backpack kind of inserts itself
before we go down to looking in global.

221
00:12:52.050 --> 00:12:55.470
Don't get me wrong the backpack
in global in the sense that it's

222
00:12:55.470 --> 00:12:57.360
attached to a function
that saved in global.

223
00:12:58.700 --> 00:13:03.099
But global really means I can access
the name for that data when I'm in global

224
00:13:03.099 --> 00:13:08.330
execution context, I can't access this
data, it's hidden, it's protected.

225
00:13:08.330 --> 00:13:09.550
Well, how is it protected?

226
00:13:09.550 --> 00:13:14.040
Well, as soon as the function increment
counter was saved inside the running of

227
00:13:14.040 --> 00:13:17.910
outer when outer was on our
call stack earlier inside that

228
00:13:17.910 --> 00:13:20.040
execution context a thread
was running through.

229
00:13:20.040 --> 00:13:21.600
As soon as increment counter was saved.

230
00:13:22.710 --> 00:13:26.340
It immediately got a link
to the surrounding memory.

231
00:13:26.340 --> 00:13:28.810
Immediately, to the whole
surrounding memory.

232
00:13:28.810 --> 00:13:32.768
That link was stored on a property
square bracket square bracket,

233
00:13:32.768 --> 00:13:34.120
two square brackets.

234
00:13:34.120 --> 00:13:36.960
Scope square bracket linked
to this running memory.

235
00:13:38.060 --> 00:13:40.310
It'll copy just a link to
where it was literally stored.

236
00:13:41.930 --> 00:13:44.100
When I returned the function, out,

237
00:13:44.100 --> 00:13:49.510
I pulled out on that link all the data
with me attached to the function.

238
00:13:49.510 --> 00:13:54.730
Still got that scope property,
there it is.

239
00:13:54.730 --> 00:13:56.161
How did the lid-
&gt;&gt; [INAUDIBLE]

240
00:13:56.161 --> 00:13:57.271
&gt;&gt; Will Sentance: I mean, [LAUGH] the lid

241
00:13:57.271 --> 00:13:58.105
has returned!

242
00:13:58.105 --> 00:14:00.050
&gt;&gt; Class: [LAUGH]
&gt;&gt; Will Sentance: Charmed,

243
00:14:00.050 --> 00:14:01.530
amazing, there it is.

244
00:14:01.530 --> 00:14:03.900
I was about to start shaking it
again then I thought, well, that's.

245
00:14:03.900 --> 00:14:07.062
Okay, meaning as I say,
whenever new function runs and

246
00:14:07.062 --> 00:14:11.909
it doesn't find counter's local memory,
it goes through its definition looks into

247
00:14:11.909 --> 00:14:16.508
its hidden scope property, in other words
into the backpack and finds counter.

248
00:14:16.508 --> 00:14:20.528
Because counter was there when it was
born and when it got returned out,

249
00:14:20.528 --> 00:14:23.414
the code of increment
counter from running outer.

250
00:14:23.414 --> 00:14:28.193
We ran outer we returned that increment
counter from it being creating it inside

251
00:14:28.193 --> 00:14:32.329
out and we returned it out into new
function and we run new function and

252
00:14:32.329 --> 00:14:35.040
it doesn't find counter
the local memory and

253
00:14:35.040 --> 00:14:38.855
looks to new functions backpack
stored on the scope property.

254
00:14:38.855 --> 00:14:40.656
I want to do thumbs but

255
00:14:40.656 --> 00:14:46.668
I want to probably tell you a few more
pieces about this backpack first.

256
00:14:46.668 --> 00:14:51.710
Firstly, it's really optimized,
Java Script makes the link on the saving

257
00:14:51.710 --> 00:14:56.438
of increment counter inside of outer
to the surrounding local memory,

258
00:14:56.438 --> 00:15:01.716
everything in there, the link to the whole
collection, everything, there is

259
00:15:01.716 --> 00:15:07.220
a link to where this all stored in memory,
but on returning out that function.

260
00:15:07.220 --> 00:15:09.350
Normally when you finish
running a function,

261
00:15:09.350 --> 00:15:12.180
what's the only thing we hold onto, Sam?

262
00:15:12.180 --> 00:15:14.250
When I finish running a function,
return out three.

263
00:15:14.250 --> 00:15:17.060
All the other stuff in the local memory,
do we hold onto it?

264
00:15:17.060 --> 00:15:18.450
&gt;&gt; Sam: No.
&gt;&gt; Will Sentance: No, we automatically

265
00:15:18.450 --> 00:15:19.340
garbage collect it.

266
00:15:19.340 --> 00:15:20.080
Why is it called garbage?

267
00:15:20.080 --> 00:15:24.275
It's called garbage because we can't
access any of that data by its name

268
00:15:24.275 --> 00:15:25.210
anymore.

269
00:15:25.210 --> 00:15:27.110
So there's no point it being there.

270
00:15:27.110 --> 00:15:28.860
We automatically collect it.

271
00:15:28.860 --> 00:15:31.440
It means it automatically
gets deleted by JavaScript.

272
00:15:31.440 --> 00:15:32.454
&gt;&gt; Sam: So weak reference.

273
00:15:32.454 --> 00:15:33.304
&gt;&gt; Will Sentance: Sure.

274
00:15:33.304 --> 00:15:37.610
This is absolutely instead here,

275
00:15:37.610 --> 00:15:42.807
we rely on when we
return out this function

276
00:15:42.807 --> 00:15:47.855
JavaScript is going to hold on to all that

277
00:15:47.855 --> 00:15:55.890
surrounding data in the backpack
of the function, but hold on.

278
00:15:55.890 --> 00:15:59.970
What if I say maybe 10 different
things in this local memory.

279
00:16:01.830 --> 00:16:05.460
I return I increment counter into
new function run new function.

280
00:16:05.460 --> 00:16:09.350
I've got 10 things in this
local memory besides counter.

281
00:16:09.350 --> 00:16:13.840
What's the only thing Alex,
inside of new function for

282
00:16:13.840 --> 00:16:17.070
me was increment counter what's
the only thing I refer to Alex?

283
00:16:17.070 --> 00:16:18.382
&gt;&gt; Alex: Counter.
&gt;&gt; Will Sentance: Counter.

284
00:16:18.382 --> 00:16:20.630
So if I've got 10 other
things in this backpack,

285
00:16:20.630 --> 00:16:22.630
can I get access to any of those?

286
00:16:22.630 --> 00:16:24.737
No, I can't access anything that's back.

287
00:16:24.737 --> 00:16:27.684
I can't go, newFunction.scope.counter,
I wouldn't want to.

288
00:16:27.684 --> 00:16:32.130
I want it to be preserved and
protected for the running of the function.

289
00:16:32.130 --> 00:16:34.500
Meaning, I know on the return sorry.

290
00:16:34.500 --> 00:16:39.570
Better, JavaScript knows, on the returning
of incrementCounter to newFunction,

291
00:16:39.570 --> 00:16:47.010
it already knows what that function
could ever end up needing or accessing.

292
00:16:47.010 --> 00:16:50.520
And so it optimizes what gets
pulled out in the backpack

293
00:16:51.640 --> 00:16:56.000
once we exit outer and delete
everything else in the local memory.

294
00:16:56.000 --> 00:16:57.980
If it's not referred to, delete it.

