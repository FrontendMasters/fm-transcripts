WEBVTT

1
00:00:00.000 --> 00:00:00.981
&gt;&gt; Will Sentance: How's is this possible?

2
00:00:00.981 --> 00:00:06.218
Well, in JavaScript, functions are what's

3
00:00:06.218 --> 00:00:12.406
called first-class objects,
that means that look.

4
00:00:13.568 --> 00:00:18.999
&gt;&gt; Will Sentance: Multiply by 2 here,
people really, it's just an object,

5
00:00:18.999 --> 00:00:23.815
and I know-
&gt;&gt; Will Sentance: for our online audience.

6
00:00:23.815 --> 00:00:29.828
I know that if I were to
create an object like that,

7
00:00:29.828 --> 00:00:33.847
that's horrible, never mind.

8
00:00:33.847 --> 00:00:39.162
If I create an object like that, I can
pass that into my function, no problem.

9
00:00:39.162 --> 00:00:41.468
In fact, arrays or
objects behind the scenes,

10
00:00:41.468 --> 00:00:43.323
we'll see that a little bit later on.

11
00:00:43.323 --> 00:00:46.820
Is quite useful for us, not very
functional, but quite useful for us.

12
00:00:46.820 --> 00:00:49.039
Based on the prototypal
nature of JavaScript,

13
00:00:49.039 --> 00:00:50.878
it's gonna have some great features.

14
00:00:50.878 --> 00:00:54.142
But to arrays or objects,
functions are just objects,

15
00:00:54.142 --> 00:00:57.344
that means they can be
treated as fully first-class.

16
00:00:57.344 --> 00:00:59.722
Have all the features of objects,

17
00:00:59.722 --> 00:01:04.322
including being able to be passed
as inputs into other functions.

18
00:01:04.322 --> 00:01:06.575
That's exactly what we did here.

19
00:01:06.575 --> 00:01:11.535
That enables our functions to become
reusable with different specifics

20
00:01:11.535 --> 00:01:13.411
of what they're gonna do.

21
00:01:13.411 --> 00:01:16.569
Our copy array and manipulate can
work on any specific code and

22
00:01:16.569 --> 00:01:19.070
what it's gonna do to each
element of the array.

23
00:01:19.070 --> 00:01:22.636
One is going to manipulate
an element of the array to do.

24
00:01:22.636 --> 00:01:27.459
And it means functions can be
returned out of other functions,

25
00:01:27.459 --> 00:01:30.737
and that we're gonna see this afternoon.

26
00:01:30.737 --> 00:01:35.483
Enables us to do some really profound
things like function decoration,

27
00:01:35.483 --> 00:01:37.833
currying, partial application.

28
00:01:37.833 --> 00:01:41.918
All to come this afternoon, but first,
let's just look at it for a second.

29
00:01:41.918 --> 00:01:46.790
Which of these is our callback function,
which is our higher-order function?

30
00:01:46.790 --> 00:01:51.098
Virginia, which you think here
is our grand higher function and

31
00:01:51.098 --> 00:01:54.299
which is our little sort
of callback function?

32
00:01:54.299 --> 00:01:59.415
This most profound of terms,
higher-order functions, intimidating,

33
00:01:59.415 --> 00:02:04.333
serious, sophisticated, and
we've seen it all already.

34
00:02:04.333 --> 00:02:06.291
&gt;&gt; Regina: Would it be
CopyArrayAndManipulate?

35
00:02:06.291 --> 00:02:08.301
&gt;&gt; Will Sentance: Is our?
&gt;&gt; Regina: What?

36
00:02:08.301 --> 00:02:09.964
&gt;&gt; Will Sentance: CopyArrayAndManipulate
is our?

37
00:02:09.964 --> 00:02:12.019
&gt;&gt; Regina: Higher-order function-
&gt;&gt; Will Sentance: It's our higher-order

38
00:02:12.019 --> 00:02:14.575
function, and which is our
little baby callback function?

39
00:02:14.575 --> 00:02:16.176
&gt;&gt; Regina: Multiply by 2.

40
00:02:16.176 --> 00:02:17.141
&gt;&gt; Will Sentance: Multiply by two.

41
00:02:17.141 --> 00:02:20.046
Our higher-order function,
folks, there it is,

42
00:02:20.046 --> 00:02:23.686
the function we pass and
multiply by 2 is our callback function.

43
00:02:23.686 --> 00:02:29.485
The outer function that takes in
the function is our higher-order function.

44
00:02:29.485 --> 00:02:33.814
It is a core component of functional
programming, and that's what it is.

45
00:02:33.814 --> 00:02:37.422
A function that we can leave a little
blank on in order that when we run it,

46
00:02:37.422 --> 00:02:39.447
we specify exactly what it's gonna do.

47
00:02:39.447 --> 00:02:42.483
Just like we specify exactly
what array it's gonna run on,

48
00:02:42.483 --> 00:02:45.715
we specify exactly what code
it's gonna use, and that's it.

49
00:02:45.715 --> 00:02:47.049
All right, people,

50
00:02:47.049 --> 00:02:51.727
just a name, you don't have to declare
them as higher-order functions.

51
00:02:51.727 --> 00:02:53.419
You can imagine the language
where you have to say this is

52
00:02:53.419 --> 00:02:54.177
not a regular function.

53
00:02:54.177 --> 00:02:57.430
This is one of a higher order,
they can take others just by using it,

54
00:02:57.430 --> 00:02:58.699
by inserting a function.

55
00:02:58.699 --> 00:03:02.315
And so we're inserting code that
then ends up being executed inside,

56
00:03:02.315 --> 00:03:04.474
that makes our higher-order function.

57
00:03:04.474 --> 00:03:07.904
Also, by the way, just as a mention,
we'll see this later on.

58
00:03:07.904 --> 00:03:12.042
Any function that also returns out
a function, we'll see that later on.

59
00:03:12.042 --> 00:03:15.085
By the way, we'll see that later on,
and I will say this,

60
00:03:15.085 --> 00:03:17.520
I give talks at these
fancy developer places.

61
00:03:17.520 --> 00:03:21.406
And even their engineers with five,
ten years experience,

62
00:03:21.406 --> 00:03:23.243
struggle with that notion.

63
00:03:23.243 --> 00:03:28.086
Of birthing a function inside the running
of another function, saving it,

64
00:03:28.086 --> 00:03:30.291
defining it and returning it out.

65
00:03:30.291 --> 00:03:33.177
They struggle with it,
so we'll see that, but

66
00:03:33.177 --> 00:03:36.222
that's also known as
a higher-order function.

67
00:03:36.222 --> 00:03:40.044
So let's review

68
00:03:40.044 --> 00:03:46.601
higher-order functions.

69
00:03:46.601 --> 00:03:50.476
Are the easier, do they make our
lives easier to add features?

70
00:03:50.476 --> 00:03:51.629
Let's see what it says.

71
00:03:51.629 --> 00:03:55.169
We don't need to build
a brand new copy array and

72
00:03:55.169 --> 00:03:59.427
add 3, copy array and
divide by 2, copy and function.

73
00:03:59.427 --> 00:04:04.335
Just use copy and manipulate and with
the input of three higher-order functions

74
00:04:04.335 --> 00:04:06.652
are crucial for keeping our code dry.

75
00:04:06.652 --> 00:04:08.732
Don't repeat yourself, write it once, and

76
00:04:08.732 --> 00:04:10.931
then combine it up again
to build new features.

77
00:04:10.931 --> 00:04:15.829
We turn copy array and divide by 2,
copy array and multiply by 2,

78
00:04:15.829 --> 00:04:17.497
copy array and add 3.

79
00:04:17.497 --> 00:04:20.336
Three separate megablocks
of code into one, and

80
00:04:20.336 --> 00:04:22.977
then add the little free
bit as a single line.

81
00:04:22.977 --> 00:04:26.925
I just inserted in, add the multiply
by 2 in a single Iine, inserted it.

82
00:04:26.925 --> 00:04:28.068
More readable?

83
00:04:28.068 --> 00:04:31.951
Yeah, that's pretty readable,
copy array and manipulate, multiply by 2.

84
00:04:31.951 --> 00:04:36.227
Once you get used to it, I understand and
create a new array doing something to it.

85
00:04:36.227 --> 00:04:39.036
And I'm using a multiply by 2.

86
00:04:39.036 --> 00:04:42.755
I know what this is doing more
readily than the four loop style.

87
00:04:42.755 --> 00:04:45.615
Easier to debug?

88
00:04:45.615 --> 00:04:50.201
Well, I would argue as long as we
understand what it's doing under the hood.

