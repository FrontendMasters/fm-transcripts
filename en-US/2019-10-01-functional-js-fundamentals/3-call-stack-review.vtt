WEBVTT

1
00:00:00.200 --> 00:00:05.788
&gt;&gt; Will Sentance: When we run a function,
&gt;&gt; Will Sentance: We call that function,

2
00:00:05.788 --> 00:00:07.728
we invoke that function.

3
00:00:07.728 --> 00:00:12.254
We know that when we finish running
that function, say, multiply by 2,

4
00:00:12.254 --> 00:00:14.150
we know where to go back to.

5
00:00:14.150 --> 00:00:18.009
I can visually see on the page, I guess
I could back out to where I was before.

6
00:00:18.009 --> 00:00:20.180
JavaScript needs to keep track of that.

7
00:00:20.180 --> 00:00:23.088
In fact, it keeps track of every
single function that we call.

8
00:00:23.088 --> 00:00:26.896
And it does so using a way of storing
data in a computer known as a stack.

9
00:00:26.896 --> 00:00:31.857
Which is a useful way of organizing
data just like a stack of plates.

10
00:00:31.857 --> 00:00:34.668
The only thing it cares about at
any given moment is the top plate.

11
00:00:34.668 --> 00:00:38.113
I can't grab random plates from a stack of
plates, I can only take the top one off.

12
00:00:38.113 --> 00:00:40.211
Well, that's exactly what
a call stack feels like.

13
00:00:40.211 --> 00:00:43.943
The only thing it cares about
is what's on it's top right now.

14
00:00:43.943 --> 00:00:50.187
And when we run a function like multiply
by two's, we do [SOUND] in this line,

15
00:00:50.187 --> 00:00:56.845
we're gonna add it to the top of the stack
of calls, with the input, there it is.

16
00:00:56.845 --> 00:01:00.526
Every time we run a function,
we add it to the stack of calls.

17
00:01:00.526 --> 00:01:03.872
Every time it finishes running,
what keyword, David,

18
00:01:03.872 --> 00:01:06.404
tells me finish running a function
&gt;&gt; David: Return?

19
00:01:06.404 --> 00:01:07.902
&gt;&gt; Will Sentance: Return, we remove it.

20
00:01:07.902 --> 00:01:13.815
Anyone know the posh word, do we know
the password for adding to a stack?

21
00:01:13.815 --> 00:01:15.749
&gt;&gt; David: Push and pop.

22
00:01:15.749 --> 00:01:18.143
&gt;&gt; Will Sentance: Push, push to
a stack and pop to remove it, exactly,

23
00:01:18.143 --> 00:01:18.791
we pop it off.

24
00:01:18.791 --> 00:01:23.765
Unfortunately this is not the whiteboard
to be rapidly popping stuff of stacks,

25
00:01:23.765 --> 00:01:25.240
but let's give it a go.

26
00:01:25.240 --> 00:01:30.042
Pop it off of stack, and actually there's
one thing I didn't mention is we can think

27
00:01:30.042 --> 00:01:34.130
of our whole file of code, cuz remember,
functions is this little mini programs.

28
00:01:34.130 --> 00:01:35.650
Our whole file of code
is the main program.

29
00:01:35.650 --> 00:01:38.274
We can think of it as being
wrapped up in a big old function.

30
00:01:38.274 --> 00:01:43.430
What do me call it, [SOUND] Charles?

31
00:01:43.430 --> 00:01:44.299
Do you know what we call the,

32
00:01:44.299 --> 00:01:46.416
that's not very fair of me to just
throw out a question out like that.

33
00:01:46.416 --> 00:01:50.281
We call the overall kind of function that
is our overall code that we're running,

34
00:01:50.281 --> 00:01:52.574
we call that, do you know Virginia?

35
00:01:52.574 --> 00:01:53.457
Did Charles?

36
00:01:53.457 --> 00:01:54.200
&gt;&gt; David: Global.

37
00:01:54.200 --> 00:01:56.643
&gt;&gt; Will Sentance: Global,
global, yeah exactly,

38
00:01:56.643 --> 00:02:01.121
think of our overall code as global,
and we're running that.

39
00:02:01.121 --> 00:02:04.059
And so as soon as I run multiply by
2 with input of 3, I add it on top.

40
00:02:04.059 --> 00:02:07.547
When I finish running it, I take it off,
and I go back out to global.

41
00:02:07.547 --> 00:02:10.682
I start running multiply by 2 input of 10,
add it on top,

42
00:02:10.682 --> 00:02:13.337
finish running it,
take it off, back to global.

43
00:02:13.337 --> 00:02:16.959
If I were to run another function inside
of multiply by 2 with the input of 3,

44
00:02:16.959 --> 00:02:20.779
I'd have multiply by 2 input of 3, and
I'd have another function on top of it.

45
00:02:20.779 --> 00:02:23.881
Another function is out of that one,
another on top of it, all the way up

46
00:02:23.881 --> 00:02:27.090
the call stack if I were to recursively
call a function inside a function,

47
00:02:27.090 --> 00:02:29.614
inside a function,
until I ran out of space on the stack.

48
00:02:29.614 --> 00:02:31.482
And I'd have what's known as?

49
00:02:31.482 --> 00:02:32.637
&gt;&gt; David: Stack overflow.

50
00:02:32.637 --> 00:02:34.425
&gt;&gt; Will Sentance: Stack overflow,
exactly, I run out of space.

51
00:02:34.425 --> 00:02:37.937
Okay, there we go, those are the founding
principles of JavaScript.

52
00:02:37.937 --> 00:02:40.275
They only took us half an hour,
no problem.

