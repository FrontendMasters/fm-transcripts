WEBVTT

1
00:00:00.000 --> 00:00:03.606
&gt;&gt; Will Sentance: We just saw,
we had three incredibly boring,

2
00:00:03.606 --> 00:00:09.815
repetitive functions, each time exactly
the same besides one little change.

3
00:00:09.815 --> 00:00:13.220
And so now we realized
there must be a better way.

4
00:00:13.220 --> 00:00:14.861
Eric was bored.

5
00:00:14.861 --> 00:00:16.403
It was rude of him to say so.

6
00:00:16.403 --> 00:00:18.246
No, Eric was bored.

7
00:00:18.246 --> 00:00:21.609
It was very nice of him to
acknowledge that and he should be.

8
00:00:21.609 --> 00:00:23.176
Cuz we need a better way.

9
00:00:23.176 --> 00:00:26.746
We do know where to build our individual
functions every time we wanna take

10
00:00:26.746 --> 00:00:28.243
an array, create a new array,

11
00:00:28.243 --> 00:00:31.657
take each element of the input array and
do something different to it.

12
00:00:31.657 --> 00:00:35.914
What if there are ways instead of
leaving a placeholder, a blank,

13
00:00:35.914 --> 00:00:39.182
into which we would then
when we run that function,

14
00:00:39.182 --> 00:00:43.303
specify exactly what we're gonna
to each element of the array.

15
00:00:43.303 --> 00:00:47.330
The first time we run the body of that for
loop there, i is gonna be 0,

16
00:00:47.330 --> 00:00:52.056
array position 0 is gonna be number 1,
instructions will be multiplied by 2,

17
00:00:52.056 --> 00:00:56.804
multiply by 2 input of 1, insert the 1,
return out the 2, push it to output.

18
00:00:56.804 --> 00:00:58.553
And then again and again.

19
00:00:58.553 --> 00:01:00.324
People, let's see it in action.

20
00:01:00.324 --> 00:01:03.197
Here we go folks, starting with Jasmine.

21
00:01:03.197 --> 00:01:07.239
Jasmine, what do we do, my friend,
here in line one of our code,

22
00:01:07.239 --> 00:01:09.159
what are we saving first here?

23
00:01:09.159 --> 00:01:11.640
&gt;&gt; Jasmine: We're declaring
copyArrayAndManipulate.

24
00:01:11.640 --> 00:01:18.571
&gt;&gt; Will Sentance: CopyArrayAndManipulate,
so we're gonna leave blank exactly

25
00:01:18.571 --> 00:01:24.097
what it's going to do to
each element of our array.

26
00:01:24.097 --> 00:01:27.577
So we save that function
there in our memory, so

27
00:01:27.577 --> 00:01:32.972
thank you to Jasmine next slide,
Virginia, little baby function here.

28
00:01:32.972 --> 00:01:34.324
What's it gonna do?

29
00:01:34.324 --> 00:01:36.086
&gt;&gt; Virginia: So we're going to
create a label, multiply by 2.

30
00:01:36.086 --> 00:01:37.554
&gt;&gt; Will Sentance: Yeah, and it's what?

31
00:01:37.554 --> 00:01:41.582
&gt;&gt; Virginia: And we're gonna go off, and-
&gt;&gt; Will Sentance: Assign a?

32
00:01:41.582 --> 00:01:42.307
&gt;&gt; Virginia: Assign a function.

33
00:01:42.307 --> 00:01:44.584
&gt;&gt; Will Sentance: Assign a function,
she's the bomb, exactly.

34
00:01:44.584 --> 00:01:48.444
Next line, Sam left hand side first.

35
00:01:48.444 --> 00:01:50.931
&gt;&gt; Sam: Declare a constant result.

36
00:01:50.931 --> 00:01:56.236
&gt;&gt; Will Sentance: Excellent, and we then
need to go and do some work, right, Sam?

37
00:01:56.236 --> 00:02:01.397
Which is to go and invoke,
go and run what function?

38
00:02:01.397 --> 00:02:02.746
&gt;&gt; Sam: CopyArrayAndManipulate.

39
00:02:02.746 --> 00:02:08.874
&gt;&gt; Will Sentance: CopyArrayAndManipulate
input of 1,

40
00:02:08.874 --> 00:02:15.930
2 and 3 and folk, the entire functionality

41
00:02:15.930 --> 00:02:20.952
of multiply by 2, there it is.

42
00:02:20.952 --> 00:02:28.625
And we're gonna create, in order to
run the CopyArrayAndManipulate code,

43
00:02:28.625 --> 00:02:32.177
we're going to create a brand new.

44
00:02:32.177 --> 00:02:35.856
[LAUGH]
&gt;&gt; Will Sentance: Yeah, thank you,

45
00:02:35.856 --> 00:02:38.663
Bivanesh, [LAUGH] nothing makes it
better than when some person decides

46
00:02:38.663 --> 00:02:41.482
to say local and that's completely
correct and everyone else says it.

47
00:02:41.482 --> 00:02:45.486
Perfect Bivanesh, exactly,
a local execution context, but

48
00:02:45.486 --> 00:02:48.049
let's call it an execution context,

49
00:02:48.049 --> 00:02:52.385
a brand new execution context
with its own little local memory.

50
00:02:52.385 --> 00:02:56.120
Into it we go, and the easy bit first.

51
00:02:56.120 --> 00:02:59.597
Andrew, array is going
to be filled in with?

52
00:02:59.597 --> 00:03:00.710
&gt;&gt; Andrew: 1, 2, 3.

53
00:03:00.710 --> 00:03:05.310
&gt;&gt; Will Sentance: Exactly, our parameter
array will be assigned the value,

54
00:03:05.310 --> 00:03:08.070
which is our argument 1, 2, 3.

55
00:03:08.070 --> 00:03:11.120
And then the hard bit,
David, our parameter,

56
00:03:11.120 --> 00:03:15.555
our placeholder instructions is
gonna be filled in with what David?

57
00:03:15.555 --> 00:03:17.433
&gt;&gt; David: Result of multiplying by 2.

58
00:03:17.433 --> 00:03:19.140
&gt;&gt; Will Sentance: Not the result.

59
00:03:19.140 --> 00:03:21.549
That's a label for the functionality, Sam?

60
00:03:21.549 --> 00:03:22.359
&gt;&gt; Sam: It's the reference.

61
00:03:22.359 --> 00:03:25.263
&gt;&gt; Will Sentance: Yes, and that it is
a link back but let's just say for

62
00:03:25.263 --> 00:03:26.060
now it is the?

63
00:03:26.060 --> 00:03:27.494
&gt;&gt; Group: Function.
&gt;&gt; Will Sentance: The function

64
00:03:27.494 --> 00:03:28.799
definition of?

65
00:03:28.799 --> 00:03:29.438
&gt;&gt; Group: Multiply by 2.

66
00:03:29.438 --> 00:03:32.359
&gt;&gt; Will Sentance: Multiply by 2, meaning
wherever you see instructions inside of

67
00:03:32.359 --> 00:03:35.927
it, and don't, David, absolutely
understandable to make that confusion.

68
00:03:35.927 --> 00:03:39.722
Wherever you see instructions inside of
here, know that it is being filled in with

69
00:03:39.722 --> 00:03:42.252
the code of multiply by 2,
meaning you're literally

70
00:03:42.252 --> 00:03:46.111
going to throw away the word instructions
and multiply by 2 is going to go in there.

71
00:03:46.111 --> 00:03:50.716
Just like, not everyone knows, this just
like wherever you see array inside that

72
00:03:50.716 --> 00:03:55.403
function that's literally going to be
thrown away and replaced with 1, 2, 3.

73
00:03:55.403 --> 00:03:57.924
We could literally throw
away ran at the 1, 2, 3.

74
00:03:57.924 --> 00:04:03.385
So it's a 123.length, 123[i],
everything becomes a value in JavaScript.

75
00:04:03.385 --> 00:04:06.101
Nothing just becomes like
a kind of it might be this.

76
00:04:06.101 --> 00:04:06.777
It's a value.

77
00:04:06.777 --> 00:04:07.784
It's a thing.

78
00:04:07.784 --> 00:04:09.851
Including instructions,

79
00:04:09.851 --> 00:04:14.440
which becomes exactly meaning there it is,
multiply by 2.

80
00:04:14.440 --> 00:04:21.856
Meaning Virginia, it's still strange,
it's my sister name.

81
00:04:21.856 --> 00:04:28.353
Meaning if, Virginia, I want to run
multiply by 2 inside this function.

82
00:04:28.353 --> 00:04:32.704
I don't use the label multiple by 2,
what they will do I use Virginia?

83
00:04:32.704 --> 00:04:33.309
&gt;&gt; Virginia: What label?

84
00:04:33.309 --> 00:04:37.124
&gt;&gt; Will Sentance: What label do I use,
Eric, to run the?

85
00:04:37.124 --> 00:04:38.099
&gt;&gt; Eric: Instructions.

86
00:04:38.099 --> 00:04:39.024
&gt;&gt; Will Sentance: Instructions, so

87
00:04:39.024 --> 00:04:42.677
if I wanted to run multiply by 2,
what specifically would I write, Mike?

88
00:04:42.677 --> 00:04:45.708
Michael, what would I specifically write
if I wanted to run multiply by 2 inside of

89
00:04:45.708 --> 00:04:46.325
this function?

90
00:04:46.325 --> 00:04:46.982
&gt;&gt; Michael: Instructions.

91
00:04:46.982 --> 00:04:50.380
&gt;&gt; Will Sentance: Instructions and,
if I want to run it.

92
00:04:50.380 --> 00:04:50.907
&gt;&gt; Michael: Parentheses.

93
00:04:50.907 --> 00:04:54.029
&gt;&gt; Will Sentance: And parentheses, and I
guess given its multiplying a number by 2

94
00:04:54.029 --> 00:04:56.660
and is expecting an input
I'd put something in there.

95
00:04:56.660 --> 00:05:01.563
That is really running multiply by 2,

96
00:05:01.563 --> 00:05:05.878
multiply by 2 input of 3, okay?

97
00:05:05.878 --> 00:05:08.056
Instructions is our general name,

98
00:05:08.056 --> 00:05:11.912
meaning I could run
copyArrayAndManipulate on any function.

99
00:05:11.912 --> 00:05:14.134
I would have it take in divide by 2 and

100
00:05:14.134 --> 00:05:17.468
instructions would be
filled in with divide by 2.

101
00:05:17.468 --> 00:05:19.006
This is getting very general.

102
00:05:19.006 --> 00:05:19.890
Very very nice.

103
00:05:19.890 --> 00:05:21.772
That makes us very happy.

104
00:05:21.772 --> 00:05:25.196
All right, excellent,
now we're trying to produce a new array.

105
00:05:25.196 --> 00:05:29.867
So Anna, what's the first thing we do
inside a copyArrayAndManipulate after

106
00:05:29.867 --> 00:05:32.427
we've handled our inputs, we produce a?

107
00:05:32.427 --> 00:05:33.356
We declare a?

108
00:05:33.356 --> 00:05:34.027
&gt;&gt; Anna: Output.

109
00:05:34.027 --> 00:05:35.961
&gt;&gt; Will Sentance: Output and it is a?

110
00:05:35.961 --> 00:05:36.747
&gt;&gt; Anna: Empty array.

111
00:05:36.747 --> 00:05:40.886
&gt;&gt; Will Sentance: Empty array,
exactly, there it is, empty array.

112
00:05:40.886 --> 00:05:44.956
And let's get iterating.

113
00:05:44.956 --> 00:05:46.888
You know what?

114
00:05:46.888 --> 00:05:52.097
I'm gonna do my cool stack just this time
just because we're recording this for

115
00:05:52.097 --> 00:05:57.007
posterity I want to be able to keep
track of this, we're always in global.

116
00:05:57.007 --> 00:05:59.366
What are we in now, Bivanesh?

117
00:05:59.366 --> 00:06:00.970
What function are we calling right now?

118
00:06:00.970 --> 00:06:01.834
&gt;&gt; Bivanesh: The copyArrayAndManipulate.

119
00:06:01.834 --> 00:06:05.754
&gt;&gt; Will Sentance: Excellent,
copyArrayAndManipulate, Bivanesh,

120
00:06:05.754 --> 00:06:08.634
I remembered your name right, right?

121
00:06:08.634 --> 00:06:09.484
&gt;&gt; Bivanesh: Yeah.
&gt;&gt; Will Sentance: Yeah,

122
00:06:09.484 --> 00:06:10.825
all right there it is.

123
00:06:10.825 --> 00:06:12.839
1, 2, 3 is our array, and

124
00:06:12.839 --> 00:06:17.687
then we've got our output we're going
to work with and put stuff into.

125
00:06:17.687 --> 00:06:19.354
Now things get interesting.

126
00:06:19.354 --> 00:06:23.917
Body of the for loop between the curly
braces, inwards, outwards, JavaScript

127
00:06:23.917 --> 00:06:28.429
never works on something where it needs
something else to figure out what it is.

128
00:06:28.429 --> 00:06:31.799
So, it always takes the thing which it
needs first, which here would be the i.

129
00:06:31.799 --> 00:06:32.783
It always starts there.

130
00:06:32.783 --> 00:06:35.207
So i, Alex, is what?

131
00:06:35.207 --> 00:06:37.601
First time you hit the body of the for
loop, i's value is?

132
00:06:37.601 --> 00:06:38.137
&gt;&gt; Alex: 0.

133
00:06:38.137 --> 00:06:40.835
&gt;&gt; Will Sentance: 0, array position 0 is?

134
00:06:40.835 --> 00:06:44.195
&gt;&gt; Alex: 1.
&gt;&gt; Will Sentance: 1, instructions,

135
00:06:44.195 --> 00:06:46.472
Alex is really?

136
00:06:46.472 --> 00:06:48.626
&gt;&gt; Alex: Multiply by 2,
&gt;&gt; Will Sentance: Multiply by2, and

137
00:06:48.626 --> 00:06:53.288
look at that people,
we're able to use code that wasn't in

138
00:06:53.288 --> 00:06:57.125
the function when it was saved,
we pulled it in.

139
00:06:57.125 --> 00:06:58.288
That's pretty insane.

140
00:06:58.288 --> 00:07:00.601
Brand new what Alex?

141
00:07:00.601 --> 00:07:01.231
&gt;&gt; Alex: Execution context.

142
00:07:01.231 --> 00:07:03.597
&gt;&gt; Will Sentance: Execution context,
into it we go.

143
00:07:03.597 --> 00:07:06.103
It's quite small here.

144
00:07:06.103 --> 00:07:07.647
What happens when I call stack Alex?

145
00:07:07.647 --> 00:07:08.236
&gt;&gt; Alex: Pushing.

146
00:07:08.236 --> 00:07:11.693
&gt;&gt; Will Sentance: Pushing the code
multiply by 2, he's spot on.

147
00:07:11.693 --> 00:07:15.996
On to the call stack,
multiply by 2, input over 1.

148
00:07:15.996 --> 00:07:17.064
Into it we go.

149
00:07:17.064 --> 00:07:20.430
We're taking the array
position 0 which is number 1,

150
00:07:20.430 --> 00:07:23.805
sticking it into instructions
which is multiply by 2.

151
00:07:23.805 --> 00:07:26.753
That means that 1 is going
down into multiple by 2.

152
00:07:26.753 --> 00:07:30.050
Therefore, Virginia, tough one, parameter,

153
00:07:30.050 --> 00:07:35.316
to which we're taking our 1 in, to what
parameter is it assigned, Virginia?

154
00:07:35.316 --> 00:07:37.405
&gt;&gt; Virginia: Input.
&gt;&gt; Will Sentance: Input, into input,

155
00:07:37.405 --> 00:07:38.391
excellent.

156
00:07:38.391 --> 00:07:39.975
There it is, input.

157
00:07:39.975 --> 00:07:45.013
Input by 2, 1 by 2, 2, return out, 2.

158
00:07:45.013 --> 00:07:48.440
Multiply by 2 input of 1,
over by 2 instructions,

159
00:07:48.440 --> 00:07:53.557
multiply by 2 of 1 evaluated to, it
becomes the output which is the number 2.

160
00:07:53.557 --> 00:07:55.134
What do we do with it, Virginia?

161
00:07:55.134 --> 00:07:56.478
&gt;&gt; Virginia: We push it on to the output.

162
00:07:56.478 --> 00:07:58.572
&gt;&gt; Will Sentance: We push it to output.

163
00:07:58.572 --> 00:08:03.392
The execution context deleted
popped off the call stack, but

164
00:08:03.392 --> 00:08:05.809
it's a for loop, so we put up.

165
00:08:05.809 --> 00:08:10.314
We pop it off the call stack,
we delete the execution context.

166
00:08:10.314 --> 00:08:12.953
And, but it's a for loop,
so we're back again.

167
00:08:12.953 --> 00:08:17.426
And this time i's value is what?

168
00:08:17.426 --> 00:08:20.977
Seth, at the back there,
i's value at this time, Seth, is what?

169
00:08:20.977 --> 00:08:23.094
&gt;&gt; Seth: 1.
&gt;&gt; Will Sentance: 1, well done Seth.

170
00:08:23.094 --> 00:08:26.639
Array position one is a number, what Seth?

171
00:08:26.639 --> 00:08:28.155
&gt;&gt; Seth: 2.
&gt;&gt; Will Sentance: 2 [LAUGH],

172
00:08:28.155 --> 00:08:31.723
instructions is really what Seth?

173
00:08:31.723 --> 00:08:32.354
&gt;&gt; Seth: Multiply by 2.

174
00:08:32.354 --> 00:08:38.118
&gt;&gt; Will Sentance: Multiply by 2 is
the input of two brand new execution

175
00:08:38.118 --> 00:08:45.346
contexts and our little local
parameter into which the 2 goes.

176
00:08:45.346 --> 00:08:46.791
No, that is horrible.

177
00:08:46.791 --> 00:08:50.528
Into which the 2 goes is,
what's the parameter name Seth?

178
00:08:50.528 --> 00:08:52.955
&gt;&gt; Seth: Input.
&gt;&gt; Will Sentance: Input, input by 2,

179
00:08:52.955 --> 00:09:00.080
2 by 2 is 4, 4 gets returned out and
stored, Virginia, into where?

180
00:09:00.080 --> 00:09:00.977
&gt;&gt; Virginia: Output.

181
00:09:00.977 --> 00:09:06.241
&gt;&gt; Will Sentance: Into output,
it's a for loop there, 2, 4, 6.

182
00:09:06.241 --> 00:09:11.337
And we then finally
Virginia return out what?

183
00:09:11.337 --> 00:09:12.230
&gt;&gt; Virginia: Return output.

184
00:09:12.230 --> 00:09:15.278
&gt;&gt; Will Sentance: Yeah, and I'm just going
to say that I prefer everyone I prefer I

185
00:09:15.278 --> 00:09:19.005
mean, I, it's beneficial for your
understanding to say, return not output

186
00:09:19.005 --> 00:09:22.580
because that gives you the sort of
false impression that it's returning.

187
00:09:22.580 --> 00:09:26.304
When I hear output I'm at least
thinking it's the label plus the value.

188
00:09:26.304 --> 00:09:28.735
It might even be in my head
the names of the label, and

189
00:09:28.735 --> 00:09:30.742
it definitely doesn't return the label.

190
00:09:30.742 --> 00:09:33.626
It doesn't even return
the label plus the value,

191
00:09:33.626 --> 00:09:37.686
it just uses the referenced output
here to evaluate that into a value.

192
00:09:37.686 --> 00:09:39.181
And that's what gets returned out.

193
00:09:39.181 --> 00:09:43.130
So I would instead help your mind
think about it the right way and

194
00:09:43.130 --> 00:09:47.018
say return the value of output
which is the array 2, 4, 6.

195
00:09:47.018 --> 00:09:48.919
Do you wanna try Virginia?

196
00:09:48.919 --> 00:09:51.473
&gt;&gt; Virginia: It would return the value
of output which is the array 2, 4, 6.

197
00:09:51.473 --> 00:09:54.747
&gt;&gt; Will Sentance: Fantastic, exactly,
yeah, yeah, very precise, very nice,

198
00:09:54.747 --> 00:09:56.006
Virginia, there it is.

199
00:09:56.006 --> 00:09:57.476
People look at this.

200
00:09:57.476 --> 00:10:00.945
Only with a slight hint
of irony from Virginia.

201
00:10:00.945 --> 00:10:04.376
Look at this people,
copyArrayAndManipulate,

202
00:10:04.376 --> 00:10:08.140
at no point did it specify
what to do with each element.

203
00:10:08.140 --> 00:10:11.104
It did not say multiply each element by 2,
but look at this.

204
00:10:11.104 --> 00:10:17.171
An array 1, 2, 3 became the array 2, 4, 6.

205
00:10:17.171 --> 00:10:21.933
[INAUDIBLE] We've created
a brand new array 2, 4, 6.

206
00:10:21.933 --> 00:10:27.085
And at no point did we specify
preset copyArrayAndManipulate

207
00:10:27.085 --> 00:10:30.461
to be multiplying each of element by2.

208
00:10:30.461 --> 00:10:32.543
Instead, we were able to,

209
00:10:32.543 --> 00:10:37.171
when we ran copyArrayAndManipulate,
we were able to edit.

210
00:10:37.171 --> 00:10:39.852
Because we had preset to
leave a little blank,

211
00:10:39.852 --> 00:10:42.620
we were able to edit
copyArrayAndManipulate.

212
00:10:42.620 --> 00:10:45.723
This starts to feel really nice.

213
00:10:45.723 --> 00:10:50.605
Already, if my goal of functional
programming is each line is a little self

214
00:10:50.605 --> 00:10:54.711
contained unit with a nice English
language label or English,

215
00:10:54.711 --> 00:10:56.271
human readable label.

216
00:10:56.271 --> 00:11:01.391
Whose only consequence is in that line if
I'm going to have to join those up again,

217
00:11:01.391 --> 00:11:03.262
hopefully I can join them up.

218
00:11:03.262 --> 00:11:05.995
This is our first example of composing.

219
00:11:05.995 --> 00:11:09.406
Just like you compose notes into a melody,

220
00:11:09.406 --> 00:11:14.712
composing individual blocks of
code together, joining them up,

221
00:11:14.712 --> 00:11:18.707
enabling us to edit
the functions we're saving.

222
00:11:18.707 --> 00:11:21.647
We're essentially saying,
copyArrayAndManipulate,

223
00:11:21.647 --> 00:11:23.450
leave bits of it TBD when you run it.

224
00:11:23.450 --> 00:11:26.822
Allow it to be reused in
multiple different scenarios.

225
00:11:26.822 --> 00:11:30.329
We're gonna pass in divide by 2.

