WEBVTT

1
00:00:00.160 --> 00:00:02.770
&gt;&gt; Will Sentance: I now want to switch
to something totally different before we

2
00:00:02.770 --> 00:00:07.300
bring this together, which is calling a
function, just as we have done 1000 times.

3
00:00:08.410 --> 00:00:13.531
Inside of another function and then asking
ourselves, if I don't find the data

4
00:00:13.531 --> 00:00:17.625
that my inner function needs inside
my inner function execution context,

5
00:00:17.625 --> 00:00:20.320
where do I get to go and look next?

6
00:00:20.320 --> 00:00:24.500
Probably we'll get that
just one step out or is it?

7
00:00:24.500 --> 00:00:30.350
Line one, let's jump straight into this,
this is not complex code.

8
00:00:30.350 --> 00:00:33.040
Line one here, Sam,
what are we doing in global memory?

9
00:00:34.100 --> 00:00:37.350
&gt;&gt; Sam: Declaring a function
&gt;&gt; Will Sentance: Declare the function,

10
00:00:37.350 --> 00:00:38.750
specifically.

11
00:00:38.750 --> 00:00:40.150
&gt;&gt; Sam: Outer.
&gt;&gt; Will Sentance: Outer and

12
00:00:40.150 --> 00:00:43.050
there it is stored into global memory.

13
00:00:44.180 --> 00:00:46.340
There it is, leaving white.

14
00:00:47.800 --> 00:00:52.170
Okay, excellent, Virginia,
next line all the way down we go to and

15
00:00:52.170 --> 00:00:55.560
run
&gt;&gt; Virginia: We're executing outer.

16
00:00:55.560 --> 00:00:56.237
&gt;&gt; Will Sentance: We're executing outer.

17
00:00:56.237 --> 00:00:57.660
Okay, there it is.

18
00:00:57.660 --> 00:00:59.048
New, brand new.

19
00:00:59.048 --> 00:01:02.496
&gt;&gt; Group: [CROSSTALK]
&gt;&gt; Will Sentance: Thank you to only one

20
00:01:02.496 --> 00:01:07.650
of our community here, let's try it again.

21
00:01:07.650 --> 00:01:10.200
A brand new
&gt;&gt; Group: Execution context.

22
00:01:10.200 --> 00:01:13.570
&gt;&gt; Will Sentance: Thanks to everybody,
but especially to Bhuvanesh.

23
00:01:13.570 --> 00:01:20.420
All right, so, there's our execution
context, let's add it to our call stack.

24
00:01:23.230 --> 00:01:23.860
There it is.

25
00:01:25.180 --> 00:01:27.100
Outer on the top of the call stack.

26
00:01:27.100 --> 00:01:29.900
I hope we leave in
the recorded version of this.

27
00:01:29.900 --> 00:01:36.200
Our wiping down of the white we
can do full for special features.

28
00:01:36.200 --> 00:01:37.780
There.
Ours is executing into it,

29
00:01:37.780 --> 00:01:39.460
we go in the local memory.

30
00:01:39.460 --> 00:01:42.139
Bhuvanesh, the first thing
in the local memory is.

31
00:01:43.140 --> 00:01:46.320
&gt;&gt; Bhuvanesh: Counter
&gt;&gt; Will Sentance: Counter set two.

32
00:01:46.320 --> 00:01:46.845
&gt;&gt; Bhuvanesh: Zero.
&gt;&gt; Will Sentance: Zero, excellent.

33
00:01:46.845 --> 00:01:48.455
Then we declare a function Michael,

34
00:01:48.455 --> 00:01:49.290
what is it?

35
00:01:49.290 --> 00:01:52.850
&gt;&gt; Michael: Increment counter
&gt;&gt; Will Sentance: Increment counter.

36
00:01:52.850 --> 00:01:53.500
There it is.

37
00:01:54.620 --> 00:01:59.525
And now we're going to use increment
counter and execute it with

38
00:01:59.525 --> 00:02:04.260
parentheses on the end of it to
say go run it inside of outer.

39
00:02:05.560 --> 00:02:07.163
Let's add it to the top
of call stack increment,

40
00:02:10.092 --> 00:02:11.296
&gt;&gt; Will Sentance: Counter, brand new.

41
00:02:12.626 --> 00:02:16.500
&gt;&gt; Will Sentance: [LAUGH] Bhuvanesh,
you're a hero.

42
00:02:16.500 --> 00:02:19.910
What is wrong with the rest of you?

43
00:02:19.910 --> 00:02:20.970
Everyone together.

44
00:02:20.970 --> 00:02:22.520
Others go ahead with their
hand now at this point.

45
00:02:22.520 --> 00:02:24.520
Thank you David as well,
I told David excellent.

46
00:02:24.520 --> 00:02:26.830
Alice just has her head in
her hand at this point.

47
00:02:26.830 --> 00:02:30.700
Everyone together, a brand new-
&gt;&gt; Group: Execution context.

48
00:02:30.700 --> 00:02:34.070
&gt;&gt; Will Sentance: The joke that never
gets old, there we go into it we go and

49
00:02:34.070 --> 00:02:37.060
nothing in local memory time,
well I guess I'll put it there.

50
00:02:37.060 --> 00:02:38.480
Nothing in local memory.

51
00:02:39.570 --> 00:02:43.040
The first line I hit,
Michael, says to be what?

52
00:02:43.040 --> 00:02:43.890
&gt;&gt; Michael: Add one to the counter.

53
00:02:43.890 --> 00:02:45.260
&gt;&gt; Will Sentance: Yeah,
I like that, counter ++.

54
00:02:45.260 --> 00:02:49.700
I'm using this green for my looking up.

55
00:02:51.300 --> 00:02:54.615
Jasmine, increment counters
top of my cool stack.

56
00:02:54.615 --> 00:02:56.900
I'm running inside it right now.

57
00:02:56.900 --> 00:02:58.200
I don't find, well where do I start?

58
00:02:58.200 --> 00:02:59.980
Where do I look for counter first?

59
00:02:59.980 --> 00:03:01.350
&gt;&gt; Jasmine: In your
local execution context.

60
00:03:01.350 --> 00:03:03.260
&gt;&gt; Will Sentance: In my local execution
context, excellent, into it let go.

61
00:03:04.670 --> 00:03:07.840
Do I find, Jasmine,
counter in the local memory?

62
00:03:07.840 --> 00:03:08.380
&gt;&gt; Jasmine: No.

63
00:03:08.380 --> 00:03:08.880
&gt;&gt; Will Sentance: No, I don't.

64
00:03:09.950 --> 00:03:11.390
Where do I go next?

65
00:03:11.390 --> 00:03:13.930
&gt;&gt; Jasmine: To the next outer-
&gt;&gt; Will Sentance: Exactly, I go out.

66
00:03:16.912 --> 00:03:18.040
&gt;&gt; Will Sentance: And find counter is?

67
00:03:18.040 --> 00:03:18.900
&gt;&gt; Jasmine: Zero.

68
00:03:18.900 --> 00:03:21.230
&gt;&gt; Will Sentance: And I do what to it?

69
00:03:21.230 --> 00:03:22.040
&gt;&gt; Jasmine: Replace it with one.

70
00:03:22.040 --> 00:03:23.320
&gt;&gt; Will Sentance: Yeah, exactly.

71
00:03:23.320 --> 00:03:27.650
I heard that replace it with one by the
way, that's nice, exactly, yeah, exactly.

72
00:03:27.650 --> 00:03:31.434
In other words, it looks to me like
I go down my call stack to outer.

73
00:03:34.519 --> 00:03:35.910
&gt;&gt; Will Sentance: And
that's what everybody thinks.

74
00:03:37.640 --> 00:03:42.510
And yet right now,
I couldn't tell you whether it's because

75
00:03:42.510 --> 00:03:47.410
I'm calling increment counter
inside the calling of outer,

76
00:03:47.410 --> 00:03:50.360
whether it's cuz I'm
calling increment counter

77
00:03:50.360 --> 00:03:53.200
inside my running of outer only got
inside about because I'm running outer.

78
00:03:53.200 --> 00:03:55.541
So that's why I'm inside of it,
inside of which I call increment counter.

79
00:03:56.990 --> 00:03:58.540
I can't tell you whether
it's a fact that I'm

80
00:03:58.540 --> 00:04:00.080
calling it inside an increment counter.

81
00:04:00.080 --> 00:04:05.190
And you may not even have made this step,
but where many of you I'm sure have or

82
00:04:05.190 --> 00:04:11.070
whether it's the fact that I saved
increment counter inside of outer.

83
00:04:12.100 --> 00:04:13.680
Because right now it could be either.

84
00:04:14.700 --> 00:04:17.830
Is that I saved increment
counter inside of outer or

85
00:04:17.830 --> 00:04:20.640
that I invoked increment
counter inside of outer.

86
00:04:20.640 --> 00:04:24.970
That means when I don't find counter
inside the local execution context memory,

87
00:04:24.970 --> 00:04:28.090
I can take a step into outer
execution context memory.

88
00:04:29.680 --> 00:04:31.140
Because it's not automatic.

89
00:04:31.140 --> 00:04:35.820
We might look at that and go, of course it
can step out of the box inside a bigger

90
00:04:35.820 --> 00:04:38.420
box but that's not built into a language.

91
00:04:38.420 --> 00:04:42.530
That is not an automatic feature, that is
a decision by language to say if I don't

92
00:04:42.530 --> 00:04:46.800
find data in my immediate local memory,
I can go look in another local memory for

93
00:04:46.800 --> 00:04:48.220
it that's not automatic.

94
00:04:49.480 --> 00:04:52.012
And right now I couldn't tell you whether
it's about I saved increment counter

95
00:04:52.012 --> 00:04:52.550
there or ran it.

96
00:04:54.668 --> 00:04:57.740
&gt;&gt; Will Sentance: There is a way
I could figure it out, though.

97
00:04:57.740 --> 00:05:06.390
If I could run increment counter out
here in global, I could then assess,

98
00:05:06.390 --> 00:05:12.160
do I have access to the data from where
function was born saved originally in

99
00:05:12.160 --> 00:05:17.150
other words it's where I save my function
that determines what data I've access to.

100
00:05:17.150 --> 00:05:21.260
Or do I only have access if I'm running
increment counter out in global.

101
00:05:21.260 --> 00:05:24.192
I guess only have access to
increment counter's memory and

102
00:05:24.192 --> 00:05:26.720
global in which I'm running it.

103
00:05:26.720 --> 00:05:29.800
But then how do I get increment
counter out of outer?

104
00:05:29.800 --> 00:05:34.520
I'm allowed to do that, Jasmine?

105
00:05:34.520 --> 00:05:36.440
No, I’m gonna get some sort of error.

106
00:05:39.000 --> 00:05:43.420
Eric, how can I get increment count
out here so that I can run it?

107
00:05:43.420 --> 00:05:46.550
&gt;&gt; Eric: You can return it from
the function and assign it a new variable.

108
00:05:46.550 --> 00:05:47.780
&gt;&gt; Will Sentance: Exactly,

109
00:05:47.780 --> 00:05:51.670
return it from the function call,
assign it to a new global label.

110
00:05:51.670 --> 00:05:53.390
Let’s do exactly that.

111
00:05:53.390 --> 00:05:55.960
What happens here In an error can't

112
00:05:55.960 --> 00:05:58.410
run the function outside
of where it's defined.

113
00:05:58.410 --> 00:06:01.630
There is a way to run a function outside
where it's defined without an error.

114
00:06:01.630 --> 00:06:05.670
We return the inner function of assigned
to a new global label and use it out here.

115
00:06:05.670 --> 00:06:08.710
And now we can pull the funds that was
originally saved as increment counter by

116
00:06:08.710 --> 00:06:10.700
its new global label, new function.

117
00:06:11.960 --> 00:06:12.830
Let's go.

118
00:06:12.830 --> 00:06:14.670
Let's see what happens people.

119
00:06:14.670 --> 00:06:18.120
So, I heard some really interesting things
that people were talking through there.

120
00:06:18.120 --> 00:06:19.750
We're gonna save that outer function,

121
00:06:19.750 --> 00:06:23.140
we're gonna call it,
we're going to return out that little baby

122
00:06:23.140 --> 00:06:26.580
increment counter function from inside
out into a new global label new function.

123
00:06:26.580 --> 00:06:29.040
And we're gonna call it by
its new global label and

124
00:06:29.040 --> 00:06:32.274
some really interesting
stuff is gonna happen.

125
00:06:32.274 --> 00:06:36.610
Stuff that's gonna give out function
superpowers, in a special way.

126
00:06:36.610 --> 00:06:40.000
So here we go, line one,
Andrew you are up.

127
00:06:40.000 --> 00:06:41.510
What are we doing in line one?

128
00:06:41.510 --> 00:06:42.940
&gt;&gt; Andrew: Declaring a function.

129
00:06:42.940 --> 00:06:45.800
&gt;&gt; Will Sentance: Declaring a function
folk technical communication means total

130
00:06:45.800 --> 00:06:47.160
precision and completeness.

131
00:06:47.160 --> 00:06:49.170
Andrew take it away, declaring?

132
00:06:49.170 --> 00:06:50.510
&gt;&gt; Andrew: A function to outer.

133
00:06:50.510 --> 00:06:53.110
&gt;&gt; Will Sentance: Exactly to
carry a function named outer.

134
00:06:53.110 --> 00:06:53.950
There it is.

135
00:06:53.950 --> 00:06:57.220
Thank you to Andrew for
his patience with me.

136
00:06:57.220 --> 00:06:58.290
Sam next line.

137
00:06:58.290 --> 00:07:00.250
Left hand side first.

138
00:07:00.250 --> 00:07:02.680
&gt;&gt; Sam: Declaring a new label.

139
00:07:03.940 --> 00:07:04.980
&gt;&gt; Will Sentance: Yes, well done.

140
00:07:04.980 --> 00:07:06.760
New label, new function exactly.

141
00:07:06.760 --> 00:07:10.060
We do not know yet what to store in
it because we've got to go ahead and

142
00:07:10.060 --> 00:07:11.140
run what Sam?

143
00:07:12.420 --> 00:07:15.029
&gt;&gt; Sam: We need to run outer as a new.

144
00:07:15.029 --> 00:07:17.635
&gt;&gt; Will Sentance: Perfect,
we need to run outer folk,

145
00:07:17.635 --> 00:07:20.420
let's have our call stack going here.

146
00:07:20.420 --> 00:07:23.223
There it is, global on the bottom,
we add outer.

147
00:07:23.223 --> 00:07:27.889
Next,
&gt;&gt; Will Sentance: Bhuvanesh,

148
00:07:27.889 --> 00:07:30.080
we're executing outer, we create a new?

149
00:07:30.080 --> 00:07:31.056
&gt;&gt; Bhuvanesh: Execution complex.

150
00:07:31.056 --> 00:07:34.790
&gt;&gt; Will Sentance: Execution complex,
thank you Bhuvanesh we appreciate it.

151
00:07:34.790 --> 00:07:40.500
That's a very on point, into it we go.

152
00:07:42.120 --> 00:07:45.600
And,
&gt;&gt; Will Sentance: We immediately,

153
00:07:45.600 --> 00:07:47.560
no inputs, no arguments.

154
00:07:47.560 --> 00:07:52.660
So instead, in local memory,
Jasmine, we immediately assign what?

155
00:07:52.660 --> 00:07:54.230
&gt;&gt; Jasmine: Counter to zero.

156
00:07:54.230 --> 00:07:56.090
&gt;&gt; Will Sentance: Counter to zero,
excellent.

157
00:07:56.090 --> 00:07:58.090
Michael, next line.

158
00:07:58.090 --> 00:08:00.497
I do this thing where I give
the same person the same question,

159
00:08:00.497 --> 00:08:02.320
every single time without
thinking about it.

160
00:08:02.320 --> 00:08:03.750
Michael, next line.

161
00:08:03.750 --> 00:08:06.230
&gt;&gt; Michael: We create a function
called the increment counter.

162
00:08:06.230 --> 00:08:09.450
&gt;&gt; Will Sentance: Increment counter,
Jasmine, did I ask you for 0 last time?

163
00:08:09.450 --> 00:08:13.204
Yeah, I did, and I asked you for
increment counter, that's so interesting,

164
00:08:13.204 --> 00:08:16.880
what is going on in my mind
subconsciously that does that?

165
00:08:16.880 --> 00:08:21.553
That process probably whatever that means,
all right?

166
00:08:21.553 --> 00:08:27.470
Increment counter is saved,
we're not gonna use it inside though,

167
00:08:27.470 --> 00:08:34.305
instead, we are going to take its code,
or if you remember from our heap piece,

168
00:08:34.305 --> 00:08:39.437
we take the label to it's under
the hood stored function.

169
00:08:39.437 --> 00:08:43.324
Wait, sorry, address if it's under
the hood, stored function and title, but

170
00:08:43.324 --> 00:08:46.603
we'll just for our purposes,
take the code of increment counter.

171
00:08:46.603 --> 00:08:47.921
We're gonna see what?

172
00:08:47.921 --> 00:08:48.926
Well, what are we gonna do, Jasmine?

173
00:08:48.926 --> 00:08:52.003
We're not gonna return, we're not gonna
run increment counter, we're going to?

174
00:08:52.003 --> 00:08:52.670
&gt;&gt; Jasmine: Return it.

175
00:08:52.670 --> 00:08:54.767
&gt;&gt; Will Sentance: Return
increment counter, so

176
00:08:54.767 --> 00:08:57.191
it's gonna say return increment.

177
00:08:59.488 --> 00:09:02.995
&gt;&gt; Will Sentance: Counter,
we use that to look up increment counter,

178
00:09:02.995 --> 00:09:06.295
it's the code of increment
counter without a label.

179
00:09:06.295 --> 00:09:09.600
And we take it, Jasmine,
and we return it out into?

180
00:09:09.600 --> 00:09:10.140
&gt;&gt; Jasmine: newFunction.

181
00:09:10.140 --> 00:09:12.460
&gt;&gt; Will Sentance: Into newFunction,
she's spot on.

182
00:09:12.460 --> 00:09:16.670
And it used to be called increment
counter, it's not called that anymore.

183
00:09:16.670 --> 00:09:19.550
I'm just putting it here, so
we know it used to be called that.

184
00:09:19.550 --> 00:09:21.189
And there it is.

185
00:09:21.189 --> 00:09:24.599
And its only code is counter plus plus.

186
00:09:24.599 --> 00:09:27.788
And our execution context here,
everybody, is what?

187
00:09:27.788 --> 00:09:28.374
&gt;&gt; Group: Gone.

188
00:09:28.374 --> 00:09:30.534
&gt;&gt; Will Sentance: Pop it off
the call stack, exactly, removed.

189
00:09:30.534 --> 00:09:34.047
We pop it off,
&gt;&gt; Will Sentance: We pop it off

190
00:09:34.047 --> 00:09:34.937
the call stack.

191
00:09:36.912 --> 00:09:39.500
&gt;&gt; Will Sentance: There it is, gone.

192
00:09:41.110 --> 00:09:45.000
And we're out to global, where newFunction
is now our new global label for

193
00:09:45.000 --> 00:09:48.750
the function that was born inside
of outer as increment counter.

194
00:09:48.750 --> 00:09:54.395
Let's run it people, and
let's see what happens,

195
00:09:54.395 --> 00:09:57.732
newFunction is called brand,

196
00:09:57.732 --> 00:10:03.109
everyone together, brand new, [CROSSTALK].

197
00:10:03.109 --> 00:10:07.974
Thank you, that energized me after
my silly lack of enthusiasm,

198
00:10:07.974 --> 00:10:10.900
there it is, it goes on the call stack.

199
00:10:12.470 --> 00:10:14.880
The newFunction is added
on the call stack.

200
00:10:14.880 --> 00:10:19.168
We go into it,
nothing in local memory assigned,

201
00:10:19.168 --> 00:10:23.465
instead we hit immediately what line,
Jasmine?

202
00:10:23.465 --> 00:10:24.479
&gt;&gt; Jasmine: The counter plus plus.

203
00:10:24.479 --> 00:10:25.661
&gt;&gt; Will Sentance: Counter
plus plus because

204
00:10:25.661 --> 00:10:29.157
the newFunction is the functionality
formerly known as increment counter.

205
00:10:29.157 --> 00:10:33.246
Where, Jasmine, do I look for
the counter first?

206
00:10:33.246 --> 00:10:35.444
&gt;&gt; Jasmine: [INAUDIBLE]
&gt;&gt; Will Sentance: Yes, excellent,

207
00:10:35.444 --> 00:10:38.705
thank you, in the local execution context.

208
00:10:38.705 --> 00:10:41.464
Again, same question, to you again.

209
00:10:41.464 --> 00:10:42.457
Anything there?

210
00:10:42.457 --> 00:10:43.845
&gt;&gt; Jasmine: No.
&gt;&gt; Will Sentance: No, now,

211
00:10:43.845 --> 00:10:48.880
where would everything,
every intuition we've thought

212
00:10:48.880 --> 00:10:54.838
over the years suggest, given we
first check top of our call stack and

213
00:10:54.838 --> 00:10:59.373
newFunction, where we would look next,
Jasmine?

214
00:10:59.373 --> 00:11:02.878
In every sort of intuition we have about,
I run my function here,

215
00:11:02.878 --> 00:11:05.811
I have access to stuff outside
of where it's running,

216
00:11:05.811 --> 00:11:08.577
where would I say I can go and
look for counter next?

217
00:11:08.577 --> 00:11:11.150
&gt;&gt; Jasmine: Maybe we
think to look in outer.

218
00:11:11.150 --> 00:11:14.322
&gt;&gt; Will Sentance: We might think looking
outer, but outer's off the execute,

219
00:11:14.322 --> 00:11:16.890
that execution context is shutdown.

220
00:11:16.890 --> 00:11:20.609
It's off our call stack, therefore,
we can't take our thread back in there,

221
00:11:20.609 --> 00:11:21.340
that's done.

222
00:11:21.340 --> 00:11:28.065
Our thread of execution went in,
came back out, and it's gone.

223
00:11:28.065 --> 00:11:29.780
We're now inside of newFunction.

224
00:11:30.820 --> 00:11:34.803
So we're running newFunction in global, so
Jasmine, where might we look for counter?

225
00:11:34.803 --> 00:11:35.340
&gt;&gt; Jasmine: Global.

226
00:11:35.340 --> 00:11:39.376
&gt;&gt; Will Sentance: In global,
in theory, sounds right to me.

227
00:11:42.741 --> 00:11:45.956
&gt;&gt; Will Sentance: [LAUGH]
This line is not very good.

228
00:11:45.956 --> 00:11:47.223
Is counter in global, Jasmine?

229
00:11:47.223 --> 00:11:47.836
&gt;&gt; Jasmine: No.

230
00:11:47.836 --> 00:11:49.385
&gt;&gt; Will Sentance: It's definitely not.

231
00:11:52.723 --> 00:11:53.822
&gt;&gt; Will Sentance: This never gets old.

232
00:11:53.822 --> 00:11:59.521
[LAUGH] No, very sad.

233
00:12:02.057 --> 00:12:04.000
&gt;&gt; Will Sentance: Very sad.

234
00:12:04.000 --> 00:12:06.954
What was it by the way, what a problematic
language design that lets this happen?

235
00:12:06.954 --> 00:12:08.850
Like this feels like a bad
language design, honestly.

236
00:12:10.500 --> 00:12:12.600
Given this is not the core
focus of this tool,

237
00:12:12.600 --> 00:12:17.390
we wanna use this for a very powerful
feature, I'm not gonna dwell on this,

238
00:12:17.390 --> 00:12:21.980
but I'm not gonna sort of
let us suffer for too long.

239
00:12:21.980 --> 00:12:27.375
Instead, I'm gonna tell you about
a powerful thing that happens

240
00:12:27.375 --> 00:12:34.055
when I return a function
out of the running

241
00:12:34.055 --> 00:12:39.380
of another function, give it a global
label and run it by its new global label.

242
00:12:40.660 --> 00:12:42.410
Something very special happens.

243
00:12:44.270 --> 00:12:49.332
I do not just get the code
of the increment counter

244
00:12:49.332 --> 00:12:53.791
function returned out into newFunction.

245
00:12:53.791 --> 00:12:58.500
I bring with my function
code something else.

246
00:12:58.500 --> 00:13:05.407
On the back of this function, comes,
&gt;&gt; Will Sentance: On

247
00:13:05.407 --> 00:13:10.364
the back of this function, comes,
&gt;&gt; Will Sentance: Its

248
00:13:10.364 --> 00:13:15.620
entire surrounding local memory.

249
00:13:15.620 --> 00:13:21.720
As the function gets returned out,
gets returned out into newFunction,

250
00:13:21.720 --> 00:13:26.780
it brings with it, attached on to it,
on the back of the function.

251
00:13:26.780 --> 00:13:31.772
And here it is on the back of
the function in a little backpack as

252
00:13:31.772 --> 00:13:34.268
the function gets pulled out,

253
00:13:34.268 --> 00:13:40.125
it pulls with it on his back the
surrounding data, from when it was born.

254
00:13:40.125 --> 00:13:46.432
And look at that, there is counter 0
attached too, and we'll talk about how,

255
00:13:46.432 --> 00:13:52.661
and we'll talk about whether there's
any more official name than backpack.

256
00:13:52.661 --> 00:13:56.639
[LAUGH] I will tell you this
I read a blog post about it,

257
00:13:56.639 --> 00:14:01.690
it has 50,000 likes,
meaning this term is ever more popular.

258
00:14:01.690 --> 00:14:05.687
May enter the spec of JavaScript,
never but maybe.

259
00:14:05.687 --> 00:14:10.912
There it is attached on the function
meaning, Jasmine, take a shot

260
00:14:10.912 --> 00:14:17.342
after not finding counter in newFunction's
immediate local execution context.

261
00:14:17.342 --> 00:14:19.900
You rightly said the local memory there.

262
00:14:19.900 --> 00:14:24.270
Before I look to global,
might there be somewhere else?

263
00:14:24.270 --> 00:14:27.210
And you can use the word,
you can say the word, it begins with b,

264
00:14:27.210 --> 00:14:30.370
and it ends in ackpack.

265
00:14:30.370 --> 00:14:34.898
Jasmine, is there somewhere else you think
that JavaScript is gonna take its look up

266
00:14:34.898 --> 00:14:37.664
journey to before it searches global for
counter?

267
00:14:37.664 --> 00:14:39.417
&gt;&gt; Jasmine: You might look
in newFunction's backpack.

268
00:14:39.417 --> 00:14:41.561
&gt;&gt; Will Sentance: You will look
in newFunction's backpack.

269
00:14:41.561 --> 00:14:45.290
Thank you so much,
Jasmine, she is spot on.

270
00:14:45.290 --> 00:14:50.173
Off we go into newFunction's

271
00:14:50.173 --> 00:14:54.087
backpack, here it is.

272
00:14:54.087 --> 00:14:56.068
And what do we find there, Jasmine?

273
00:14:56.068 --> 00:14:58.160
We find counter is?

274
00:14:59.230 --> 00:15:01.507
&gt;&gt; Jasmine: 0.
&gt;&gt; Will Sentance: Counter is 0,

275
00:15:01.507 --> 00:15:03.542
she's spot on.

276
00:15:03.542 --> 00:15:04.885
What do we do to it?

277
00:15:04.885 --> 00:15:06.547
We increment, Jasmine, to?

278
00:15:06.547 --> 00:15:07.387
&gt;&gt; Jasmine: 1.

279
00:15:09.316 --> 00:15:14.555
&gt;&gt; Will Sentance: To 1,
this execution context, gone.

280
00:15:14.555 --> 00:15:16.154
I'm not gonna erase it,

281
00:15:16.154 --> 00:15:20.965
we're gonna add it back home because
we're gonna run newFunction again.

282
00:15:20.965 --> 00:15:24.712
We're gonna talk about this backpack in
a moment, people, it's super powerful.

283
00:15:27.473 --> 00:15:30.974
&gt;&gt; Will Sentance: Everything in the local
memory, there's nothing here, but

284
00:15:30.974 --> 00:15:34.287
everything as always is deleted,
it's only temporary.

285
00:15:34.287 --> 00:15:39.730
Run newFunction again, brand new,
Anna, brand new, what?

286
00:15:39.730 --> 00:15:42.806
&gt;&gt; Group: [CROSSTALK]
&gt;&gt; Will Sentance: Excellent, everybody,

287
00:15:42.806 --> 00:15:44.738
but Anna as well, excellent, Anna.

288
00:15:44.738 --> 00:15:48.168
Into it we go, when they turn
up the audio for your mics and

289
00:15:48.168 --> 00:15:51.321
it's just Bhuvanesh saying,
execution context.

290
00:15:51.321 --> 00:15:56.355
[LAUGH] What we find
in As next code to new

291
00:15:56.355 --> 00:16:01.323
function counter, plus plus.

292
00:16:04.282 --> 00:16:07.439
&gt;&gt; Will Sentance: Eric,
where do I look for counter first?

293
00:16:07.439 --> 00:16:08.705
By the way, just to be clear,

294
00:16:08.705 --> 00:16:11.256
there's a new function execution
calls on the call stack.

295
00:16:11.256 --> 00:16:13.900
I erased it and put it back on again.

296
00:16:13.900 --> 00:16:15.927
And where do I look first, Eric?

297
00:16:15.927 --> 00:16:17.999
&gt;&gt; Eric: Sure going to look in
the local execution context.

298
00:16:17.999 --> 00:16:20.272
&gt;&gt; Will Sentance: Fantastic,
do I find counter?

299
00:16:20.272 --> 00:16:21.068
&gt;&gt; Eric: No counter there?

300
00:16:21.068 --> 00:16:23.015
&gt;&gt; Will Sentance: Where do I look next?

301
00:16:23.015 --> 00:16:24.598
Don't use any fancy terms.

302
00:16:24.598 --> 00:16:25.709
&gt;&gt; Eric: We're gonna go to the backpack.

303
00:16:25.709 --> 00:16:29.402
&gt;&gt; Will Sentance: We're gonna go to
the backpack where we find counter is.

304
00:16:29.402 --> 00:16:30.972
&gt;&gt; Eric: One.

305
00:16:30.972 --> 00:16:33.770
&gt;&gt; Will Sentance: Ha, wow.

306
00:16:33.770 --> 00:16:37.765
We find counter is 1,
we increment it to 2.

307
00:16:39.037 --> 00:16:42.727
&gt;&gt; Will Sentance: Immediately people,
you might be able to see,

308
00:16:42.727 --> 00:16:46.360
this has supercharged our functions.

309
00:16:46.360 --> 00:16:48.470
Functions are just two things.

310
00:16:48.470 --> 00:16:49.840
Well, that's for

311
00:16:49.840 --> 00:16:54.670
now say, two blocks of code which when
run, they get to walk through the code,

312
00:16:54.670 --> 00:16:58.861
the thread, and a temporary memory bundled
up just for the function at that time.

313
00:17:00.450 --> 00:17:06.600
This enables our functions to have
two types of place to store data.

314
00:17:06.600 --> 00:17:10.932
One temporary for their single execution,
their single running.

315
00:17:10.932 --> 00:17:12.253
And one permanent,

316
00:17:12.253 --> 00:17:17.004
persistent, that's there as long as
the code of the function is saved.

317
00:17:17.004 --> 00:17:19.400
Our function's not just code anymore.

318
00:17:19.400 --> 00:17:23.030
It saved code under the label new function
that was originally increment counters

319
00:17:23.030 --> 00:17:26.830
code, plus persistent data attached to it.

320
00:17:27.920 --> 00:17:32.270
That we get access to by making
reference in new function

321
00:17:32.270 --> 00:17:35.660
borders increment counter to
something that's not in local memory.

322
00:17:37.000 --> 00:17:39.020
So we jump out and look in the backpack.

323
00:17:39.020 --> 00:17:43.600
And as long as when we birthed,
when we created the now known as new

324
00:17:43.600 --> 00:17:47.450
function function
originating from encounter.

325
00:17:47.450 --> 00:17:50.780
We had around it in local
memory save counter is zero.

326
00:17:50.780 --> 00:17:56.840
That gets pulled out on the back
of the function into new function.

327
00:17:56.840 --> 00:17:58.030
And there, it is attached.

328
00:17:58.030 --> 00:18:00.661
There, it is attached, people.

329
00:18:00.661 --> 00:18:06.821
Folk, I'm going to,
[SOUND] I will stress this one more time,

330
00:18:06.821 --> 00:18:10.731
new functions definition, its code,

331
00:18:10.731 --> 00:18:15.127
its saved code now has
a hidden link hidden.

332
00:18:15.127 --> 00:18:19.354
Well, that's why I gotta start to tell
you a few more important things about

333
00:18:19.354 --> 00:18:21.283
this before we move on to.

334
00:18:21.283 --> 00:18:23.330
How is this hidden?

335
00:18:23.330 --> 00:18:27.133
How is this permanent data
here attached to the function?

336
00:18:27.133 --> 00:18:30.882
Well, firstly,
we can't get to it directly.

337
00:18:30.882 --> 00:18:33.806
I can't go new function in global,

338
00:18:33.806 --> 00:18:39.260
newFunction.backpack.counter, this
is not possible.

339
00:18:39.260 --> 00:18:42.999
I can't even go
newFunction.officialNameForIt.counter.

340
00:18:42.999 --> 00:18:45.574
There's no way of getting into it.

341
00:18:45.574 --> 00:18:51.015
It is absolutely, they call it,
private to that increment counter,

342
00:18:51.015 --> 00:18:54.259
now known as new function function call.

343
00:18:54.259 --> 00:18:57.440
We can only get into it
by running new function.

344
00:18:57.440 --> 00:18:59.970
Not finding something we
reference in the local memory and

345
00:18:59.970 --> 00:19:02.040
jumping out to the backpack.

346
00:19:02.040 --> 00:19:07.426
The backpack kind of inserts itself before
we go it down to looking in global.

347
00:19:07.426 --> 00:19:10.660
Don't get me wrong,
the backpack in global in the sense that

348
00:19:10.660 --> 00:19:12.730
it's attached to a function
that is saved in global.

349
00:19:14.060 --> 00:19:16.850
But global reading means
I can access the name for

350
00:19:16.850 --> 00:19:19.380
that data when I'm in
global execution context.

351
00:19:19.380 --> 00:19:23.435
I can't access this data,
it's hidden, it's protected.

352
00:19:23.435 --> 00:19:24.649
Well, how is it protected?

353
00:19:24.649 --> 00:19:28.067
Well, as soon as a function increment
counter was saved inside the running of

354
00:19:28.067 --> 00:19:31.641
outer, when outer was on our call stack
earlier, when outer was on a call stack,

355
00:19:31.641 --> 00:19:35.400
I got over it inside its execution
context, the thread was running through.

356
00:19:35.400 --> 00:19:37.897
As soon as increment count was saved,

357
00:19:37.897 --> 00:19:41.415
it immediately got a link
to the surrounding memory.

358
00:19:41.415 --> 00:19:44.273
Immediately because the whole
surrounding memory,

359
00:19:44.273 --> 00:19:48.082
that link was stored on a property
square brackets, square brackets,

360
00:19:48.082 --> 00:19:52.350
two square brackets, scope, square
brackets linked to this running memory.

361
00:19:53.480 --> 00:19:55.670
Old copy, just a link to where
it was literally stored.

362
00:19:57.300 --> 00:20:01.800
When I returned the function out,
I pulled out, on that link,

363
00:20:01.800 --> 00:20:04.910
all the data with me
attached to the function.

364
00:20:04.910 --> 00:20:08.650
So we got that scope, property.

365
00:20:08.650 --> 00:20:09.270
There it is.

366
00:20:10.400 --> 00:20:14.668
Half the lead,
half of the lead is returned.

367
00:20:14.668 --> 00:20:16.360
John, amazing.

368
00:20:16.360 --> 00:20:17.931
There it is.
I was about to start shaking

369
00:20:17.931 --> 00:20:18.730
again, I thought.

370
00:20:18.730 --> 00:20:22.064
Okay, meaning,
I'd say whenever new function runs and

371
00:20:22.064 --> 00:20:27.066
it doesn't find counters local memory,
it goes through its definition, looks into

372
00:20:27.066 --> 00:20:32.084
its hidden scope property, in other words,
into the backpack, and finds counter.

373
00:20:32.084 --> 00:20:36.164
Because counter was there when it was
born and when it got returned out,

374
00:20:36.164 --> 00:20:39.097
the code of increment
counter from running outer.

375
00:20:39.097 --> 00:20:44.297
We ran outer, we returned increment
counter from creating it inside outer and

376
00:20:44.297 --> 00:20:46.832
we returned it out into new function.

377
00:20:46.832 --> 00:20:51.038
When we run new function and it doesn't
find counter in the local memory and

378
00:20:51.038 --> 00:20:54.590
looks to new functions backpack
stored on the scope property.

379
00:20:56.440 --> 00:20:57.565
I wanna do films so

380
00:20:57.565 --> 00:21:02.068
I want to probably tell you a few more
pieces about this backpack first.

381
00:21:02.068 --> 00:21:05.360
Firstly, it's really optimized.

382
00:21:06.540 --> 00:21:11.820
JavaScript makes the link on the saving
of increment counter inside of outer,

383
00:21:11.820 --> 00:21:13.850
to the surrounding local memory,
everything in there.

384
00:21:13.850 --> 00:21:15.776
The link to the whole collection,
everything.

385
00:21:15.776 --> 00:21:17.360
There's a link to where
this is all sort in memory.

386
00:21:18.990 --> 00:21:23.460
But on returning out that function,
normally when you finish

387
00:21:23.460 --> 00:21:27.550
running a function,
what's the only thing we hold on to, Sam?

388
00:21:27.550 --> 00:21:28.740
When I finish running a function,

389
00:21:28.740 --> 00:21:32.420
return out free, all the other stuff in
the local memory, do we hold on to it?

390
00:21:32.420 --> 00:21:34.700
No, we automatically garbage collect it.

391
00:21:34.700 --> 00:21:35.620
Why is it called garbage?

392
00:21:36.720 --> 00:21:39.560
It's called garbage because we
can't access any of that data by

393
00:21:39.560 --> 00:21:40.280
his name anymore.

394
00:21:40.280 --> 00:21:42.528
So there's no point it being there.

395
00:21:42.528 --> 00:21:46.667
We automatically collect it, it means it
automatically gets deleted by JavaScript.

396
00:21:46.667 --> 00:21:48.423
&gt;&gt; Speaker 10: It's a weak reference.

397
00:21:48.423 --> 00:21:54.937
&gt;&gt; Will Sentance: Sure,
this is, absolutely.

398
00:21:54.937 --> 00:22:00.528
Instead here, we rely on,
when we return out this function,

399
00:22:00.528 --> 00:22:05.153
JavaScript is gonna hold
on to all that surrounding

400
00:22:05.153 --> 00:22:09.460
data in the backpack of the function.

401
00:22:09.460 --> 00:22:16.858
But hold on, what if I save maybe ten
different things in this local memory?

402
00:22:16.858 --> 00:22:20.058
I return our increment counter into
new function, run new function.

403
00:22:20.058 --> 00:22:24.720
I've got ten things in this
local memory besides counter.

404
00:22:24.720 --> 00:22:28.270
What's the only thing, Alex,
inside of new function for

405
00:22:28.270 --> 00:22:32.337
me, was increment counter,
was the only thing I refer to, Alex?

406
00:22:32.337 --> 00:22:33.470
&gt;&gt; Alex: Counter.
&gt;&gt; Will Sentance: Counter.

407
00:22:33.470 --> 00:22:35.967
So if I got ten other
things in this backpack,

408
00:22:35.967 --> 00:22:37.757
can I get access to any of those?

409
00:22:37.757 --> 00:22:40.314
No, I can't access anything that's bad.

410
00:22:40.314 --> 00:22:43.790
I can't go like new
function.scope.counter, I would want to.

411
00:22:43.790 --> 00:22:47.215
I want this to be preserved and
protected for the running of the function.

412
00:22:47.215 --> 00:22:55.207
Meaning, JavaScript knows on the returning
of increment counter out of new function,

413
00:22:55.207 --> 00:23:02.130
it already knows what that function
could ever end up needing or accessing.

414
00:23:02.130 --> 00:23:07.791
And so it optimizes what gets pulled out
in the backpack once we exit outer and

415
00:23:07.791 --> 00:23:11.159
delete everything else
in the local memory.

416
00:23:11.159 --> 00:23:13.340
If it's not referred to delete it.

