WEBVTT

1
00:00:00.000 --> 00:00:03.932
Any questions about statements and
expressions and how you can use them for

2
00:00:03.932 --> 00:00:06.941
automatic return in functions or
if branches like this?

3
00:00:06.941 --> 00:00:10.800
&gt;&gt; The last expression would be
the return then it sounds like.

4
00:00:10.800 --> 00:00:11.864
&gt;&gt; Right, yeah.
So if I wanted,

5
00:00:11.864 --> 00:00:13.840
I could put other stuff
in this block above this.

6
00:00:13.840 --> 00:00:16.922
And that would be the same thing as it
would be the function where like the,

7
00:00:16.922 --> 00:00:19.958
the last expression in there would be
automatically become the result of

8
00:00:19.958 --> 00:00:21.280
the whole branch.

9
00:00:21.280 --> 00:00:25.038
&gt;&gt; If a function contains
more than one expression,

10
00:00:25.038 --> 00:00:27.716
then also can we still do this?

11
00:00:27.716 --> 00:00:28.506
&gt;&gt; Great question.
Yeah,

12
00:00:28.506 --> 00:00:31.573
if a function contains more than one
expression also can you do this.

13
00:00:31.573 --> 00:00:35.101
So basically the rule is you can have as
many statements as you want in a row,

14
00:00:35.101 --> 00:00:37.410
and then after that one final expression.

15
00:00:37.410 --> 00:00:39.108
But if you tried to put like,
here's an expression,

16
00:00:39.108 --> 00:00:41.200
then here's another expression,
you get a compiler error.

17
00:00:41.200 --> 00:00:44.078
So it has to be like a bunch of statements
followed by an expression at the end

18
00:00:44.078 --> 00:00:45.418
that's just sort of hanging out.

19
00:00:45.418 --> 00:00:47.299
Then that last expression right there,

20
00:00:47.299 --> 00:00:49.640
that's sort of the last
thing in the function.

21
00:00:49.640 --> 00:00:52.720
That's what gets turned to
the automatic return and

22
00:00:52.720 --> 00:00:55.384
it's the same thing
inside these if blocks.

23
00:00:55.384 --> 00:00:59.994
&gt;&gt; Would you want to specify explicitly
a return statement if you were trying to

24
00:00:59.994 --> 00:01:01.670
make an early return?

25
00:01:01.670 --> 00:01:02.460
&gt;&gt; Yeah, for sure.

26
00:01:02.460 --> 00:01:04.285
Yeah, if you want to do an early return,

27
00:01:04.285 --> 00:01:06.740
then you do need to use
the return keyword for that.

28
00:01:06.740 --> 00:01:09.470
But if you want, you can do an early
return and then still at the end

29
00:01:09.470 --> 00:01:13.365
have like the default return use
the expression style, that's totally fine.

30
00:01:13.365 --> 00:01:17.663
But yeah, if you wanna do an early return,
either you need to do that or you need

31
00:01:17.663 --> 00:01:22.379
to do something like this where you have
conditionals like throughout the function.

32
00:01:22.379 --> 00:01:24.690
You never need to use the return keyword,

33
00:01:24.690 --> 00:01:27.473
you can always express
the same thing without it.

34
00:01:27.473 --> 00:01:30.265
But yeah, early returns generally
use the return keyword for that.

35
00:01:31.560 --> 00:01:32.766
&gt;&gt; For the comparison,

36
00:01:32.766 --> 00:01:37.020
I'm guessing that it takes that type
into account like a string of 1.1.

37
00:01:37.020 --> 00:01:42.620
Would it be false if it was
compared to a float of 1.1?

38
00:01:42.620 --> 00:01:46.020
&gt;&gt; That's even better you
would get a type error.

39
00:01:46.020 --> 00:01:50.055
So if you tried to compare if
the string foo is greater than one,

40
00:01:50.055 --> 00:01:52.320
it would just not compile.

41
00:01:52.320 --> 00:01:56.956
&gt;&gt; And then the second question was
kind of setting these variables of

42
00:01:56.956 --> 00:01:59.390
conditional statements.

43
00:01:59.390 --> 00:02:04.690
Can you then like pass these around
like in the string interpolation?

44
00:02:05.766 --> 00:02:07.630
&gt;&gt; Sure yeah, if you want to [LAUGH].

45
00:02:07.630 --> 00:02:09.410
&gt;&gt; Yeah that's awesome.

46
00:02:09.410 --> 00:02:12.788
&gt;&gt; Yeah, so actually this entire if like
starting from the INF to this close curly

47
00:02:12.788 --> 00:02:14.690
brace, that whole thing is an expression.

48
00:02:14.690 --> 00:02:17.655
So you can just pick it up and
drop it anywhere you want.

49
00:02:17.655 --> 00:02:20.428
[LAUGH]
&gt;&gt; Can that be used for

50
00:02:20.428 --> 00:02:22.581
knowledge coercion?

51
00:02:22.581 --> 00:02:23.293
&gt;&gt; Great question.

52
00:02:23.293 --> 00:02:26.889
Can that be used for knowledge coercion,
RUSS actually does not have

53
00:02:26.889 --> 00:02:30.780
a concept of null or undefined or
any similar kinds of coercion.

54
00:02:30.780 --> 00:02:33.840
We'll see how, like the alternative
that it has when we get to EOMS.

55
00:02:33.840 --> 00:02:38.530
But basically those are no nil undefined,
anything like that RUSS does not have it.

