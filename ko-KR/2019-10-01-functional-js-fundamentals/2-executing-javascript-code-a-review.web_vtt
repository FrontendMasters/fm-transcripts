WEBVTT

00:00:01.743 --> 00:00:05.825
Will Sentance: 여러분들이 이전에, Hard Parts를
수료하셨다면, 뭘 할 지 알거예요.

00:00:05.825 --> 00:00:10.616
우린 JavaScript가 코드를 실행할 때
정확히 어떤 일을 하는지

00:00:10.616 --> 00:00:11.261
살펴볼겁니다.

00:00:11.261 --> 00:00:16.291
아마 아주 아주 쉬워보일거예요.
아주 쉽게할겁니다.

00:00:16.291 --> 00:00:21.140
하지만, 여러분들이 모든 Hard Part들을 수료하게 되면,

00:00:21.140 --> 00:00:24.236
코드의 진행에 헷갈리는게 하나도 없어질거예요.

00:00:24.236 --> 00:00:26.605
좋아요, 진행하죠.

00:00:26.605 --> 00:00:30.391
JavaScript가 코드를 진행하면요, 여기 이 코드를요.

00:00:30.391 --> 00:00:34.875
말한대로 2가지를 하는데,
첫 번째는, 데이터를 저장하는거예요.

00:00:34.875 --> 00:00:39.079
퀴즈 게임을 할 때는, 점수나 마지막으로 푼 문제같은 걸

00:00:39.079 --> 00:00:43.570
저장할거고, 그건 화면에 그려지는거랑은

00:00:43.570 --> 00:00:46.730
다른 곳에 저장되어 있겠죠.

00:00:46.730 --> 00:00:50.819
그것들은 JavaScript의
숨겨진 부분에 저장되어있죠.

00:00:50.819 --> 00:00:55.710
결국, JavaScript는 잡다한 데이터를
저장할 공간이 필요하고,

00:00:55.710 --> 00:00:57.099
우린 그걸 Memory라고 부릅니다.

00:00:57.099 --> 00:01:01.887
그럼, 이걸 유념하시고, David,
일종의 저장 공간인 Memory의 관점에서,

00:01:01.887 --> 00:01:05.822
여기 우리 코드의 첫 번째 라인이 실행되면 뭘 할까요?

00:01:05.822 --> 00:01:08.537
이제 저장하는 것들은 다 이 쪽에 쓸께요.
이걸 Memory라고 할겁니다.

00:01:08.537 --> 00:01:12.708
진행하면서 저장할 것들은 다 이 쪽에 순서대로 쓸거예요.

00:01:12.708 --> 00:01:16.182
이런 관점에서, David,
코드의 첫 번째 라인에서 가장 먼저 하는게 뭐죠?

00:01:16.182 --> 00:01:19.545
David: 변수를 num이라는 이름으로 선언합니다.

00:01:19.545 --> 00:01:20.461
Will Sentance: num이죠.

00:01:20.461 --> 00:01:22.413
David: 그리고 거기에 3이라는 값을 줘요.

00:01:22.413 --> 00:01:24.605
Will Sentance: 3, 완벽해요.

00:01:24.605 --> 00:01:29.505
이 말은, 이제부터 사람들이 이 App 내 어디에서든
num을 참조하면 그건

00:01:29.505 --> 00:01:30.304
3이라는 걸 뜻하죠.

00:01:30.304 --> 00:01:34.031
이미 우린 코드 중 3줄을 봤죠. 좋아요.

00:01:34.031 --> 00:01:35.187
10,000줄?

00:01:37.579 --> 00:01:40.553
Will Sentance: 이건 Global Memory예요.
때때로 저장된 데이터가 Global State라고도

00:01:40.553 --> 00:01:41.209
말합니다.

00:01:43.454 --> 00:01:47.249
Will Sentance: 이렇게 전역으로 저장되는 것들을
어떻게 해야 잘 받아들이실지 저도 잘 모르겠지만

00:01:47.249 --> 00:01:51.683
어쨌거나, 다음을 하실 분은, Alex죠.

00:01:51.683 --> 00:01:54.462
Alex, 두 번째 라인에선 뭘 하죠?

00:01:54.462 --> 00:01:57.499
Alex: multiplyBy2라는 이름의 변수를 선언해요.

00:01:57.499 --> 00:02:01.179
Will Sentance: 좋아요,
multiplyBy2라는 label이 있고,

00:02:01.179 --> 00:02:06.481
우린 이 코드 블럭 전체와 label을 연결짓죠.
그리고 이런 형태로 작성하는 건요.

00:02:06.481 --> 00:02:07.933
뭘 작성한다고 하죠, Alex?

00:02:07.933 --> 00:02:09.073
Alex: 함수요.
Will Sentance: 함수죠

00:02:09.073 --> 00:02:10.938
Alex가 잘하는군요, 함수입니다.

00:02:10.938 --> 00:02:14.104
function이라는 이 멋진 키워드가 그 자체의 코드가 어떤 것인지

00:02:14.104 --> 00:02:16.547
말해주진 않을 수도 있지만, 우린 이걸 함수라고 알고 있죠.

00:02:16.547 --> 00:02:19.955
저기 괄호가 있죠, 그리고 입력값을 기다릴거예요.

00:02:19.955 --> 00:02:24.010
multiplyBy2가 실행될 때, 저기가 채워질겁니다.
이건 arrow function이라고 알려져있죠.

00:02:24.010 --> 00:02:26.429
그리고 중괄호 안은, 코드가 실행 될 때,

00:02:26.429 --> 00:02:28.427
저 코드들이 실행될겁니다.

00:02:28.427 --> 00:02:31.425
이게 두 번째 라인에서 JavaScript가 하는겁니다.

00:02:31.425 --> 00:02:35.859
저 코드 전체를 들고, 여기에 저장할거예요,
여기에 저 코드 전체를 쓰진 않을게요.

00:02:35.859 --> 00:02:40.152
하지만, 전체가 저장됩니다.
전 그 대신 f가 있는 작은 박스로 대체하겠습니다.

00:02:40.152 --> 00:02:44.336
함수를 표현하는거죠, 그리고 입력과 출력도 그릴께요.

00:02:44.336 --> 00:02:49.568
그럼, 이제, Anna, 여기서 세 번째 라인은 뭐죠?

00:02:49.568 --> 00:02:53.830
두 번째 라인에선 multiplyBy2를 저장했어요,
그럼 세 번째 라인은 뭐죠, Anna?

00:02:53.830 --> 00:02:58.858
Anna: name이라는 변수를 선언하고,
거기에 Will을 할당해요.

00:02:58.858 --> 00:03:02.705
Will Sentance: 상수 name을 선언하고
Will을 할당하죠.

00:03:02.705 --> 00:03:07.341
Anna가 multiplyBy2의 바디 부분을
건너 뛴 걸 알면 됩니다. 이미 저장됐죠.

00:03:07.341 --> 00:03:10.426
이건 끝났죠, 나중에 실행하지 않는 한은요.

00:03:10.426 --> 00:03:13.110
아무튼, 우린 이걸 실행하지 않죠,
그럼 처리되지 않아요.

00:03:13.110 --> 00:03:14.890
절대 처리되지 않습니다.

00:03:14.890 --> 00:03:16.838
훌륭해요, 고마워요, Anna.

00:03:16.838 --> 00:03:20.751
여러분, 우린 이미 JavaScript가 하는
가장 큰 2개의 역할을 봤어요.

00:03:20.751 --> 00:03:23.808
첫 번째는, Memory에 저장하는거,
이거죠. 그리고

00:03:23.808 --> 00:03:27.267
나머지는 우리가 명확하게 하진 않았지만,

00:03:27.267 --> 00:03:32.111
이미 일종의 힌트를 앞서 줬던 게,
우린 이 코드를 라인 단위로 진행했죠.

00:03:32.111 --> 00:03:34.899
하나의 라인이 끝나면,
그 다음 두 번째 라인으로 가죠.

00:03:34.899 --> 00:03:39.263
또 다음 라인으로 갔고요.
이걸 Thread of Execution이라고 해요.

00:03:39.263 --> 00:03:44.647
이 실행흐름은 페이지를 내려가면서 각 라인을 실행하죠.

00:03:44.647 --> 00:03:49.415
많은 시간이 Memory에 저장하느라 막힙니다.

00:03:49.415 --> 00:03:53.750
JavaScript를 실행하기 위해 필요한 것이 이 2가지예요.

00:03:53.750 --> 00:03:56.730
이것 저것들을 저장할 공간과, 코드를 라인 단위로

00:03:56.730 --> 00:04:00.134
진행하면서 처리하는 것, Thread of Execution이죠.

00:04:00.134 --> 00:04:04.914
그리고 이것들을 합쳐서 Execution Context라고 합니다.

00:04:04.914 --> 00:04:09.937
Context라는 건 뭔가를 하기 위한 공간이죠,
코드를 실행할 공간이요.

00:04:09.937 --> 00:04:13.320
좋아요, 이건 Global Execution Context라고 해요.

00:04:13.320 --> 00:04:18.262
우리 코드가 실행되기 시작할 때 먼저 처리 되죠.

00:04:18.262 --> 00:04:22.250
그리고, 그것의 Memory는 Application의 전체에서

00:04:22.250 --> 00:04:24.870
사용이 가능합니다.

00:04:24.870 --> 00:04:28.742
이건 Local Execution Context와 대비됩니다.

00:04:28.742 --> 00:04:33.936
이건 미니 버전으로, 함수가 실행될 때 생성되죠.

00:04:33.936 --> 00:04:36.896
그래서 함수라는 건 어떤 미니 프로그램이예요.

00:04:36.896 --> 00:04:40.133
사람들은 실제로 그걸 전체 프로그램의
서브 프로그램이라고 하죠.

00:04:40.133 --> 00:04:42.859
전체 App 내의 작은 미니 App인거죠.

00:04:42.859 --> 00:04:45.739
그리고 이게 정확히 우리가 이 아래에서 할 거죠.

00:04:45.739 --> 00:04:49.967
우린 이전에 저장해뒀던 이 코드를 실행할거예요,
이걸 수행할겁니다.

00:04:49.967 --> 00:04:52.161
아까 name을 Will이라고 여기 했었죠.

00:04:52.161 --> 00:04:55.359
그리고 우린 아래로 점프했어요,
Virginia?

00:04:55.359 --> 00:04:58.873
만약 저기 left-hand 영역부터 본다면, 뭘 선언하죠?

00:04:58.873 --> 00:05:02.738
multiplyBy2를 선언 한뒤에,
left-hand 영역에 뭘 선언하고 있죠?

00:05:02.738 --> 00:05:03.290
Virginia: output이요.

00:05:03.290 --> 00:05:07.658
Will Sentance: Virginia가 말한대로,
우린 const output을 선언하죠.

00:05:07.658 --> 00:05:12.703
Virginia, 우리가 이 시점에서
output에 뭐가 저장되는지 아나요?

00:05:12.703 --> 00:05:14.171
JavaScript가 뭘 저장하는지 아나요?

00:05:14.171 --> 00:05:14.762
Virginia: 네.

00:05:14.762 --> 00:05:15.494
Will Sentance: 알아요?

00:05:15.494 --> 00:05:18.147
Virginia: 아직 몰라요.

00:05:18.147 --> 00:05:20.676
Will Sentance: 아직이죠, 왜냐하면, right-hand 영역이

00:05:20.676 --> 00:05:22.187
아직 처리가 덜 됐으니까요.

00:05:22.187 --> 00:05:27.478
이건 실행된 다음에 넘겨질 표현식이죠.

00:05:27.478 --> 00:05:30.315
고마워요, David, 온라인 수강생들도요.

00:05:30.315 --> 00:05:32.586
귓속말이 아주 좋아요.

00:05:32.586 --> 00:05:34.210
[웃음] 실행이 필요하죠.

00:05:34.210 --> 00:05:35.753
완벽하다고 생각해요.

00:05:35.753 --> 00:05:41.793
실행이 먼저 되어져야 하고,
output이 그 실행을 받을거예요, 반환값을요.

00:05:41.793 --> 00:05:44.694
저 함수의 코드로 가서 실행할거고,

00:05:44.694 --> 00:05:49.275
저 작은 미니 프로그램,
미니 앱인 multiplyBy2 함수를요.

00:05:49.275 --> 00:05:53.939
그리고 output에게 어떤 저장될 데이터를 줄거예요.
출력값이죠.

00:05:53.939 --> 00:05:57.770
좋아요, 지금은 output이 초기화되어있지 않죠.

00:05:57.770 --> 00:06:01.518
우린 아직 어떤 값도 줄 수 없어요.
비어있어요.

00:06:01.518 --> 00:06:08.231
우리가 가서 실행하죠, multiplyBy2를요.

00:06:08.231 --> 00:06:12.166
Virginia, 어떤 기호가 multiplyBy2로
가서 실행하라고 할까요?

00:06:12.166 --> 00:06:16.476
JavaScript에게 어떤 기호가 해당 코드를
가서 수행하라고 하죠?

00:06:16.476 --> 00:06:17.160
Virginia: 괄호요.

00:06:17.160 --> 00:06:18.804
Will Sentance: 괄호죠, 맞았어요.

00:06:18.804 --> 00:06:21.871
그리고 뭐가 전달되죠, Sam?

00:06:21.871 --> 00:06:22.777
Sam: 3이요.

00:06:22.777 --> 00:06:24.133
Will Sentance: 3이죠, num이 3이니까요.

00:06:24.133 --> 00:06:27.519
자 그럼 여러분, 함수를 실행합니다.

00:06:30.088 --> 00:06:32.729
Will Sentance: 이 작은 미니 앱인 함수를
실행할 때 만드는 게

00:06:32.729 --> 00:06:36.972
뭔지 이미 말했어요,
그건 Memory와 Thread를 갖게 되죠.

00:06:36.972 --> 00:06:40.519
우린 1개의 Thread를 가지고 있죠.
그래서 JavaScript는 한 번에 하나의 일만 해요.

00:06:40.519 --> 00:06:44.082
이제 multiplyBy2를 실행하기 시작하면서 넘어갈거예요.

00:06:44.082 --> 00:06:48.739
이런 걸 하기 위한 걸,
Execution Context라고 합니다.

00:06:48.739 --> 00:06:51.026
Virginia 잘했어요.

00:06:51.026 --> 00:06:59.331
Execution Context는 기본적으로
아까 봤던 것의 미니 버전이예요.

00:06:59.331 --> 00:07:05.042
전체 프로그램의 미니버전은
그냥 multiplyBy2 함수를 실행하기 위한겁니다.

00:07:05.042 --> 00:07:09.757
똑같이 2개의 영역을 가집니다.
하나는 Thread of Execution으로,

00:07:09.757 --> 00:07:14.805
컴퓨터가 함수의 코드를 라인단위로 처리하는거죠,

00:07:14.805 --> 00:07:18.806
그리고 뭔가를 저장할 작은 Local Memory가 있죠.

00:07:18.806 --> 00:07:21.942
아무튼 우린 함수가 어떻게 하는지 이미 봤어요.

00:07:21.942 --> 00:07:24.969
메인 프로그램을 잠시 멈추고,
미니 프로그램으로 가죠.

00:07:24.969 --> 00:07:29.404
문제는, 여기 내의 10~15줄의 코드가 될 수 있죠.

00:07:29.404 --> 00:07:30.763
여러분들은 이런 함수를 봤나요?

00:07:30.763 --> 00:07:34.635
15라인의 함수는 너무 길어서
쉽게 이해하기가 어렵죠.

00:07:34.635 --> 00:07:36.383
컴퓨터 코드로 가득 차 있으니까요.

00:07:36.383 --> 00:07:39.832
그리고 그 15라인은 다 종속적이죠,

00:07:39.832 --> 00:07:42.936
14개의 라인들이 이 라인에 종속적이고,
또 14개 라인들이 여기에 종속이고,

00:07:42.936 --> 00:07:45.874
14개의 라인들이 또 여기에 종속이고,
너무 어려워요.

00:07:45.874 --> 00:07:48.875
일단 지금은 진행하죠,
우린 이걸 어떻게 개선할지 볼건데,

00:07:48.875 --> 00:07:50.044
일단 진행하죠.

00:07:50.044 --> 00:07:53.494
이 Execution Context라고 하는 것의
내부에서 가장 먼저 하는게 뭐죠?

00:07:53.494 --> 00:07:57.901
Execution Context에서 가장 먼저 땡기는게 뭐죠?

00:07:57.901 --> 00:07:58.805
Andrew에게 물어볼께요.

00:07:58.805 --> 00:08:00.482
Andrew: 변수인가요?

00:08:00.482 --> 00:08:02.120
Will Sentance: 변수죠, 계속 말해봐요.

00:08:02.120 --> 00:08:03.359
Andrew: inputNumber요.

00:08:03.359 --> 00:08:03.876
Will Sentance: inputNumber죠.

00:08:03.876 --> 00:08:06.770
우린 이걸 변수라고 하지 않고
Parameter라고 합니다.

00:08:06.770 --> 00:08:10.716
전 여기 전체를 constant로 간주하는게 좋을 것 같아요.

00:08:10.716 --> 00:08:13.069
사람들은 여전히 그걸 변수라고 표현하죠.

00:08:13.069 --> 00:08:15.885
변수는 말 그대로 풀이하면,
여러분들이 이 안에 뭐든 넣을 수 있단 거죠.

00:08:15.885 --> 00:08:19.386
뭐 그렇게 부르고 싶을지 모르겠지만,
이제 constant라고 하거나

00:08:19.386 --> 00:08:20.716
여러분들이 원하면 변수라고 해도 좋아요.

00:08:20.716 --> 00:08:26.012
전 이걸 2가지로 분류합니다.
label과 값으로요.

00:08:26.012 --> 00:08:28.964
label에 뭔가를 저장할 수 있는거예요.

00:08:28.964 --> 00:08:34.534
여러분들이 이 실제 값을
이 multiplyBy2 함수의

00:08:34.534 --> 00:08:40.956
placeholder에 채워넣을 때,
여러분들이 말한대로, 지역 변수를 생성하는데요.

00:08:40.956 --> 00:08:44.176
이 Local Label의 특별한 이름이 있죠,

00:08:44.176 --> 00:08:45.973
Virginia?

00:08:45.973 --> 00:08:46.576
Virginia: Parameter요.

00:08:46.576 --> 00:08:48.252
Will Sentance: Parameter죠, 좋아요.

00:08:48.252 --> 00:08:51.412
이게 Parameter고, 이게 Argument입니다.

00:08:51.412 --> 00:08:55.576
좋아요, Andrew,
이제 multiplyBy2의 바디영역을 만났죠, 뭘 하나요?

00:08:58.117 --> 00:08:58.677
Andrew: result를 만들어요.

00:08:58.677 --> 00:09:00.809
Will Sentance: result를 만들고 뭘 할당하죠?

00:09:00.809 --> 00:09:04.294
Andrew: 실행하는데, 음 제 생각엔-
Will Sentance: 네,

00:09:04.294 --> 00:09:07.275
result엔 할당될 inputNumber는 뭐죠?

00:09:07.275 --> 00:09:07.877
Andrew: 6이요.

00:09:07.877 --> 00:09:10.726
Will Sentance: 6이죠,
3X2는 6이죠. 이렇게요.

00:09:10.726 --> 00:09:14.669
그리고 마지막 라인은 result를 반환하죠.

00:09:14.669 --> 00:09:19.116
이건 나중에 나타날 것이기 때문에,
강조하고 싶은건,

00:09:19.116 --> 00:09:22.994
JavaScript가 당장 뭘 반환해야할지 모른다는 거죠.

00:09:22.994 --> 00:09:26.666
뭔가 보내야한다는 건 알지만
잠깐 멈춰보면, 이걸 보고,

00:09:26.666 --> 00:09:27.322
이게 뭐지? 하는거죠.

00:09:27.322 --> 00:09:30.840
그리고 그 값이 되는거죠, 왜냐하면 여러분들은 값만 반환하니까요.

00:09:30.840 --> 00:09:33.618
그럼 이걸 보고, 진행하는 거죠, result가 뭐지?

00:09:33.618 --> 00:09:34.622
그것의 값이 뭐지?

00:09:34.622 --> 00:09:36.457
왜냐하면 이거 자체로는 값이 아니니까요.

00:09:36.457 --> 00:09:39.373
이건 분명히, 평가가 되어져야만이 값으로 변하는거고,

00:09:39.373 --> 00:09:42.419
그 자체로만 값이 되는건 아니예요.

00:09:42.419 --> 00:09:45.543
그럼 이것의 값은 뭐죠, Virginia?

00:09:45.543 --> 00:09:46.209
음 다시, Jasmine?

00:09:46.209 --> 00:09:47.256
Jasmine: 6이요.

00:09:47.256 --> 00:09:47.779
Will Sentance: 6이죠.

00:09:47.779 --> 00:09:54.721
그럼 실제로 6이 반환되면,
Global의 어떤 Label로 들어갈까요, Jasmine?

00:09:54.721 --> 00:09:57.456
Jasmine: output으로 들어가요.

00:09:57.456 --> 00:10:00.025
Will Sentance: output에 들어가죠, 맞았어요.
이렇게죠.

00:10:01.831 --> 00:10:07.364
Will Sentance: 여러분들이 경력 개발자라면,
반드시 이렇게 사고해야해요.

00:10:07.364 --> 00:10:13.213
저도 3을 넣어서 multiplyBy2가 6을 output에 저장하겠죠
라고 할 수도 있어요.

00:10:14.421 --> 00:10:17.526
Will Sentance: 하지만, 우리가 대학의 교수들이
말했던 것처럼 손을 써야해요.

00:10:17.526 --> 00:10:20.910
항상 무언가를 이해하는 것처럼 다 손을 써야해요.

00:10:20.910 --> 00:10:25.173
그리고 여러분들이 기초에 대한 이해를 바탕으로 한다면,

00:10:25.173 --> 00:10:28.709
다음 레벨은 그 이해의 일부가 되는거죠.

00:10:28.709 --> 00:10:32.644
여러분들이 진짜로 이 원리가 실제로
뭘 하는지에 대해 명확하게 안다면,

00:10:32.644 --> 00:10:36.074
여러분들은 견고한 기초를 쌓아서 다음 레벨로 갈 수 있어요.

00:10:36.074 --> 00:10:37.871
이게 오늘 우리가 할 것입니다.

00:10:37.871 --> 00:10:43.063
좋아요, 이제 Thread of Execution이 이 함수에서 나오면,
우린 이걸 종료할거예요.

00:10:43.063 --> 00:10:47.911
이 함수 전체가 지워지는거죠, 그것의 Local Memory도 지워지고,

00:10:47.911 --> 00:10:50.345
이게 반환 되면서 진행되죠.

00:10:50.345 --> 00:10:52.985
다시 말씀드리지만,
전 좀 더 구체적으로 할거예요. 이게 몇 번이고

00:10:52.985 --> 00:10:53.651
반복되기 때문이예요.

00:10:53.651 --> 00:10:58.043
JavaScript가 동작하는 방식은요,
깔끔하게 유지해볼테지만,

00:10:58.043 --> 00:11:01.643
함수의 출력값이 나오면, 그러니까 여기에,

00:11:01.643 --> 00:11:06.036
3이 입력값으로 들어간 multiplyBy2의 실행이요.
실제로, 이게 평가되면,

00:11:06.036 --> 00:11:09.512
이 라인에서 이동하기 전에, output으롤 바뀌는거죠.

00:11:09.512 --> 00:11:16.274
그래서 평가되자마자, 바로 그 값으로 변하는거예요.

00:11:16.274 --> 00:11:20.842
기억하세요, 값이고, 값이고, 값이죠.
심지어 저장된 함수 코드도 값이예요.

00:11:20.842 --> 00:11:24.105
그래서 이 코드를 실행하고, 코드를 실행하는 명령은 값이 아닌거죠.

00:11:24.105 --> 00:11:25.821
이건 가서 값을 얻어오라는 명령인거예요.

00:11:25.821 --> 00:11:28.126
이제 이건 말 그대로 출력값으로 변하죠.

00:11:28.126 --> 00:11:31.237
우리고 우리가 쉽게 알 수 있듯이
output에 6이 할당되는 거예요.

00:11:31.237 --> 00:11:34.056
다음 라인에서 우린 다시 newOutput을 선언하고,

00:11:34.056 --> 00:11:38.807
반환 값을 받는 Global로 돌아왔죠.

00:11:38.807 --> 00:11:44.529
또 다시 multiplyBy2의 실행 반환 값이죠.

00:11:44.529 --> 00:11:47.087
이번엔, 여러분 모두 같이 해볼까요?

00:11:47.087 --> 00:11:48.136
학생들: 10이요.

00:11:48.136 --> 00:11:49.048
Will Sentance: 잘했어요.

00:11:49.048 --> 00:11:53.866
아무튼, FrontEnd Masters 팀인
Richard와 Martin이 너무 좋아요.

00:11:53.866 --> 00:11:57.078
모든 그룹원들에게 마이크를 달아줬거든요.

00:11:57.078 --> 00:12:00.008
정말 최고입니다.

00:12:00.008 --> 00:12:07.245
좋아요, 만들면서, 오 보세요,
multiplyBy2를 실행하죠?

00:12:07.245 --> 00:12:11.144
함수를 실행할 때 필요한게 뭐죠? 새로운-?

00:12:11.144 --> 00:12:14.040
학생들: 웅얼웅얼
Will Sentance: 이상했어요.

00:12:14.040 --> 00:12:16.351
Execution Context예요.

00:12:16.351 --> 00:12:17.531
학생들: [웃음]
Will Sentance: 이거

00:12:17.531 --> 00:12:18.101
몇 번 했죠.

00:12:18.101 --> 00:12:19.309
새로운-?

00:12:19.309 --> 00:12:21.441
학생들: Execution Context.

00:12:21.441 --> 00:12:24.421
Will Sentance: 네, 특별히 크고
분명하게 말해주신 분들께

00:12:24.421 --> 00:12:26.461
감사를 드립니다.

00:12:26.461 --> 00:12:31.363
우린 이걸 실제로 다 만들고 하진 않을거예요.
이게 20을 반환해서 newOutput에 들어간다는 걸

00:12:31.363 --> 00:12:32.985
방금 알았으니까요.

00:12:32.985 --> 00:12:36.621
여러분들과 다 같이 했었고 따로 그리진 않을께요.

00:12:36.621 --> 00:12:38.155
그리고 newOutput은 20입니다.

00:12:38.155 --> 00:12:40.787
그래서 Thread of Execution이 들어갔었고,

00:12:40.787 --> 00:12:45.877
음 Thread of Execution은 다른 펜을 써야겠어요.

00:12:45.877 --> 00:12:50.210
넘어갔다가 넘어와서, 넘어갔다가 다시 돌아오죠.

00:12:50.210 --> 00:12:53.918
Context를 사용하여 보여드리진 않았지만,
들어갔다가 나온거예요.

00:12:55.595 --> 00:12:58.053
Will Sentance: 이것과 관련하여 하나 더 강조하고 싶은건,

00:12:58.053 --> 00:13:02.983
이번 건 하지 않았지만, 계속 할거라는거죠.

00:13:02.983 --> 00:13:05.442
multipyBy2를 저장했었고, 그게 뭔지 말하지 않았죠.

00:13:05.442 --> 00:13:09.810
사실 실제로는 이걸 뭔가를 2로 곱하는 거라고 불러야했어요.

00:13:09.810 --> 00:13:14.846
그리고 코드를 저장하구요. 뭔가를 2로 곱한다구요.
제가 어떤 값이라고 결정했나요?

00:13:14.846 --> 00:13:19.456
혹은 어떤 값을 2로 곱할거라고 지정했었나요?

00:13:19.456 --> 00:13:20.150
Sam?

00:13:20.150 --> 00:13:20.896
Sam: 아뇨.

00:13:20.896 --> 00:13:21.420
Will Sentance: 아니죠.

00:13:21.420 --> 00:13:27.453
제 함수의 핵심 용도를 보고 한 번만 저장하면 되는거예요.

00:13:27.453 --> 00:13:32.849
그리고 그걸 계속해서 사용하는 거죠.
다른 경우에 다른 데이터로요.

00:13:32.849 --> 00:13:41.214
제가 이 함수를 동적으로 실행하면서,
3X2로 변화시킬 수 있고,

00:13:41.214 --> 00:13:46.736
동적으로 바로 10X2로 할 수도 있죠.

00:13:46.736 --> 00:13:52.617
그리고 함수를 실행할 때가 아니라
데이터를 저장할 때

00:13:52.617 --> 00:13:58.512
일부 데이터를 동적으로 설정하기를
원하지 않는 사람들이 있을 수 있어요.

00:13:58.512 --> 00:14:01.067
우리는 이걸 처음 만들 때, 2로 설정했죠. 우리가 이걸 저장했을 때요.

00:14:01.067 --> 00:14:03.919
우린 뭘 곱할지는 따로 저장하지 않았구요.

00:14:06.063 --> 00:14:07.015
Will Sentance: 오직 함수를 실행할 때,

00:14:07.015 --> 00:14:11.162
함수를 실행할 때 실제 기능 중

00:14:11.162 --> 00:14:16.315
일부만 결정하고 그때에 들어서

00:14:16.315 --> 00:14:21.351
결정하도록 할 수도 있습니다.

00:14:21.351 --> 00:14:25.155
사실 이게 Functional Programming 패러다임의

00:14:25.155 --> 00:14:27.211
가장 첫 번째 파트가 되는데, 좀 이따가 볼거예요.

00:14:27.211 --> 00:14:30.760
이제, 다시 해보면, 여러분이 함수를 실행할 때,

00:14:30.760 --> 00:14:32.959
Virginia 어떤 기호가 함수를 실행하라고 하죠?

00:14:32.959 --> 00:14:33.696
Virginia: 괄호요.

00:14:33.696 --> 00:14:34.711
Will Sentance: 괄호죠. 감사합니다.

00:14:34.711 --> 00:14:39.486
새로운 Execution Context를 만들어
Thread of Execution을 구성해요.

00:14:39.486 --> 00:14:42.384
각 코드를 라인 단위로 처리한다는 걸 방금 알았죠.

00:14:42.384 --> 00:14:44.772
제가 하나 하나 다 적진 않았지만,
그 코드를 하나씩 진행한다는 걸 알죠.

00:14:44.772 --> 00:14:46.488
그리고 작은 Local Memory가 있구요.

00:14:46.488 --> 00:14:51.425
그냥 Local이라고 불러요.
그건 오직 함수 안에서만 동작하고, 임시적이죠.

00:14:51.425 --> 00:14:55.088
함수를 빠져 나오면, 오늘 오후에 볼 것만 빼곤

00:14:55.088 --> 00:14:59.594
다 임시적인 Memory고, 반환 값을 제외하곤 전부 지워지죠.

00:14:59.594 --> 00:15:02.823
이걸 종종 변수라고 부르지,
Variable Environment라고 부르는 사람은 없어요.

00:15:02.823 --> 00:15:05.664
하지만 여러분들이 진짜 있어보이게
이걸 부르고 싶다면, Variable Environment라고 하세요.

00:15:05.664 --> 00:15:09.827
Environment는 자기 자신을 둘러싸고 있는거죠.

00:15:09.827 --> 00:15:14.157
이 변수와 그걸 둘러싸는 게 이 함수인거예요.

00:15:14.157 --> 00:15:14.703
네, 괜찮죠?

00:15:14.703 --> 00:15:19.304
이제 Functional Programming으로 들어가기 전에
마지막으로 볼 개념이

00:15:19.304 --> 00:15:19.883
하나 남았습니다.