WEBVTT

00:00:00.270 --> 00:00:06.620
학생: 만약 map에 전달되는 배열이 스칼라 값이 아니라면요,

00:00:06.620 --> 00:00:08.260
0번째 인덱스는 사실 배열이잖아요.

00:00:09.440 --> 00:00:15.920
[의역] 우리가 이전에 구현한 약간 나이브한 구현은
내부의 배열을 수정하여

00:00:15.920 --> 00:00:18.950
변화시키잖아요.
Will Sentance: 그걸 보고

00:00:18.950 --> 00:00:19.880
한 번 해보세요.

00:00:19.880 --> 00:00:21.410
그건 아주 합당한 거예요.

00:00:21.410 --> 00:00:22.777
한 번 해보세요. 진짜로요.

00:00:22.777 --> 00:00:24.989
Alex, 괜찮나요?

00:00:24.989 --> 00:00:27.566
좋아요 여러분,
지금 이 시점에서

00:00:27.566 --> 00:00:29.823
마지막 결론 하나만 볼께요.

00:00:29.823 --> 00:00:33.430
그러니까, Pure Functions와 Immutability는요.

00:00:33.430 --> 00:00:35.340
기능 추가가 쉽다는, 그 자체로도 아주 중요합니다.

00:00:35.340 --> 00:00:37.370
하지만, 우리가 이거에 대해 확실히 알아야 해요.

00:00:37.370 --> 00:00:40.080
그리고 참조에 의한 전달을 이해해야 하죠.

00:00:40.080 --> 00:00:45.160
Pure Functions와 Immutability입니다.
기능 추가가 쉽다. 저장된 모든 함수는

00:00:45.160 --> 00:00:48.940
새로운 조합으로 안전하게 사용될 수 있다.

00:00:50.650 --> 00:00:52.640
저것들을 가지고 아무데서나 쓰죠.

00:00:52.640 --> 00:00:57.060
App의 다른 부분을 손상시키지 않을 거라는 걸 알죠.
더 읽기 쉽다.

00:00:57.060 --> 00:00:58.800
모든 라인이 자기 충족적이고 완전하다.

00:00:58.800 --> 00:01:01.350
전 단어가 처음이자 끝일 때 모든 것이
그 라인에 있는 것처럼

00:01:01.350 --> 00:01:02.200
완전한 이라는 말을 좋아해요.

00:01:03.410 --> 00:01:04.620
충분히 서술적이고

00:01:04.620 --> 00:01:07.070
그 라인을 직접 들여다 볼 필요가 없도록 더 읽기 쉽게 해주죠.

00:01:07.070 --> 00:01:08.430
"잠깐, 이게 진짜 하는 게 뭐야?" 하고요.

00:01:08.430 --> 00:01:10.650
바로 읽고 그것의 시작과 끝을 알 수 있도록요.

00:01:11.770 --> 00:01:15.370
그건 그렇고, 그 끝은 다음 라인이죠. 바로 다음 라인이요.

00:01:15.370 --> 00:01:17.160
항상요, 이건 굉장히 엄격한 규칙입니다.

00:01:17.160 --> 00:01:21.390
제가 말했듯 그것의 이름만으로도 엄청난 힌트를 줘서
그것이 정확히 뭘 하는지 밝혀낼 수 있죠.

00:01:21.390 --> 00:01:26.320
그냥 제 맘대로 썼어요 [웃음]
디버깅이 쉽다. 1000 라인의 상호 의존성이 없어요.

00:01:26.320 --> 00:01:27.808
그게 상호의존이라는 의미인데,

00:01:27.808 --> 00:01:28.786
모든 라인은 서로 의존하죠.

00:01:28.786 --> 00:01:32.782
서로 직접적으로 하는 건 아니지만, 전역 상태,
Global Memory, 전역의 안전한 데이터로

00:01:32.782 --> 00:01:34.970
서로 간에 모두 의존하게 되죠.

00:01:34.970 --> 00:01:36.730
전 이걸 다른 곳 어디에서도 쓸 수 있죠.

00:01:36.730 --> 00:01:38.820
이 라인을 만들지 마세요.

00:01:38.820 --> 00:01:41.521
이 라인을 종속시켜서는 안됩니다.
이 라인을 다른 모든 라인들이

00:01:41.521 --> 00:01:46.275
이 배열에 암묵적으로 종속되게 할 수도 있어요.

00:01:46.275 --> 00:01:48.970
여기 있는 배열은 여러분들이 변이시켜고 됩니다만,

00:01:48.970 --> 00:01:50.656
그러니까, map의 변이된 버전이라면

00:01:50.656 --> 00:01:52.662
그건 다른 모든 라인들을 여기에 의존시킬거예요.

00:01:52.662 --> 00:01:54.920
Map을 깨끗하게 하는 게 아주 중요해요.

00:01:56.190 --> 00:01:58.990
새롭게 데이터를 만들고, 변이 시키지 마세요.

00:01:58.990 --> 00:02:00.410
데이터의 불변성에 포커스를 맞춰야해요.

00:02:01.930 --> 00:02:03.810
좋아요 여러분,
이제 Pair Programming을 하죠.

00:02:05.060 --> 00:02:06.250
그리고 그런 뒤에, 그냥 알아두시면 되는데,

00:02:06.250 --> 00:02:08.277
굉장히 재밌는 곳으로 넘어갈거예요.

00:02:08.277 --> 00:02:10.821
Seth의 질문이었죠.

00:02:10.821 --> 00:02:14.772
Seth가 "잠깐, 제 함수의 목록들은 동작하지 않을거예요"

00:02:14.772 --> 00:02:16.815
여러분들 이걸 RRT(?)의 미스매치라고 불러요.

00:02:16.815 --> 00:02:19.710
RRT(?)는 함수가 취하는 많은 입력이고,

00:02:19.710 --> 00:02:21.439
그 많은 수의 입력이 일치하지 않는거예요.

00:02:21.439 --> 00:02:25.930
여러분들이 그렇게 하면, 그건 이 모든 걸 망칠거예요.

00:02:25.930 --> 00:02:26.580
무서워하지 마세요.

00:02:26.580 --> 00:02:32.760
우린 이제 Closure를 써서,
우리의 함수에 엄청난 힘을 부여할겁니다.

00:02:32.760 --> 00:02:36.770
그리고 나면 우린 Decorated Function을 쓸 수 있을거예요.
함수를 수정하는

00:02:36.770 --> 00:02:38.000
가장 빠른 방법이죠.

00:02:39.220 --> 00:02:42.080
그럼 우린 새로운 함수를 만들 필요가 없고

00:02:42.080 --> 00:02:44.770
만약 우리가 더 많이 준비를 해두고, 다른 방법으로 함수들에게

00:02:44.770 --> 00:02:45.820
줄 수 있는 특별한 속성을 넘기는거죠.

00:02:47.090 --> 00:02:51.772
그리고 그건 Partial Application에 도달하게 해주는데,

00:02:51.772 --> 00:02:54.656
함수를 수정하게 해주고, 여러 개의 입력도 처리해주죠.