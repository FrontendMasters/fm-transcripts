WEBVTT

00:00:00.289 --> 00:00:04.047
Will Sentance: 상세한 JavaScript의 실행말고
좀 더 크게 보는 관점에서

00:00:04.047 --> 00:00:08.836
다이어그램을 그려보며 이야기를 해보죠.

00:00:08.836 --> 00:00:10.946
그래서 우리는, 우리가 가진 조건들은요?

00:00:17.543 --> 00:00:20.571
Will Sentance: multiplyBy2,

00:00:20.571 --> 00:00:22.361
add3랑,

00:00:22.361 --> 00:00:24.350
이건 아까 봤던 그 배열이예요.

00:00:24.350 --> 00:00:27.622
그건 그렇고, 잠깐 쉬는 동안 Michael이 질문을 하나 했어요.

00:00:27.622 --> 00:00:30.961
뭐라고 했냐면, 이게 React나 Redux에서
일어나는 것과 관련이 있나요? 라고요.

00:00:30.961 --> 00:00:34.922
네, 완전 똑같다고 알고 있어요.

00:00:34.922 --> 00:00:38.065
실제 사용하는 측면에서 오늘 하는 것 중 한 가지만 본다면,

00:00:38.065 --> 00:00:41.626
이건 실제로 우리가 했던 reduce에서
무슨 일이 일어나는지를 보면 됩니다.

00:00:41.626 --> 00:00:43.886
좋아요

00:00:43.886 --> 00:00:45.576
지금 여기서 하는거랑 완전 똑같죠.

00:00:45.576 --> 00:00:50.792
좋아요, multiplyBy2, add3랑 divideBy5죠.

00:00:50.792 --> 00:00:55.875
그리고, 우리는 목표를 위해 데이터를 가지고 실행하고 싶을거예요.

00:00:55.875 --> 00:00:58.082
다음 슬라이드에서 약간 다르게 표현된 걸 보여드릴께요.

00:00:58.082 --> 00:00:59.905
엄청 상세하게 보진 않을거예요.

00:00:59.905 --> 00:01:02.421
하지만, 약간 다르게 하얀 공간이 좀 더 보일겁니다.

00:01:02.421 --> 00:01:06.683
그리고 멋있게 label이 붙은 각각의 작업들을 하나의

00:01:06.683 --> 00:01:08.242
개별 라인으로 끝낼 거예요.

00:01:08.242 --> 00:01:10.709
아마 어떤 모습일지 이미 짐작하고 계실 수도 있겠네요.
아주 멋질거예요.

00:01:10.709 --> 00:01:11.493
자, 시작하죠.

00:01:11.493 --> 00:01:15.629
자 그래서, multiplyBy2, add3랑 divideBy5가 있죠.
체이닝하고, 결과를 파싱해서

00:01:15.629 --> 00:01:20.056
체이닝한다고 하기보단, 이걸 이제부터 compose라고 부를게요.

00:01:20.056 --> 00:01:22.582
그 말은 들어온 11로 이걸 합친다는거죠.

00:01:22.582 --> 00:01:26.024
넘어온 11을 가지고,

00:01:26.024 --> 00:01:31.960
이걸 multiplyBy2랑 조합하고,

00:01:31.960 --> 00:01:36.783
이걸 multiplyBy2랑 조합하는거예요.
당신을 통해 할거예요.

00:01:36.783 --> 00:01:41.132
Virginia,
이걸 조합하면 뭘 얻죠?

00:01:41.132 --> 00:01:41.888
Virginia: 22요.

00:01:41.888 --> 00:01:43.871
Will Sentance: 22죠, 그건 그렇고,
아주 멋진

00:01:43.871 --> 00:01:46.147
오디오네요, 완벽해요.

00:01:46.147 --> 00:01:49.855
이 2개를 조합해 하나를 얻죠.
그냥 생각해보세요.

00:01:49.855 --> 00:01:53.713
누가 도대체, 조합의 개념을 생각했을까요.
두 가지를  하나로 줄이는 걸요.

00:01:53.713 --> 00:01:58.134
실제로 함수가 있고, 숫자나 입력값이 있다면,

00:01:58.134 --> 00:02:02.796
이것들을 조합해서 하나로 만들어내는거죠.
두 개가 하나로 되는거요.

00:02:02.796 --> 00:02:06.706
어쨌건, 그래서 여기서 조합하는 규칙은 뭐죠?

00:02:06.706 --> 00:02:11.717
음, 실행한 함수를, 음 이걸 우린

00:02:11.717 --> 00:02:16.830
accumulator라고 했죠,
실행한 우리 함수 accumulator고,

00:02:16.830 --> 00:02:22.356
그리고 이것의 결과는,
조합의 결과입니다.

00:02:22.356 --> 00:02:26.959
그리고 이걸 가지고, 이걸 add3랑 조합하면,

00:02:26.959 --> 00:02:32.878
다시, add3를 3이랑하면, 이것의 결과는, 2개를 가지고,

00:02:32.878 --> 00:02:38.247
이것들을 가지고, 배열의 요소를 acuumulator에

00:02:38.247 --> 00:02:44.184
넣어서 조합하는거죠. 이게 만들어가는거예요.

00:02:44.184 --> 00:02:48.204
이걸 buildingUp이라고 했었죠.
이건 매 회차마다 갱신되고 있죠.

00:02:48.204 --> 00:02:52.919
for-loop의 두 번째 회차에, buildingUp을 넣고,

00:02:52.919 --> 00:02:56.619
array의 첫 번째 위치인 add3를 넣죠.

00:02:56.619 --> 00:03:01.705
이것들을 howToCombine인
runFunctionOnInput에 던짐으로써

00:03:01.705 --> 00:03:07.000
이것들을 조합하는거죠. 그리고 두번째는 add3고요. 그렇죠?

00:03:07.000 --> 00:03:11.595
howToCombine인 runFunctionOnInput에 들어갈
두 번째가 add3라는 말이예요.

00:03:11.595 --> 00:03:13.402
첫 번째는 22구요.

00:03:13.402 --> 00:03:19.199
그리고 나면, runFunctionOnInput안에서
우린 add3를 22로 실행하죠.

00:03:19.199 --> 00:03:26.599
add3를 가지고 22로 실행을 하면 뭐가 나오죠?

00:03:26.599 --> 00:03:27.473
Bivanesh: 25요.

00:03:27.473 --> 00:03:31.159
Will Sentance: 25죠. 그럼 우린 25를 조합하죠.

00:03:31.159 --> 00:03:37.490
divideBy5랑요. divideBy2를 5로 하면,

00:03:37.490 --> 00:03:39.954
뭐가 나오죠?

00:03:39.954 --> 00:03:40.976
Bivanesh: 5요.
Will Sentance: 5예요.

00:03:40.976 --> 00:03:43.645
이거죠, 여러분.

00:03:43.645 --> 00:03:48.923
여기 이건,
우리가 이걸 어떻게 조합할 지에 대한 거죠.

00:03:48.923 --> 00:03:52.575
자 이건 reducer라고 합니다.
2개로부터 1개의 출력을 만들어내느거고,

00:03:52.575 --> 00:03:54.787
그 출력과 다음 요소인 2개를 1개로 조합하죠.

00:03:54.787 --> 00:04:01.318
reducer를 전 여기에선 howToCombine이라고 썼고,
조합하는 방법의 규칙을 뜻합니다.

00:04:01.318 --> 00:04:06.618
reducer라는 용어에 익숙해지세요.
계속 이건 쓰입니다.

00:04:06.618 --> 00:04:09.465
좋아요, 이게 끝이예요.

00:04:09.465 --> 00:04:10.344
첫 번째 라인, 시작해보죠.

00:04:10.344 --> 00:04:11.988
한 사람씩 돌아가면서 해볼께요.

00:04:11.988 --> 00:04:13.761
그럼 Alex, 당신부터예요. 첫 번째 라인입니다.

00:04:13.761 --> 00:04:17.156
Global Memory에 저장하는 게 뭐죠?

00:04:17.156 --> 00:04:19.974
여기 우리가 어떻게 진행할지에 대한 큰 줄기가 있어요.

00:04:19.974 --> 00:04:21.855
이제 JavaScript에서 직접 실행해보죠.

00:04:21.855 --> 00:04:23.079
첫 번째 라인입니다. Alex.

00:04:23.079 --> 00:04:26.487
Alex: multiplyBy2라는 label의 함수를 선언해요.

00:04:26.487 --> 00:04:28.443
Will Sentance: multiplyBy2죠.

00:04:28.443 --> 00:04:31.283
x같은 거에 대해선 생각하지 마세요.

00:04:31.283 --> 00:04:33.406
엇, 약간 잘못했네요.

00:04:36.919 --> 00:04:42.233
Will Sentance: x가 전역으로 사용가능하다고 생각하면 안돼요.

00:04:42.233 --> 00:04:48.359
여러분 이건 그냥 괄호 안에 들어갈 parameter 이름이예요.

00:04:48.359 --> 00:04:49.754
이건 그 괄호를 제거해도 되는 거구요.

00:04:49.754 --> 00:04:51.309
확실히 아니예요.

00:04:51.309 --> 00:04:54.171
"잠깐, Global에 x가 3개나 있네?" 라고 보면 안돼요.

00:04:54.171 --> 00:04:56.703
그게 아니라, 괄호로 감싸진 parameter 이름이니까요.

00:04:56.703 --> 00:05:01.257
그리고, right-hand 영역은
중괄호 안에 return x * 2가 있는거예요.

00:05:01.257 --> 00:05:03.831
지금 이건 축약형입니다.

00:05:03.831 --> 00:05:05.017
좋아요, 정확히 이건 함수죠.

00:05:05.017 --> 00:05:06.757
이겁니다.

00:05:06.757 --> 00:05:09.205
그래서 x를 가지고 x * 2를 반환하죠.

00:05:09.205 --> 00:05:11.183
다음 라인은, Anna.

00:05:11.183 --> 00:05:14.285
Anna: 함수 add3를 선언해요.

00:05:14.285 --> 00:05:18.573
Will Sentance: 훌륭해요. 그리고 이건 x를 받아서
x + 3을 반환하죠. 전 그냥 이게

00:05:18.573 --> 00:05:23.272
짧아서 좋아요. 우린 말 그대로 right-hand에 코드만 쓰면 되죠.

00:05:23.272 --> 00:05:25.643
이건 작은 코드라고 생각하세요. 여러분.

00:05:25.643 --> 00:05:26.641
이게 이것들이 하는 전부에요.

00:05:26.641 --> 00:05:32.274
좋아요, 그리고 divideBy5가 있죠.

00:05:32.274 --> 00:05:36.173
이게 그 코드죠.

00:05:36.173 --> 00:05:39.416
아 다음 사람한테 묻는다는 걸 해버렸네요, 좋아요.

00:05:39.416 --> 00:05:42.850
다음 라인은 Charles입니다.

00:05:42.850 --> 00:05:46.513
Charles: 네, 우린 변수 reduce를 선언해요.

00:05:46.513 --> 00:05:48.551
Will Sentance: 한 번 더 언급하자면요 여러분,

00:05:48.551 --> 00:05:50.117
우린 이걸 그냥 함수 선언이라고 하기로 했어요.

00:05:50.117 --> 00:05:52.234
이걸 그렇게 다르게 생각할 필요가 없어요.

00:05:52.234 --> 00:05:54.133
이 코드를 저장했어요. reduce를요.

00:05:54.133 --> 00:05:55.521
훌륭해요, 고마워요, Chalres.

00:05:55.521 --> 00:05:56.609
David, 다음 라인이요.

00:05:56.609 --> 00:05:59.879
David: runFunctionOnInput이라는 함수를 선언해요.

00:05:59.879 --> 00:06:05.048
Will Sentance: 너무 좋아요,
이건 runFunctionOnInput이죠.

00:06:05.048 --> 00:06:06.423
이렇게죠.

00:06:06.423 --> 00:06:09.509
그리고 이건 실제로 2개의 parameter를 가지죠.

00:06:09.509 --> 00:06:10.798
원하는대로 부를 수 있어요.

00:06:10.798 --> 00:06:19.215
2개예요.
첫 번째  것은 두 번째 것의 실행 시의 입력이죠.

00:06:19.215 --> 00:06:22.667
만약 그래서 이걸 전달받으면, 첫 번째 입력이 숫자일거고,

00:06:22.667 --> 00:06:27.318
두 번째가 함수면, 그 안을 보세요. 끝에, 두 번째를 가지고

00:06:27.318 --> 00:06:29.174
실행 할 때 첫 번째 걸로 실행하죠.

00:06:29.174 --> 00:06:33.029
이게 두 가지를 하나로 조합해내는 아주 효과적인 방법입니다.

00:06:33.029 --> 00:06:34.901
그리고 그것의 출력을 반환하죠.

00:06:34.901 --> 00:06:39.783
얼마나 reduce가 유연한지 아셔야해요.
대신 숫자에 대한 배열을 가지고,

00:06:39.783 --> 00:06:44.265
어떤 숫자인지는 모른 채로 그걸 결합하면,

00:06:44.265 --> 00:06:48.207
숫자에 대한 배열을 쓴다고 가정하는거예요.

00:06:48.207 --> 00:06:49.788
간단히 스스로 상기시켜보죠.

00:06:49.788 --> 00:06:54.868
이렇게 해도 상관없는거예요.
[1, 2, 3]을 가지고,

00:06:54.868 --> 00:07:00.157
숫자 0을 가지고, 이 2개를 더하기로 조합하거나

00:07:00.157 --> 00:07:05.966
함수와 숫자를 가져와서 조합하여 두 가지를

00:07:05.966 --> 00:07:11.462
reduce를 하기 위한 규칙으로 조합하는거죠.
두 개를 하나로 만들기 위해서요.

00:07:11.462 --> 00:07:16.579
이걸 실행하고, 이걸 실행해서 숫자를 얻는거예요.
뭐가 되도 상관없어요.

00:07:16.579 --> 00:07:19.776
이것만 알면 다 되는겁니다.
어떻게 조합할지에 대한 규칙으로

00:07:19.776 --> 00:07:23.630
전달해서 아무 타입의 두 가지를 하나로 만들어내는거죠.

00:07:23.630 --> 00:07:28.305
그리고 그 하나를 다음 요소와 조합하게 될거구요.

00:07:28.305 --> 00:07:29.651
이게 전부예요.

00:07:29.651 --> 00:07:31.523
아무 타입이나 하나를 여러분들이
전달한다고 하면,

00:07:31.523 --> 00:07:35.109
이번 경우엔 두 번째인데, 이건 실제로 함수죠, 
첫 번째 것으로 실행하고

00:07:35.109 --> 00:07:37.696
결과를 만든 뒤, 그걸 buildingUp에 반환하죠.

00:07:37.696 --> 00:07:41.253
아무 상관없어요.
정말 대단한 함수입니다.

00:07:41.253 --> 00:07:46.206
분명 이 reduce에 대한 과정을 깊이 있고, 일반화시켜서 만든

00:07:46.206 --> 00:07:51.014
대단한 사람들이 있을거예요.

00:07:51.014 --> 00:07:53.832
장담하는데, 분명 그럴거예요.

00:07:53.832 --> 00:07:56.014
분명 있을겁니다. 좋아요.

00:07:56.014 --> 00:07:57.677
잠깐만요, Sam.

00:07:57.677 --> 00:07:58.605
제가 꼭 해낼께요.

00:07:58.605 --> 00:08:00.370
좋아요.

00:08:00.370 --> 00:08:01.526
꼭 해낼겁니다.

00:08:01.526 --> 00:08:03.550
자 이제 준비 다 됐어요.

00:08:03.550 --> 00:08:08.170
이제, 마지막 라인입니다. Eric,
left-hand 영역은 뭐라고 나와있죠?

00:08:08.170 --> 00:08:09.817
Eric: output을 만들어요.

00:08:09.817 --> 00:08:11.195
Will Sentance: 좋아요.

00:08:11.195 --> 00:08:12.212
Eric: 아직 값은 갖지 않지만요.

00:08:12.212 --> 00:08:15.570
Will Sentance: 네.
Eric: 하지만 그건 reduce의 실행이 될거예요.

00:08:15.570 --> 00:08:17.057
Will Sentance: 잘했어요, Eric.

00:08:17.057 --> 00:08:23.325
자 그럼, array로 처리되는 reduce로 가보죠.

00:08:23.325 --> 00:08:28.645
다른 데이터의 배열과는 다른거죠.

00:08:28.645 --> 00:08:35.520
이번엔 각각의 함수로 이뤄진 배열입니다. 그건 뭐죠, Eric?

00:08:35.520 --> 00:08:39.394
Eric: [multiplyBy2, add3, divideBy5]입니다.

00:08:39.394 --> 00:08:42.630
Will Sentance: divideBy2죠. 좋아요.

00:08:42.630 --> 00:08:48.347
그리고, howToCombine을 채워줄 함수죠.

00:08:48.347 --> 00:08:51.932
그리고 그건 2개의 입력으로 실행될거예요.

00:08:51.932 --> 00:08:54.848
그게 지금은 뭘로 되어있죠, Eric?

00:08:54.848 --> 00:08:56.163
Eric: runFunctionOnInput이요.

00:08:56.163 --> 00:09:01.180
Will Sentance: runFunctionOnInput이죠. 이겁니다.

00:09:01.180 --> 00:09:06.100
그리고 마지막이요, 첫 번째 함수와 조합될 건

00:09:06.100 --> 00:09:08.330
뭐죠 Eric?

00:09:08.330 --> 00:09:09.880
Eric: buildingUp이요.
Will Sentance: buldingUp인데,

00:09:09.880 --> 00:09:11.020
그 값이 뭐죠?

00:09:11.020 --> 00:09:11.628
Eric: 11이요.

00:09:11.628 --> 00:09:15.720
Will Sentance: 11이죠, 좋아요. 함수를 실행하죠.

00:09:15.720 --> 00:09:20.510
우린 새로운 뭘-?
Charles [웃음], 여러분 모두요.

00:09:20.510 --> 00:09:23.443
새로운-
학생들: Execution Context요.

00:09:23.443 --> 00:09:25.842
Will Sentance: 좋아요.

00:09:25.842 --> 00:09:28.640
너무 앞서서, Chalres가 먼저
Execution이라고 말해버렸어요.

00:09:28.640 --> 00:09:30.550
좋아요.

00:09:31.550 --> 00:09:32.450
크게 그리죠.

00:09:32.450 --> 00:09:34.012
이게 중요하니까 크게 할께요.

00:09:37.267 --> 00:09:38.436
Will Sentance: 좋아요, 충분하겠네요.

00:09:45.304 --> 00:09:46.420
Will Sentance: 뭔가 항상 비뚤어요.

00:09:46.420 --> 00:09:50.410
뭔가 제 마음이 비뚤어져서 그런가봐요.

00:09:50.410 --> 00:09:51.557
전보다 조금 나아졌나요?

00:09:51.557 --> 00:09:52.505
학생: 네.

00:09:52.505 --> 00:09:54.060
Will Sentance: 이번엔 좀 나아졌죠?

00:09:56.300 --> 00:09:59.500
좋아요, 사실 얼마나 길어질지 몰라서 밑에는 그냥 둘께요.

00:09:59.500 --> 00:10:04.600
Local Memory로 가보죠.
Local Memory로 가봅시다.

00:10:06.240 --> 00:10:10.920
첫번째는 뭐죠?

00:10:10.920 --> 00:10:12.382
Andrew,
Andrew: array요.

00:10:12.382 --> 00:10:14.811
Will Sentance: array죠, 그건 뭐죠?

00:10:14.811 --> 00:10:17.962
Andrew: [multiplyBy2, add3, divideBy5]요.

00:10:17.962 --> 00:10:22.643
Will Sentance: 좋아요, 고마워요. 잠시만요.

00:10:22.643 --> 00:10:26.940
[multiplyBy2, add3, divideBy5]죠.

00:10:26.940 --> 00:10:29.767
전 이게 얼마나 특별한지에 대해서는 아직 생각하지 않을거예요.

00:10:29.767 --> 00:10:31.509
그냥 함수의 목록이죠.

00:10:31.509 --> 00:10:35.978
하지만, 입력과 출력을 언급하지 않아도 되는 멋진 이름들이

00:10:35.978 --> 00:10:37.055
나열되었어요.

00:10:37.055 --> 00:10:39.510
굉장히 좋은 이름이예요.

00:10:39.510 --> 00:10:40.450
잠시 뒤에 보겠습니다.

00:10:40.450 --> 00:10:43.448
아주 중요해요. 특별한 점이고

00:10:43.448 --> 00:10:46.271
Functional Programming에서 되게 중요한 부분이 될겁니다.

00:10:46.271 --> 00:10:50.291
좋아요, 이제, 배열을 받았고, 이제 우린 첫번째를 시작으로

00:10:50.291 --> 00:10:54.328
어떻게 조합할 건지에 대한 규칙을 필요로 하죠.

00:10:54.328 --> 00:10:57.548
그건 howToCombine이라는 parameter고,

00:10:57.548 --> 00:11:00.049
이 규칙은 뭐가 되죠, Michael?

00:11:00.049 --> 00:11:01.680
Michael: runFunctionOnInput이요.

00:11:01.680 --> 00:11:06.729
Will Sentance: 정확해요. howToCombine은

00:11:06.729 --> 00:11:13.110
runFunctionOnInput이 될거예요.

00:11:13.110 --> 00:11:20.770
그리고 이건 2개의 입력을 가질 거예요. 2개의 argument죠. 
2개의 parameter겠죠.

00:11:20.770 --> 00:11:23.740
input은 이게 실행될 때,

00:11:23.740 --> 00:11:25.750
처리될 buildingUp값이겠죠.

00:11:25.750 --> 00:11:30.360
그리고 두 번째는 fn이고 이건

00:11:30.360 --> 00:11:35.830
배열의 0번째에 있는 함수로 채워지겠죠. 그럼 그게 뭐죠 여러분?

00:11:35.830 --> 00:11:36.920
multiplyBy2죠.

00:11:36.920 --> 00:11:41.820
그리고 이 함수는 input인 11이고
multiplyBy2가 넘어와 실행되죠.

00:11:41.820 --> 00:11:45.169
이것들이 input과 fn으로 들어오는거예요.

00:11:45.169 --> 00:11:48.814
그리고 나서, multiplyBy2랑 그 안에

00:11:48.814 --> 00:11:50.537
11을 넣어서 실행하죠.

00:11:50.537 --> 00:11:51.324
잠시 뒤에 보게 될 거예요.

00:11:51.324 --> 00:11:58.277
일단 지금은, 네, input으로 fn을 실행하겠죠. 이렇게요.

00:11:58.277 --> 00:12:01.547
마지막 parametet와 argument는 뭐죠?

00:12:01.547 --> 00:12:04.130
Bivanesh: buildingUp이란 parameter가
11이란 값이 됩니다.

00:12:04.130 --> 00:12:07.309
Will Sentance: 환상적이예요. 아주 좋은 의사소통이었어요.
그겁니다.

00:12:08.840 --> 00:12:13.122
이제 여길 Local Memory로 칩시다.

00:12:13.122 --> 00:12:17.445
이렇게요. 이게 우리가
필요한 모든 것이 있는 Local Memory예요.

00:12:20.439 --> 00:12:23.820
Will Sentance: 좋습니다. 이제 for-loop으로 들어가죠.

00:12:23.820 --> 00:12:27.033
i의 값은요, Jasmine? i의 값이요.

00:12:27.033 --> 00:12:31.857
네, 좋아요 0이죠.

00:12:31.857 --> 00:12:34.180
array의 0번째 위치죠.

00:12:34.180 --> 00:12:37.990
두 가지 중 첫 번째 반은요, 두 가지 중 첫 번째는요.

00:12:37.990 --> 00:12:39.700
이걸 한 개로 줄일겁니다.

00:12:40.840 --> 00:12:44.506
array의 0번째는 뭐죠, Jasmine?

00:12:44.506 --> 00:12:47.619
multiplyBy2죠, 뭔지 알죠,
아 죄송해요. Jasmine.

00:12:47.619 --> 00:12:49.190
여기에 다 쓸께요.

00:12:49.190 --> 00:12:53.090
실제로 우리가 뭘 하는 지 따라가보죠.

00:12:53.090 --> 00:13:01.344
howToCombine은
buildingUp과, array의 0번째 위치로 돌죠.

00:13:01.344 --> 00:13:07.056
자 이게 뭘로 되냐면 Jasmine이 말한대로겠죠.

00:13:07.056 --> 00:13:12.230
여긴 제가 제일 좋아하는 부분이예요.

00:13:12.230 --> 00:13:17.154
학생들: [웃음]
Will Sentance: 배열의 0번째 위치는

00:13:17.154 --> 00:13:18.985
뭐가 되죠, Jasmine?

00:13:18.985 --> 00:13:19.824
Jasmine: multiplyBy2요.

00:13:19.824 --> 00:13:22.402
Will Sentance: multiplyBy2죠.

00:13:22.402 --> 00:13:25.271
우린 이제 너무 익숙하죠,
이 시점에서, 이건 우리가 조합할 숫자

00:13:25.271 --> 00:13:27.418
또는 뭔가로 보이나요?

00:13:27.418 --> 00:13:31.720
아니죠, 이건 함수예요.
그리고 이건 뭐랑 조합되죠, Jasmine?

00:13:31.720 --> 00:13:32.340
Jasmine: 11이요.

00:13:32.340 --> 00:13:33.065
Will Sentance: 11이죠.

00:13:33.065 --> 00:13:37.980
자 그리고 이걸 howToCombine에다
넣을건데 그게 뭐죠, Jasmine?

00:13:37.980 --> 00:13:38.509
Jasmine: runFunctionOnInput이요.

00:13:38.509 --> 00:13:45.820
Will Sentance: runFunctionOnInput이죠.
이 안으로 들어갑시다.

00:13:47.840 --> 00:13:55.446
11이 multiplyBy2에 삽입될거예요.
저 11이요.

00:13:55.446 --> 00:14:00.629
그리고 multiplyBy2를 가지고 들어가서,
multiplyBy2를 가지고 실행하는데

00:14:00.629 --> 00:14:04.060
11로 하는거죠. 이렇게요.

00:14:04.060 --> 00:14:08.990
이렇게 생각하실 수 있어요.
"잠깐, 왜 이 함수를 그렇게 할 수 없지?"

00:14:08.990 --> 00:14:11.388
음, 이 함수는 아주 일반적이여야 해요.

00:14:11.388 --> 00:14:13.397
그냥 2가지를 하나로 조합하는거죠.

00:14:13.397 --> 00:14:16.950
그리고, 이 함수 내에서 우리가 그걸 조합하는 방법에 대해
고민하는 건 우리에게 달려있는거구요.

00:14:16.950 --> 00:14:18.560
그래서 howToCombine인거예요.

00:14:18.560 --> 00:14:22.280
여러분들은 2개의 숫자를 더하는 식으로 조합할 수 있어요.
여러분들이 원하는 조합 어떤 거든지요.

00:14:22.280 --> 00:14:25.189
우린 여기서 함수를 조합하고 숫자를 추가하죠.
그 2개를 모두 가져오죠.

00:14:25.189 --> 00:14:28.376
그리고 그 안에서 우린 저 숫자로 함수를 실행하죠.

00:14:28.376 --> 00:14:29.560
이게 두 가지로부터 하나로 줄이는 방법이예요.

00:14:29.560 --> 00:14:30.640
그리고 그걸 반환해내죠.

00:14:30.640 --> 00:14:35.112
multiplyBy2는 뭘 주냐면.

00:14:35.112 --> 00:14:39.777
Seth, 11을 입력으로 가지는 multiplyBy2가 뭘 주죠?

00:14:39.777 --> 00:14:41.693
Seth: 22요.
Will Sentance: 22죠.

00:14:41.693 --> 00:14:46.657
그리고, 그게 input을 11로
array의 0번째를 multiplyBy2로 갖는

00:14:46.657 --> 00:14:50.853
howToCombine의 결과가 될 겁니다.

00:14:50.853 --> 00:14:53.642
결국 그 말은 22가 나올거고,

00:14:53.642 --> 00:14:57.087
어떤 값이 갱신되죠, Virginia?

00:14:57.087 --> 00:15:01.812
우린 어떤 값을 갱신할거예요.
실행된 howToCombine의 결과값으로요.

00:15:01.812 --> 00:15:05.719
함수를 11로 실행하고 22로.

00:15:05.719 --> 00:15:07.850
아 죄송해요. 11에 multiplyBy2를 하죠.

00:15:07.850 --> 00:15:12.305
그래서 22를 가지고,
그걸 반환해서 그게 뭐에 할당되죠, Virginia?

00:15:12.305 --> 00:15:14.802
Virginia: [웅얼웅얼]
Will Sentance: 어디에 들어가죠, Seth?

00:15:14.802 --> 00:15:15.345
Seth: buildingUp이요.

00:15:15.345 --> 00:15:21.940
Will Sentance: buldingUp으로 들어가죠.

00:15:21.940 --> 00:15:25.480
우린 buidlingUp을 22로 갱신하죠.

00:15:25.480 --> 00:15:30.930
여기 이거죠 여러분, buildingUp이 계속 처리되죠.

00:15:30.930 --> 00:15:35.178
for-loop의 매 회차마다, 여러분들이 이거 때문에 놓칠까봐 그런데,

00:15:35.178 --> 00:15:39.331
매번 우리가 for-loop을 돌 때마다,
우린 buildingUp을 가지고, right-hand 영역을 먼저 처리해요.

00:15:39.331 --> 00:15:42.764
우린 buildingUp에 들어있는 값이 뭐든 간, 지금은 11이죠.

00:15:42.764 --> 00:15:45.762
그걸 multiplyBy2에 input으로 던져서 실행하죠.

00:15:45.762 --> 00:15:49.060
결국 multiplyBy2를 11로 던져서 22를 얻고 반환하죠.

00:15:49.060 --> 00:15:53.150
그리고 같은 라인에서 buildingUp의 값을 갱신하죠.

00:15:53.150 --> 00:16:00.363
여러분들 혹시 이런거 보셨나요. num = num + 2;

00:16:00.363 --> 00:16:02.649
이 수학이 말하는 모든게 뭐죠?

00:16:02.649 --> 00:16:04.897
여러분들은 처음 코드를 배웠을 때 기억나요?

00:16:04.897 --> 00:16:09.468
여기서 =은 동등을 말하는 게 아니라 할당을 말하는거죠.

00:16:09.468 --> 00:16:11.458
right-hand 영역을 처리하죠.

00:16:11.458 --> 00:16:15.463
만약 지금 num이 음 만약 3이라면, 3 + 2가 되고,

00:16:15.463 --> 00:16:17.309
이제 num이 5가되죠.

00:16:17.309 --> 00:16:20.280
저 값이 갱신되죠. 절대 이걸로 헷갈리면 안돼요.
여러분들은 이걸 보고

00:16:20.280 --> 00:16:22.859
"잠깐, 어떻게 buildingUp이 양 쪽에 다 있지?" 할 수 있죠.

00:16:22.859 --> 00:16:25.389
저 라인의 시작점에서 buildingUp을 가지고

00:16:25.389 --> 00:16:28.777
여러분들이 작업을 하죠.
그리고 Global의 buildingUp을 갱신하는거예요.

00:16:28.777 --> 00:16:33.695
그럼 이걸 또 다음 라인에서 사용하겠죠.

00:16:33.695 --> 00:16:37.491
Virginia, 이제 i는 0이 아니죠.
이번 회차에 i는 뭐죠?

00:16:37.491 --> 00:16:40.305
Virginia: 1이요.
Will Sentance: 1이죠, 맞았어요.

00:16:40.305 --> 00:16:41.288
i는 1입니다.

00:16:41.288 --> 00:16:44.198
좋아요, Sam, array의 1번째 위치와

00:16:44.198 --> 00:16:50.130
buildingUp 2개가 조합되길 원하죠.
그럼 그 2개가 뭐죠 Sam?

00:16:50.130 --> 00:16:52.761
Sam: add3랑-
Will Sentance: add3랑,

00:16:52.761 --> 00:16:54.030
맞았어요, 고마워요.

00:16:54.030 --> 00:16:55.238
Sam: 22요.

00:16:55.238 --> 00:16:58.003
Will Sentance: 그리고 22죠.
이게 buildingUp의 새로운 값이죠.

00:16:58.003 --> 00:17:01.645
이게 전달되었고, buildingUp의 값이 갱신된거죠.

00:17:01.645 --> 00:17:04.890
그래서 loop를 돌아와서 이제 22를 던지는거죠.

00:17:06.180 --> 00:17:10.430
그리고 이제 우린 이걸 어떤
조합 규칙을 사용해서 조합하죠, Sam?

00:17:10.430 --> 00:17:13.479
Sam: runFunctionOnInput이요.
Will Sentance: runFunctionOnInput이죠.

00:17:13.479 --> 00:17:18.543
그리고 이 안으로 가서 이 함수의 실행으로 가서

00:17:18.543 --> 00:17:23.890
우린 22랑, array의 1번째 위치는 add3죠.

00:17:23.890 --> 00:17:26.420
우린 이것들을 가지고 와서 실행하죠.

00:17:26.420 --> 00:17:29.471
그럼 우리가 이 안에서 실행하는게 뭐죠, Seth?

00:17:29.471 --> 00:17:32.575
Will Sentance: 우리가 실행하는건-
Seth: add3에-

00:17:32.575 --> 00:17:33.908
Will Sentance: 그거에?

00:17:33.908 --> 00:17:34.490
Seth: 22요.

00:17:34.490 --> 00:17:35.918
Will Sentance: 22를 넣죠.

00:17:35.918 --> 00:17:37.277
이거죠.

00:17:37.277 --> 00:17:43.125
22로 add3를 하죠. 그럼 25를 받아요.

00:17:43.125 --> 00:17:46.918
그리고 그걸 반환하죠.

00:17:46.918 --> 00:17:50.838
기억하세요. 우리가 할 수 있는 건 이 함수를 가지고 2가지를 취해서

00:17:50.838 --> 00:17:55.629
어떤 방식으로 그 안엔서 이걸 조합하는거예요.
이번 경우엔 하나를 다른 하나로 실행해서

00:17:55.629 --> 00:17:58.194
하나를 만들어내고 그걸 반환하는거죠.

00:17:58.194 --> 00:18:02.369
그리고, 우리가 그 반환된 값을 가지고 어디에 저장하죠, Sam?

00:18:02.369 --> 00:18:02.990
Sam: buildingUp에요.

00:18:02.990 --> 00:18:04.626
Will Sentance: buildingUp에 넣죠.

00:18:07.231 --> 00:18:10.685
Will Sentance: 그리고 buildingUp은 25가 되죠.

00:18:10.685 --> 00:18:12.241
그러나 아직 끝나지 않았어요.

00:18:12.241 --> 00:18:15.269
i는 2죠, i가 2로 할당되죠.

00:18:15.269 --> 00:18:19.895
죄송해요. 2랑 동등해진게 아니예요.
이제 i의 값이 2죠.

00:18:19.895 --> 00:18:21.820
아주 긴 Execution Context네요.

00:18:21.820 --> 00:18:24.742
이제 i가 2죠 이번엔.

00:18:24.742 --> 00:18:29.081
array의 2번째 위치가 뭐죠, Jasmine?

00:18:29.081 --> 00:18:30.630
Jasmine: divideBy5요.
Will Sentance: divideBy5죠.

00:18:30.630 --> 00:18:33.626
그래서 우린 25를 얻었고, 이제 5로 나눠보죠.

00:18:33.626 --> 00:18:41.374
왜냐하면 이제 buildingUp이 25니까요.
25랑 divideBy5를 쓰고

00:18:41.374 --> 00:18:44.236
이제 이것들을 조합하기 위한 규칙이 뭐죠 Jasmine?

00:18:44.236 --> 00:18:46.332
뭐가 실행되어 이것들을 조합하죠?

00:18:46.332 --> 00:18:48.885
Jasmine: runFunctionOnInput이요.
Will Sentance: runFunctionOnInput이죠.

00:18:48.885 --> 00:18:49.495
맞았어요.

00:18:49.495 --> 00:18:53.590
runFunctionOn, 이걸 약간 줄여서 쓸께요.
하지만 이건 runFunctionOnInput입니다.

00:18:53.590 --> 00:18:56.364
이것의 결과는 어디에 저장되죠, Bivanesh?

00:18:59.520 --> 00:19:01.745
Bivanesh: 함수 내에요.

00:19:01.745 --> 00:19:03.007
buildingUp이요.

00:19:03.007 --> 00:19:06.129
Will Sentance: buildingUp이죠. 맞았어요.
buildingUp에 가죠.

00:19:06.129 --> 00:19:08.638
맞았어요. Bivanesh, buildingUp으로 가죠.

00:19:08.638 --> 00:19:10.964
이 안으로 가죠.

00:19:10.964 --> 00:19:14.819
이 안에서 실행되는 것들은요.

00:19:14.819 --> 00:19:16.493
두 번째는가

00:19:16.493 --> 00:19:17.381
첫 번째로 처리되죠, 그렇죠?

00:19:17.381 --> 00:19:18.931
그냥 좀 더 확실히 하는거예요.

00:19:18.931 --> 00:19:23.744
이걸 취해서, 2개를 숫자와,

00:19:23.744 --> 00:19:27.760
이번 경우엔 함수죠.
그리고 두 번째로 첫 번째를 실행하죠.

00:19:27.760 --> 00:19:29.666
그래서 이 안에서 실행할 게 뭐죠, Bivanesh?

00:19:29.666 --> 00:19:30.712
Bivanesh: 그걸로 divideBy5를 실행해요.

00:19:30.712 --> 00:19:35.323
Will Sentance: 좋아요, divideBy5죠. 입력은 25고,
5를 반환하고

00:19:35.323 --> 00:19:39.238
그 이 입력으로 실행한 함수의 반환을 얻죠.

00:19:39.238 --> 00:19:42.555
이 안에서 두 개를 하나로 조합했어요.

00:19:42.555 --> 00:19:44.864
우린 이것들을 더함으로써도 조합할 수 있죠.
그것이 우리가 하는 작업이지만,

00:19:44.864 --> 00:19:46.326
숫자에 함수를 추가할 수는 없죠.

00:19:46.326 --> 00:19:50.388
그 대신 우린 숫자로 함수를 실행했었고,
이걸 뒤집어 써야했었네요.

00:19:50.388 --> 00:19:54.319
이거 좀 이상합니다.
우린 이 함수를 가지고 buildingUp으로

00:19:54.319 --> 00:19:58.598
실행해서 얻은 결과를 buildingUp에 저장할거죠.

00:19:58.598 --> 00:20:02.265
이렇게요.

00:20:02.265 --> 00:20:04.513
그리고 마지막 buildingUp의 값은,

00:20:04.513 --> 00:20:08.019
for-loop이 끝났고, array의 길이는 3이니까요.

00:20:08.019 --> 00:20:12.946
지금 i는 2고 이제 3가되니까 for-loop에서 짤렸죠.

00:20:12.946 --> 00:20:17.695
마지막 라인입니다. Alex, 함수를 입력 값과

00:20:17.695 --> 00:20:21.840
하나씩 조합하는 reduce 함수는요?

00:20:21.840 --> 00:20:26.094
runFunctionOnInput의 도움으로요.
마지막 라인의 반환값은 뭐죠, Alex?

00:20:26.094 --> 00:20:27.661
Alex:  5가 output에 할당됩니다.

00:20:27.661 --> 00:20:31.980
Will Sentance: 완벽한 기술적 의사소통이었습니다.

00:20:31.980 --> 00:20:36.991
반환값은 buildingUp이고

00:20:36.991 --> 00:20:42.361
그건 숫자 5이고 방금 말한대로 output에 저장됐죠.

00:20:42.361 --> 00:20:48.449
여러분, 이것은 우리가 코드를 작성하는 방법을 바꾸고

00:20:48.449 --> 00:20:53.030
Functional Programming의 본질이 될겁니다.