WEBVTT

00:00:00.113 --> 00:00:04.131
Will Sentance: 배열, 객체, 함수들은
접근할 수 있는 메소드가 있어요.

00:00:04.131 --> 00:00:07.266
그 말은 배열, 객체, 함수 자체에
사용 가능한 함수가 있단거죠.

00:00:07.266 --> 00:00:09.185
이걸 보세요.

00:00:09.185 --> 00:00:11.093
[1, 2, 3]을 array로 저장하죠.

00:00:11.093 --> 00:00:13.783
그리고 우린 저기에 붙은 메소드를 실행할 수 있어요.

00:00:13.783 --> 00:00:18.350
그리고 Push라는 함수는 어떻게든 [1, 2, 3]에서 접근이 되죠.

00:00:18.350 --> 00:00:22.089
뭐 숫자 10을 저 배열에 추가하기 위해서요.

00:00:22.089 --> 00:00:23.308
그럼 저게 어디 저장되어있죠?

00:00:23.308 --> 00:00:26.042
혹시 여러분들이 OOP Hard Parts 강의를 수강했다면,

00:00:26.042 --> 00:00:27.502
여러분들은 이걸 모두 알고 있을거예요.

00:00:27.502 --> 00:00:30.203
혹시 OOP Hard Parts 강의를
수강하신 분은 손 들어보실래요?

00:00:30.203 --> 00:00:36.588
좋아요, 나머지 분들은 새로울 거예요.
여기에 끼워서 쓸게요.

00:00:36.588 --> 00:00:41.606
여기에 끼워넣어 볼께요.
파란 펜을 써야겠군요.

00:00:41.606 --> 00:00:45.788
여기에 넣어볼께요, 아 핑크색을 좀 쓸까요.

00:00:45.788 --> 00:00:49.863
그럼, 첫 번째 라인입니다. Seth.
저기 간단해보이는 첫 번째 라인은 뭘 하는거죠?

00:00:49.863 --> 00:00:53.566
Seth: const로 array를 선언하고 그 값은 배열이예요.

00:00:53.566 --> 00:00:58.543
Will Sentance: 정확해요, 좋아요.
여기에다가 이어 쓸께요.

00:00:58.543 --> 00:01:05.744
이제 만약, array.push(10)을 한다면,

00:01:12.362 --> 00:01:14.056
Will Sentance: JavaScript는 찾아볼거예요.

00:01:14.056 --> 00:01:15.925
이 array를 보고, 이게 대체 뭐야? 하고요.

00:01:15.925 --> 00:01:16.987
그래서 여기로 가서 찾아볼거예요.

00:01:23.564 --> 00:01:25.564
Will Sentance: 여기로 가서 이걸 찾겠죠.
그리고 찾았죠.

00:01:25.564 --> 00:01:28.047
여기서요. "오 이건 배열이구나" 하죠.

00:01:28.047 --> 00:01:32.150
왜 전 이걸 마치 객체처럼 . 으로 처리했을까요?

00:01:32.150 --> 00:01:34.179
혹시 왜 인지 아시는 분?

00:01:34.179 --> 00:01:35.671
학생: 그건 저게 객체니까요.

00:01:35.671 --> 00:01:36.342
Will Sentance: 음, 너무 쉬운데.

00:01:36.342 --> 00:01:39.188
학생: [웃음]
Will Sentance: [웃음] 천재네.

00:01:39.188 --> 00:01:40.510
여러분 모두요.

00:01:40.510 --> 00:01:45.035
알고보면, 여러분들이 배열이나 함수를 저장하는 순간

00:01:45.035 --> 00:01:51.412
그 내부에선, 또한 이걸 객체로 저장해요.

00:01:51.412 --> 00:01:54.275
. 표기법으로 접근이 가능한걸 객체죠.

00:01:54.275 --> 00:01:55.959
그래서 이걸 얻으면, 객체를 찾죠.

00:01:55.959 --> 00:01:58.674
그리고 이 객체에서 Push를 찾아요.

00:01:58.674 --> 00:02:00.558
오늘 이걸 하진 않을거라서

00:02:00.558 --> 00:02:03.669
음 게다가, 모든 배열에 동일한 push 함수의 복사본을

00:02:03.669 --> 00:02:04.513
갖고 싶지도 않을거구요.

00:02:04.513 --> 00:02:07.083
여기엔 Push 메소드가 저장되어있지 않아요.

00:02:07.083 --> 00:02:15.489
그 대신 우린 저장소를 가지고 있는데,

00:02:15.489 --> 00:02:18.297
오 아주 신기한 펜이네요.

00:02:18.297 --> 00:02:24.461
함수들의 저장소가 있어요.

00:02:24.461 --> 00:02:31.376
이건 배열이 저장되자마자 접근이 가능하죠.

00:02:31.376 --> 00:02:38.305
그리고 이건 아주 멋지고 유용한 함수로
가득 차 있는 객체입니다.

00:02:38.305 --> 00:02:39.779
그들 중 하나가 push죠.

00:02:39.779 --> 00:02:41.091
뭐 다른 건 뭐가 있죠?

00:02:41.091 --> 00:02:41.832
Jasmine?

00:02:41.832 --> 00:02:42.521
Jasmine: pop이요.

00:02:42.521 --> 00:02:43.291
Will Sentance: 네,

00:02:43.291 --> 00:02:44.772
근데 이건 일단 잠깐 홀드할께요.

00:02:44.772 --> 00:02:45.869
네, Sam?

00:02:45.869 --> 00:02:47.192
Sam: length요?

00:02:47.192 --> 00:02:49.688
Will Sentance: 그건 좀 아니예요. 완전 달라요.

00:02:49.688 --> 00:02:51.868
이것들을 우린 이미 다 봤어요.

00:02:51.868 --> 00:02:53.751
Sam: reduce랑 filter요.
Will Sentance: reduce랑 filter죠.

00:02:53.751 --> 00:02:57.997
좋았어요. reduce, filter예요.

00:02:57.997 --> 00:03:02.612
map도 여기에 다 있죠.

00:03:02.612 --> 00:03:08.342
이 객체에 다 저장되어 있어요.

00:03:08.342 --> 00:03:11.674
그리고 JavaScript는 모든 배열들에게
이걸 접근하도록 해줘요.

00:03:11.674 --> 00:03:15.417
여러분이 이것에 대해 모두 알고 싶다면,
그건 OOP Hard Parts를 들으시면 됩니다.

00:03:16.992 --> 00:03:19.308
Will Sentance: 최소한 기본 Hard Parts를 봐주세요.

00:03:19.308 --> 00:03:20.869
그래도 제가 제일 좋아하는거예요.

00:03:20.869 --> 00:03:25.653
이 강의는 OOP Hard Parts를 홍보하기 위한
아주 긴 밑밥깔기죠.

00:03:25.653 --> 00:03:27.189
사실 OOP Hard Parts라고 하면 안돼요.

00:03:27.189 --> 00:03:31.029
그건 Class와 Prototype이라고 불러야하고,
사람들도 그렇게 반응하는 것 같아요.

00:03:31.029 --> 00:03:33.484
더 이상 문제가 잘 안풀리면 말해주세요.

00:03:33.484 --> 00:03:37.469
아무튼, JavaScript가 .push를 배열에 호출하면,

00:03:37.469 --> 00:03:41.037
여기로 가서 찾고, 이 객체를 바라볼거예요.

00:03:41.037 --> 00:03:45.371
이 객체를 볼거예요.
근데 거기엔 push 메소드가 저장되어 있지 않죠.

00:03:45.371 --> 00:03:47.288
하지만 JavaScript는 포기하지 않죠.

00:03:47.288 --> 00:03:52.680
그 다음 숨겨진 속성인 __proto__를 봐요.

00:03:52.680 --> 00:04:00.187
그건 모든 배열들이 접근 가능한
이 공유된 객체의 링크죠.

00:04:00.187 --> 00:04:05.871
그냥 알고 계시면 되는건,
이 공유된 객체는 array.prototype이라고 해요.

00:04:05.871 --> 00:04:09.155
JavaScript에서 이 객체에 대한 label이예요.

00:04:09.155 --> 00:04:11.935
console.log로 가서
array.prototype을 하시면,

00:04:11.935 --> 00:04:14.513
여러분들은 함수들로
가득 찬 이 객체를 보게 될거예요.

00:04:14.513 --> 00:04:18.573
그 말은 우리가 push를 실행할 때,
JavaScript가 사용하려고 하는 건

00:04:18.573 --> 00:04:23.218
너무 대단한, 제 생각에 세 손가락 안에
꼽히는 좋은 기능인데,

00:04:23.218 --> 00:04:28.053
prototype 특성이죠, 그 기능의 의미는 만약 메소드를

00:04:28.053 --> 00:04:30.836
이 객체에서 찾지 못하면, 포기하지 않고

00:04:30.836 --> 00:04:35.108
이 숨겨진 속성으로 가서,
다음 체인으로 넘어가 찾는단거죠.

00:04:35.108 --> 00:04:37.018
그리고 이 모든 기능들을 쉽게 연결하게 되죠.

00:04:37.018 --> 00:04:41.182
그리고 push를 찾았죠. 그리고 그걸 가지고 사용하죠.

00:04:41.182 --> 00:04:45.510
그리고 여기 자동 삽입되는게..배열이 뭐죠?

00:04:45.510 --> 00:04:50.801
[1, 2, 3]은 이 함수에 해당 배열을 자동으로 삽입하죠.

00:04:50.801 --> 00:04:56.669
그래서 이 push 안에서 이 배열에 10이 추가될 수 있는거예요.

00:04:56.669 --> 00:05:00.504
좋아요, 그러면 이 구간의 전체의 결과값은,

00:05:00.504 --> 00:05:03.222
이건 [1, 2가 될-

00:05:03.222 --> 00:05:04.522
아 이거 아니죠.

00:05:04.522 --> 00:05:05.544
실제로 아니예요.

00:05:05.544 --> 00:05:08.790
실제로 push가 반환하는게 아니예요.

00:05:08.790 --> 00:05:10.127
두 번 다 그랬지만, 이건 아니예요.

00:05:10.127 --> 00:05:14.720
일단, [1, 2, 3]에 배열을 추가하고,

00:05:14.720 --> 00:05:17.805
이건 결국 [1, 2, 3, 10]이 되겠죠.

00:05:17.805 --> 00:05:21.088
잠시 다른 이야기였어요.
왜냐하면 여러분들과 이 사실을 이용하여

00:05:21.088 --> 00:05:22.797
좀 더 흥미로운 일을 하고 싶기 때문이죠.

00:05:22.797 --> 00:05:26.005
보시다시피, 객체에 저장된 배열의 메소드는

00:05:26.005 --> 00:05:30.395
. 표기법으로 배열을 참조할 때, 모든 배열에서 접근 가능합니다.

00:05:30.395 --> 00:05:33.038
OOP Hard Parts를 봐주세요.

00:05:33.038 --> 00:05:37.239
공유된 메소드들이 있는 객체로 가는 링크는
모든 배열의 숨겨진 객체에 있는

00:05:37.239 --> 00:05:39.293
__proto__ 속성입니다.

00:05:39.293 --> 00:05:42.204
좋아요, 솔직히 말하고 싶으신지 모르겠지만,

00:05:42.204 --> 00:05:45.137
여러분들이 물어볼 수 있는 흥미로운 질문들이 굉장히 많아요.

00:05:45.137 --> 00:05:51.838
하지만, 그건 다 OOP Hard Parts에 있으므로,
정말 궁금하지 않는 한,

00:05:51.838 --> 00:05:55.710
학생: 이게 꼭 JavaScript에 대한 답인지 모르겠지만,

00:05:55.710 --> 00:06:00.182
제가 말할 건, 배열을 처리할 때,

00:06:00.182 --> 00:06:03.469
새 배열을 만들고 수행하는 건가요?

00:06:03.469 --> 00:06:06.205
Will Sentance: 사용 방법에 따라 달라요.

00:06:06.205 --> 00:06:07.677
그렇게 하는 걸 한 번 보죠.

00:06:07.677 --> 00:06:09.867
고마워요, Charles, 총대를 잘 메줬어요.

00:06:09.867 --> 00:06:14.789
JavaScript는 모든 배열에서 접근 가능한
내장형 reduce가 있어요. 이거죠.

00:06:14.789 --> 00:06:19.859
우리 버전의 reduce를 상기해보면,
array인 [1, 2, 3]을 받았죠.

00:06:19.859 --> 00:06:23.668
그리고 함수를 받아서, 첫 번째 요소와 accumulator를

00:06:23.668 --> 00:06:24.672
조합할 겁니다.

00:06:24.672 --> 00:06:27.555
그 조합된 것의 결과를 가지고,

00:06:27.555 --> 00:06:29.356
다음 요소와 결합했죠.

00:06:29.356 --> 00:06:32.771
내장형에선, 배열이 첫번째 argument로서

00:06:32.771 --> 00:06:37.658
reduce 함수에 자동적으로 삽입됩니다.

00:06:37.658 --> 00:06:39.278
이걸 보세요. 이걸 봤죠.

00:06:39.278 --> 00:06:43.365
내장형과 유일하게 다른 게 저거죠.
써드릴께요.

00:06:43.365 --> 00:06:44.779
여기다가 쓸게요.

00:06:44.779 --> 00:06:49.056
만약 우리가

00:06:49.056 --> 00:06:53.816
[1, 2, 3].reduce를 했다면

00:06:53.816 --> 00:06:56.115
add는 조합하기 위한 함수고,

00:06:56.115 --> 00:06:58.726
0은 조합될 것이죠.

00:06:58.726 --> 00:07:03.098
그리고 여기로 가서 보죠. 
여기 [1, 2, 3]은

00:07:03.098 --> 00:07:08.860
접근 가능한 공유 객체가 있어요 여기에요.

00:07:08.860 --> 00:07:14.645
모든 배열이 그것의 객체의
숨겨진 __proto__ 속성을 통해 이를 수행하죠.

00:07:14.645 --> 00:07:18.061
여기를 찾아서 선택하죠. 이거겠죠.

00:07:18.061 --> 00:07:23.200
이 함수 코드를 가지고, 실행하기 시작하는데

00:07:23.200 --> 00:07:27.297
[1, 2, 3]을 자동으로 넣어줘요.
좋아요.

00:07:27.297 --> 00:07:28.531
전 이거에 머물고 싶지 않아요.

00:07:28.531 --> 00:07:31.885
어떤 키워드가 reduce 함수 내에서 . 표기법으로 왼쪽에

00:07:31.885 --> 00:07:35.651
접근 가능하게 해주는지 아나요? 아시는 분?

00:07:35.651 --> 00:07:38.493
이 함수는 JavaScript로 만들어졌으니까

00:07:38.493 --> 00:07:40.482
어떤 키워드를 사용하죠?
학생: this요.

00:07:40.482 --> 00:07:43.066
Will Sentance: this로 동작하죠. 정확해요. 정확합니다.

00:07:43.066 --> 00:07:48.324
하지만 바뀐 건 하나도 없어요.
완전 똑같아요. 계속 가죠.

00:07:48.324 --> 00:07:50.434
아 이 말을 해야하네요.
사실,

00:07:50.434 --> 00:07:53.010
우리는 다수의 내장된
Higher Order Function들을 가지죠.

00:07:53.010 --> 00:07:57.540
그 함수들은 map, forEach,
filter, flatMap, reduce,

00:07:57.540 --> 00:07:59.940
reduceRight, 모든 것들이 이 객체에 있죠.

00:07:59.940 --> 00:08:02.870
모든 배열은 이 객체에 접근 가능해요.

00:08:04.790 --> 00:08:10.743
이런 모든 Higher Order Function들은
배열의 각 요소를 순회해요.

00:08:10.743 --> 00:08:14.706
[1, 2, 3]이고, [1, 2, 3]을 하나씩 순회하죠.

00:08:14.706 --> 00:08:18.180
map은 이게 아니지만, 배열의 모든 요소를 순회하고

00:08:18.180 --> 00:08:19.478
그리고 각각에서 함수를 실행하죠.

00:08:19.478 --> 00:08:24.371
Chalres의 질문으로 다시 가보면, 결과나 배열을 붙이죠.

00:08:24.371 --> 00:08:29.741
reduce는 조합하기로 결정한 것과 그 결과를 조합해서 붙이죠.

00:08:29.741 --> 00:08:33.136
map은 새로운 함수, 아 새로운 배열이예요, 그건 그 안에 있구요.

00:08:33.136 --> 00:08:35.365
나중에 그것과 관련된 걸 볼 거예요.

00:08:35.365 --> 00:08:39.424
데이터의 불변성에 대해 말할겁니다.
Charles, 하지만 MDN이랑은 약간 달라요.

00:08:39.424 --> 00:08:44.193
MDN은 Mozila의 문서죠.  아까 Jasmine이 말했던 것 같아요.

00:08:44.193 --> 00:08:47.183
그 각 용법에 대한 안내서죠.

00:08:47.183 --> 00:08:52.055
이런 각가의 내장 함수들의 방식이 있죠.

00:08:52.055 --> 00:08:56.763
그리고 이 함수들의 집합에 "array.prototype" 이라는
label이 있다는 걸 알게 되셨길 바랍니다.

00:08:56.763 --> 00:08:58.687
"array.prototype" 이란 label 입니다.

00:08:58.687 --> 00:09:03.102
왜 MDN에서 array.prototype.reduce라고 하는지
이제 이해하죠.

00:09:03.102 --> 00:09:06.660
array.prototype.filter는 label이죠.
그닥 도움은 안돼요 그렇죠?

00:09:06.660 --> 00:09:10.585
여러분들이 그걸 보기 시작할 때,
그냥 reduce 함수를 원하는건데,

00:09:10.585 --> 00:09:12.846
Array.prototype.reduce는 뭐지? 할거예요.

00:09:12.846 --> 00:09:15.758
하지만 그건 내장된 reduce 함수가 있는 곳이죠.