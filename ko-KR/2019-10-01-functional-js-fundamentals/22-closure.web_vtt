WEBVTT

00:00:03.143 --> 00:00:08.252
Will Sentance: 그러나 그 모든 것은,
우리의 친구 Seth가 친절하게 물어본 것과 관련이 있어요

00:00:08.252 --> 00:00:14.860
즉, 코드 라인을 이름으로
나열할 수 있다는 목표는, 말하자면,

00:00:14.860 --> 00:00:20.700
여러분들이 하나 하나 그것들을
실행할 수 있다는 거죠. 맨 처음 입력을 11로요.

00:00:20.700 --> 00:00:26.523
그리고 그 첫번째 라인의 결과가 오직 영향을 미치는건,

00:00:26.523 --> 00:00:32.165
reduce의 특성으로 인해 오직 영향을 끼치는 건
그 다음 라인인 add3라는거죠.

00:00:32.165 --> 00:00:37.171
오직 그 다음 라인에만 영향을 끼칩니다. 알았죠.

00:00:37.171 --> 00:00:38.796
음 저는, 아, 그건 그렇고,

00:00:38.796 --> 00:00:43.617
바로 다음 라인에 영향이 미치는데, argument가 전혀 필요 없죠.

00:00:43.617 --> 00:00:49.124
reduce의 도움 아래 내부에서 자동적으로 함수가 실행됩니다.

00:00:49.124 --> 00:00:49.995
문제는,

00:00:49.995 --> 00:00:54.921
따라서, 함수에게 전달되는 입력을 제어할 수는 없는거죠.

00:00:54.921 --> 00:00:59.536
예를 들어, add3를 보면,
만약 add3가

00:00:59.536 --> 00:01:01.484
2개의 입력값을 기대한다면,

00:01:01.484 --> 00:01:06.967
근데 함수에 숫자를 추가하지 않았다고 가정하면,
큰 문제가 되겠죠.

00:01:06.967 --> 00:01:12.186
음, 우린 이런 문제를 앞의 반 동안 확인할거고,
그걸 해결할 겁니다.

00:01:12.186 --> 00:01:17.414
근데 그렇게 하려면, 먼저 생각해야 할 건,
우리가 아주 작은 함수 단위를

00:01:17.414 --> 00:01:21.700
기반으로 응용 프로그램을 구축한다면,

00:01:21.700 --> 00:01:24.878
그 기반으로 응용 프로그램이 구축된다면요.

00:01:24.878 --> 00:01:29.994
우리가 그들에게 대단한 능력을 줄 수 있다면 어떨까요?

00:01:29.994 --> 00:01:33.473
그것들을 가능한 강력하게 만들 수 있다면요?

00:01:33.473 --> 00:01:35.587
Closure는 그걸 가능하게 할겁니다.

00:01:35.587 --> 00:01:39.909
그건 Seth가 제기한 문제를 해결하도록 하는 데
아주 중요한 역할을 할거예요.

00:01:39.909 --> 00:01:43.325
그건 음 "잠깐, 만약 내가 함수의 목록을 가지고 있는데"

00:01:43.325 --> 00:01:47.018
"그 중 하나가 2개의 입력을 기대하고, 난 그 이전 라인의 결과값은"

00:01:47.018 --> 00:01:51.717
"오직 하나의 입력이라는 걸 내가 알 때,
어떻게 이걸 조절할 수 있을까" 하는거죠.

00:01:51.717 --> 00:01:56.116
나중에 알게 될 테지만, 그 함수를 미리 채우는거예요.

00:01:56.116 --> 00:02:01.012
작은 영구적인 메모리에 데이터 저장소가
붙어있는 함수가 필요해요.

00:02:01.012 --> 00:02:05.577
그리고 그 안에 함수의 다른 입력을 저장할 수 있는 거죠.

00:02:05.577 --> 00:02:10.230
그래서 실제로 그걸 한 번만 호출하는 거예요.

00:02:10.230 --> 00:02:12.893
이 개념들은 전부 Closure와 연관됩니다.

00:02:12.893 --> 00:02:14.362
그럼 시작해보죠.

00:02:14.362 --> 00:02:18.797
우리가 reduce를 공부했지만,
제 생각에 JavaScript에서 가장 난해한 개념이예요.

00:02:18.797 --> 00:02:19.597
아닐지도요.

00:02:19.597 --> 00:02:23.606
함수들을 우리의 단위로 사용하지만 제한적이다.

00:02:23.606 --> 00:02:28.020
매 실행 시마다 함수들은 이전의 실행을 잊어버리죠.

00:02:28.020 --> 00:02:32.606
특히, 매 실행 시마다, 이전에 실행했던 부분들을

00:02:32.606 --> 00:02:37.349
전부 잊어버리기 때문에,
특별한 전역 상태가 없는 한 별로인거죠.

00:02:37.349 --> 00:02:41.250
만약 함수들에게 영구적인 기억을 줄 수 있다면,

00:02:41.250 --> 00:02:42.844
우리가 뭘 할 수 있을지 상상해보세요.

00:02:42.844 --> 00:02:46.165
전 누군가가  이번 Functional Programming으로
어떤 도전을 하길 원합니다.

00:02:46.165 --> 00:02:49.504
그리고 전 그것에 대한 몇 가지 아이디어를 드릴거예요.

00:02:49.504 --> 00:02:55.696
일단 지금은, 함수가 실제로
어떻게 동작하는지 다시 되새겨 보죠.

00:02:55.696 --> 00:02:56.894
여기 multiplyBy2 함수가 있어요.

00:02:56.894 --> 00:02:58.291
실행하고, 한 번 더 하죠.

00:02:58.291 --> 00:03:03.769
여러분 모두가 다시 이 흐름을 되찾길 바라기 때문에,
이걸 다시 해볼거예요.

00:03:03.769 --> 00:03:05.314
multiplyBy2는 이 함수죠.

00:03:05.314 --> 00:03:09.866
입력을 7로 실행하면, 이 multiplyBy2의

00:03:09.866 --> 00:03:11.301
parameter는 뭐죠, Alex?

00:03:11.301 --> 00:03:11.831
Alex: inputNumber요.

00:03:11.831 --> 00:03:13.721
Will Sentance: inputNumber고,
그건 뭘로 채워지죠?

00:03:13.721 --> 00:03:15.398
Alex: 7이요.
Will Sentance: 7이죠, 좋아요.

00:03:15.398 --> 00:03:17.919
그리고 7x2는 14가 반환되어 output이 될겁니다.

00:03:17.919 --> 00:03:21.435
multiplyBy2를 다시 호출할 때, 이번엔 입력이 3이겠네요.

00:03:21.435 --> 00:03:26.993
그럼, 이전에 7로 실행했던 것에 대한
기록이 하나라도 있나요?

00:03:26.993 --> 00:03:30.305
절대 없죠. 왜 그런지 직접 결과를 써야하나요?

00:03:30.305 --> 00:03:31.384
다들 이해할거예요.

00:03:31.384 --> 00:03:33.981
이전 실행의 기록이 없죠.

00:03:33.981 --> 00:03:38.306
만약 우리가 함수에 영구적인 Memory를
줄 수 있다고 상상해보세요.

00:03:38.306 --> 00:03:43.013
이제 이건 아마, [웃음],
제가 자원봉사를 하는 소리 같아요.

00:03:43.013 --> 00:03:45.420
음, 이거에 대해 이야기를 하죠.

00:03:45.420 --> 00:03:49.318
일단 지금은, 우리가 함수에게 그들의 이전 실행을 기억하도록

00:03:49.318 --> 00:03:52.126
영구적인 메모리 공간을 준다면 어떨지 상상해보죠.

00:03:52.126 --> 00:03:56.334
이전 실행이요, 일단, 이 모든 건
함수로부터 함수가 반환되는 것에서부터 시작됩니다.

00:03:56.334 --> 00:03:57.889
지금, 여러분들이 Closure Hard Part를 들었다면,

00:03:57.889 --> 00:04:00.715
혹시 Hard Part의 Closure 파트를
보신 분 계시면 손 들어보실래요?

00:04:00.715 --> 00:04:01.223
Hard Part의 Closure요.

00:04:01.223 --> 00:04:01.886
네, 좋아요.

00:04:01.886 --> 00:04:03.835
전에 이걸 했었습니다.

00:04:03.835 --> 00:04:07.728
우린 강력한 Fucntional Programming의
테크닉을 위해 이걸 사용할겁니다.

00:04:07.728 --> 00:04:09.283
그걸 시작하려면, 이걸 알아야해요.

00:04:09.283 --> 00:04:13.062
그리고 이게 다죠, 함수로부터 반환되는 함수로 시작한다.

00:04:13.062 --> 00:04:16.223
어쩌면, 우린 지금 작은 동작들로
뭉쳐져 있는 함수들의 상위에 있기 때문에

00:04:16.223 --> 00:04:18.472
그냥 지나칠 수 있고, 우린 이걸 쉽게 찾을 수 있을 수도 있어요.

00:04:18.472 --> 00:04:21.912
하지만, 제가 작성한 다음 페이지의 코드를 보고

00:04:21.912 --> 00:04:24.564
화려한 엔지니어링 조직과,

00:04:24.564 --> 00:04:29.529
수석 엔지니어들도 실제로 여기서 무슨 일이 일어나고 있는지
정확히 모른다는 걸 알아두셔야 해요.

00:04:29.529 --> 00:04:32.633
이걸 우리가 직접 만들어가면서 보죠.

00:04:32.633 --> 00:04:37.411
함수를 저장할 건데, functionCreator라고 부를겁니다.

00:04:37.411 --> 00:04:41.978
입력이 없죠, 그리고 우린 이걸 실행할거고,
그 결과가 무엇이든간에

00:04:41.978 --> 00:04:47.032
generatedFunc로 저장할거고, 우린 이걸 한 번 실행하죠.

00:04:47.032 --> 00:04:52.617
우린 generatedFunc에 functionCreator를 저장하지 않죠.

00:04:52.617 --> 00:04:56.979
우린 functionCreator를 실행할 거고,
그것의 반환값이 뭐든지 간에

00:04:56.979 --> 00:05:00.612
뭐, 이미 여러분들은 그게 generatedFunc가
뭐가 될 지 추측하겠지만,

00:05:00.612 --> 00:05:03.471
그리고 그 다음 라인에서, 실행할거예요.

00:05:03.471 --> 00:05:08.094
음, 바라건대 generateFunc의 반환이 뭐든간에
하나의 함수일겁니다.

00:05:08.094 --> 00:05:11.932
그래서 우린 functionCreator에서 나온 함수에 대한

00:05:11.932 --> 00:05:15.876
새로운 label로 generatedFunc를 사용할거예요.

00:05:15.876 --> 00:05:20.936
제가 정말 강조하고 싶은건, 경력이 많은 엔지니어들 조차도,
항상 이런 코드를 보고

00:05:20.936 --> 00:05:26.240
이렇게 할거에요.
"generatedFunc는 functionCreator가 만든 거고"

00:05:26.240 --> 00:05:29.612
"오 그렇구나, functionCreator에 2를 넣는거구나."

00:05:29.612 --> 00:05:31.910
아니죠, 아니예요.

00:05:31.910 --> 00:05:34.300
이게 쉽게 이해되면 손들어주세요.

00:05:34.300 --> 00:05:37.443
여기에서 무슨 일이 일어나는지
본능적으로 이해가 되시는 분들

00:05:37.443 --> 00:05:38.175
손들어 주세요.

00:05:38.175 --> 00:05:39.768
네, 몇 분이 계시네요.

00:05:39.768 --> 00:05:43.872
놀랍지도 않아요. 전 정말로 제가 말했던
경력있는 엔지니어들을 봐왔어요.

00:05:43.872 --> 00:05:46.380
전 10년의 경력을 가진 엔지니어지만

00:05:46.380 --> 00:05:48.150
이거에 대해 헷갈려하는 사람이랑 이야기했었어요.

00:05:48.150 --> 00:05:51.425
아니죠, 우린 functionCreator를 한 번 실행함으로써

00:05:51.425 --> 00:05:53.772
뭐가 반환되든 그걸 generatedFunc로 저장해주고,

00:05:53.772 --> 00:05:57.230
여러분들이 이걸 다시 사용하기 전까지
다시는 functionCreator를 신경쓰지도 않죠.

00:05:57.230 --> 00:05:59.855
그리고 generatedFunc가 functionCreator에서
뭘 반환받았던지 간에

00:05:59.855 --> 00:06:04.144
아마도 그건 함수일거예요.