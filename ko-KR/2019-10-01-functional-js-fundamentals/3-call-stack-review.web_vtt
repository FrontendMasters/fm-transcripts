WEBVTT

00:00:00.200 --> 00:00:05.788
Will Sentance: 우리가 함수를 실행할 때,
함수를 호출할 때,

00:00:05.788 --> 00:00:07.728
함수를 부를 땐요.

00:00:07.728 --> 00:00:12.254
우린 이미 함수, multiplyBy2라고 하죠.
그것의 실행이 종료되면,

00:00:12.254 --> 00:00:14.150
어디로 돌아갈 지 알죠.

00:00:14.150 --> 00:00:18.009
전 이 페이지를 시각적으로 볼 수 있고,
내가 있던 곳으로 돌아가야 한다는 걸 알 수 있어요.

00:00:18.009 --> 00:00:20.180
JavaScript는 이걸 계속 추적할 필요가 있어요.

00:00:20.180 --> 00:00:23.088
사실, 우리가 호출하는 모든 함수를 다 추적하죠.

00:00:23.088 --> 00:00:26.896
컴퓨터는 이런 데이터를 저장하기 위해
Stack이라는 방법을 써요.

00:00:26.896 --> 00:00:31.857
데이터를 구조화하는 아주 유용한 방법이고,
접시를 쌓는 것 같은 거죠.

00:00:31.857 --> 00:00:34.668
특정 시간에 신경 쓰는 건 오직 제일 위의 접시죠.

00:00:34.668 --> 00:00:38.113
Stack 구조에선 아무 접시나 잡을 수 없고,
오직 제일 위에 1개만 가질 수 있어요.

00:00:38.113 --> 00:00:40.211
그 개념이 이 Call Stack이랑 비슷하죠.

00:00:40.211 --> 00:00:43.943
우리가 신경 쓸 건
지금 제일 위에 있는 거예요.

00:00:43.943 --> 00:00:50.187
우리가 이 라인에서
multiplyBy2 같은 함수를 실행할 때,

00:00:50.187 --> 00:00:56.845
우린 Call Stack의 제일 위에 이걸 추가하죠.
입력값이랑요.

00:00:56.845 --> 00:01:00.526
매번 우리가 함수를 실행할 때, Call Stack에 추가해요.

00:01:00.526 --> 00:01:03.872
그리고 매번 실행을 끝낼 때의 키워드가 있어요,
David,

00:01:03.872 --> 00:01:06.404
함수가 끝날 때 어떤 키워드가 있죠?
David: return인가요?

00:01:06.404 --> 00:01:07.902
Will Sentance: return이죠, 지워요.

00:01:07.902 --> 00:01:13.815
혹시 Stack에 추가하는 걸
일컫는 멋있는 용어를 아시는 분?

00:01:13.815 --> 00:01:15.749
David: Push와 Pop이요.

00:01:15.749 --> 00:01:18.143
Will Sentance: Push죠. Stack에 Push하고,
Pop 해서 지워버리죠. 정확해요.

00:01:18.143 --> 00:01:18.791
이걸 Pop 합니다.

00:01:18.791 --> 00:01:23.765
불행하게도, 이게 화이트보드가 아니라
Stack에서 빠르게 Pop할 수가 없네요.

00:01:23.765 --> 00:01:25.240
그래도 계속 하죠.

00:01:25.240 --> 00:01:30.042
Stack에서 Pop으로 떼내고,
제가 말하지 않은 한 가지가 있는데,

00:01:30.042 --> 00:01:34.130
코드의 전체 파일이라고 생각해보면,
왜냐하면 떠올려보세요.

00:01:34.130 --> 00:01:35.650
함수는 전체 메인 프로그램의 작은 미니프로그램이잖아요.

00:01:35.650 --> 00:01:38.274
우린 이걸 어떤 하나의 큰 함수로 묶어낼 수 있어요.

00:01:38.274 --> 00:01:43.430
이걸 뭐라고 할까요? Charles?

00:01:43.430 --> 00:01:44.299
뭐라고 부르는지 아나요?

00:01:44.299 --> 00:01:46.416
사실 이런 질문을 던지는 건 공평하지가 않아요.

00:01:46.416 --> 00:01:50.281
우린 모든 종류의 함수 그러니까, 실행 중인 전체 코드를

00:01:50.281 --> 00:01:52.574
뭐라고 부르는지 아나요, Virginia?

00:01:52.574 --> 00:01:53.457
Charles가 하나요?

00:01:53.457 --> 00:01:54.200
Charles: Global이요.

00:01:54.200 --> 00:01:56.643
Will Sentance: Global이죠. 맞았어요.

00:01:56.643 --> 00:02:01.121
전체 코드를 Global로 간주하는거죠.
그리고 그걸 실행하고 있구요.

00:02:01.121 --> 00:02:04.059
multiplyBy2를 3이랑 실행하자마자,
Top에 이걸 추가하죠.

00:02:04.059 --> 00:02:07.547
그리고 끝나면, 이걸 빼내고,
다시 Global로 돌아가는거죠.

00:02:07.547 --> 00:02:10.682
그리고 10으로 mulitplyBy2를
실행하기 시작하면, Top에 넣고,

00:02:10.682 --> 00:02:13.337
실행이 끝나면, 빼서, 다시 Global로 가죠.

00:02:13.337 --> 00:02:16.959
만약 3이랑 실행된 multiplyBy2 안에
또 다른 함수가 실행된다면,

00:02:16.959 --> 00:02:20.779
입력이 3인 multiplyBy2가 있고,
또 다른 함수가 그 위로 올라가는거예요.

00:02:20.779 --> 00:02:23.881
그 다른 함수는 저거에서 벗어난거죠.
그게 다른 Top이 되는거고,

00:02:23.881 --> 00:02:27.090
함수 내부에서 함수를 재귀적으로 호출해야할 경우
Call Stack이 계속 올라가요.

00:02:27.090 --> 00:02:29.614
Stack의 공간이 부족해질 때까지요.

00:02:29.614 --> 00:02:31.482
이걸 뭐라고 하죠?

00:02:31.482 --> 00:02:32.637
David: Stack Overflow요.

00:02:32.637 --> 00:02:34.425
Will Sentance: Stack overflow죠.
공간이 부족한걸 말하죠.

00:02:34.425 --> 00:02:37.937
좋아요, 이것들이 JavaScript의 원리예요.

00:02:37.937 --> 00:02:40.275
30분만에 했죠, 문제 없이요.