WEBVTT

00:00:00.160 --> 00:00:02.770
[의역다수]
Will Sentance: 이제 이걸 좀 바꾸려고 해요.

00:00:02.770 --> 00:00:07.300
우리가 이미 수도 없이 했던 함수 호출을 하기 전에요.

00:00:08.410 --> 00:00:13.531
다른 함수 안에있고, 한 번 생각해보죠.
만약 내부 함수에서,

00:00:13.531 --> 00:00:17.625
내부 함수의 Execution Context에서 데이터를 찾지 못했을 때,

00:00:17.625 --> 00:00:20.320
그 다음으로 보는 곳은 어디일까요?

00:00:20.320 --> 00:00:24.500
아마도, 한 단계만 나가면 되겠죠?

00:00:24.500 --> 00:00:30.350
첫 번째 라인이예요. 이 안으로 들어가보죠.
복잡한 코드가 아니예요.

00:00:30.350 --> 00:00:33.040
첫 번재 라인입니다. Sam,
Global Memory에 뭘 하죠?

00:00:34.100 --> 00:00:37.350
Sam: 함수 선언이요.
Will Sentance: 함수를 선언하죠.

00:00:37.350 --> 00:00:38.750
구체적으로요?

00:00:38.750 --> 00:00:40.150
Sam: outer요.
Will Sentance: outer고,

00:00:40.150 --> 00:00:43.050
이렇게 Global Memory에 저장되죠.

00:00:44.180 --> 00:00:46.340
이거죠.
오. 펜이 묻었네요.

00:00:47.800 --> 00:00:52.170
좋아요, Virginia,
다음 라인으로 내려가서

00:00:52.170 --> 00:00:55.560
실행하는 건?
Virginia: outer를 실행해요.

00:00:55.560 --> 00:00:56.237
Will Sentance: outer를 실행하죠.

00:00:56.237 --> 00:00:57.660
좋아요. 이렇게죠.

00:00:57.660 --> 00:00:59.048
새로운, 새로운-?

00:00:59.048 --> 00:01:02.496
학생들: Execution Context요.
Will Sentance: 해준 분들만 고마워요.

00:01:02.496 --> 00:01:07.650
다시 해보죠.

00:01:07.650 --> 00:01:10.200
Will Sentance: 다시 새로운?
학생들: Execution Context요.

00:01:10.200 --> 00:01:13.570
Will Sentance: 모두 고마워요.
특히 Bivanesh가요.

00:01:13.570 --> 00:01:20.420
좋아요, 그럼, Execution Context가 있고,
Call Stack에 추가하죠.

00:01:23.230 --> 00:01:23.860
이거죠.

00:01:25.180 --> 00:01:27.100
outer가 Call Stack의 Top에 있습니다.

00:01:27.100 --> 00:01:29.900
전 이게 어디에 저장이 되어있으면 좋겠어요.

00:01:29.900 --> 00:01:36.200
뭔가 칠판을 닦으면 이게 딱 남도록 하는
특별한 기능이 필요해요.

00:01:36.200 --> 00:01:37.780
이거죠, 이제 실행 안으로 가보죠.

00:01:37.780 --> 00:01:39.460
Local Memory로 갑니다.

00:01:39.460 --> 00:01:42.139
Bivanesh, Local Memory의
첫 번째 할 일은요?

00:01:43.140 --> 00:01:46.320
Bivanesh: counter요.
Will Sentance: counter를 뭐로 설정하죠?

00:01:46.320 --> 00:01:46.845
Bhuvanesh: 0이요.
Will Sentance: 0입니다. 좋아요.

00:01:46.845 --> 00:01:48.455
그리고, 어떤 함수를 선언하죠, Michael?

00:01:48.455 --> 00:01:49.290
뭐죠?

00:01:49.290 --> 00:01:52.850
Michael: incrementCounter요.
Will Sentance: incrementCounter입니다.

00:01:52.850 --> 00:01:53.500
이거죠.

00:01:54.620 --> 00:01:59.525
그리고 이제, outer 내부의 가장 마지막 라인에서

00:01:59.525 --> 00:02:04.260
incrementCounter를 괄호를 붙여 실행할거예요.

00:02:05.560 --> 00:02:07.163
이제 Call Stack의 incrementCounter를

00:02:10.092 --> 00:02:11.296
Will Sentance: 추가하죠, 새로운-

00:02:12.626 --> 00:02:16.500
Will Sentance: [웃음] Bivanesh가 최고입니다.

00:02:16.500 --> 00:02:19.910
나머지 분들은 왜 안하시죠?

00:02:19.910 --> 00:02:20.970
그럼 모두 다같이-

00:02:20.970 --> 00:02:22.520
지금 다른 분들은 손이 먼저 나가요.

00:02:22.520 --> 00:02:24.520
고마워요, David.
David가 잘해주고 있습니다.

00:02:24.520 --> 00:02:26.830
Alice도 지금 막 손을 들고 있죠

00:02:26.830 --> 00:02:30.700
모두 다같이, 새로운-
학생들: Execution Context요.

00:02:30.700 --> 00:02:34.070
Will Sentance: 질리지 않는 농담이예요, 시작해보죠.

00:02:34.070 --> 00:02:37.060
이번엔 Local Memory가 없죠.
음, 여기에 쓸게요.

00:02:37.060 --> 00:02:38.480
Local Memory에 아무 것도 없어요.

00:02:39.570 --> 00:02:43.040
첫 번째 라인을 시작하죠,
Michael, 뭐라고 되어있죠?

00:02:43.040 --> 00:02:43.890
Michael: counter에 1을 더해요.

00:02:43.890 --> 00:02:45.260
Will Sentance: 네, counter++죠.

00:02:45.260 --> 00:02:49.700
녹색을 써야겠어요.

00:02:51.300 --> 00:02:54.615
Jasmin, Call Stack의
Top이 incrementCounter죠.

00:02:54.615 --> 00:02:56.900
전 지금 그걸 실행하고 있어요.

00:02:56.900 --> 00:02:58.200
근데 못 찾았죠. 음, 어딜 먼저 봐야하죠?

00:02:58.200 --> 00:02:59.980
counter를 맨 처음 찾는 곳이 어디죠?

00:02:59.980 --> 00:03:01.350
Jasmine: Local Execution Context요.

00:03:01.350 --> 00:03:03.260
Will Sentance: Local Execution Context죠.
좋아요. 이리로 갑니다.

00:03:04.670 --> 00:03:07.840
Local Memory에서 counter를 찾았나요, Jasmine?

00:03:07.840 --> 00:03:08.380
Jasmine: 아뇨.

00:03:08.380 --> 00:03:08.880
Will Sentance: 아니죠.

00:03:09.950 --> 00:03:11.390
그럼 그 다음은 어딜 보죠?

00:03:11.390 --> 00:03:13.930
Jasmine: 그 다음은 outer로-
Will Sentance: 맞았어요. 밖으로 가죠.

00:03:16.912 --> 00:03:18.040
Will Sentance: 그럼 counter를 찾나요?

00:03:18.040 --> 00:03:18.900
Jasmine: 0이요.

00:03:18.900 --> 00:03:21.230
Will Sentance: 그럼 그거에 뭘 하죠?

00:03:21.230 --> 00:03:22.040
Jasmine: 1로 바꾸죠.

00:03:22.040 --> 00:03:23.320
Will Sentance: 네, 정확해요.

00:03:23.320 --> 00:03:27.650
그건 그렇고, 1로 교체한다고 들었는데,
좋았어요. 정확해요.

00:03:27.650 --> 00:03:31.434
다른 말로, 여길 보면,
Call Stack의 아래인 outer로 가는 거죠.

00:03:34.519 --> 00:03:35.910
Will Sentance: 그리고 모두가 이렇게 생각하겠죠.

00:03:37.640 --> 00:03:42.510
그러나 지금은, outer의 호출 안에서 incrementCounter를

00:03:42.510 --> 00:03:47.410
호출하기 때문에 그러는지 알 수가 없어요.

00:03:47.410 --> 00:03:50.360
그러니까 incrementCounter의 호출이

00:03:50.360 --> 00:03:53.200
outer의 실행 안에 있다는 말이예요.
제가 outer를 실행했으니까요.

00:03:53.200 --> 00:03:55.541
저 outer를 실행하고 있으니까, 안으로 들어간거죠.

00:03:56.990 --> 00:03:58.540
호출한 incrementCounter 내에서.

00:03:58.540 --> 00:04:00.080
이게 일어난건지 알 수가 없죠

00:04:00.080 --> 00:04:05.190
이 단계를 수행하지 않았을 수도 있지만,
여기 많은 분들이 확신할 수 있는 것 또는

00:04:05.190 --> 00:04:11.070
outer의 내에서 incrementCounter를 저장했는지의 여부죠.

00:04:12.100 --> 00:04:13.680
지금은 뭐든 될 수 있으니까요.

00:04:14.700 --> 00:04:17.830
outer의 내부에 incrementCounter를 저장했나요? 아니면

00:04:17.830 --> 00:04:20.640
outer 내의 incrementCounter를 호출한건가요?

00:04:20.640 --> 00:04:24.970
그 말은, Local Execution Context의 Memory에서
counter를 못 찾을 때,

00:04:24.970 --> 00:04:28.090
그 다음 단계로 가져가는 건 outer의 Execution Context의
Memory를 본다는거죠.

00:04:29.680 --> 00:04:31.140
자동은 아니예요.

00:04:31.140 --> 00:04:35.820
우린 그냥 아마 보고 당연히 더 큰 박스로
나가면 되는 거라고 볼 수 있지만

00:04:35.820 --> 00:04:38.420
언어는 그렇게 구현되어있지 않죠.

00:04:38.420 --> 00:04:42.530
자동적인 기능은 아니고, 언어에 의해 결정되는거죠.

00:04:42.530 --> 00:04:46.800
만약 데이터를 Local Memory에서 바로 찾지 못한 경우,
다음 Local Memory로 가서 보는 건

00:04:46.800 --> 00:04:48.220
자동적인게 아닙니다.

00:04:49.480 --> 00:04:52.012
그리고 지금, incrementCounter가 여기 저장됐는지,
실행됐는지에 대한 여부를

00:04:52.012 --> 00:04:52.550
말할 수가 없죠.

00:04:54.668 --> 00:04:57.740
Will Sentance: 그래도 알아낼 수 있는 방법은,

00:04:57.740 --> 00:05:06.390
만약 incrementCounter를
이 밖의 Global에서 호출했다면, 평가할 수 있겠죠.

00:05:06.390 --> 00:05:12.160
함수가 만들어진 곳에서
원래 저장된 데이터에 접근이 가능한가요?

00:05:12.160 --> 00:05:17.150
다른 말로, 우리가 접근할 수 있는
데이터를 결정하는 함수의 위치는요?

00:05:17.150 --> 00:05:21.260
또는, Global에서 incrementCounter를
실행했을 때 접근할 수 있을까요?

00:05:21.260 --> 00:05:24.192
전 아마 incrementCounter의 Memory와 그걸 실행한

00:05:24.192 --> 00:05:26.720
Global에만 접근이 가능할겁니다.

00:05:26.720 --> 00:05:29.800
그럼 어떻게 outer의 incrementCounter를 알 수 있죠?

00:05:29.800 --> 00:05:34.520
제기 이렇게 할 수 있나요, Jasmine?

00:05:34.520 --> 00:05:36.440
아니죠, 에러가 나올거예요.

00:05:39.000 --> 00:05:43.420
Eric, 그럼 어떻게 incrementCounter를
이 밖에서 실행할 수 있죠?

00:05:43.420 --> 00:05:46.550
Eric: 저걸 함수에서 반환한 다음
새로운 변수에 할당하면 돼요.

00:05:46.550 --> 00:05:47.780
Will Sentance: 정확해요.

00:05:47.780 --> 00:05:51.670
호출된 함수에서 반환한 다음,
그걸 새로운 Global Label에 할당하는거죠.

00:05:51.670 --> 00:05:53.390
이제 그걸 제대로 해봅시다.

00:05:53.390 --> 00:05:55.960
여기서 일어나는 일은? 에러죠.

00:05:55.960 --> 00:05:58.410
저 밖에서 함수를 실행할 수가 없어요.

00:05:58.410 --> 00:06:01.630
정의된 곳 밖에서 함수를 에러 없이
실행할 수 있는 방법이 있어요.

00:06:01.630 --> 00:06:05.670
우린 내부 함수를 반환하고 그걸 새로운 Global Label에 할당하면
이 밖에서 쓸 수 있어요.

00:06:05.670 --> 00:06:08.710
이제 우린 이 incrementCounter라는 원래 함수를 땡겨와서

00:06:08.710 --> 00:06:10.700
새로운 Global Label인 newFunction에 저장합니다.

00:06:11.960 --> 00:06:12.830
시작하죠.

00:06:12.830 --> 00:06:14.670
무슨 일이 일어나는지 봅시다 여러분.