WEBVTT

00:00:00.000 --> 00:00:04.861
Will Sentance:
Partial Application과 Currying입니다.

00:00:04.861 --> 00:00:10.018
다시 라인 단위로 함수의 이름만 있는 목록을

00:00:10.018 --> 00:00:14.995
실행해가던 코드로 돌아가보죠.

00:00:14.995 --> 00:00:18.310
Seth가 손을 들었는데,
잠시만요. 만약 우리가 이렇게 할 때,

00:00:18.310 --> 00:00:21.561
만약 이 함수들 중 하나가 2개의 입력을 받는다면요?

00:00:21.561 --> 00:00:25.229
전 이 Functional Programming의 핵심 원리가
잘 실행되고 있는 걸 알아요.

00:00:25.229 --> 00:00:27.218
11로 multiplyBy2를 실행하고,

00:00:27.218 --> 00:00:32.855
그리고 그것의 결과를, 2개를 1개로 조합하는거죠.
그래서 자동으로 add3에 삽입되죠.

00:00:32.855 --> 00:00:38.098
근데 만약 add3가 사실은 숫자 2개를 더하는 거고,
3을 넣으면,

00:00:38.098 --> 00:00:43.578
하나는 3이되고, 하나는 undefined겠죠.
그래서 조합된건 숫자가 아닐겁니다.

00:00:43.578 --> 00:00:48.756
아마도요, 그리고 그 다음에 전달이되면,
모든 게 깨져버리겠죠.

00:00:48.756 --> 00:00:53.316
그럼 전 입력을 하나만 갖는 함수를 써야하나요?

00:00:53.316 --> 00:00:55.716
굉장히 심한 제약이 될 거예요.

00:00:55.716 --> 00:00:59.286
전 multiplyBy2, multiplyBy7, multiplyBy5 함수를

00:00:59.286 --> 00:01:02.459
가질 필요가 없어요.
multiply2Numbers 함수를 쓰고 싶죠.

00:01:02.459 --> 00:01:06.707
그게 2인지 7인지 5인지 상관없이
동적으로 넣어서 쓰고 싶은거예요.

00:01:06.707 --> 00:01:09.652
똑같이 add3도, 이렇게 쓸 필요가 없는거죠.

00:01:09.652 --> 00:01:14.036
add2Numbers 함수를 쓸 수 있길 원하는거예요.
숫자가 어떻게 오건간에

00:01:14.036 --> 00:01:17.975
계속해서 재사용할 수 있도록요.
함수를 매번 다시 써야 하나요?

00:01:17.975 --> 00:01:23.375
아니죠. 여길 보세요.
백팩에 있는 2개의 arguement를 가지는

00:01:23.375 --> 00:01:28.475
작은 함수가 있다고 하고,

00:01:28.475 --> 00:01:32.275
만약 제가 그걸 쓸 수 있다고 하면,

00:01:32.275 --> 00:01:37.449
그리고, argument중 하나는 여기 백팩에 있고,

00:01:37.449 --> 00:01:43.430
그 말은 함수가 실행될 때, 이건 잘 모르겠지만
1개의 입력으로 실행된다고 하면,

00:01:43.430 --> 00:01:46.624
그 내부에서 이건 백팩의 함수를 미리 채워진 입력과

00:01:46.624 --> 00:01:50.077
들어온 다른 입력으로 실행할거예요.

00:01:50.077 --> 00:01:54.912
그럼 이게 2개의 입력을 받는 함수로 바뀐다면

00:01:54.912 --> 00:01:59.059
이 함수가 마지막에 실행될 때 붙어있을

00:01:59.059 --> 00:02:03.000
백팩에서 하나는 미리 채워둔 거고,
나머지 1개의 입력을 가지고 오는거죠.

00:02:03.000 --> 00:02:06.522
그럼 이렇게 넘어온 입력은, 두 번째가 되는거고,

00:02:06.522 --> 00:02:08.880
백팩에서 미리 저장된 입력이 다른 하나로 사용되는거죠.

00:02:08.880 --> 00:02:14.672
이런 함수를 가지고 있다고 하면,
이렇게 바꿀 수 있을 겁니다.

00:02:14.672 --> 00:02:20.917
multiply 그리고 뭘 받냐면,
아,

00:02:20.917 --> 00:02:26.352
함수 multiply는 A랑 B를 받아서,

00:02:26.352 --> 00:02:32.101
A * B를 반환하는거죠.
이 함수를 사용할 순 없어요.

00:02:32.101 --> 00:02:37.021
이건 함수의 목록에서 쓸모가 없으니까요.

00:02:37.021 --> 00:02:41.519
하지만 만약 제가 이걸 이렇게 바꾼다면,

00:02:41.519 --> 00:02:46.459
하나의 값은 미리 2로 채워놓고,
이건 기본적으로

00:02:46.459 --> 00:02:51.311
multiplyBy2가 되는거고, 
그 다음 이걸 7이랑 호출할 수 있게 되면요.

00:02:51.311 --> 00:02:52.726
이걸 어떻게 하죠?

00:02:52.726 --> 00:02:56.655
이 multiply 함수를 가질거고,

00:02:56.655 --> 00:03:01.527
미리 채워진 값 2가 있다면,
이것들을 백팩에 새로운 함수로 저장하는거죠.

00:03:01.527 --> 00:03:06.502
그리고 거기에 유용한 이름을 주면 되죠,
실제로는 저렇게 될거예요.

00:03:06.502 --> 00:03:09.686
multiply 함수는 백팩에서

00:03:09.686 --> 00:03:11.695
2가 미리 채워진 상태로 실행하는거죠.

00:03:11.695 --> 00:03:16.552
Function Decoration은
Closure, 백팩 안에서 감싸진 기존 함수를

00:03:16.552 --> 00:03:21.328
부분적으로 적용하기 위해 사용되곤 합니다.

00:03:21.328 --> 00:03:26.458
정말로 강력하죠. 시작해보죠.
우리의 마지막 단원입니다.

00:03:26.458 --> 00:03:32.712
이건 함수를 인자랑 사용할 수 있도록 해주죠.
그 말은 입력이 2개가 된다는겁니다.

00:03:32.712 --> 00:03:36.970
우리가 인자가 2개가 아닌 1개가 있는

00:03:36.970 --> 00:03:41.893
함수를 기대하는 곳에서요.

00:03:41.893 --> 00:03:45.402
함수의 인자를 2개에서 1개로 변형시킬 수 있을거예요.

00:03:45.402 --> 00:03:49.478
arity(항수)는 함수의 입력의 갯수를 뜻하는 걸로

00:03:49.478 --> 00:03:50.226
기억하시면 됩니다.

00:03:50.226 --> 00:03:53.979
그리고 이 항수가 맞지 않으면,
만약 2개의 입력을 가지는 함수가 있고,

00:03:53.979 --> 00:03:56.618
우리가 함수의 목록에 그걸 넣길 원하고,

00:03:56.618 --> 00:04:00.900
reduce를 하면, 다른 말로는 합성인데,
그럼 이 항수가 맞지 않을거예요.

00:04:00.900 --> 00:04:04.890
왜냐하면 모든 함수는 그 출력값이 다음의 입력에 넣어지고
그래서 하나의 출력만 가집니다.

00:04:04.890 --> 00:04:07.677
그래서 2개의 입력을 가지는 함수를 쓸 수 없어요.

00:04:07.677 --> 00:04:15.260
좋아요, 거의 다 왔어요 여러분. 거의 끝나가요.
그럼 시작해보죠.

00:04:15.260 --> 00:04:19.363
함수의 합성은 아주 강력하죠. 함수의 목록을 가질 수 있죠.

00:04:19.363 --> 00:04:23.374
근데 각각의 함수는 똑같은 방식으로 동작해야해요.
한 개의 입력과 한 개의 출력만 반환하죠.

00:04:23.374 --> 00:04:29.806
사용하려는 함수가 뭐든지간에,
그게 2개의 입력을 기대하면 항수가 맞지 않는거죠.

00:04:29.806 --> 00:04:36.970
우린 arguement 중 하나를 미리 채워놓기 위해서
이 함수를 꾸며줄 필요가 있어요.

00:04:36.970 --> 00:04:40.609
이건 실제로, 새로운 함수를 만드는 걸 의미해요.

00:04:40.609 --> 00:04:44.336
새로운 함수를 만들고,

00:04:44.336 --> 00:04:50.119
우리가 그걸 호출 할 수 있는거죠.
multiplyBy2라고 하고 이걸 실제 multiply 함수의

00:04:50.119 --> 00:04:54.894
백팩에 가지고 있다면, 입력값 하나가 미리 채워지는거죠.

00:04:57.512 --> 00:04:58.549
Will Sentance: 여러개의 argument가 있는

00:04:58.549 --> 00:05:02.361
함수를 편리하게 백팩에 저장한거죠.