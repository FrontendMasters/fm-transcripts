WEBVTT

00:00:00.080 --> 00:00:00.640
Will Sentance: 전 사람들이 이것에 대해

00:00:00.640 --> 00:00:02.760
아주 흥미롭게 이야기하는 걸 들었어요.

00:00:02.760 --> 00:00:05.630
우린 outer 함수를 저장하고, 호출할겁니다.

00:00:05.630 --> 00:00:09.380
그럼 우린 작은 incrementCounter 함수를 반환받을거예요.

00:00:09.380 --> 00:00:11.210
그리고 그걸 새로운 Global Label인
newFunction에 넣을겁니다.

00:00:11.210 --> 00:00:13.680
그리고 이 새로운 Global Label로 이걸 호출하고

00:00:13.680 --> 00:00:16.890
여기에서 아주 재밌는 일들이 일어날겁니다.

00:00:16.890 --> 00:00:19.730
그것들이 함수에게 엄청난 힘을 줄거예요.

00:00:19.730 --> 00:00:21.290
특별한 방법으로요.

00:00:21.290 --> 00:00:26.200
그럼, 시작해보죠, 첫 번째 라인입니다. Andrew.
첫 번째 라인에서 뭘 하나요?

00:00:26.200 --> 00:00:27.620
Andrew: 함수를 선언합니다.

00:00:27.620 --> 00:00:29.020
Will Sentance: 함수 선언이죠.

00:00:29.020 --> 00:00:31.820
여러분, 기술적 의사소통이란
완전한 정확도와 완성도를 뜻해요.

00:00:31.820 --> 00:00:32.790
Andrew, 다시 해보죠.

00:00:32.790 --> 00:00:33.850
뭘 선언하죠?

00:00:33.850 --> 00:00:35.190
Andrew: outer란 함수요.

00:00:35.190 --> 00:00:37.790
Will Sentance: 정확합니다.
outer란 이름의 함수를 선언하죠.

00:00:37.790 --> 00:00:41.910
이렇게죠. Andrew,
다시 잘 해줘서 고마워요.

00:00:41.910 --> 00:00:44.930
Sam, 다음 라인입니다. left-hand 영역부터요.

00:00:44.930 --> 00:00:47.360
Sam: 새로운 label을 선언해요.

00:00:48.620 --> 00:00:51.440
Will Sentance: 네, 잘했어요.
새로운 label인 newFunction이죠.

00:00:51.440 --> 00:00:54.740
우린 아직 여기에 뭐가 저장될지 몰라요.
왜냐하면 우린 계속해서

00:00:54.740 --> 00:00:55.820
뭘 실행해야 하기 때문이죠, Sam?

00:00:57.110 --> 00:00:59.491
Sam: outer를 실행해야해요.

00:00:59.491 --> 00:01:00.715
Will Sentance: 좋아요.

00:01:01.442 --> 00:01:03.070
Will Sentance: outer죠 여러분.

00:01:03.070 --> 00:01:05.110
그럼 여기 Call Stack도 써보죠.

00:01:05.110 --> 00:01:08.240
밑에 Global이 있고, outer를 추가합니다.

00:01:09.420 --> 00:01:10.030
다음,

00:01:12.160 --> 00:01:15.110
Bivanesh, 이제 outer를
실행하면 뭘 새로 만들죠?

00:01:15.110 --> 00:01:15.890
Bivanesh: Execution Context요.

00:01:15.890 --> 00:01:18.815
Will Sentance: Execution Context죠.
고마워요 Bivanesh.

00:01:18.815 --> 00:01:24.410
중요한거예요.

00:01:24.410 --> 00:01:25.150
거기로 가보죠.

00:01:26.800 --> 00:01:32.240
그리고 여기엔 입력이나 argument가 없죠

00:01:32.240 --> 00:01:37.365
그 대신 Local Memory에는-
Jasmine, 뭘 할당해야하죠?

00:01:37.365 --> 00:01:38.294
Jasmine: counter를 0으로요.

00:01:38.294 --> 00:01:40.730
Will Sentance: counter를 0으로죠. 좋아요.

00:01:40.730 --> 00:01:45.240
Michael, 다음 라인입니다.
전 별 생각없이 하는데, 매번 같은 곳에서

00:01:45.240 --> 00:01:48.430
같은 사람한테 질문을 하게 되는 것 같아요.
Michael, 다음은요?

00:01:48.430 --> 00:01:50.860
Michael: 우린 incrementCounter라고 하는
함수를 만들어요.

00:01:50.860 --> 00:01:51.990
Will Sentance: incrementCounter죠.

00:01:51.990 --> 00:01:54.090
Jasmine, 지난번에 제가 0을 물어봤나요?

00:01:54.090 --> 00:01:56.830
incrementCounter에 대한 질문을 안했죠.
이게 진짜 웃겨요.

00:01:56.830 --> 00:01:57.550
뭔 일인지 도대체

00:01:57.550 --> 00:02:01.510
머리 속이 어떻게 된건지 무의식적으로 그렇게 된다니까요.

00:02:01.510 --> 00:02:05.480
뭔가 그런 프로세스가 있나봐요.

00:02:05.480 --> 00:02:11.760
좋아요, incrementCounter가 저장됐죠.
우린 이걸 내부에서 사용하지 않을겁니다.

00:02:11.760 --> 00:02:17.370
그 대신, 우린 이 코드를 가지고, 혹은,
만약 여러분들이 heap에 대해 기억하신다면,

00:02:17.370 --> 00:02:23.080
우린 저 내부에 저장된 함수를 가리키는 label을 가지는거죠.

00:02:24.305 --> 00:02:28.230
아, 죄송해요.
저 내부에 저장된 함수로 가는 주소죠.

00:02:28.230 --> 00:02:30.790
incrementCounter의 코드를 취하죠.

00:02:30.790 --> 00:02:33.770
그럼 우리가 뭘 하냐면, 뭘하죠 Jasmine?

00:02:33.770 --> 00:02:34.490
반환을 안하나요?

00:02:34.490 --> 00:02:36.940
incrementCounter를 실행을 하지 않고 뭘 하죠?

00:02:36.940 --> 00:02:38.268
Jasmine: incrementCounter를 반환해요.

00:02:38.268 --> 00:02:38.950
Will Sentance: incrementCounter를 반환하죠.

00:02:38.950 --> 00:02:41.770
그러니까 return incrementCounter죠.

00:02:44.350 --> 00:02:49.850
우린 여기서 incrementCounter를 찾죠.
그럼 여기에 incrementCounter의 코드가 있죠.

00:02:49.850 --> 00:02:54.240
label은 빼고요. 그러면 그걸 가지고 Jasmine,
이 반환값을 어디로 보내죠?

00:02:54.240 --> 00:02:54.770
Jasmine: newFunction이요.

00:02:54.770 --> 00:02:57.090
Will Sentance: newFunction으로 보내죠. 맞았어요.

00:02:57.090 --> 00:02:59.670
이건 incrementCounter라고 불렸었던거죠.

00:02:59.670 --> 00:03:01.300
하지만 이제 더이상 그렇게 부르지 않죠.

00:03:01.300 --> 00:03:04.210
제가 이걸 여기 쓴 건 여러분들이
이게 이전에 뭐였는지 알아야해서예요.

00:03:04.210 --> 00:03:08.702
이렇게죠.
그리고 이것의 코드는 counter++밖에 없죠.

00:03:08.702 --> 00:03:12.920
그리고 이제 이 Execution Context는-
여러분, 어떻게 되죠?

00:03:12.920 --> 00:03:13.730
학생들: 사라져요.
Will Sentance: Call Stack에서

00:03:13.730 --> 00:03:15.410
제거되죠, 맞아요. 지워집니다.

00:03:15.410 --> 00:03:19.492
이제 Pop되는거죠.
Call Stack에서 Pop합니다.

00:03:21.572 --> 00:03:24.140
Will Sentance: 네, 사라졌죠.

00:03:25.740 --> 00:03:29.630
그리고 다시 Global로 나왔고,
newFunction이라는 새로운 Global Label은

00:03:29.630 --> 00:03:33.390
이전에 outer에서 incrementCounter라고
만들어졌던 그 함수가 되는거죠.

00:03:33.390 --> 00:03:37.910
이제 그걸 실행해보죠 여러분
그리고 무슨 일이 일어나나 보죠.

00:03:37.910 --> 00:03:42.431
newFunction이 이제 호출됐고,
새--.. 네

00:03:42.431 --> 00:03:46.690
여러분 다같이, 새로운-?

00:03:46.690 --> 00:03:47.890
학생들: Execution Context요.

00:03:47.890 --> 00:03:50.540
Will Sentance: 고마워요, 힘이 납니다.

00:03:50.540 --> 00:03:54.100
제 열정이 채워주셨어요.

00:03:54.100 --> 00:03:55.540
이거고, Call Stack로 이어가보면

00:03:57.080 --> 00:03:59.510
newFunction이 Call Stack에 추가됐죠.

00:03:59.510 --> 00:04:03.490
그 안으로 가면,
Local Memory에 할당되는건 없고,

00:04:03.490 --> 00:04:07.080
그 대신 어떤 라인을 시작하죠 Jasmine?

00:04:08.350 --> 00:04:09.260
Jasmine: counter++요.

00:04:09.260 --> 00:04:09.930
Will Sentance: counter++죠.

00:04:09.930 --> 00:04:12.790
왜냐하면 newFunction은
이전에 incrementCounter라고 했던 함수니까요.

00:04:14.020 --> 00:04:17.690
Jasmine, counter를 찾기 위해
처음 보는 곳이 어디죠?

00:04:18.830 --> 00:04:19.440
Jasmine: Local Context요.

00:04:19.440 --> 00:04:23.468
Will Sentance: 네 훌륭해요.
Local Execution Context죠.

00:04:23.468 --> 00:04:28.185
또 같은 질문을 했네요. 거기 있나요?

00:04:28.185 --> 00:04:28.939
Jasmine: 아뇨.
Will Sentance: 없죠.

00:04:28.939 --> 00:04:33.411
이제, 어디로 가야할까요?
우리가 지난 시간동안 생각해온

00:04:33.411 --> 00:04:38.167
모든 직관성으로 봤을 때,
Call Stack의 맨 처음 Top인 newFunction의

00:04:38.167 --> 00:04:43.112
다음으로 보는 곳이 어디죠, Jasmine?

00:04:43.112 --> 00:04:47.980
함수를 실행하는 것에 대해서 우리가 가진 직관성을 보면

00:04:47.980 --> 00:04:51.490
그게 실행된 곳 밖으로 접근을 할 수 있겠죠.

00:04:51.490 --> 00:04:53.180
그럼 counter를 찾으러 그 다음으로 갈 수 있는 곳이 어디죠?

00:04:53.180 --> 00:04:55.085
Jasmine: 아마 outer를 봐야할 것 같아요.

00:04:55.085 --> 00:04:58.508
Will Sentance: outer를 본다고 생각할 수도 있지만,

00:04:58.508 --> 00:05:01.124
이 Execution Context는 끝나버렸죠.

00:05:01.124 --> 00:05:03.115
Call Stack에서 빠졌잖아요.

00:05:03.115 --> 00:05:07.960
우린 다시 Thread를 거기로 돌릴 수 없어요.
끝났으니까요.

00:05:07.960 --> 00:05:12.912
우리의 Thread of Execution은 들어왔다가,
다시 나오고, 이건 사라지죠.

00:05:12.912 --> 00:05:14.410
그래서 이제 우린 newFunction안이죠.

00:05:15.450 --> 00:05:17.120
그리고 우린 Global에서 newFunction을 실행하고 있죠.

00:05:17.120 --> 00:05:19.670
그럼 Jasmine,
counter를 찾으러 어디로 갈까요?

00:05:19.670 --> 00:05:22.043
Jasmine: Global이요.
Will Sentance: Global이죠.

00:05:22.043 --> 00:05:23.740
이론적으로 맞는 것처럼 들리네요.

00:05:27.511 --> 00:05:30.880
Will Sentance: 선이 좀 이상하게 그어졌네요.

00:05:30.880 --> 00:05:32.760
counter가 Global에 있나요, Jasmine?

00:05:32.760 --> 00:05:34.050
확실히 없죠.

00:05:37.273 --> 00:05:39.421
Will Sentance: 좀 뻔한데.

00:05:39.421 --> 00:05:42.467
안돼! 없죠

00:05:42.467 --> 00:05:48.760
학생들: [웃음]
Will Sentance: 슬프게도 말이죠.

00:05:48.760 --> 00:05:51.570
그건 그렇고, 이런 일이 일어나도록 만들어진
언어는 문제가 좀 있죠.

00:05:51.570 --> 00:05:53.520
확실히 좋지 않은 언어 설계처럼 느껴져요.

00:05:55.130 --> 00:05:58.980
그래도 이게 이 강연의 핵심이 아니라는 걸
감안할 때 우린 이걸 써야하죠.

00:05:58.980 --> 00:06:02.030
아주 강력한 기능들이 있어서,
이걸 오래 끌진 않을거지만

00:06:02.030 --> 00:06:06.620
이걸로 스트레스를 너무 받지 않도록 할께요.

00:06:06.620 --> 00:06:12.015
그 대신, 어떤 강력한 기능에 대해 말하고 싶어요.

00:06:12.015 --> 00:06:20.450
그건 다른 함수로부터 반환된 함수를 실행할 때에 대한 거죠.

00:06:20.450 --> 00:06:24.020
이것에 Global Label을 주고,
그걸 새로운 Global Label로 실행했을 때

00:06:25.300 --> 00:06:27.050
생기는 아주 특별한 점을요.

00:06:28.910 --> 00:06:33.914
incrementCounter를 반환해서 newFunction에 넣을 때

00:06:33.914 --> 00:06:38.321
단순히 코드만 넘기는게 아니예요.

00:06:38.321 --> 00:06:42.600
함수의 코드 외에 뭔가를 또 가져오죠.

00:06:50.160 --> 00:06:55.200
이 함수의 뒤에요.
Will Sentance: 이 함수의 뒤에

00:06:55.200 --> 00:07:00.259
따라오는 건, 그것의 주변 메모리 전체예요.

00:07:00.259 --> 00:07:06.350
이 함수가 반환되어 나와질 때,
그 반환된 걸 newFunction에 넣으면서

00:07:06.350 --> 00:07:11.426
이건 그 함수의 뒤에 이걸 달고 옵니다.

00:07:11.426 --> 00:07:15.040
함수 뒤에 붙어 있는거예요.
함수를 가져오면서 딸려오는

00:07:15.040 --> 00:07:18.700
작은 백팩인거죠.
그것의 뒤에 딸려있는거예요.

00:07:18.700 --> 00:07:26.062
이게 만들어졌을 때의 주변 데이터가 있고,
이걸 보는겁니다.

00:07:26.062 --> 00:07:30.113
여기에 0인 counter가 붙어있어요.

00:07:30.113 --> 00:07:37.423
백팩보다 더 오피셜한 이름이 있는지도 말할거예요.

00:07:37.423 --> 00:07:40.927
여러분들 중 누군가가 이 강의 이후에

00:07:40.927 --> 00:07:44.433
좋아요 50,000개 정도의 븜로그 포스트를 쓰면요.

00:07:44.433 --> 00:07:49.324
그건 JavaScript의 스펙보다도 더 인기가 있는 용어예요.

00:07:49.324 --> 00:07:53.157
아마도요. 아무튼 함수에 붙어있죠.

00:07:53.157 --> 00:07:58.293
그 말은, Jasmine,
newFunction의 Local Execution Context에서

00:07:58.293 --> 00:08:04.540
즉시 counter를 찾지 못하면, 해결책이 있는겁니다.
말했던대로, Local Memory에서

00:08:04.540 --> 00:08:10.530
Global을 보기 전에, 어딘가에 있을 것이고,
그 말을 쓰면 됩니다.

00:08:10.530 --> 00:08:13.930
b로 시작하는 그 말을 하면 되는거죠. 끝은 back인?

00:08:15.012 --> 00:08:18.200
Jasmine,
JavaScript가 Global로 counter를 찾기 위해

00:08:18.200 --> 00:08:22.480
여행을 떠나기 전에 봐야할 곳이 어디라고 생각하나요?

00:08:22.480 --> 00:08:24.270
Jasmine: newFunction의 백팩이요.

00:08:24.270 --> 00:08:26.370
Will Sentance: newFunction의 백팩을 보면되죠.

00:08:26.370 --> 00:08:27.770
고마워요, Jasmine.

00:08:27.770 --> 00:08:33.045
맞았어요. 어디로 가냐면,

00:08:33.045 --> 00:08:37.670
newFunction의 백팩입니다.

00:08:37.670 --> 00:08:42.790
여기예요. 그리고 여기에서 뭘 찾죠?
Jasmine, counter는 뭐죠?

00:08:43.860 --> 00:08:44.420
Jasmine: 0이요.

00:08:44.420 --> 00:08:47.750
Will Sentance: counter는 0이죠. 맞았어요.

00:08:47.750 --> 00:08:51.020
그거에 뭘하죠?
Jasmine, 얼마나 증가시키죠?

00:08:51.020 --> 00:08:51.520
Jasmine: 1이요.

00:08:55.058 --> 00:08:55.652
Will Sentance: 1이죠.

00:08:55.652 --> 00:08:59.690
이 Execution Context는 사라지죠.

00:08:59.690 --> 00:09:02.030
이걸 지우지 않을께요.

00:09:02.030 --> 00:09:05.310
우린 또 이걸 추가해야하니까요.
왜냐하면 newFunction을 또 실행할거거든요.

00:09:05.310 --> 00:09:08.050
잠시 뒤에, 이 백팩에 대한
모든 걸 이야기할거예요. 여러분.

00:09:08.050 --> 00:09:08.920
굉장히 강력합니다.

00:09:12.025 --> 00:09:14.640
Will Sentance: Local Memory엔 모든 게 다 있죠.
이건 아니지만요.

00:09:14.640 --> 00:09:17.320
여기 있는 건 다 지워졌죠.
이건 일시적이니까요.

00:09:19.150 --> 00:09:20.820
newFunction을 다시 실행합니다.

00:09:20.820 --> 00:09:22.394
Anna, 새로운-,
새로운 뭐죠?

00:09:22.394 --> 00:09:24.684
학생들: Execution Context요.

00:09:24.684 --> 00:09:27.946
Will Sentance: 모두들 좋았어요. Anna도 잘했어요.

00:09:27.946 --> 00:09:32.370
잘했어요 Anna, 여기로 가보죠.
아마 여러분들의 마이크에 연결된 오디오를 켜면

00:09:32.370 --> 00:09:36.980
그냥 Bivanesh의 Execution Context만 들릴것 같아요.

00:09:36.980 --> 00:09:42.752
그럼 이제 다음 호출 된
newFunction의 counter++가 있죠.

00:09:42.752 --> 00:09:49.727
Eric, counter를 처음 찾는 곳이 어디죠?
그건 그렇고, 좀 더 명확하게 말하는건데,

00:09:49.727 --> 00:09:56.130
지금 Call Stack에 이건
새로운 newFunction의 Execution Context입니다.

00:09:56.130 --> 00:09:58.530
이걸 지웠고, 다시 쌓은거예요.

00:09:58.530 --> 00:10:00.434
어딜 처음 보죠, Eric?

00:10:00.434 --> 00:10:02.940
Eric: 먼저 Local Execution Context를 봅니다.

00:10:02.940 --> 00:10:05.170
Will Sentance: 좋아요, counter를 찾았나요?

00:10:05.170 --> 00:10:05.940
Eric: 아뇨 없어요.

00:10:05.940 --> 00:10:07.820
Will Sentance: 다음으로 보는 곳은 어디죠?

00:10:07.820 --> 00:10:09.410
뭔가 멋있는 용어 쓰지 마세요.

00:10:09.410 --> 00:10:10.600
Eric: 백팩으로 갑니다.

00:10:10.600 --> 00:10:14.080
Will Sentance: 백팩으로 갈거예요. 찾은 counter는요?

00:10:14.080 --> 00:10:14.944
Eric: 1이요.

00:10:14.944 --> 00:10:18.760
Will Sentance: 와우, 1인 counter를 찾았죠.

00:10:18.760 --> 00:10:20.790
이걸 얼마나 증가시키죠?

00:10:20.790 --> 00:10:21.513
Eric: 2요.

00:10:21.513 --> 00:10:25.836
Will Sentance: 2죠. 바로요 여러분

00:10:25.836 --> 00:10:30.990
이게 우리 함수를 엄청나게 강화시킨 걸 보실 수 있을거예요.

00:10:30.990 --> 00:10:33.110
함수는 그냥 2개예요.

00:10:33.110 --> 00:10:36.550
음, 그럼 이제 2개의 코드 블럭에 대해 살펴보죠.

00:10:36.550 --> 00:10:40.160
이 코드를 실행할 때,
Thread가 코드를 처리해가면서

00:10:40.160 --> 00:10:43.510
이 함수의 임시적인 메모리 공간을 각 회차별로 묶어내죠.

00:10:45.090 --> 00:10:51.240
이건 함수가 2개 타입의 데이터 저장소를
가지는 걸 가능하게 하죠.

00:10:51.240 --> 00:10:56.170
하나의 Execution에 대해 하나의 임시 공간이 있고,

00:10:56.170 --> 00:11:01.960
하나의 영구적인 지속적인 공간도 있죠.
함수 코드가 저장되어 있는 한 계속 존재하죠.

00:11:01.960 --> 00:11:06.400
add 함수는 이제 더 이상 단순한 코드가 아니죠.
newFunction이라는 label에 저장된 코드는

00:11:06.400 --> 00:11:11.460
원래는 incrementCounter였고,
거기에 영구적인 데이터가 붙어 있는거예요.

00:11:12.550 --> 00:11:16.910
새로운 함수인 incrementCounter가 만들어지면서
그 참조를 생성하여

00:11:16.910 --> 00:11:20.290
접근 가능해졌고, 그건 Local Memory가 아니예요.

00:11:21.640 --> 00:11:23.780
그래서 우린 여기로 건너가서 백팩을 보는거죠.

00:11:23.780 --> 00:11:29.390
원래는 incrementCounter인 newFunction를

00:11:29.390 --> 00:11:32.112
만들었을 때부터 남아있는겁니다.

00:11:32.112 --> 00:11:35.410
이 Local Memory 옆에
counter = 0이라고 저장되어 있었고

00:11:35.410 --> 00:11:41.210
이걸 이 함수의 뒤에 붙여서 newFunction으로 끌고간 거예요.

00:11:41.210 --> 00:11:44.070
여기에 붙어 있는겁니다.
여기에 붙어있죠 여러분.

00:11:45.630 --> 00:11:46.626
그럼 이제,

00:11:46.626 --> 00:11:53.506
이걸 다시 한 번 해보자면,
새로운 함수 정의는 코드죠.

00:11:53.506 --> 00:11:58.960
코드를 저장하는거였고,
이제 이건 숨겨진 링크를 가지죠.

00:11:58.960 --> 00:12:03.766
숨겨진..음..
질문 시간으로 넘어가기 전에 이것에 대해

00:12:03.766 --> 00:12:05.758
몇 가지 더 중요한 걸 말하고 싶은 이유인데요.

00:12:05.758 --> 00:12:11.990
함수에 영구적인 데이터가 어떻게 붙었을까요?

00:12:11.990 --> 00:12:15.770
우선 먼저, 우린 여기에 직접 붙을 수 없어요.

00:12:15.770 --> 00:12:17.985
Global의 newFunction으로 가서,

00:12:17.985 --> 00:12:23.900
newFunction.backpack.counter 이런 게 안됩니다.

00:12:23.900 --> 00:12:25.890
심지어 newFunction. 음..
공식적인 이름은 .counter 아니지만,

00:12:25.890 --> 00:12:31.650
이렇게 들어갈 수가 없어요.

00:12:31.650 --> 00:12:36.810
이걸 incrementCounter, 이제 newFunction이라는 것의
Private이라고 하죠.

00:12:38.090 --> 00:12:42.800
함수의 호출에서요. 우린 여기를 newFunction을
실행해서만 들어갈 수 있어요.

00:12:42.800 --> 00:12:46.730
어떤 Local Memory안의 참조로
백팩으로 넘어가는 방식이 안되죠.

00:12:46.730 --> 00:12:52.050
이 백팩은 Global로 내려가 보기 전에
어떤..삽입과 비슷하게 되어있는거죠.

00:12:52.050 --> 00:12:55.470
백팩이 Global에 있는거라고 오해하시면 안됩니다.

00:12:55.470 --> 00:12:57.360
이건 Global에 저장된 함수에 붙어있는거예요.

00:12:58.700 --> 00:13:03.099
Global의 실제 의미는, 내가 Global의
Execution Context에 있을 때,

00:13:03.099 --> 00:13:08.330
데이터를 이름으로 접근할 수 있다는건데,
이 데이터에 접근이 안되죠. 숨어있으니까요. 보호되고 있어요.

00:13:08.330 --> 00:13:09.550
그럼, 이건 어떻게 보호되고 있죠?

00:13:09.550 --> 00:13:14.040
Thread가 outer의 Execution Context를
실행해서 동작하려고

00:13:14.040 --> 00:13:17.910
Call Stack에 올라간 그 초기 시점에 incrementCounter를

00:13:17.910 --> 00:13:20.040
저장하자마자 바로 처리가 되죠.

00:13:20.040 --> 00:13:21.600
incrementCounter가 저장되자마자입니다.

00:13:22.710 --> 00:13:26.340
그 즉시, 이 메모리 주변으로 가는 링크를 얻죠.

00:13:26.340 --> 00:13:28.810
그 즉시 이 메모리 주변 전체에 대한걸요.

00:13:28.810 --> 00:13:34.020
이 링크는 2개의 대괄호죠.
[[Scopes]]라는 속성에 연결됩니다.

00:13:34.120 --> 00:13:36.960
이 동작하는 메모리에서요.

00:13:38.060 --> 00:13:40.310
말 그대로 저장된 위치에 대한 링크만 복사를 할거예요.

00:13:41.930 --> 00:13:44.100
함수를 반환할 때,

00:13:44.100 --> 00:13:49.510
저 링크를 같이 끌고 오는거예요.
모든 데이터를 이 함수에 붙이는거죠.

00:13:49.510 --> 00:13:54.730
그래서 [[ Scopes ]]가 있는거예요.

00:13:54.730 --> 00:13:56.161
뚜껑이 어떻게 된거지

00:13:56.161 --> 00:13:57.271
Will Sentance: 갑자기 뚜껑이

00:13:57.271 --> 00:13:58.105
반환됐어요.

00:13:58.105 --> 00:14:00.050
신기하네요.

00:14:00.050 --> 00:14:01.530
웃겨요.

00:14:01.530 --> 00:14:03.900
뭔가 이걸 흔들었다고 생각한 것 같아요.

00:14:03.900 --> 00:14:07.062
좋아요, 제 말은, newFunction이 실행되고,

00:14:07.062 --> 00:14:11.909
counter를 Local Memory에서 못찾을 때마다,
그것의 정의에 숨겨진

00:14:11.909 --> 00:14:16.508
[[Scopes]] 속성을 본다는거죠.
다른 말로는 counter를 찾으러 백팩을 본다는거구요.

00:14:16.508 --> 00:14:20.528
이게 만들어졌을 때 counter가 있었고 
outer의 실행으로 incrementCounter의 코드가 반환되었을 때,

00:14:20.528 --> 00:14:23.414
outer의 실행으로 나온 incrementCounter 코드는,

00:14:23.414 --> 00:14:28.193
outer를 실행했고, 이게 만들어진 상태에서
반환된 incrementCounter는

00:14:28.193 --> 00:14:32.329
반환되서 newFunction으로 가고,
우리가 newFunction을 실행하고

00:14:32.329 --> 00:14:35.040
Local Memory에서 counter를 못찾으면

00:14:35.040 --> 00:14:38.855
newFunction의 [[Scopes]] 속성인
백팩을 본다는거죠.

00:14:38.855 --> 00:14:40.656
질문 시간으로 가고싶은데

00:14:40.656 --> 00:14:46.668
백팩에 대한 몇 가지 내용을 먼저 말하고 싶어요

00:14:46.668 --> 00:14:51.710
첫째로, 이건 굉장히 최적화되어 있어요.
JavaScript는 outer의 내부의 incrementCounter의

00:14:51.710 --> 00:14:56.438
Local Memory 주변을 저장하는 링크를 만드는데,

00:14:56.438 --> 00:15:01.716
거기에 있는 모든 것들을 쓰죠.
그 링크는 그 전체 컬렉션을 향합니다. 전부 다요.

00:15:01.716 --> 00:15:07.220
Memory의 모든 것을 저장하는 곳으로 링크가 되죠.
하지만, 함수를 반환하면,

00:15:07.220 --> 00:15:09.350
보통 함수의 실행이 끝날 때,

00:15:09.350 --> 00:15:12.180
뭐 하나만 남아있을까요? Sam?

00:15:12.180 --> 00:15:14.250
함수의 실행이 끝나고 3을 반환했을 때요.

00:15:14.250 --> 00:15:17.060
나머지 모든 것들은 Local Memory에 있을거고,
우리가 그걸 들고있나요?

00:15:17.060 --> 00:15:18.450
Sam: 아뇨.
Will Sentance: 아니죠. 자동적으로

00:15:18.450 --> 00:15:19.340
Garbage가 수집되죠.

00:15:19.340 --> 00:15:20.080
왜 그걸 Garbage라고 하죠?

00:15:20.080 --> 00:15:25.210
그것의 이름으로 더 이상 접근할 수 없기 때문에
Garbage라고 해요.

00:15:25.210 --> 00:15:27.110
그것이 있는 곳을 가리키는게 없죠.

00:15:27.110 --> 00:15:28.860
그걸 자동으로 수집하는거구요.

00:15:28.860 --> 00:15:31.440
그 말은 JavaScript에 의해 자동적으로 지워진다는거죠.

00:15:31.440 --> 00:15:32.454
Sam: 그래서 약한 참조인가요?

00:15:32.454 --> 00:15:33.304
Will Sentance: 그렇죠.

00:15:33.304 --> 00:15:40.410
이건, 이건, 당연한건데,
여기 대신,

00:15:40.410 --> 00:15:45.607
이 함수를 반환할 때,

00:15:45.607 --> 00:15:48.855
JavaScript가 이 함수의 백팩에 보관할

00:15:48.855 --> 00:15:55.890
모든 주변 데이터들 잡아놔요.
하지만, 잠시 보면,

00:15:55.890 --> 00:15:59.970
만약 10가지의 뭔가가 Local Memory에 있을 때,

00:16:01.830 --> 00:16:05.460
제가 incrementCounter를 반환해 newFunction에 넣고,
newFunction을 실행하면,

00:16:05.460 --> 00:16:09.350
전 10개를 이 counter 옆에 가지겠죠.

00:16:09.350 --> 00:16:13.840
Alex, 하나, incrementCounter였던

00:16:13.840 --> 00:16:17.070
newFunction에서 참조하는 하나가 뭐죠?

00:16:17.070 --> 00:16:18.382
Alex: counter요.
Will Sentance: counter죠.

00:16:18.382 --> 00:16:20.630
그래서 만약 나머지 10개를 백팩에 가지고 있으면,

00:16:20.630 --> 00:16:22.630
그것들 중 하나라도 접근을 할 수 있나요?

00:16:22.630 --> 00:16:24.737
아니죠, 전 이 백팩 안의 아무것도 접근할 수 없죠.

00:16:24.737 --> 00:16:27.684
할 수가 없죠. newFunction.scopes.counter
이렇게 할 수 없어요.

00:16:27.684 --> 00:16:32.130
함수의 실행에서만 보호되어야하고
보존되어야하니까요.

00:16:32.130 --> 00:16:34.500
그 말은, 반환으로 제가 아는건, 아 죄송합니다.

00:16:34.500 --> 00:16:39.570
다시 Javascript가 incrementCounter의 반환이
newFunction으로 갈 때 아는 건

00:16:39.570 --> 00:16:47.010
함수가 마지막에 필요로 하거나 접근할 것들을
이미 알고 있다는거예요.

00:16:47.010 --> 00:16:50.520
그래서 outer를 빠져나갈 때 백팩에 끌고가면서

00:16:51.640 --> 00:16:56.000
Local Memory에 나머지 것들은
다 지워버리는 최적화를 한다는거예요.

00:16:56.000 --> 00:16:57.980
참조가 안된다면, 다 지우는겁니다.