WEBVTT

00:00:00.000 --> 00:00:00.950
Will Sentance: Sam 말해봐요.

00:00:00.950 --> 00:00:04.872
Sam: 2개가 있는데, 첫 번째는,
간단한 다이어그램의 divideBy5를 보면,

00:00:04.872 --> 00:00:07.452
5를 넣어줬지만, 25여야 해요.

00:00:07.452 --> 00:00:09.025
Will Sentance: [웃음] 고마워요, Sam.

00:00:09.025 --> 00:00:12.132
Sam: 두번째로, 궁금한 건 어떤 배치인데요.

00:00:12.132 --> 00:00:17.644
실행코드는 function에 input인데 parameter에
input, function이라고 쓴 게 궁금해요.

00:00:17.644 --> 00:00:21.472
Will Sentance: 왜냐하면, reduce의 동작 방식을 보면,
두 가지를 하나로

00:00:21.472 --> 00:00:26.019
조합하는 reducer 함수로 전달되는 첫 번째가

00:00:26.019 --> 00:00:30.673
항상 accumulator이기 때문이예요.

00:00:30.673 --> 00:00:35.318
그리고 reducer가 모든 시나리오에서
동작할 수 있길 원하죠.

00:00:35.318 --> 00:00:38.047
하지만 이걸 뒤집어 놓아야 해요.

00:00:38.047 --> 00:00:40.055
조금 이상한 느낌이 들어요 그렇죠?

00:00:40.055 --> 00:00:43.394
하지만 우리가 조합을 해야하니까,
그 조합하는 함수는

00:00:43.394 --> 00:00:46.549
늘 첫 번째로 buildingUp을 가져요.

00:00:46.549 --> 00:00:51.464
그리고 두번째로는 우리가 조합해서 하나로 만들

00:00:51.464 --> 00:00:52.580
배열의 요소죠.

00:00:52.580 --> 00:00:57.647
우리가 처리할 때 그 내부에서,
두 번째는 저 페이지에 보이는데

00:00:57.647 --> 00:01:00.202
첫 번째가 붙어서 실행되죠.
그래서 뒤집혀 있는 거예요.

00:01:00.202 --> 00:01:05.228
Sam: 좋아요, reduce의 내부를 묘사하시는 것 같은데,

00:01:05.228 --> 00:01:08.095
제가 궁금한건 input으로 function을 실행하는 부분이요.

00:01:08.095 --> 00:01:10.890
Will Sentance: 음 runFunctionOnInput이
대체되는 곳이 어디죠?

00:01:10.890 --> 00:01:12.190
어디로 대체 되죠?

00:01:12.190 --> 00:01:13.951
Sam: 그건 reducer예요.

00:01:13.951 --> 00:01:18.294
Will Sentance: 이 reduce안에 어떤
placeholder를 채워주죠, Charles?

00:01:18.294 --> 00:01:19.012
Charles: howToCombine이요.

00:01:19.012 --> 00:01:20.119
Will Sentance: howToCombine이죠.

00:01:20.119 --> 00:01:21.830
제 말은요, Sam, 제가 미리 설정해둔 건,
아, 제 말은, 보세요.

00:01:21.830 --> 00:01:26.568
이론적으로 제가 만든 reduce엔 맞출 수 있지만,

00:01:26.568 --> 00:01:29.741
실제 내장된 reduce의 동작 방식이 이것과 일치하는거예요.

00:01:29.741 --> 00:01:32.884
그러니 기억하세요, runFunctionOnInput은
howToCombine의 위치에서 실행되는거예요.

00:01:32.884 --> 00:01:35.755
그리고 그 조합하는 방식이 예상하던대로 잘 동작한거구요.

00:01:35.755 --> 00:01:39.952
여러분 이런 질문들이
다 여러분들에게 도움이 됩니다.

00:01:39.952 --> 00:01:42.149
간단한 거 하나 더 말씀드리고 싶네요, 이걸 보세요.

00:01:42.149 --> 00:01:45.828
제가 이 다음 슬라이드에서 한 모든 건,
추가 함수를 보탠 거예요.

00:01:45.828 --> 00:01:47.467
이걸 강조하고 싶어요.

00:01:47.467 --> 00:01:51.870
그건 그렇고 Seth에게 마이크가 없어서
그게 안들렸을 수도 있는데,

00:01:51.870 --> 00:01:55.906
Seth가 묻기를, 만약 함수에 다중 arity(?)라는게
있으면 어떻게 되냐고 했어요.

00:01:55.906 --> 00:01:58.432
함수에 1개 이상의 입력이 있을 때요.

00:01:58.432 --> 00:02:02.526
이게 설정되는 방식은 Sam의 질문이랑 비슷해요.

00:02:02.526 --> 00:02:06.567
이 함수들이 어떻게 실행될지 미리 규정했죠.

00:02:06.567 --> 00:02:10.574
reduce는 이것들과 howToCombine이라는 규칙으로

00:02:10.574 --> 00:02:12.668
하나의 입력을 매개변수로 함수를 실행하죠.

00:02:12.668 --> 00:02:14.017
여기에 여러개의 입력값들이 있지 않아요.

00:02:14.017 --> 00:02:17.950
만약 여기 multiplyBy2나 add같은
함수 중에 하나가 2개나

00:02:17.950 --> 00:02:20.326
그 이상의 입력을 기대하면, 그건 망가질겁니다.

00:02:20.326 --> 00:02:24.055
그게 Functional Programming의 기술의 마지막 부분이예요.

00:02:24.055 --> 00:02:26.103
여러분들이 들을 멋진 것들이 있죠.

00:02:26.103 --> 00:02:29.875
Monad, Partial Application, Currying이요.

00:02:29.875 --> 00:02:34.544
모든 함수를 나열할 때, 코드 블럭이 하나씩 자동으로

00:02:34.544 --> 00:02:38.482
실행되는 문제를 해결하려고 하는 것들이죠.

00:02:38.482 --> 00:02:40.707
그리고 여러분들이 그걸 직접 호출하지 않고,

00:02:40.707 --> 00:02:43.853
여러분들은 이런 reduce같은 구조에
의지하여 호출할거예요.

00:02:43.853 --> 00:02:46.981
그리고 이들이 굉장히 예측 가능한 방식으로
동작하는지 확인해야해요.

00:02:46.981 --> 00:02:49.729
여러분들은 이것들이 정확히
하나의 입력과 하나의 출력을 갖는지 확인해야해요.

00:02:49.729 --> 00:02:52.073
그리고 만약 이것들이 에러를 내더라도

00:02:52.073 --> 00:02:54.492
데이터의 전체 흐름을 방해하지 않는지 확인해야해요.

00:02:54.492 --> 00:02:58.945
그리고 그것은 실제로 Functional Programming의
남은 모든 것이예요.

00:02:58.945 --> 00:03:02.666
우리가 코드 라인들을 리스트화할 수 있는
일관성을 보장하기 위한거죠.

00:03:02.666 --> 00:03:03.771
코드 라인, 라인이요.

00:03:03.771 --> 00:03:04.916
그걸 곧 볼겁니다.

00:03:04.916 --> 00:03:07.229
이걸 보세요, 우리가 해온 2개의 슬라이드 간의 차이는

00:03:07.229 --> 00:03:08.710
이 두 슬라이드의 차이는요.

00:03:08.710 --> 00:03:12.005
추가 함수를 넣은거고, 또 한 건, 함수들의 목록을

00:03:12.005 --> 00:03:15.212
저렇게 생긴 블럭으로 옮긴거죠.
우리가 내내 한거죠.

00:03:15.212 --> 00:03:18.650
전 그냥 좀 더 공백을 두고
이걸 라인 단위로 작성했죠.

00:03:18.650 --> 00:03:22.739
따라서 여러분들은 Functional Programming이
이런식으로 작성될거라는 걸 느낄 수 있어야해요.

00:03:22.739 --> 00:03:27.527
각 라인은 분리된 독립 작업으로

00:03:27.527 --> 00:03:32.771
그것의 출력만이 reduce의 내부를 타고 전달 되고

00:03:32.771 --> 00:03:35.629
 또 다음 함수로 전달되는거죠.

00:03:35.629 --> 00:03:40.320
add3의 오직 하나인 출력인 25가

00:03:40.320 --> 00:03:45.198
바로 그 다음 라인으로 넘어가고,
또 바로 다음으로 넘어가는거에요.

00:03:45.198 --> 00:03:47.106
다음 라인으로요.

00:03:47.106 --> 00:03:50.043
개념적으로 divideBy5도 코드 한 줄인거죠.

00:03:50.043 --> 00:03:52.100
지금은 우리가 이걸 다 한 줄에 쓴거구요.

00:03:52.100 --> 00:03:54.448
여러분, 이게 목표예요.

00:03:54.448 --> 00:03:57.871
이걸 새로 시작하시는 분들은 이럴 수도 있어요.

00:03:57.871 --> 00:03:59.121
내가 지금 제대로 하고 있나?

00:03:59.121 --> 00:04:03.807
그러나 일단 구조에 익숙해지면, 가독성이 좋은 이름과

00:04:03.807 --> 00:04:06.647
시작값으로 작업들을 나열할 수 있으면서,

00:04:06.647 --> 00:04:11.627
계속 다음 다음 다음으로 넘어갈 수 있게 됩니다.

00:04:11.627 --> 00:04:16.469
이건 코드를 훨씬 읽기 쉽게 만들어줍니다.

00:04:16.469 --> 00:04:19.437
이게 Functional Programming의 핵심이예요.

00:04:19.437 --> 00:04:24.235
이제 여러분들에게 이걸 말할건데,
우린 이걸 하기 위해 reduce에 저렇게 쓰지 않을거예요.

00:04:24.235 --> 00:04:27.107
우린 이걸 Compose나 Pipe라고 부릅니다.

00:04:27.107 --> 00:04:30.872
둘 다 함수를 하나 하나씩 통과합니다.

00:04:30.872 --> 00:04:32.439
그들의 내부에서 하는건요?

00:04:32.439 --> 00:04:34.235
이걸 문서들로 확인했어요.

00:04:34.235 --> 00:04:35.931
그게 어떻게 내장되어있는지 확인했죠.

00:04:35.931 --> 00:04:37.422
그 안에서 하는건요?

00:04:37.422 --> 00:04:39.775
우리의 좋은 친구, reduce를 동작하는거죠.

00:04:39.775 --> 00:04:43.273
함수들의 목록을 통해, 그리고 값을 통해

00:04:43.273 --> 00:04:45.791
각 함수들을 실행시키면서
그것들을 reduce로 처리하죠.

00:04:49.956 --> 00:04:51.101
Will Sentance: 심지어 Compose는

00:04:51.101 --> 00:04:56.220
Functional Programming에서 가장 중요한 도구예요.

00:04:56.220 --> 00:04:58.271
이게 그 내부에서 일어나는 일이예요.

00:04:58.271 --> 00:05:01.116
여러분들이 Functional Programming
면접에 갔을 때, 면접관들이

00:05:01.116 --> 00:05:02.500
어떻게 함수들을 Compose하나요? 하면

00:05:02.500 --> 00:05:07.762
여러분들은, 저라면 각 함수들을 값과 reducing합니다.

00:05:07.762 --> 00:05:10.344
그게 compose가 실제로 하는 거예요.

00:05:10.344 --> 00:05:11.974
좋아요, 여러분.

00:05:11.974 --> 00:05:14.655
Function Composition입니다.

00:05:16.849 --> 00:05:20.433
Will Sentance: 기능 추가가 쉽다.

00:05:20.433 --> 00:05:24.128
Functional JavaScript에서 가장 중요한 부분이죠.

00:05:24.128 --> 00:05:28.167
개별 코드 단위를 이름으로 나열할 수 있죠.

00:05:28.167 --> 00:05:33.868
딱, 딱, 딱,
하나, 둘, 셋, 넷, 이름으로죠.

00:05:33.868 --> 00:05:37.143
그리고 각각 독립적으로, 자기 충족적으로 하나씩 실행하죠.

00:05:37.143 --> 00:05:38.680
그 출력을 다음으로 넘기기만하구요.

00:05:38.680 --> 00:05:41.310
더 가독성이 좋다.
보통 reduce는 compose에 쌓여있어요.

00:05:41.310 --> 00:05:45.071
음 이를테면, 음표를 멜로디로 작곡하는 것처럼요.

00:05:45.071 --> 00:05:49.059
여러분들도 각각의 코드 단위를
전체의 작업으로 완전히 조립할 수 있죠.

00:05:49.059 --> 00:05:53.897
함수에 10줄의 코드가 있는 걸
이제 10개의 함수를

00:05:53.897 --> 00:05:57.336
조립하는 것처럼요.
함수의 집합체가 되는거죠.