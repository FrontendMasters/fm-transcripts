WEBVTT

00:00:00.000 --> 00:00:01.513
Will Sentance: 입력이 2개인 함수죠.

00:00:01.513 --> 00:00:03.873
기억해두세요.
함수 리스트를 자동으로 실행할 수 있죠.

00:00:03.873 --> 00:00:07.951
각각은 하나의 결과를 반환할거고
그게 다음 함수의 입력으로 들어갈겁니다.

00:00:07.951 --> 00:00:10.857
만약 다음 함수가 2개의 입력을 원하게 되면,

00:00:10.857 --> 00:00:13.135
우린 이걸 1개의 입력으로 줄여야하죠.

00:00:13.135 --> 00:00:14.501
그냥 하면 동작하지 않을거예요.

00:00:14.501 --> 00:00:19.410
그래서 그 대신 우린 prefillFunction을 실행하는거죠.

00:00:19.410 --> 00:00:24.164
그 안에서 우리가 미리 채우길 원하는 함수를 넣어서
새로운 함수를 만들죠.

00:00:24.164 --> 00:00:31.524
그리고 미리 채울 값을
그 함수의 백팩에 저장해서 반환하는거예요.

00:00:31.524 --> 00:00:36.354
그럼 그 코드는 나중에 새로운 label인

00:00:36.354 --> 00:00:40.620
multiplyBy2로 실행될 때,
1개의 입력인 5로 실행되는겁니다.

00:00:40.620 --> 00:00:43.098
그건 그렇고,
우리는 이걸 우리의 팀원이 읽을 수 있도록

00:00:43.098 --> 00:00:46.657
직관적으로 만들려고 노력해야 하죠.

00:00:46.657 --> 00:00:51.881
이런 5를 넣고 multiplyBy2, 실제로는 inner안에서,

00:00:51.881 --> 00:00:56.583
이 함수와 데이터가 있는 백팩이 있으니까

00:00:56.583 --> 00:01:01.398
multiply라는 최초 생성될 때
전달받은 백팩의 함수를

00:01:01.398 --> 00:01:02.310
실행할 수 있고,

00:01:02.310 --> 00:01:08.953
미리 채워진 값도 같이 multiply에서
처리가 되어 그 결과를 반환하고

00:01:08.953 --> 00:01:15.611
그건 그냥 multiplyBy2를 한 것 처럼 보이죠.
미리 채워진 prefilledValue인 2로요.

00:01:15.611 --> 00:01:20.503
이걸 Partial Application이라고 해요.

00:01:20.503 --> 00:01:22.757
부분적으로 데이터를 함수에 적용하는거죠.

00:01:22.757 --> 00:01:27.009
이게 Functional Programming에서의 Closure예요.

00:01:27.009 --> 00:01:30.602
prefiiledValue가 변하지 않는 걸 아니까요.

00:01:30.602 --> 00:01:34.909
제가 JavaScript에서 제일 좋아하는 개념이지만,
Closure를 사용할 때,

00:01:34.909 --> 00:01:38.289
정말로 Functional을 엄격하게 적용한다면,
이게 순수한건가요?

00:01:38.289 --> 00:01:39.398
음 아니예요.

00:01:39.398 --> 00:01:42.862
기억하세요. 제가 함수를 실행할 때
백팩의 뭔가를 변경한다면,

00:01:42.862 --> 00:01:46.748
그러니까 이 함수를 실행할 때,
회차를 기억하기 위해 여길 바꿔야만 한다면요.

00:01:46.748 --> 00:01:49.465
이 말은 코드가 라인 단위로 독립적이지 않은거죠.

00:01:49.465 --> 00:01:52.507
Global namespace엔 결과를 가지지는 않지만,

00:01:52.507 --> 00:01:55.811
기술적으로 함수를 다시 실행하면 백팩의 값이

00:01:55.811 --> 00:01:57.214
계속 1씩 증가할거니까요.

00:01:57.214 --> 00:02:00.866
그게 바뀌는거예요.
그게 함수의 순수성을 깍아내리죠.

00:02:00.866 --> 00:02:05.665
그 말은 다음에 이 코드를 실행하면,
multiplyBy2를 찾는다고 하더라도,

00:02:05.665 --> 00:02:09.409
그 다음번엔 다르게 동작할거예요.

00:02:09.409 --> 00:02:13.783
그 말은, 이 라인이 multiplyBy2를 처음 찾아서

00:02:13.783 --> 00:02:17.259
실행하면 그게 나머지 코드베이스에 영향을 주는거죠.

00:02:17.259 --> 00:02:19.956
어디서 이 함수를 다시 실행하건,
영향을 받죠. 변해있어요.

00:02:19.956 --> 00:02:22.958
이건 각각의 라인이 독립적이지 않는거예요.

00:02:22.958 --> 00:02:25.528
그리고 제 최종의 어떤, 여러분들 알죠,

00:02:25.528 --> 00:02:28.437
Functional Programming의 가장 중요한 목표로 돌아가면,

00:02:28.437 --> 00:02:32.285
이런 테크닉은 우리 코드의 가독성을
드라마틱하게 올려주지만,

00:02:32.285 --> 00:02:35.090
이걸 늘 항상 완벽하게 쫓아가려고 할 필요는 없어요.

00:02:35.090 --> 00:02:40.828
하지만 지금처럼 Closure나
함수의 백팩을 사용하는 것도

00:02:40.828 --> 00:02:45.759
Functional Programming이라고 불려도 괜찮은거예요.

00:02:45.759 --> 00:02:48.965
왜냐하면, 여기서 우린 이걸 미리 채워진 값이랑

00:02:48.965 --> 00:02:53.098
이걸 실행함으로써 수정이 된 함수를 만들고

00:02:53.098 --> 00:02:57.147
매번 multiplyBy2를 실행할 때마다
백팩 내부를 바꾸는게 없으니까요.

00:02:57.147 --> 00:02:59.953
이 라인은 확실히 독립적이죠

00:02:59.953 --> 00:03:03.897
이 라인은 우리가 이걸 실행하면서
다른 결과가 없다는 걸 알 수 있어요.

00:03:03.897 --> 00:03:07.637
다음에 이걸 실행하더라도,
백팩안의 이런 것들은 똑같으니까요.