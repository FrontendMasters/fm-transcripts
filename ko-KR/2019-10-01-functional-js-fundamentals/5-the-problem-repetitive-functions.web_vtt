WEBVTT

00:00:02.510 --> 00:00:07.377
Will Sentance: 여기 보드에 쓰여진대로,

00:00:07.377 --> 00:00:12.364
모든 함수는 거의 동일해요.

00:00:12.364 --> 00:00:15.266
딱 변한 건 뭐죠 Eric?

00:00:15.266 --> 00:00:16.339
방금 했던 이 다른 함수들 간에요.

00:00:16.363 --> 00:00:18.038
Eric: 연산자가 달라요.

00:00:18.039 --> 00:00:24.490
네, 이 기능은, 뭘 하는거죠?

00:00:24.490 --> 00:00:26.534
array의 각 요소를 먼저 보죠,

00:00:26.534 --> 00:00:31.356
0번째 위치, 1번째 위치, 2번째 위치가
각 1, 2, 3이고,

00:00:31.356 --> 00:00:37.295
이 각각 화면 중 이건 동일하죠.

00:00:37.295 --> 00:00:40.443
입력값인 array를 가지고,
output 배열을 새로 만들어요.

00:00:40.443 --> 00:00:44.226
그리고, 입력된 array를 순회하면서
각 요소에 다른 작업을 하죠.

00:00:44.226 --> 00:00:45.625
이걸 보세요.

00:00:45.625 --> 00:00:47.392
다른 작업을 합니다.

00:00:50.065 --> 00:00:52.217
Will Sentance: 이게 다른 일의 전부예요.
반면에,

00:00:52.217 --> 00:00:53.277
다른 모든 코드는 똑같아요.

00:00:53.277 --> 00:00:56.982
Functional Programming에서도 마찬가지지만,
함수의 첫 번째 원칙은

00:00:56.982 --> 00:00:58.412
반복하지 말라예요.

00:00:58.412 --> 00:01:00.769
한 번만 저장하고, 계속 반복 실행하는거죠.

00:01:00.769 --> 00:01:03.040
그게 우리가 여기에서 할 일인거죠.

00:01:03.040 --> 00:01:05.426
그럼 어떻게..Seth, 제가 이러면,

00:01:05.426 --> 00:01:11.156
만약 placeholder를 만들어둠으로써,
multiplyBy2 함수를 일반화한다면,

00:01:11.156 --> 00:01:16.422
multiplyBy2에 아무 숫자나 할 수 있게 실행한다면요,

00:01:16.422 --> 00:01:19.287
어떤 게 가능할까요, Seth,
멋진 말 말고

00:01:19.287 --> 00:01:23.226
직관적으로요. 완전 직관적인 느낌으로
뭐가 가능하죠, Seth?

00:01:23.226 --> 00:01:26.232
매번 이런 함수를 만들어야 하는 굴레에서 벗어나려면요?

00:01:26.232 --> 00:01:27.842
Seth: 실행 시에 Closure를 전달하나요?

00:01:27.842 --> 00:01:31.524
Will Sentance: 완전 틀린 말은 아닌데,
좀 더 간단하게요, Sam?

00:01:31.524 --> 00:01:34.481
Sam: 추가적인 argument를 전달합니다.

00:01:34.481 --> 00:01:37.148
Will Sentance: 그게 어떤 함수가 되겠죠.

00:01:37.148 --> 00:01:39.516
어떤 기능인거죠.

00:01:39.516 --> 00:01:43.212
여러분, 이론적으로는요,
Seth가 힌트를 준 것처럼,

00:01:43.212 --> 00:01:46.572
Sam도 그렇구요. 
뭔가 이론적으로는 *2를 넘길 수 있고,

00:01:46.572 --> 00:01:51.289
이론적으로 /2를 넘기면 될 것 같죠.

00:01:51.289 --> 00:01:55.426
그럼, 이런 코드 조각을 제가 넘길 수 있나요?

00:01:55.426 --> 00:01:56.527
JavaScript에서요?

00:01:56.527 --> 00:01:57.829
이런 걸 전달할 수 있나요?

00:01:57.829 --> 00:02:01.209
이렇겐 못하죠.

00:02:01.209 --> 00:02:04.643
여러분, JavaScript에서는요, 
이런 작은 코드 조각을 묶어서

00:02:04.643 --> 00:02:07.848
저장할 수 밖에 없고,
물론 이걸 string으로 전달하는 걸 상상할 수도 있죠.

00:02:07.848 --> 00:02:11.570
여러분들도 이런 걸 해서, 전달하고 그걸 채우고

00:02:11.570 --> 00:02:12.799
이런 걸 상상할 수 있을거예요.

00:02:12.799 --> 00:02:16.442
저걸 넘겨서, *2를 해서 이걸 채워주는 거죠.

00:02:16.442 --> 00:02:21.348
JavaScript에선 안돼요. 이렇게 할 수 없죠. 
*2만 처리할 순 없어요.

00:02:21.348 --> 00:02:26.344
뭔가 array 옆에 빈 칸으로 두고, 그걸 나중에 채우고,

00:02:26.344 --> 00:02:27.382
안돼요. 안됩니다.

00:02:27.382 --> 00:02:34.026
JavaScript에선 나중에 사용할 코드를 묶어서

00:02:34.026 --> 00:02:39.518
다른 함수에 삽입하는 유일한 방법은 어디에 저장하는거죠?

00:02:39.518 --> 00:02:40.691
학생들: Function이요.

00:02:40.691 --> 00:02:41.254
Will Sentance: 잘했어요.

00:02:41.254 --> 00:02:43.497
[웃음] 좋았어요.

00:02:43.497 --> 00:02:45.206
정확해요.

00:02:45.206 --> 00:02:48.476
우린 지금 DRY 원칙을 어기고 있죠.
굉장히 반복하고 있어요.

00:02:48.476 --> 00:02:49.591
Eric 지금 지루하죠.

00:02:49.591 --> 00:02:50.573
우린 뭘 할 수 있죠?

00:02:50.573 --> 00:02:54.839
우린 함수를 일반화 할 수 있고, 특별한 지시문을 전달 할 수 있어요.

00:02:54.839 --> 00:02:59.510
copyArray, 이제 Manipulate라고 하죠.
이걸 실행할 때요. 넘어가서 처리하죠.

00:02:59.510 --> 00:03:04.558
이제 여기에서, 각 요소를 *2 하는 걸
미리 설정하지 않아요

00:03:04.558 --> 00:03:08.227
*2나 /2를 하지 않아요, +3도 안하죠.

00:03:08.227 --> 00:03:12.595
그 대신 여기에 placeholder로 instructions를 만들어두고

00:03:12.595 --> 00:03:16.327
이제 1, 2, 3을 복사하고, *2를 하지 않고,

00:03:16.327 --> 00:03:20.474
이제 배열을 복사하고, 함수를 실행할 때 그걸 채운 뒤,

00:03:20.474 --> 00:03:24.959
그러니까, 배열을 복사하고, 뭔가를 하는거죠.
그래서 instructions를

00:03:24.959 --> 00:03:29.789
빈 공간으로 두죠. 결국 함수를 실행해서

00:03:29.789 --> 00:03:33.527
array가 1, 2, 3이 되고,
우린 뭔가 아무거나 할 수 있어요.

00:03:33.527 --> 00:03:34.716
아직 그걸 사용 안했죠.

00:03:34.716 --> 00:03:39.770
우리가 실행할 때, 더 상세하게 만들 수 있죠.
[1, 2, 3]을 가지고,

00:03:39.770 --> 00:03:45.378
instructions는 문자 그대로
multiplyBy2로 대체될거예요.

00:03:45.378 --> 00:03:48.607
그래서 어쨌거나 여러분이 본
instructions는 사라지고

00:03:48.607 --> 00:03:52.318
그건 multiplyBy2가 되는거죠.
이게 뭔가 좋아보이죠.

00:03:52.318 --> 00:03:55.663
array의 0번째는 1이 될 거구요.

00:03:55.663 --> 00:03:58.958
instructions는 multiplyBy2가 될 겁니다.

00:03:58.958 --> 00:04:05.401
multiplyBy2(1)은 multiplyBy2에
1을 넣어서 실행하란 뜻이죠.

00:04:05.401 --> 00:04:11.151
그래서 1은 2가 곱해지고
1x2는 2가 반환되는거죠,

00:04:11.151 --> 00:04:16.442
입력값 1은 2가 곱해져서 2로 평가될 거고,

00:04:16.442 --> 00:04:21.981
그 출력이 2가 되면
그 2는 output에 Push되는거죠.

00:04:21.981 --> 00:04:27.565
그럼 이걸 라인 단위로 쫓아가보죠. 
정확히 어떤 일이 일어나는지 보죠.

00:04:27.565 --> 00:04:31.605
이게 실제로 오늘 우리가 하는 모든 것의 가장 중요한

00:04:31.605 --> 00:04:34.286
기본 원칙 중 하나가 될 것입니다.