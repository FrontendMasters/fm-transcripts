WEBVTT

00:00:00.396 --> 00:00:04.262
Will Sentance: 그 함수들은 하나씩 데이터를 넘겨주며 실행하죠.

00:00:04.262 --> 00:00:06.850
그런 스타일을 point free라고 합니다.

00:00:06.850 --> 00:00:10.123
Point free 스타일로 코드를 작성하는 건,
pointless 라고도 불립니다.

00:00:10.123 --> 00:00:13.813
코드를 작성하기 위해,

00:00:13.813 --> 00:00:18.743
함수의 목록을 작성하는거죠.

00:00:18.743 --> 00:00:21.152
우린 그것들의 argument와 그 라인에서 반환된 값을

00:00:21.152 --> 00:00:23.859
명시적으로 처리하지 않죠.

00:00:23.859 --> 00:00:28.665
그걸 괄호로 호출하지 않아요, 그것을 명시적으로 만들지 않죠.

00:00:28.665 --> 00:00:30.971
그 대신, 우린 이걸 그냥 리스트화하고

00:00:30.971 --> 00:00:35.097
그것들이 실행되는 각 라인별 입력 출력의 구조만 아는거죠.

00:00:35.097 --> 00:00:37.419
해당 라인의 출력이 다음 라인의 입력이 됩니다.

00:00:38.550 --> 00:00:41.099
이 함수의 출력이 다음 함수의 입력이 되고,
그 함수의 출력이

00:00:41.099 --> 00:00:42.260
다음 라인의 입력이 되죠.

00:00:42.260 --> 00:00:44.122
이게 point free 스타일이예요.

00:00:44.122 --> 00:00:46.790
그리고, 가독성이 올라가죠.

00:00:46.790 --> 00:00:47.664
해, 해, 해, 해.

00:00:47.664 --> 00:00:52.133
값이랑 실행하고, 그 값이랑 실행하고,
이건 값이 2개일 텐데 그거랑 실행하고

00:00:52.133 --> 00:00:55.197
이건 값 3개가 있는데, 위에 사이드이펙트가 있고
이런게 아니죠.

00:00:55.197 --> 00:00:56.122
그냥 실행, 실행, 실행, 실행.

00:00:56.122 --> 00:00:59.320
모든 라인이 거기서 뭘 하는 건지 정확히 알죠.

00:00:59.320 --> 00:01:02.771
그 코드의 나머지 부분을 볼 필요가 없죠.
다른 곳에 영향이 없어요.

00:01:02.771 --> 00:01:04.766
이건 오직 바로 다음 라인에만 영향을 주죠.

00:01:04.766 --> 00:01:07.930
그것이 유일한 입력값이기 때문에
argument에 대한 걱정도 없죠.

00:01:07.930 --> 00:01:10.121
입력은 바로 이전 라인의 결과라는 걸 알고 있기 때문에

00:01:10.121 --> 00:01:11.282
명시적인 입력값이 필요 없죠.

00:01:11.282 --> 00:01:12.048
근데 뭐하러 쓰겠어요.

00:01:12.048 --> 00:01:13.770
그냥 묵시적으로 존재하죠.

00:01:13.770 --> 00:01:17.696
이게 point free 스타일 코딩이라고 알려져 있고
가독성을 올려주죠.

00:01:17.696 --> 00:01:19.700
일단 받아들이게 되면, 엄청날겁니다.

00:01:19.700 --> 00:01:20.768
좋아요.

00:01:20.768 --> 00:01:23.582
디버깅이 쉽다.
버그가 어디서 발생했는지 정확한 라인을 알죠.

00:01:23.582 --> 00:01:25.625
첫번째로 label이 있으니까요.

00:01:25.625 --> 00:01:29.218
호출된 곳으로 가서 보면,
"어 여기네" 할 수 있죠.

00:01:29.218 --> 00:01:30.630
라인에 label이 있으니까요.

00:01:30.630 --> 00:01:35.119
그 결과값도 그 라인이죠.
그래서 나오는 질문은,

00:01:35.119 --> 00:01:37.214
얼마나 많은 버그가 있을 수 있는가?

00:01:37.214 --> 00:01:41.218
이게 Functional Programming의 추종자들이
왜 버그를 못잡는지에 대한

00:01:41.218 --> 00:01:43.938
소리를 듣는 이유예요.
버그를 넘겨버리고 동작했으니까요.

00:01:43.938 --> 00:01:48.482
이게 진짜인진 모르겠지만,
대부분의 버그는 모든 end-to-end 레벨에

00:01:48.482 --> 00:01:52.745
의존하는 코드 트리에서 나온다는
인식에서 출발했기 때문이라고 봐요.

00:01:52.745 --> 00:01:55.394
모든 개별 라인이 라인 전체에 영향을 미치죠.

00:01:55.394 --> 00:02:00.457
그리고 함수를 통해 여러분들은 10가지의 다른 라인들에 미치는 영향을

00:02:00.457 --> 00:02:03.443
10개의 라인으로 줄일 수 있죠.

00:02:03.443 --> 00:02:10.133
하지만 우린 실제로 보통 함수 밖에서
결과를 갖는다는 걸 알고있죠.

00:02:10.133 --> 00:02:15.173
실제로 대부분의 경우 모든 라인들은
다른 라인들에 영향을 주죠.

00:02:15.173 --> 00:02:19.276
이건 정말 절대적으로 완전히 정반대예요.

00:02:19.276 --> 00:02:21.596
완전 정반대 개념이죠.

00:02:21.596 --> 00:02:22.878
좋아요.

00:02:22.878 --> 00:02:28.388
네, 이제 우린 각각의 모든 라인들이 완전히 자기 충족적이고,

00:02:28.388 --> 00:02:35.420
밖으로 어떤 영향도 미치지 않는 개념에 대해
잠시 이야기를 해볼까 합니다.

00:02:36.440 --> 00:02:39.640
여기에는 약간의 코멘트만 언급하려고 해요.

00:02:39.640 --> 00:02:41.800
이것이 그렇게 놀라운 건 아니거든요.

00:02:41.800 --> 00:02:45.362
Functional Programming에서
이게 굉장히 중요하다고 하더라도,

00:02:45.362 --> 00:02:46.860
우리가 진행해가면서 이걸 보고 있어요.

00:02:46.860 --> 00:02:51.053
작은 단위로 조합되고
자동적으로 실행되는 함수는 반드시

00:02:51.053 --> 00:02:54.270
높은 확률로 예측 가능해야 하는게 아니라
완전히 예측 가능해야 해요.

00:02:54.270 --> 00:02:57.955
말 그대로 명확한 반환 값에 argument는 따로 없을 것이기 때문에

00:02:57.955 --> 00:03:01.045
그 라인은 하나의 결과값만 가지는 것에 대해 확신해야해요.

00:03:01.045 --> 00:03:05.067
전 대부분의 경우 add3 함수를 직접 들어가서 보지 않을거니까요.

00:03:05.067 --> 00:03:07.678
하나의 결과만이 다음 라인으로 넘어가죠.

00:03:07.678 --> 00:03:08.432
Pure Function은,

00:03:08.432 --> 00:03:12.281
음, 읽어보죠, 우린 평가된 결과값이
다음 코드 유닛의 입력값으로

00:03:12.281 --> 00:03:14.350
자동적으로 전달 되는 것에 의지한다.

00:03:14.350 --> 00:03:17.831
무슨 뜻인지 잠시 뒤에 보게 될텐데, 모든 사이드 이펙트가

00:03:17.831 --> 00:03:21.144
모든 걸 다 파괴할거니까요.

00:03:21.144 --> 00:03:23.418
우리가 진행하는 모든 걸 취소할겁니다.

00:03:23.418 --> 00:03:26.009
원하는 건 이 함수를 실행시켰을 때,

00:03:26.009 --> 00:03:30.841
그 결과만이 해당 라인의 출력이 되어야 하고,

00:03:30.841 --> 00:03:35.760
자동적으로 reduce의 구조에 따라
다음 라인에 들어가야 한다는거죠.

00:03:35.760 --> 00:03:39.380
Global Memory 어딘가에 다른 결과가 된다면,
모든 게 다 꼬여요.

00:03:39.380 --> 00:03:40.730
더 이상 읽기 쉬운 코드가 아닌거죠.

00:03:42.780 --> 00:03:44.720
multiplyBy2, add3, divideBy5를 실행하지 않고

00:03:44.720 --> 00:03:48.528
add3를 실행하고 그게 어딘가 임의의 위치로 가게 되거나

00:03:48.528 --> 00:03:51.960
코드의 다른 어딘가로 가면, 모든 게 다 깨지는거예요.

00:03:51.960 --> 00:03:54.425
그래서 이런 "순수"라고 하는 함수를 사용해야 합니다.

00:03:54.425 --> 00:03:57.579
유일한 결과는 바로 평가된 결과여야 하는거죠.

00:03:57.579 --> 00:04:00.721
참조 투명성과도 관련있어요.

00:04:00.721 --> 00:04:04.115
하지만 참조 투명성은 우리가
지금 하고 있는 것들의 범위를 넘어서는

00:04:04.115 --> 00:04:05.692
좀 더 정교한 개념이예요.

00:04:05.692 --> 00:04:10.328
좀 벗어나죠, 하지만 Pure Function과 관련 있고

00:04:10.328 --> 00:04:12.720
일단 Pure Function만 보죠.

00:04:12.720 --> 00:04:14.735
여기있는 짧은 코드를 한 번 보죠

00:04:14.735 --> 00:04:16.949
여기 있는 분들이 모두 사이드 이펙트라는 걸
알고있는지 확인합시다.

00:04:16.949 --> 00:04:22.028
이게 너무 짧아서 오래 끌고 싶진 않지만,

00:04:22.028 --> 00:04:27.120
이건 꽤 중요해요. 우리가 하는 모든 내용과
관련이 있다고 생각하거든요.

00:04:27.120 --> 00:04:31.846
그래도 우리는 기본적으로 대부분의 개념을 세웠기 때문에

00:04:31.846 --> 00:04:34.100
오래 걸리지 않을 것 같아요.

00:04:34.100 --> 00:04:34.952
좋아요.

00:04:37.309 --> 00:04:41.390
Will Sentance: 좋아요, 여기 아래에 진행하죠.

00:04:41.390 --> 00:04:43.810
첫 번째 라인이예요,
여기 작은 미니 앱으로 할께요.

00:04:43.810 --> 00:04:46.380
Memory도 있는 미니 앱입니다.

00:04:46.380 --> 00:04:49.340
첫 번째 라인입니다. Michael, 간단하게 할께요.
뭘 하죠?

00:04:49.340 --> 00:04:53.306
Michael: num이라는 label을 가지고
거기에 10이란 값이 할당됩니다.

00:04:53.306 --> 00:04:54.090
Will Sentance: 네

00:04:55.540 --> 00:04:56.380
다음 라인은요, Reginald?

00:04:56.380 --> 00:04:58.400
Reginald: add3요.

00:04:58.400 --> 00:05:01.210
Will Sentance: 거의 눈이 마주치자마자 이렇게 빠르게

00:05:01.210 --> 00:05:03.890
대답한 사람은 처음이네요. 대단합니다.

00:05:03.890 --> 00:05:05.103
맞았어요, add3라는 함수죠.

00:05:05.103 --> 00:05:08.420
이걸 이렇게 그릴께요. 실제로.

00:05:08.420 --> 00:05:14.870
입력은 x고, 반환은 x + 3값이고,
알 수 없는 동작이 있죠.

00:05:14.870 --> 00:05:16.611
이 안에 있어요.

00:05:16.611 --> 00:05:18.442
이제 실행하죠.
아마 이것의 결과가

00:05:18.442 --> 00:05:19.802
어딘가에 할당되긴 할거예요.

00:05:19.802 --> 00:05:25.680
7을 넣은 add3입니다. 여러분.

00:05:25.680 --> 00:05:32.322
3시인데, 다시 활기를 찾을 수 있을겁니다.
새로운-

00:05:32.322 --> 00:05:34.510
학생들: Execution Context
Will Sentance: 아주 좋아요.

00:05:34.510 --> 00:05:35.651
Will Sentance: 이 안으로 가죠.

00:05:35.651 --> 00:05:39.777
Local Memory로 가면,

00:05:39.777 --> 00:05:44.498
x를 뭘로 설정하죠, Virginia?

00:05:44.498 --> 00:05:45.941
Virginia: 10이요.

00:05:45.941 --> 00:05:50.295
Will Sentance: 우린 지금 add3를 실행하고 있어요.

00:05:50.295 --> 00:05:51.683
Virginia: 죄송해요, 7이요.

00:05:51.683 --> 00:05:53.113
Will Sentance: 맞았어요, 7입니다.

00:05:55.271 --> 00:05:57.517
Will Sentance: num++죠?
주황색으로 해야겠네요.

00:05:57.517 --> 00:06:01.710
주황색을 쓸 건데

00:06:01.710 --> 00:06:05.309
위험한 색이라고 생각해주세요.

00:06:05.309 --> 00:06:12.690
좋아요, num이죠.
이게 Local Memory에 있나요, Jasmine?

00:06:12.690 --> 00:06:15.730
아니죠. 
JavaScript가 그럼 어디를 찾아보죠?

00:06:15.730 --> 00:06:16.580
Jasmine: Global이요.

00:06:16.580 --> 00:06:17.350
Will Sentance: 네, 밖으로 나가죠.

00:06:17.350 --> 00:06:19.960
말 그대로 Execution Context의 밖으로 나가요.

00:06:19.960 --> 00:06:21.770
그리고 num에 뭘 하죠?

00:06:21.770 --> 00:06:24.910
Jasmine: 1을 더해요.

00:06:24.910 --> 00:06:29.707
Will Sentance: 그리고 나서
7 + 3은 10이 될거고,

00:06:29.707 --> 00:06:31.820
그걸 반환하겠죠.