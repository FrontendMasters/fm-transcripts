WEBVTT

00:00:00.000 --> 00:00:00.981
Will Sentance: 이게 어떻게 가능하죠?

00:00:00.981 --> 00:00:06.218
음, JavaScript에서 함수는

00:00:06.218 --> 00:00:12.406
1급 객체라고 불립니다.
그 말은 저걸 보세요.

00:00:13.568 --> 00:00:18.999
Will Sentance: 여기 multiplyBy2는, 여러분, 
실제로 이건 객체예요.

00:00:18.999 --> 00:00:23.815
그리고 알아요-, 온라인 수강생을 위해서.

00:00:23.815 --> 00:00:29.828
전 알아요. 만약 새로운 객체를
이렇게 만든다면,

00:00:29.828 --> 00:00:33.847
좀 이상한데, 신경쓰지 마요.

00:00:33.847 --> 00:00:39.162
만약 객체를 이렇게 만든다면,
전 이걸 함수를 전달할 수 있어요. 문제 없이요.

00:00:39.162 --> 00:00:41.468
사실 배열이나 객체는 내부는

00:00:41.468 --> 00:00:43.323
조금 뒤에 볼거예요.

00:00:43.323 --> 00:00:46.820
꽤 유영할겁니다.
완전히 Functional은 아니지만, 도움될 거예요.

00:00:46.820 --> 00:00:49.039
JavaScript의 프로토타입 특성을 기반으로,

00:00:49.039 --> 00:00:50.878
훌륭한 특징이 있어요.

00:00:50.878 --> 00:00:54.142
하지만 배열이나 객체, 함수는 그냥 객체예요.

00:00:54.142 --> 00:00:57.344
그 말은, 완전히 1급 시민으로 간주된다는거죠.

00:00:57.344 --> 00:00:59.722
객체의 모든 특징을 가집니다.

00:00:59.722 --> 00:01:04.322
입력값으로서 다른 함수에 전달될 수 있다는 것도 포함이죠.

00:01:04.322 --> 00:01:06.575
그게 우리가 방금 여기서 한 거예요.

00:01:06.575 --> 00:01:11.535
이를 통해 우리가 수행할 다양한
특정 작업들로 함수를

00:01:11.535 --> 00:01:13.411
재사용할 수 있는거죠.

00:01:13.411 --> 00:01:16.569
copyArrayAndManipulate는 어떤 코드로도 동작할 수 있고,

00:01:16.569 --> 00:01:19.070
그건 array의 각 요소를 처리할겁니다.

00:01:19.070 --> 00:01:22.636
array를 처리하기 위해 조작하는거죠.

00:01:22.636 --> 00:01:27.459
그리고 다른 함수로부터
함수를 반환할 수 있죠.

00:01:27.459 --> 00:01:30.737
그건 오후에 볼거예요.

00:01:30.737 --> 00:01:35.483
Function Decoration나, Currying,
Partial Application같은

00:01:35.483 --> 00:01:37.833
아주 어려운 일들을 할 수 있게 해줍니다.

00:01:37.833 --> 00:01:41.918
모든 건 오후에 할거예요. 하지만 먼저, 이걸 좀 봐요.

00:01:41.918 --> 00:01:46.790
이것들 중에 Callback Function이 뭐고,
Higher Order Function이 뭐죠?

00:01:46.790 --> 00:01:51.098
Virginia, 여기에서 가장 상위 함수와

00:01:51.098 --> 00:01:54.299
약간 작은 Callback Function이 뭔가요?

00:01:54.299 --> 00:01:59.415
이건 약간 어려운 용어예요
Higher Order Function, 주눅들게 하고,

00:01:59.415 --> 00:02:04.333
뭔가 진지하고 세련되보이고 그렇지만
이미 다 봤던거예요.

00:02:04.333 --> 00:02:06.291
Virginia: copyArrayAndManipulate인가요?

00:02:06.291 --> 00:02:08.301
Will Sentance: 그게?
Virginia: 네?

00:02:08.301 --> 00:02:09.964
Will Sentance: copyArrayAndManipulate가?

00:02:09.964 --> 00:02:12.019
Virginia: Higher Order Function이요.
Will Sentance: 그게 Higher Order Function이죠.

00:02:12.019 --> 00:02:14.575
그리고 작은 Callback Fucntion은요?

00:02:14.575 --> 00:02:16.176
Virginia: multiplyBy2요.

00:02:16.176 --> 00:02:17.141
Will Sentance: multiplyBy2죠.

00:02:17.141 --> 00:02:20.046
Hihger Order Function이예요,
여러분, 이거예요.

00:02:20.046 --> 00:02:23.686
전달되어 들어가는 multiplyBy2가
Callback Fucntion이구요.

00:02:23.686 --> 00:02:29.485
저 바깥의 함수가 함수를 받아들이죠.
이게 Higher Order Function이예요.

00:02:29.485 --> 00:02:33.814
이게 Functional Programming의 핵심 요소예요.
그게 이거죠.

00:02:33.814 --> 00:02:37.422
비워둘 수 있는 작은 공간이 있는 함수죠.

00:02:37.422 --> 00:02:39.447
실행할 때 그게 뭘 할건지 지정하기 위해서요.

00:02:39.447 --> 00:02:42.483
실행할 배열을 정하는 것처럼 사용할 코드를

00:02:42.483 --> 00:02:45.715
특정하게 지정하는 것이죠. 이거예요.

00:02:45.715 --> 00:02:47.049
좋아요, 여러분.

00:02:47.049 --> 00:02:51.727
그냥 이름이예요. 여러분들이 굳이
Higher Order Function이라고 할 필요도 없어요.

00:02:51.727 --> 00:02:53.419
그냥 이게 일반적인 함수가 아니라고 하는 말을

00:02:53.419 --> 00:02:54.177
상상할 수 있으면 되죠.

00:02:54.177 --> 00:02:57.430
Higher Order 중 하나는, 함수를 삽입함으로써, 
그걸 그냥 가지고

00:02:57.430 --> 00:02:58.699
사용할 수 있는거죠.

00:02:58.699 --> 00:03:02.315
그래서 우리는 내부에서 실행될 코드를 삽입하여

00:03:02.315 --> 00:03:04.474
Higher Order Function을 만드는거죠.

00:03:04.474 --> 00:03:07.904
또한, 아무튼 말했듯이 이따가 볼거예요.

00:03:07.904 --> 00:03:12.042
어떤 함수로 함수를 반환할 수 있어요.
이걸 이따 볼거예요.

00:03:12.042 --> 00:03:15.085
아무튼 이걸 이따 볼건데, 이걸 말할거예요.

00:03:15.085 --> 00:03:17.520
사실 이런 멋진 개발자들이 있는 곳에서 이야기를 하지만,

00:03:17.520 --> 00:03:21.406
5년 10년의 경험을 가진 엔지니어들 조차도,

00:03:21.406 --> 00:03:23.243
이 개념이랑 늘 씨름합니다.

00:03:23.243 --> 00:03:28.086
다른 함수를 실행하는 안에서 태어나는 함수랑
그걸 저장하고,

00:03:28.086 --> 00:03:30.291
선언하고 반환하고 그런것들이요.

00:03:30.291 --> 00:03:33.177
그들도 이거랑 매일 씨름해요.
이따 볼거예요.

00:03:33.177 --> 00:03:36.222
그것 또한 Higher Order Function이라고 해요.

00:03:36.222 --> 00:03:40.044
Higher Order Function을

00:03:40.044 --> 00:03:46.601
복습해보죠.

00:03:46.601 --> 00:03:50.476
더 쉽나요? 더 쉽게 기능을 추가할 수 있게 만드나요?

00:03:50.476 --> 00:03:51.629
뭐라고 하는지 보죠.

00:03:51.629 --> 00:03:55.169
새로운 copyArrayAndAdd3를 만들 필요가 없고,

00:03:55.169 --> 00:03:59.427
copyArrayAndDivideBy2를 만들 필요가 없다.
copyArrayAnd 어떤 함수든지요.

00:03:59.427 --> 00:04:04.335
그냥 add3를 넣은 Higher OrderFunction으로
copyArrayAndManipulate를 쓰는 것이

00:04:04.335 --> 00:04:06.652
코드를 DRY로 유지하는데 중요한 역할을 하죠.

00:04:06.652 --> 00:04:08.732
반복하지 말라. 한 번만 써라.

00:04:08.732 --> 00:04:10.931
그리고 그걸 조합해서
새로운 기능으로 만들어내라.

00:04:10.931 --> 00:04:15.829
우린 copyArrayAndDivideBy2로도,
copyArrayAndMultiplyBy2로도,

00:04:15.829 --> 00:04:17.497
copyArradAndAdd3로도 변화시켰죠.

00:04:17.497 --> 00:04:20.336
세 개의 큰 코드 블럭을 하나로 묶어낸 뒤

00:04:20.336 --> 00:04:22.977
작은 코드를 한 줄 추가하는거죠.

00:04:22.977 --> 00:04:26.925
거기에 삽입해서 그 안 줄안에서
더하고, 곱하죠. 그걸 넣었죠.

00:04:26.925 --> 00:04:28.068
더 읽기 쉬웠나요?

00:04:28.068 --> 00:04:31.951
네, 꽤 가독성이 좋았죠.
copyArrayAndManipulate와 multiplyBy2죠.

00:04:31.951 --> 00:04:36.227
한 번만 익숙해지면,
새로운 배열에 뭔가를 한다는 걸 이해하죠.

00:04:36.227 --> 00:04:39.036
전 multiplyBy2를 썼죠.

00:04:39.036 --> 00:04:42.755
이게 for-loop 방식보다
더 쉽게 일할 수 있게 하는 걸 알죠.

00:04:42.755 --> 00:04:45.615
Debug가 쉽나요?

00:04:45.615 --> 00:04:50.201
음, 전 우리가 무슨 일을 하고 있는지 이해하는 한
논쟁거리가 좀 될 것 같아요.