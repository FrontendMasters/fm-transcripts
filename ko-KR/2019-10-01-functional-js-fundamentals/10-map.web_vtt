WEBVTT

00:00:00.000 --> 00:00:02.170
Will Sentance: 마지막으로 이것의 실제 버전에

00:00:02.170 --> 00:00:04.310
적용하기 위해 체크할 건

00:00:04.310 --> 00:00:08.380
사람들이 이걸 copyArrayAndManipulate라고 하지 않는다는거죠.

00:00:08.380 --> 00:00:11.170
그들은 이 이름으로 부릅니다.
저도 이렇게 했었죠.

00:00:11.170 --> 00:00:12.690
이건 꽤 직관적이죠.

00:00:12.690 --> 00:00:14.020
3개의 문자죠.

00:00:14.020 --> 00:00:15.660
그게 Map이예요.

00:00:15.660 --> 00:00:19.510
copyArrayAndManipulate인 Map을 호출하는 건

00:00:19.510 --> 00:00:24.780
Higher Order Function에서 가장 중요한 것 중 한 가지입니다.

00:00:24.780 --> 00:00:25.450
이거죠.

00:00:25.450 --> 00:00:32.910
그럼 이제 이걸 copyArrayAndManipulate라고 안하고,
Map이라고 하죠.

00:00:32.910 --> 00:00:36.250
copyArrayAndManipulate가 아니라,
Map이라고 부릅시다.

00:00:37.470 --> 00:00:44.180
그러니까, 하나의 상태에서
데이터를 매핑한 거에 대해 생각했었죠.

00:00:44.180 --> 00:00:49.410
그 상태는 [1, 2, 3] 었고, 그걸 매핑해서, 변환시켜

00:00:49.410 --> 00:00:53.970
어떤 방법으로 변환된
새로운 데이터의 모음으로 바꾼거고,

00:00:53.970 --> 00:00:57.014
그게 바로 Mapping의 개념이라고 하는겁니다.

00:00:57.014 --> 00:01:01.530
Mapping은 데이터를 새로운 방식으로 사상(매핑)하여

00:01:03.060 --> 00:01:05.670
데이터를 변환하는 수학적인 개념이예요.

00:01:05.670 --> 00:01:10.220
각 요소 단위로 바꿔서 저장하는 거죠.

00:01:11.260 --> 00:01:13.610
저도 수학에서 그걸 뭐라고 부르는진 몰라요

00:01:13.610 --> 00:01:14.740
이유는 모르겠지만 그게 뭐든지요.

00:01:14.740 --> 00:01:17.770
좋아요, 약간 다른 방식으로 이야기해보죠.

00:01:17.770 --> 00:01:21.720
이건 JavaScript가 실행하는 걸 다이어그램으로 그린 거죠.

00:01:21.720 --> 00:01:25.200
이 다이어그램 방식은, 아,
전 이틀 전부터 목이 갔어요.

00:01:26.500 --> 00:01:28.790
어떤식으로든 다이어그램으로 해보죠.

00:01:30.710 --> 00:01:35.130
이건은 그게 실제로 하고 있는 것에 대한
높은 수준의 이해로 이어집니다.

00:01:35.130 --> 00:01:37.755
실제로 하는 게 뭘까요? Map이 뭐죠?

00:01:37.755 --> 00:01:44.574
copyArrayAndManipulte가 실제로 하는거죠. 
음, [1, 2, 3] 을 가지고요.

00:01:44.574 --> 00:01:49.080
좋아요. 첫 번째로 하는거죠.

00:01:49.080 --> 00:01:51.772
map이 하는 첫 번째가 뭐죠, Charles?

00:01:51.772 --> 00:01:54.641
map인 copyArrayAndManipulate가 한 첫 번째요.

00:01:54.641 --> 00:01:58.416
어떻게 array를 가지고 복사를 하고,
우리가 했던 것들 중에 첫번째는요, Charles?

00:02:01.562 --> 00:02:04.586
Charles: context요?

00:02:04.586 --> 00:02:05.240
Will Sentance: 맞아요.

00:02:05.240 --> 00:02:09.260
좋아요, 그 Context 안에서 처음 했던 건 뭐죠, Sam?

00:02:09.260 --> 00:02:10.094
Sam: parameter요.

00:02:10.094 --> 00:02:11.517
Will Sentance: 맞아요, 근데 다음 거요.

00:02:11.517 --> 00:02:13.752
Charles: 새로운 배열이요.

00:02:13.752 --> 00:02:14.300
Will Sentance: 맞아요.

00:02:14.300 --> 00:02:17.530
그게 Map이 하는 거예요.
새로운 배열을 만들죠.

00:02:18.800 --> 00:02:24.630
그리고 첫 번째 요소를 가지고 2를 곱하죠.

00:02:26.410 --> 00:02:28.360
음, 이번 경우엔, 2를 곱하는거죠.
우리가 여기서 하는거죠.

00:02:29.610 --> 00:02:33.440
2를 받고, 그걸 이 배열에 Push하죠.

00:02:33.440 --> 00:02:34.360
이해가죠?

00:02:34.360 --> 00:02:40.640
이걸 array에 Push하고,
2를 2로 곱하면 뭘 얻죠, Jasmine?

00:02:40.640 --> 00:02:41.245
Jasmine: 4요.
Will Sentance: 4죠.

00:02:41.245 --> 00:02:43.330
이걸 또 array에 Push하죠 이렇게요.

00:02:43.330 --> 00:02:47.320
그리고 또 하면 6이죠.

00:02:47.320 --> 00:02:52.305
우린 multiplyBy2 함수를 적용한거죠.

00:02:52.305 --> 00:02:58.890
이 각각의 요소가 있고,
이 배열에 Push한거죠. 좋아요.

00:02:58.890 --> 00:03:00.204
별 거 없어요.

00:03:00.204 --> 00:03:04.020
간단한 다이어그램을 보여주고 싶었어요.

00:03:04.020 --> 00:03:08.860
우리가 정확히 뭘 했는지에 대해 멀리서 보는 관점이죠.

00:03:08.860 --> 00:03:12.660
이유는, 이게 정확히 어떻게 보이는지에 대해

00:03:12.660 --> 00:03:15.082
개념적으로 알고 싶기 때문이죠?

00:03:15.082 --> 00:03:19.080
여러분들에게 말할 거니까요.
사실 우린 이거에 대해 꽤 많은 가정을 했고,

00:03:19.080 --> 00:03:20.490
이미 그걸로 일종의 힌트도 줬죠.

00:03:20.490 --> 00:03:23.810
우린 첫 번째 요소를 가져와서 배열에 결합하는 거에 대해

00:03:23.810 --> 00:03:25.560
가정을 했었어요.