WEBVTT

00:00:00.000 --> 00:00:02.579
Will Sentance: 우선 이걸 봐보세요.

00:00:02.579 --> 00:00:07.363
우린 우리가 해야할 코드 리스트를
이렇게 예쁘게 만들 수 있어요.

00:00:07.363 --> 00:00:08.885
이렇게죠.

00:00:08.885 --> 00:00:15.529
우리 퀴즈 게임에서, name이 Will이고, score가 3인

00:00:15.529 --> 00:00:19.828
객체를 가지고 player의 이름 전체를 찾죠.

00:00:19.828 --> 00:00:21.609
그 뒤에 First Name을 찾고,

00:00:21.609 --> 00:00:23.645
적절한 케이스를 처리하고,

00:00:23.645 --> 00:00:28.192
그리고 이 사용자를 알릴 label을 붙일거예요.

00:00:28.192 --> 00:00:33.777
그리고 DOM Element나 저 data가 있는 요소를 만들겁니다.

00:00:33.777 --> 00:00:37.644
그리고 그걸 가져와서 웹 페이지에 그릴 수 있겠죠.

00:00:37.644 --> 00:00:40.504
여러분, 정말 예쁘죠.

00:00:40.504 --> 00:00:43.024
이 읽기 쉽고 아름다운 느낌의 코드를 보세요.

00:00:43.024 --> 00:00:48.262
이 코드가 실제로 무엇을 할지 하나도 헷갈리지 않죠.

00:00:48.262 --> 00:00:53.052
하지만 이렇게 하기 위해서는 코드를 아주 작은 단위로 다뤄야 하고,

00:00:53.052 --> 00:00:58.531
이 작은 함수들도 아주 흥미로운 방식으로 처리해야 합니다.

00:00:58.531 --> 00:01:04.207
그리고 이 코드 라인들을 전체를 처리할 작업으로 다시 조립해야하죠.

00:01:04.207 --> 00:01:06.559
우린 여기에서 미리 봤죠.

00:01:06.559 --> 00:01:10.240
우린 그래서 이 작은 코드 블럭들을
재사용이 가능하도록 확실히 해야합니다.

00:01:10.240 --> 00:01:12.620
여러분들이 전체 작업을 작은 단계들로 쪼개고 나면,

00:01:12.620 --> 00:01:15.235
여러분들은 이 작은 단계들을
전체에서 재사용할 수 있게 됩니다.

00:01:15.235 --> 00:01:17.851
하지만, 여러분들이 이걸 전체 구간에서 재사용한다면,

00:01:17.851 --> 00:01:21.479
여러분들은 이것들이 그 주변의 것들과도 
독립적인지 알아야할 거예요.

00:01:21.479 --> 00:01:24.263
그게 오늘 우리가 할 일인거죠.

00:01:24.263 --> 00:01:28.255
우린 오늘 Higher Order Function과
Function Composition으로 시작할거예요.

00:01:28.255 --> 00:01:32.624
말했다시피, 이런 작은 코드들은 어디에서도 재사용될 수 있어요.

00:01:32.624 --> 00:01:36.670
어떻게 해야 Higher Order Function과
Function Composition에 따라

00:01:36.670 --> 00:01:38.194
잘 조립할 수 있을까요.

00:01:38.194 --> 00:01:41.042
이런 작업들 대부분은 숫자를 증가시키거나,

00:01:41.042 --> 00:01:43.666
배열을 순회하는 것들이 전형적입니다.

00:01:43.666 --> 00:01:44.846
우린 그것들을 계속 반복하죠.

00:01:44.846 --> 00:01:45.570
그걸 재사용해야해요.

00:01:45.570 --> 00:01:48.529
코드를 한 번만 작성하고, DRY를 유지해야하죠.
반복하지 않는 걸요. (Don't Repeat Yourself)

00:01:48.529 --> 00:01:49.929
재사용하셔야 해요.

00:01:52.251 --> 00:01:55.977
Will Sentance: 제가 말했듯이, 한 곳에서 한 번만
그 함수를 사용하지 않고

00:01:55.977 --> 00:02:00.255
모든 곳에서 사용한다면, 우리는 독립적이고

00:02:00.255 --> 00:02:03.782
그것이 외부의 데이터에 의존하지 않기를 바랄겁니다.

00:02:03.782 --> 00:02:09.155
그래서 우린 순수 함수와 상태 불변에 대해 이해해야 합니다.

00:02:09.155 --> 00:02:12.621
그리고 우리가 이런 코드들을 연결하고

00:02:12.621 --> 00:02:18.763
우리가 제어하지 않고 다른 함수에 의해 제어되는 코드를

00:02:18.763 --> 00:02:24.210
차례대로 실행하려면 기존의 저장된 함수을 조정하는

00:02:24.210 --> 00:02:29.581
꽤 흥미로운 일을 해야 할 수도 있습니다.

00:02:29.581 --> 00:02:31.733
그건 우리에게 또 다른 힘을 줄거예요.

00:02:31.733 --> 00:02:34.950
Closure의 도움과 함께 Function Decoration과

00:02:34.950 --> 00:02:40.215
Closure와 함께하는 Partial Application은
우리가 할 주요 테크닉입니다.

00:02:40.215 --> 00:02:45.307
만약 우리가 그걸 할 수 있다면,
우린 마지막엔 더 읽기 쉬운 코드를 만들거예요.

00:02:45.307 --> 00:02:50.932
모든 하나 하나의 라인에요. 너무 멋있을겁니다.

00:02:50.932 --> 00:02:55.546
우린 그게 뭘 하는지 정확히 알고,
디버깅 하기도 쉽겠죠.

00:02:55.546 --> 00:02:59.789
각 개별 라인은 멋진 label을 갖고,
개별적인 유닛은 하나의 결과만

00:02:59.789 --> 00:03:03.060
Application의 나머지로 보내는 게 아니라
다음 단계로만 넘길거예요.

00:03:03.060 --> 00:03:05.668
각 라인이 하는 일이 절대 헷갈리지 않고

00:03:05.668 --> 00:03:08.608
Application의 다른 부분에
영향을 미칠 위험도 없죠.

00:03:08.608 --> 00:03:10.979
기능을 추가하기도 쉽습니다.

00:03:10.979 --> 00:03:13.991
우린 이런 작은 함수들, 작은 유닛들을 가지고

00:03:13.991 --> 00:03:15.339
우린 그걸 조합해서 모든 걸 대응하죠.

00:03:15.339 --> 00:03:17.018
우린 특정 컴포넌트를 재작성할 필요도 없구요.

00:03:17.018 --> 00:03:20.331
우린 미리 작성된 컴포넌트들을 써내면 되죠.

00:03:20.331 --> 00:03:22.860
그런 것들이 우리가 오늘 할 겁니다.

00:03:22.860 --> 00:03:28.193
이건 우리가 재사용 가능한 함수와

00:03:28.193 --> 00:03:33.850
가변적이며, 유연한 코드 블럭과, 독립적이고, 예측 가능한 단계로

00:03:33.850 --> 00:03:39.140
하나에서 다음으로, 다음에서 다음으로 데이터를
전달하는 Application을 구축 할 수 있게 해줍니다.

00:03:39.140 --> 00:03:46.265
하지만, 이것은 JavaScript의 핵심 원리를
먼저 아는 것으로 시작해야 합니다.