WEBVTT

00:00:00.000 --> 00:00:01.062
Will Sentance: 한 가지,

00:00:01.062 --> 00:00:06.465
이 배열 결과에 더 많은 체인을 걸기 위해 우리가 확인할건요.

00:00:06.465 --> 00:00:09.456
만약 제가 함수를 붙이고, 그걸 리스트화 하고,

00:00:09.456 --> 00:00:13.840
결과를 저장하기보단, 바로 새로운 함수에 넘겨준다면,

00:00:13.840 --> 00:00:18.592
그 결과는 이런 공유된 함수들을 가진 배열이 아닐까요?

00:00:18.592 --> 00:00:21.112
좀 뒤에 볼께요, 그 전에 엄지를 들어보죠.

00:00:21.112 --> 00:00:24.168
여기 써진 걸 보면, 배열인 각 Higher Order Function인
filter reduce 같은 것의 결과는

00:00:24.168 --> 00:00:27.780
아 여기서 한 배열 reduce는 아니예요. 이건 숫자로 조합했으니까요.

00:00:27.780 --> 00:00:30.772
그 배열들은 모든 Higher Order Functions들에
접근할 수 있어요. map이나 reduce나

00:00:30.772 --> 00:00:32.149
이 prototype 체인을 통해서요.

00:00:32.149 --> 00:00:36.405
자 이 기본적인 개념의 체이닝에 대해
엄지를 들어보죠, 모르겠다, 알겠다.

00:00:36.405 --> 00:00:37.418
질문이 있다.

00:00:37.418 --> 00:00:41.208
여러분, 질문이 있으시면 해도 좋아요.
한 게 많이 없어요.

00:00:41.208 --> 00:00:43.183
좋아요, 여러분.

00:00:43.183 --> 00:00:46.148
reduce, filter and
chaining higher order functions입니다.

00:00:46.148 --> 00:00:47.016
기능추가가 더 쉽다.

00:00:47.016 --> 00:00:51.621
우린 수천가지의 다른 필터링 케이스로,
filter를 재사용할 수 있어요.

00:00:51.621 --> 00:00:53.378
그리고 다른 함수들이랑 체이닝도 걸 수 있죠.

00:00:53.378 --> 00:00:54.305
더 읽기 쉽다.

00:00:54.305 --> 00:00:55.496
상당히 가독성이 좋죠.

00:00:55.496 --> 00:00:57.999
저기 array가 있고, 그걸 저 조건으로 필터링한단거죠.

00:00:57.999 --> 00:01:00.437
그리고 그걸 각 요소를 0에서부터 더해가면서 reduce하고

00:01:00.437 --> 00:01:04.995
그 reduce의 결과를 다음 요소랑 다시 reduce하죠.

00:01:04.995 --> 00:01:08.232
app라는 조합을 통해서요. 필터링 된 배열을 누적하죠.

00:01:08.232 --> 00:01:12.683
각 단계를 따라가는데 있어서 아주 읽기 쉬워요. 가독성이 훨씬 좋죠.

00:01:12.683 --> 00:01:13.394
저걸 보세요.

00:01:13.394 --> 00:01:18.019
이제, 문제가 있어요.
전 for-loop보다 디버깅이 좀 더 어렵다고 생각해요.

00:01:18.019 --> 00:01:19.669
우린 for-loop에서 모든 걸 볼 수 있죠.

00:01:19.669 --> 00:01:23.655
여기에선 뭘 하는 지 알 수가 없죠.
하지만 이제 할 거예요.

00:01:23.655 --> 00:01:27.309
수행 중인 작업을 이해만 한다면,
디버그 하기도 더 쉽습니다.

00:01:27.309 --> 00:01:29.322
그렇기 때문에 여러분들은
무엇을 하고 있는지 알아야해요.

00:01:29.322 --> 00:01:37.333
그리고 reduce는 우리가 더 강력한 것을 할 수 있게 해줄거예요.

00:01:37.333 --> 00:01:38.472
이제 그걸 봐보죠.

00:01:38.472 --> 00:01:42.108
아 이제 Pair Programming을 할거예요.
여기까지 오신 걸 환영합니다.

00:01:42.108 --> 00:01:50.073
여기, Function Composition입니다.

00:01:50.073 --> 00:01:55.089
함수 조합이예요.

00:01:55.089 --> 00:02:00.016
그리고 여기에서 순수함수 또한 볼거예요.

00:02:00.016 --> 00:02:03.899
그리고, 데이터 불변성도요.

00:02:03.899 --> 00:02:08.789
하지만 여러분들이 가장 흥미롭게 보실 것은
Function Composition이예요.

00:02:08.789 --> 00:02:10.000
아주, 아주 특별해요.

00:02:10.000 --> 00:02:15.551
Function Composition은
우리가 개별 함수를 가지고 다시 결합하는겁니다.

00:02:15.551 --> 00:02:19.773
코드의 각 라인 혹은 filter, map같은 몇 줄을 가지고,

00:02:19.773 --> 00:02:23.807
그 작은 함수들을 모아 통합하는거죠.

00:02:23.807 --> 00:02:26.452
그래서 체이닝으로 그걸 모으는 게 아주 재밌어요.

00:02:26.452 --> 00:02:28.964
.으로 하는 체이닝은 JavaScript의
prototype 특성에 의존해요.

00:02:28.964 --> 00:02:32.018
함수가 모든 내장 함수에 접근가능한 배열을 반환하면,

00:02:32.018 --> 00:02:36.685
그 결과를 다음 함수에 전달하는거죠.
암묵적으로 여기 안에요.

00:02:36.685 --> 00:02:38.647
이런 키워드를 통해서요.

00:02:38.647 --> 00:02:40.895
몇몇 분은 이걸 미리 말하셨죠.

00:02:40.895 --> 00:02:45.146
배열이 아닌 일반적인 출력을 반환하는 함수를 연결하려면 어떻게 해야하죠?

00:02:45.146 --> 00:02:48.179
그건 그렇고, 멋진 체인 함수들은
JavaScript의 Prototype 특성에

00:02:48.179 --> 00:02:51.467
약간 덜 의존하는 방식으로 그들끼리 연결될 거예요.

00:02:51.467 --> 00:02:56.289
그건 아마도 가장 Functional Programming
패러다임의 일관성있는

00:02:56.289 --> 00:02:57.660
스타일이 아닐 수 있어요.

00:02:57.660 --> 00:03:01.988
그래서, 일련의 숫자들을 multiplyBy2에
체인 태우면, 11이 될 거고,

00:03:01.988 --> 00:03:03.929
거기에 3을 더하면 14죠.
굉장히 효과적이라 생각해요.

00:03:03.929 --> 00:03:07.455
알죠 여러분?

00:03:07.455 --> 00:03:10.959
이런 결과들은 자동적으로 다음에 접근하진 않아요.

00:03:10.959 --> 00:03:12.053
음, 여기 그걸 하는 방법이 있네요.

00:03:12.053 --> 00:03:16.783
이걸 해보죠, multiplyBy2는, 똑같은데
더 간단한 parameter이름인 x를 갖죠.

00:03:16.783 --> 00:03:21.443
그리고 그것을 2로 곱해서 결과를 주고,

00:03:21.443 --> 00:03:24.334
이제 11이라는 입력으로 multiplyBy2를 실행할 수 있죠.

00:03:24.334 --> 00:03:30.635
right-hand 영역에서,
Virginia, 11*2는 뭘로 평가되죠.

00:03:30.635 --> 00:03:31.151
Virginia: 22요.

00:03:31.151 --> 00:03:32.857
Will Sentance: 22죠.

00:03:32.857 --> 00:03:35.854
그럼 그게 어디로 저장되죠, Virginia.

00:03:35.854 --> 00:03:36.967
Virginia: initialResult로요.

00:03:36.967 --> 00:03:40.070
Will Sentance: 훌륭해요. 그럼 22를 가져오죠,
그리고 add3에 넣죠.

00:03:40.070 --> 00:03:41.667
그럼 뭘-
Virginia: 25요.

00:03:41.667 --> 00:03:44.074
Will Sentance: 그럼 그걸 어디에-
Virginia: nextStep이요.

00:03:44.074 --> 00:03:47.050
Will Sentance: nextStep을 가지고,
divideBy2에 전달하죠.

00:03:47.050 --> 00:03:49.180
finalStep은 뭐가 되죠?

00:03:49.180 --> 00:03:49.890
Virginia: 5요.

00:03:49.890 --> 00:03:50.439
Will Sentance: 5죠.

00:03:50.439 --> 00:03:54.953
아 Anna한테 물어봤어야 하는데,
말 그대로 보통,

00:03:54.953 --> 00:03:58.913
너무너무 나이브한 수학이었죠.

00:03:58.913 --> 00:04:03.566
수학 전공생이시라면, 이걸 수학이라고 말할 때 굉장히 답답해

00:04:03.566 --> 00:04:04.155
하실 것 같아요.

00:04:04.155 --> 00:04:07.277
아주 쉬운거죠.
좋아요, 여러분 이건 꽤 리스크가 있어요.

00:04:07.277 --> 00:04:11.049
initialResult를 다음 라인으로 파싱해줄 뿐 아니라,

00:04:11.049 --> 00:04:13.524
이후의 모든 라인을 다 파싱하나요?

00:04:13.524 --> 00:04:15.862
앞으로 나오는 라인들을 다 파싱하죠.

00:04:15.862 --> 00:04:19.656
말하자면, 미묘한 의존성 트리인거예요.

00:04:19.656 --> 00:04:23.778
다른 말로, 앞으로 나올 모든 라인들은 이거에 의존하고,
이게 앞으로 나올 모든 라인들에 들어가겠죠.

00:04:23.778 --> 00:04:24.685
대단하죠.

00:04:24.685 --> 00:04:28.948
더 나은 방법이 있나요?
여기 함수가 호출되었죠.

00:04:28.948 --> 00:04:33.868
그걸 initialResult에 저장하고,
다만 그걸 다음 라인에서 잠깐 멈추죠.

00:04:33.868 --> 00:04:39.428
Alex, 좀 더 좋은 방법이 있을까요?
전역 Label에 저장하는 걸 건너 뛸 방법이요.

00:04:39.428 --> 00:04:43.916
Alex: 그러니까 divideBy5를 하고, 그걸 add에 전달하고

00:04:43.916 --> 00:04:47.528
그걸 또 multiplyBy2에 전달하는거예요.

00:04:47.528 --> 00:04:49.916
Will Sentance: 아주 중요한 포인트를 집었어요.

00:04:49.916 --> 00:04:51.337
그걸 바로 호출하는 add에 전달하는거죠.

00:04:51.337 --> 00:04:51.930
Alex: 맞아요.
Will Sentance: 네,

00:04:51.930 --> 00:04:55.793
그 평가된 결과값을 바로 주는거죠. 네, 아주 좋아요.

00:04:55.793 --> 00:04:59.007
입력이 11인 multiplyBy2가 있고,

00:04:59.007 --> 00:05:03.512
이건 그대로 22로 평가되죠.
참조 투명성입니다.

00:05:03.512 --> 00:05:06.750
프로그램 동작의 변경 없이 이 실행된 함수와

00:05:06.750 --> 00:05:08.513
그것의 결과가 대체 가능하죠.

00:05:08.513 --> 00:05:11.239
따라서 참조 투명성이 무엇을 의미하는지에 대해선
많은 이야기가 있어요.

00:05:11.239 --> 00:05:12.613
그게 의미하는 바가 좀 범위가 넓기 때문이죠.

00:05:12.613 --> 00:05:15.688
이 함수의 코드를 보고, 그걸 치워버리고

00:05:15.688 --> 00:05:18.171
그것의 출력, 평가된 결과값을 가지고

00:05:18.171 --> 00:05:22.219
거기에 대신 넣을 수 있는거죠.
거기에 뭘 따로 처리하는 등의 변화 없이요.

00:05:22.219 --> 00:05:24.168
음, 이걸 보죠, 함수의 중첩입니다.

00:05:24.168 --> 00:05:27.348
또는 JavaScript가 모든 함수 호출을 진행하기 전에
평가한다는 사실을 사용할 수

00:05:27.348 --> 00:05:27.860
있습니다.

00:05:27.860 --> 00:05:34.596
multiplyBy2를 11로 하면, 22고,
이걸 그대로 add3에 넣으면, 25죠.

00:05:34.596 --> 00:05:37.763
그리고 그걸 divideBy5로 처리하면 5죠.

00:05:37.763 --> 00:05:39.318
이건 좀 가독성이 떨어져요.

00:05:39.318 --> 00:05:43.618
만약 여러분의 코드가 이런 함수의 충접들로
만들어져있다고 생각하면,

00:05:43.618 --> 00:05:44.726
너무 읽기가 어렵겠죠.

00:05:44.726 --> 00:05:48.144
그건 그렇고, 이건 함수들이 참조 투명성을
기반으로 한다는 걸 말하죠.

00:05:48.144 --> 00:05:51.406
우리는 App에서 아무런 결과 없이 반환 값으로 함수 호출을

00:05:51.406 --> 00:05:51.943
반복할 수 있죠.

00:05:51.943 --> 00:05:55.714
인터뷰에서 꺼낼 수 있는 멋진 용어 리스트로 기억해두세요.

00:05:55.714 --> 00:05:58.554
전 제 함수가 좀 더 참조 투명성을 갖는 걸 선호한다고요.

00:05:58.554 --> 00:06:03.179
이건 끔찍해요, 우린 이렇게 함수를 중첩해서 쓰면 안됩니다.

00:06:03.179 --> 00:06:06.113
그럼 우리가 여기서 실제로 하는게 뭐죠?

00:06:06.113 --> 00:06:13.457
우린 숫자와 함수를 조합해서 뭘 얻죠, Virginia?

00:06:13.457 --> 00:06:16.615
11이랑 multiplyBy2를 조합해서 얻는건요?
Virginia: 숫자요.

00:06:16.615 --> 00:06:17.721
Will Sentance: 어떤?

00:06:17.721 --> 00:06:18.592
Virginia: 22요.

00:06:18.592 --> 00:06:22.839
Will Sentance: 22죠,
그리고 우린 그 숫자 22를 함수와 좋아해서

00:06:22.839 --> 00:06:26.028
그 2가지를 가지고 뭘 얻-
Virginia: 25요.

00:06:26.028 --> 00:06:27.557
Will Sentance: 25란 숫자죠, 하나죠.

00:06:27.557 --> 00:06:35.710
그리고 우린 divideBy5라는 함수랑 조합하죠.
2개가 1개로 변합니다.

00:06:35.710 --> 00:06:39.183
우린 함수와 값을 조합해서 결과값을 얻고,
그 조합의 결과값과

00:06:39.183 --> 00:06:41.162
다른 함수로 다른 결과를 얻어요.

00:06:41.162 --> 00:06:42.566
여러분, 뭐가 생각나죠?
학생들: reduce요.

00:06:43.575 --> 00:06:46.033
Will Sentance: 진짜 장난아니죠?

00:06:46.033 --> 00:06:50.673
결국 알고보니 이건 Functional Programming에서
진짜 중요한 요소였던거죠.

00:06:50.673 --> 00:06:54.253
정말 가장 다재다능한 함수죠.

00:06:54.253 --> 00:06:59.305
말 그대로 함수의 리스트를 나열할 수 있어요.

00:06:59.305 --> 00:07:06.125
그리고, 그걸 reduce로 넣어주죠.
첫 번째를 가지고 이거랑 입력값을 조합하죠.

00:07:06.125 --> 00:07:08.825
그래서 나온 결과값으로 다음 요소와 조합하죠.

00:07:08.825 --> 00:07:13.351
결과값을 얻고, 다음 요소와 조합하죠.
2개가 1개로 변하고,

00:07:13.351 --> 00:07:16.131
2개가 1개로 변하고, 2개가 1개로 변하는거예요.

00:07:16.131 --> 00:07:19.988
그리고 이걸 조합하는 규칙은 꽤 정교할거예요.

00:07:19.988 --> 00:07:24.782
이걸 가져오고, 전달하고 함수를 실행하죠.
아무튼 이건 조합하는데,

00:07:24.782 --> 00:07:29.428
초기 입력값으로 만들어질건데, 그 첫 번째 함수는

00:07:29.428 --> 00:07:34.097
조합하죠, 첫번째랑..아 죄송합니다.
초기 입력값인 첫 번째 함수랑요.

00:07:34.097 --> 00:07:38.857
배열 내의 첫 함수 요소랑 조합하는거죠.
0번째 위치요.

00:07:38.857 --> 00:07:43.456
이걸 howToCombine으로 넣어주고,
이건 입력값으로 함수를 실행할거예요.

00:07:43.456 --> 00:07:47.415
그럼 이렇게 말하겠죠,
좋아, 11이 들어왔어, 또 뭐가 들어왔지?

00:07:47.415 --> 00:07:49.388
첫 번째 함수가 뭐죠, Jasmine?

00:07:49.388 --> 00:07:51.050
Jasmine: multiplyBy2요.
Will Sentance: multiplyBy2죠, 그리고

00:07:51.050 --> 00:07:55.990
그 안에서, multiplyBy2를 11로 실행하면서 결합하고

00:07:55.990 --> 00:07:58.995
22를 받겠죠. 
그걸 buildingUp에 반환하는거예요.

00:07:58.995 --> 00:08:04.663
그리고 그게 다음 값으로 전달 되고,
다음 함수랑 조합되는거죠.

00:08:04.663 --> 00:08:09.219
아무튼, 우린 모든 Functional Programming에서
가장 중요하고

00:08:09.219 --> 00:08:12.419
많이 사용되는 함수를 재구성했어요.

00:08:12.419 --> 00:08:13.357
이게 첫 번째 주요 챕터예요.

00:08:13.357 --> 00:08:15.230
전 확인을 했어요.

00:08:15.230 --> 00:08:18.696
전 Functional Programming에서
가장 인기 있는 작업들을 확인했어요.

00:08:18.696 --> 00:08:19.628
Library, Ramda요.

00:08:19.628 --> 00:08:23.433
그들이 사용하는 가장 중요한 함수들의 내부에서

00:08:23.433 --> 00:08:26.503
그들이 하는 일의 모든 핵심이 이거예요.

00:08:26.503 --> 00:08:29.187
우린 방금 배웠죠.