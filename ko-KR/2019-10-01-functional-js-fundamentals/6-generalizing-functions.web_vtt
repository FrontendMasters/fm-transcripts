WEBVTT

00:00:00.000 --> 00:00:03.606
Will Sentance: 방금 본, 3가지의 지루한

00:00:03.606 --> 00:00:09.815
반복적인 함수들은
매번 조금씩만 변하고 아주 똑같았죠.

00:00:09.815 --> 00:00:13.220
이제 우린 이걸 개선해야한다는 걸 알았어요.

00:00:13.220 --> 00:00:14.861
Eric도 지루했죠.

00:00:14.861 --> 00:00:16.403
좀 무례했죠.

00:00:16.403 --> 00:00:18.246
아니예요, Eric도 지루했어요.

00:00:18.246 --> 00:00:21.609
그것을 인정하는 것은 멋있었고
그는 있어야 해요.

00:00:21.609 --> 00:00:23.176
우린 더 나은 방법이 필요해요.

00:00:23.176 --> 00:00:26.746
우린 매번 개별적으로 함수를 만드는 것에 대해 알았죠.
배열을 가지고,

00:00:26.746 --> 00:00:28.243
새로운 배열을 만들고

00:00:28.243 --> 00:00:31.657
입력으로 들어온 배열의 각 요소를 취해서
다른 작업을 하는거죠.

00:00:31.657 --> 00:00:35.914
만약 placeholder를 두는 대신에

00:00:35.914 --> 00:00:39.182
빈 공간을 두는 방법이 있다면,
우리가 함수를 실행할 때,

00:00:39.182 --> 00:00:43.303
우리가 배열의 각 요소에
정확히 뭘 할 지 지정할 수 있죠.

00:00:43.303 --> 00:00:47.330
저기 for-loop의 바디의 첫 번째 회차에
i는 0일거고,

00:00:47.330 --> 00:00:52.056
array의 0번째 위치는 1일거고,
instructions는 multiplyBy2겠죠.

00:00:52.056 --> 00:00:56.804
multiplyBy2에 1을 넣고, 1이 삽입되면 2가 반환될 거고,
그걸 output에 Push하죠.

00:00:56.804 --> 00:00:58.553
그리고 이걸 계속 반복해요.

00:00:58.553 --> 00:01:00.324
여러분 이제 실제로 보죠.

00:01:00.324 --> 00:01:03.197
여러분들 해봅시다,
Jasmine이 시작하죠.

00:01:03.197 --> 00:01:07.239
Jasmins, 우리가 뭘 하죠,
이 코드의 첫 번째 라인에서요.

00:01:07.239 --> 00:01:09.159
가장 먼저 뭘 저장하죠?

00:01:09.159 --> 00:01:11.640
Jasmine: copyArrayAndManipulate를 선언해요.

00:01:11.640 --> 00:01:18.571
Will Sentance: copyArrayAndManipulate죠, 
이제 여기에 빈 공간을 둘거예요.

00:01:18.571 --> 00:01:24.097
배열의 각 요소에 대해 수행할 작업이죠.

00:01:24.097 --> 00:01:27.577
그래서 이 함수를 Memory에 저장했죠.

00:01:27.577 --> 00:01:32.972
고마워요, Jasmine,
다음은 Virginia, 여기 작은 함수가 있죠.

00:01:32.972 --> 00:01:34.324
뭘 하죠?

00:01:34.324 --> 00:01:36.086
Virginia: multiplyBy2라는 label을 만들겁니다.

00:01:36.086 --> 00:01:37.554
Will Sentance: 네, 그리고 그게 뭐죠?

00:01:37.554 --> 00:01:41.582
Virginia: 우리는 그 안으로 가서-
Will Sentance: 뭐가 할당 되죠?

00:01:41.582 --> 00:01:42.307
Virginia: 함수가 할당됩니다.

00:01:42.307 --> 00:01:44.584
Will Sentance: 함수가 할당되죠,
맞았어요. 정확합니다.

00:01:44.584 --> 00:01:48.444
다음은, Sam, left-hand 영역 먼저요.

00:01:48.444 --> 00:01:50.931
Sam: constant result를 선언해요.

00:01:50.931 --> 00:01:56.236
Will Sentance: 훌륭해요. 그리고 우린
이제 뭔가 작업을 해야하죠, 그렇죠, Sam?

00:01:56.236 --> 00:02:01.397
그건, 호출하는거죠,
어떤 함수를 실행하죠?

00:02:01.397 --> 00:02:02.746
Sam: copyArrayAndManipulate요.

00:02:02.746 --> 00:02:08.874
Will Sentance: copyArrayAndManipulate죠.
입력이

00:02:08.874 --> 00:02:15.930
[1, 2, 3]이고, 여러분, 여기

00:02:15.930 --> 00:02:20.952
 multiplyBy2 함수의 전체입니다.

00:02:20.952 --> 00:02:28.625
그리고 copyArrayAndManiplulate 코드를
실행하기 위해 만들겁니다.

00:02:28.625 --> 00:02:32.177
새로운 뭘 만들죠?

00:02:32.177 --> 00:02:35.856
[웃음]
Will Sentance: 네, 고마워요. Bivanesh.

00:02:35.856 --> 00:02:38.663
[웃음] 어떤 사람이 Local이라는 말을 하기로

00:02:38.663 --> 00:02:41.482
결정했을 때 보다 더 좋은 건 없었어요.

00:02:41.482 --> 00:02:45.486
완벽해요. Bivanesh,
정확히, Local Execution Context죠.

00:02:45.486 --> 00:02:48.049
하지만 그냥 Execution Context라고 부르죠,

00:02:48.049 --> 00:02:52.385
새로운 Execution Context에, Local Memory가 있죠.

00:02:52.385 --> 00:02:56.120
이 안으로 가서, 쉬운 겁니다.
먼저 하는건요?

00:02:56.120 --> 00:02:59.597
Andrew, array가 뭘로 채워지죠?

00:02:59.597 --> 00:03:00.710
Andrew: [1, 2, 3]이요.

00:03:00.710 --> 00:03:05.310
Will Sentance: 정확해요. Parameter인
array에 argument의 값인

00:03:05.310 --> 00:03:08.070
[1, 2, 3]이 할당될겁니다.

00:03:08.070 --> 00:03:11.120
그리고, 조금 어려운거죠, 
David, Parameter인

00:03:11.120 --> 00:03:15.555
instructions란 placeholder는 뭘로 채워지죠, David?

00:03:15.555 --> 00:03:17.433
David: multiplyBy2의 결과요.

00:03:17.433 --> 00:03:19.140
Will Sentance: 결과가 아니예요.

00:03:19.140 --> 00:03:21.549
저 기능의 label이죠, Sam?

00:03:21.549 --> 00:03:22.359
Sam: 참조예요.

00:03:22.359 --> 00:03:25.263
Will Sentance: 네 그렇죠. 그 뒤에 링크가 있지만,
우린 지금 이걸

00:03:25.263 --> 00:03:26.060
뭐라고 하죠?

00:03:26.060 --> 00:03:27.494
학생들: 함수요.
Will Sentance: 함수인데

00:03:27.494 --> 00:03:28.799
선언이 뭐죠?

00:03:28.799 --> 00:03:29.438
학생들: multiplyBy2요.

00:03:29.438 --> 00:03:32.359
Will Sentance: multiplyBy2죠, 그 말은 여러분들이
이제 이 안에서 instructions을 어디에서 만나던간에

00:03:32.359 --> 00:03:35.927
David의 혼동을 저는 확실히 이해할 수 있어요.

00:03:35.927 --> 00:03:39.722
이 안의 어디에서건 여러분들이 instructions를 보면,
이게 multiplyBy2의 코드로

00:03:39.722 --> 00:03:42.252
채워져있다는 걸 아셔야해요.
그 말은 말 그대로

00:03:42.252 --> 00:03:46.111
instructions라는 단어는 치워지는거고,
multiplyBy2가 그 자리에 있을거란거죠.

00:03:46.111 --> 00:03:50.716
여러분 모두가 아는 것처럼,
여러분들이 이 함수 안에서 array를

00:03:50.716 --> 00:03:55.403
어디에서 만나던간에  그 문자는 날라가고
거기에 [1, 2, 3]이 대체되죠.

00:03:55.403 --> 00:03:57.924
말 그대로 [1, 2, 3]을 두고 치워지는거예요.

00:03:57.924 --> 00:04:03.385
그래서 이게 [1, 2, 3].length, [1, 2, 3][i]죠.
모든 것이 JavaScript에선 값이 되죠.

00:04:03.385 --> 00:04:06.101
이것처럼 될 수 있는 건 건 없어요.

00:04:06.101 --> 00:04:06.777
값이예요.

00:04:06.777 --> 00:04:07.784
어떤 것이 되는거죠.

00:04:07.784 --> 00:04:09.851
insturctions를 포함해서요.

00:04:09.851 --> 00:04:14.440
결국 그건 정확히 이렇게 multiplyBy2가 되죠.

00:04:14.440 --> 00:04:21.856
이 뜻은, Virginia, 아직도 어색해요.
제 여동생 이름입니다.

00:04:21.856 --> 00:04:28.353
Virginia, 만약 제가 이 함수 내에서
multiplyBy2를 실행하고 싶다면요.

00:04:28.353 --> 00:04:32.704
전 multiplyBy2라는 label을 사용하지 않죠.
어떤 label을 사용하죠, Virginia?

00:04:32.704 --> 00:04:33.309
Virginia: label이요?

00:04:33.309 --> 00:04:37.124
Will Sentance: 어떤 label을 사용하죠,
Eric? 실행하려면요.

00:04:37.124 --> 00:04:38.099
Eric: instructions요.

00:04:38.099 --> 00:04:39.024
Will Sentance: instructions죠, 그래서

00:04:39.024 --> 00:04:42.677
multiplyBy2를 실행하고 싶다면,
어떤 걸 써야할까요, Mike?

00:04:42.677 --> 00:04:45.708
Michael, 어떤 걸 써야하죠, 만약 제가
이 함수 안에서 multiplyBy2를 실행하길

00:04:45.708 --> 00:04:46.325
원한다면요?

00:04:46.325 --> 00:04:46.982
Michael: instructions요.

00:04:46.982 --> 00:04:50.380
Will Sentance: instructions고, 그걸 실행하기 원한다면,

00:04:50.380 --> 00:04:50.907
Michael: 괄호요.

00:04:50.907 --> 00:04:54.029
괄호죠, 그럼 이제 거기에 multiplyBy2가 있을거고,

00:04:54.029 --> 00:04:56.660
여기에 입력이 있을걸 예상하죠.
여기에 뭔가를 넣는거죠.

00:04:56.660 --> 00:05:01.563
이게 실제로는 multiplyBy2를 실행하는거죠.

00:05:01.563 --> 00:05:05.878
3을 넣은 multiplyBy2죠. 맞죠?

00:05:05.878 --> 00:05:08.056
instructions가 일반화를 한 이름인거고,

00:05:08.056 --> 00:05:11.912
그 말은 copyArrayAndManipulate에
어떤 함수든 실행할 수 있는거죠.

00:05:11.912 --> 00:05:14.134
제가 divideBy2를 가졌으면,

00:05:14.134 --> 00:05:17.468
instructions는 divideBy2로 채워지겠죠.

00:05:17.468 --> 00:05:19.006
굉장히 일반화 되고 있죠.

00:05:19.006 --> 00:05:19.890
아주 아주 좋아요.

00:05:19.890 --> 00:05:21.772
우린 아주 행복하게 했어요.

00:05:21.772 --> 00:05:25.196
좋아요, 훌륭해요. 이제 새로운 배열을 만들어보죠.

00:05:25.196 --> 00:05:29.867
그럼, Anna, 입력을 처리한 뒤,
copyArrayAndManipulate안에서

00:05:29.867 --> 00:05:32.427
처음 하는 건 뭐죠? 뭘 만들죠?

00:05:32.427 --> 00:05:33.356
어떤 걸 선언하나요?

00:05:33.356 --> 00:05:34.027
Anna: output이요.

00:05:34.027 --> 00:05:35.961
Will Sentance: output이죠 그건 뭐죠?

00:05:35.961 --> 00:05:36.747
Anna: 빈 배열이요.

00:05:36.747 --> 00:05:40.886
Will Sentance: 빈 배열입니다. 정확해요.
빈 배열이죠.

00:05:40.886 --> 00:05:44.956
이제 반복문을 해보죠.

00:05:44.956 --> 00:05:46.888
아 아시나요?

00:05:46.888 --> 00:05:52.097
이번만 Call Stack도 해보겠습니다.
왜냐하면, 다음 자식을 위해

00:05:52.097 --> 00:05:57.007
이걸 추적할 수 있어야해서죠.
우린 항상 Global에 있었었죠.

00:05:57.007 --> 00:05:59.366
이제 우린 어디있죠? Bivanesh?

00:05:59.366 --> 00:06:00.970
지금 호출한 함수가 뭐죠?

00:06:00.970 --> 00:06:01.834
Bivanesh: copyArraynAndManipulate요.

00:06:01.834 --> 00:06:05.754
Will Sentance: 좋아요
copyArrayAndManipulate죠. Bivanesh.

00:06:05.754 --> 00:06:08.634
제가 기억한 이름이 맞죠?

00:06:08.634 --> 00:06:09.484
Bivanesh: 네.
Will Sentance: 네

00:06:09.484 --> 00:06:10.825
좋아요, 이렇게죠.

00:06:10.825 --> 00:06:12.839
[1, 2, 3]은 배열이고,

00:06:12.839 --> 00:06:17.687
그 뒤에 output도 처리하고,
이제 이것들로 작업해서 뭔가를 넣겠죠.

00:06:17.687 --> 00:06:19.354
이제 흥미로워집니다.

00:06:19.354 --> 00:06:23.917
JavaScript는 for-loop의 중괄호 안쪽, 바깥쪽 사이인 바디에서,

00:06:23.917 --> 00:06:28.429
그게 뭔지 평가하기 위해 다른 것이 필요한지에 대해 처리하지 않아요.

00:06:28.429 --> 00:06:31.799
그냥 늘 처음 것이 필요하죠. 여긴 그게 i죠.

00:06:31.799 --> 00:06:32.783
항상 여기서부터 시작해요.

00:06:32.783 --> 00:06:35.207
그래서, Alex, i가 뭐죠?

00:06:35.207 --> 00:06:37.601
for-loop의 바디에 만났을 때 처음 i의 값은요?

00:06:37.601 --> 00:06:38.137
Alex: 0이요.

00:06:38.137 --> 00:06:40.835
Will Sentance: 0이죠, array의 0번째 위치는?

00:06:40.835 --> 00:06:44.195
Alex: 1이요.
Will Sentance: 1이죠, instructions는?

00:06:44.195 --> 00:06:46.472
Alex, 그건 실제로?

00:06:46.472 --> 00:06:48.626
Alex: multiplyBy2요.
Will Sentance: multiplyBy2죠, 그리고

00:06:48.626 --> 00:06:53.288
저길 보세요 여러분,
저장되었을 때 함수에 없었던 코드를

00:06:53.288 --> 00:06:57.125
사용할 수 있죠. 그걸 끌어왔어요.

00:06:57.125 --> 00:06:58.288
굉장해요.

00:06:58.288 --> 00:07:00.601
Alex, 뭘 새롭게 하죠?

00:07:00.601 --> 00:07:01.231
Alex: Execution Context요.

00:07:01.231 --> 00:07:03.597
Will Sentance: Execution Context죠.
그 안으로 갑니다.

00:07:03.597 --> 00:07:06.103
여긴 좀 작게 할게요.

00:07:06.103 --> 00:07:07.647
Call Stack엔 어떤 일이 일어나죠, Alex?

00:07:07.647 --> 00:07:08.236
Alex: Push 됩니다.

00:07:08.236 --> 00:07:11.693
Will Sentance: multiplyBy2가 Push되죠. 맞았어요.

00:07:11.693 --> 00:07:15.996
Call Stack의 위에
1이 들어간 multiplyBy2죠.

00:07:15.996 --> 00:07:17.064
이제 들어가보죠.

00:07:17.064 --> 00:07:20.430
우린 array의 0번째 위치인 1을 가지고,

00:07:20.430 --> 00:07:23.805
instructions인 multiplyBy2에 붙이죠.

00:07:23.805 --> 00:07:26.753
그 말은 1이 multiplyBy2 안으로 들어간다는거죠.

00:07:26.753 --> 00:07:30.050
그래서, Virginia,
어려운 거예요. 1을 받아낼

00:07:30.050 --> 00:07:35.316
Parameter요,
어떤 parameter가 1이 할당되죠, Virginia?

00:07:35.316 --> 00:07:37.405
Virginia: input이요.
Will Sentance: input이죠, input으로 가죠.

00:07:37.405 --> 00:07:38.391
좋아요.

00:07:38.391 --> 00:07:39.975
이거죠, input입니다.

00:07:39.975 --> 00:07:45.013
input * 2는 1*2고 2죠,
2를 반환해 내보내죠.

00:07:45.013 --> 00:07:48.440
1이 입력인 multiplyBy2는
instructions고,

00:07:48.440 --> 00:07:53.557
1의 multiplyBy2는 출력값인
숫자 2로 평가되어집니다.

00:07:53.557 --> 00:07:55.134
그걸로 뭘 하죠, Virginia?

00:07:55.134 --> 00:07:56.478
Virginia: 그걸 output으로 Push합니다.

00:07:56.478 --> 00:07:58.572
Will Sentance: output에 Push하죠.

00:07:58.572 --> 00:08:03.392
이제 Execution Context는 지워지고,
Call Stack에서도 Pop되죠.

00:08:03.392 --> 00:08:05.809
하지만 for-loop이예요,
그래서 그냥 위에 둘께요.

00:08:05.809 --> 00:08:10.314
Call Stack에서 Pop되고,
Execution Context는 지워요.

00:08:10.314 --> 00:08:12.953
하지만 for-loop이예요.
그래서 다시 합니다.

00:08:12.953 --> 00:08:17.426
이번 회차에 i의 값은 뭐죠?

00:08:17.426 --> 00:08:20.977
Seth, 뒤에 있죠,
이번에 i값은 뭐죠, Seth?

00:08:20.977 --> 00:08:23.094
Seth: 1이요.
Will Sentance: 1이죠, 잘했어요. Seth.

00:08:23.094 --> 00:08:26.639
array의 1번째 숫자는 뭐죠 Seth?

00:08:26.639 --> 00:08:28.155
Seth: 2요.
Will Sentance: 2죠.

00:08:28.155 --> 00:08:31.723
instructions는 실제로 뭐죠, Seth?

00:08:31.723 --> 00:08:32.354
Seth: multiplyBy2요.

00:08:32.354 --> 00:08:38.118
Will Sentance: 2를 입력으로 하는 multiplyBy2는
새로운 Execution Context를

00:08:38.118 --> 00:08:45.346
만들고 여기 작은 Parameter엔 2가 들어오죠.

00:08:45.346 --> 00:08:46.791
오우 망했어요.

00:08:46.791 --> 00:08:50.528
2가 들어왔고,
parameter의 이름은요, Seth?

00:08:50.528 --> 00:08:52.955
Seth: input이요.
Will Sentance: input이죠, input * 2죠.

00:08:52.955 --> 00:09:00.080
2 * 2고 이건 4고,
4가 반환되서 어디에 저장되죠, Virginia?

00:09:00.080 --> 00:09:00.977
Virginia: output이요.

00:09:00.977 --> 00:09:06.241
Will Sentance: output으로 가죠,
그래서 for-loop은 2, 4, 6입니다.

00:09:06.241 --> 00:09:11.337
그럼 Virginia,
마지막으로 반환하는 건 뭐죠?

00:09:11.337 --> 00:09:12.230
Virginia: output을 반환해요.

00:09:12.230 --> 00:09:15.278
Will Sentance: 네. 전 제가 선호하는
사람들을 계속 말하게 할거예요.

00:09:15.278 --> 00:09:19.005
제 말은, 여러분들이 말하면서 이해에 도움이 될거란거예요.
output을 반환하는게 아니죠.

00:09:19.005 --> 00:09:22.580
왜냐하면, 그걸 반환 한다는건 약간 잘못된 느낌을 주기 때문이예요.

00:09:22.580 --> 00:09:26.304
제가 output을 들었을 때
전 최소한 label과 값을 떠올립니다.

00:09:26.304 --> 00:09:28.735
머리 속에 label 이름이 있을 수도 있지만,

00:09:28.735 --> 00:09:30.742
확실하게 label을 반환하는 건 아닙니다.

00:09:30.742 --> 00:09:33.626
심지어 label과 값을 반환하는 것도 아니예요.

00:09:33.626 --> 00:09:37.686
이 값을 평가하기 위해
output은 참조로 사용하는거죠.

00:09:37.686 --> 00:09:39.181
그리고 저게 반환되서 나가는거예요.

00:09:39.181 --> 00:09:43.130
그래서 저는 여러분의 머리 속에서
이것에 대해 제대로 생각하고,

00:09:43.130 --> 00:09:47.018
output의 값인 [2, 4, 6]을 반환한다고
말하도록 도울거예요.

00:09:47.018 --> 00:09:48.919
Virginia, 한 번 해볼래요?

00:09:48.919 --> 00:09:51.473
Virginia: output의 값인 [2, 4, 6]을 반환할거예요.

00:09:51.473 --> 00:09:54.747
Will Sentance: 환상적입니다. 정확했어요.
네 아주 자세하죠. 좋았어요.

00:09:54.747 --> 00:09:56.006
Virginia, 이렇게죠.

00:09:56.006 --> 00:09:57.476
여러분 이걸 보세요.

00:09:57.476 --> 00:10:00.945
아이러니한 기색이 살짝 있죠.

00:10:00.945 --> 00:10:04.376
이걸 보세요, copyArrayAndManipulate는

00:10:04.376 --> 00:10:08.140
각 요소에 대해 수행할 동작을 지정하지 않았어요.

00:10:08.140 --> 00:10:11.104
각 요소를 2로 곱하라고 말하지 않았죠.
하지만 이걸 보세요.

00:10:11.104 --> 00:10:17.171
[1, 2, 3]이 [2, 4, 6]이 됐죠.

00:10:17.171 --> 00:10:21.933
우린 새로운 배열로 [2, 4, 6]을 만든거죠.

00:10:21.933 --> 00:10:27.085
하지만 copyArrayAndManipulate에
각 요소를 2로 곱하라는

00:10:27.085 --> 00:10:30.461
사전처리가 지정되지 않았죠.

00:10:30.461 --> 00:10:32.543
그 대신, copyArrayAndManipulate가 호출됐을 때,

00:10:32.543 --> 00:10:37.171
할 수 있었죠. 조작할 수 있었어요.

00:10:37.171 --> 00:10:39.852
왜냐하면, 이 사전작업을
빈 칸으로 만들어뒀으니까요.

00:10:39.852 --> 00:10:42.620
그래서 copyArrayAndManipulte를
조작할 수 있죠.

00:10:42.620 --> 00:10:45.723
정말 기분이 좋아지기 시작하죠.

00:10:45.723 --> 00:10:50.605
이미, Functional Programming의 목표가 각 라인이

00:10:50.605 --> 00:10:54.711
멋진 영어이거나, 사람이 쉽게 읽을 수 있는

00:10:54.711 --> 00:10:56.271
label을 가진 단위로 되는거죠.

00:10:56.271 --> 00:11:01.391
뭔가 그것들이 합쳐질 수 있기를 바라면서,

00:11:01.391 --> 00:11:03.262
각 결과만이 그 라인에 있는거죠.

00:11:03.262 --> 00:11:05.995
이게 조합의 첫 번째 예제입니다.

00:11:05.995 --> 00:11:09.406
뭔가 멜로디로 음표를 만드는 것처럼

00:11:09.406 --> 00:11:14.712
각 코드 블럭을 조합하고 묶어내서

00:11:14.712 --> 00:11:18.707
조작이 가능한 함수를 저장하는거죠.

00:11:18.707 --> 00:11:21.647
우리가 본질적으로 말했던 copyArrayAndManipulate는

00:11:21.647 --> 00:11:23.450
그게 실행될 때 그걸 결정하도록 뭔가를 남겨뒀죠.

00:11:23.450 --> 00:11:26.822
여러개의 다른 시나리오로 재사용이 가능했죠.

00:11:26.822 --> 00:11:30.329
우린 divideBy2를 넣어볼겁니다.