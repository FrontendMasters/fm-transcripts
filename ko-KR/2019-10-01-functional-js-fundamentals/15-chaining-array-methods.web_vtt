WEBVTT

00:00:00.000 --> 00:00:04.125
Will Sentance: 이 함수를 실행하는 요소로 가면,

00:00:04.125 --> 00:00:06.323
true 값을 반환합니다.

00:00:06.323 --> 00:00:09.249
이건 true를 가지고 array에 넣지 않아요,

00:00:09.249 --> 00:00:12.867
그 요소 그 자체를 가지고
array에 붙여줍니다.

00:00:12.867 --> 00:00:13.918
이게 filter가 하는 일의 전부죠.

00:00:13.918 --> 00:00:15.124
우린 이걸 직접 만들진 않을거예요.

00:00:15.124 --> 00:00:17.239
별로 어렵지가 않죠, 그게 전부예요.

00:00:17.239 --> 00:00:20.458
그럼 첫 번째 요소인 1을 가지고,

00:00:20.458 --> 00:00:24.517
그리고 이게 greaterThan2 함수에 들어갈거예요.

00:00:24.517 --> 00:00:29.073
그래서 greaterThan2에 1을 넣고

00:00:29.073 --> 00:00:32.559
만들죠. 여러분 새로운-?

00:00:32.559 --> 00:00:33.066
학생: Execution Context

00:00:33.066 --> 00:00:35.533
Will Sentance: Execution Context죠,
좋아요. 이거죠.

00:00:35.533 --> 00:00:40.125
이 안으로 가죠, 그리고 Local Memory가 있어요.

00:00:43.184 --> 00:00:47.502
Jasmine, 우린 array의 첫 번째 요소인 1로,

00:00:47.502 --> 00:00:51.490
array에 있는 filter 안의 greaterThan2를 실행했죠.

00:00:51.490 --> 00:00:55.028
그래서 1을 넣으면,
1을 greaterThan2로 던지면요, Jasmine.

00:00:55.028 --> 00:00:59.276
그러니까 1이 할당될 parameter는 뭐죠?

00:00:59.276 --> 00:01:01.378
Jasmine: num이요.
Will Sentance: num이죠, 좋아요.

00:01:01.378 --> 00:01:04.563
그래서 num을 가지고 2보다 큰 지 보죠.

00:01:04.563 --> 00:01:07.392
그럼 이건 return num > 2를 읽죠.

00:01:07.392 --> 00:01:09.951
1 > 2는 뭘로 평가되죠, Jasmine?

00:01:09.951 --> 00:01:11.052
Jasmine: false요.
Will Sentance: false고,

00:01:11.052 --> 00:01:12.297
우린 false를 반환하죠.

00:01:12.297 --> 00:01:14.100
그럼 또 여길 처리하죠.

00:01:14.100 --> 00:01:20.494
그리고 2로 greaterThan2를 하죠,
2를 입력으로요.

00:01:20.494 --> 00:01:25.209
아마 이것 또한 false를 반환하겠죠.

00:01:25.209 --> 00:01:29.553
자 이제 3을 가지고

00:01:29.553 --> 00:01:35.971
3을 넣어서 greaterThan2를 호출해요.

00:01:35.971 --> 00:01:38.594
이번엔 Execution Context를 만들어보죠.

00:01:38.594 --> 00:01:43.098
Jasmime, 여기서 num이 뭐가 되죠?

00:01:43.098 --> 00:01:44.319
Jasmine: 3이요.

00:01:44.319 --> 00:01:47.859
Will Sentance: num은 3이 될거예요.

00:01:47.859 --> 00:01:49.872
3 > 2는요, Jasmine?

00:01:49.872 --> 00:01:52.923
Jasmine: true요.
Will Sentance: true고 그걸 반환하죠.

00:01:52.923 --> 00:01:56.576
그리고 어떻게 filter가 작성되었는지에 대해
이게 정확히 어떻게 동작하는지에

00:01:56.576 --> 00:01:59.166
열을 올릴 필요는 없지만, 알아내야하긴 해요.

00:01:59.166 --> 00:02:04.143
3이 전달 되었을 때, greaterThan2의 반환이 true면,

00:02:04.143 --> 00:02:07.698
3을 가지고, 그걸 새로운 배열에 넣어주죠.

00:02:07.698 --> 00:02:09.645
4도 똑같이 여기로 가고,

00:02:09.645 --> 00:02:11.967
5도 똑같이, 여기로 가요.

00:02:11.967 --> 00:02:14.026
6도 마찬가지입니다.

00:02:14.026 --> 00:02:18.037
그리고 이 배열,

00:02:18.037 --> 00:02:23.461
[3, 4, 5, 6]을 반환하는거죠.

00:02:23.461 --> 00:02:29.043
우린 잠시 뒤에 볼텐데, 알아두세요.
우린 원래 있던 배열을 변화시키지 않았고, 조작하지도 않았어요.

00:02:29.043 --> 00:02:34.255
그 말은, 이 조건으로 배열에서 실행된 filter의
이 라인의 결과 의미는

00:02:34.255 --> 00:02:39.485
그 라인 자체에서 전부 알아서 된다는거죠.
이것처럼 전부 전역에 할당되어있지 않다면요.

00:02:39.485 --> 00:02:44.282
모두 그 라인안에서 처리가 됩니다.
하지만 이런 문제가 있을 수 있쬬.

00:02:44.282 --> 00:02:46.219
전역에 할당하고 다른 모든 코드 라인이

00:02:46.219 --> 00:02:49.848
의존하는 코드 라인을 가지고 싶다면 어떻게 하죠?

00:02:49.848 --> 00:02:54.388
방법이 있어요 여러분.

00:02:54.388 --> 00:02:57.426
우린 Higher Order Function들을
모아서 체인을 만들 수 있어요.

00:02:57.426 --> 00:02:58.575
우린 이렇게 할 수 있어요.

00:02:58.575 --> 00:03:01.768
이걸 보세요,
array.filter()에 greaterThan2를 넣었죠.

00:03:01.768 --> 00:03:06.967
이걸 제가 직접적으로 보여드리진 않았지만
이제 보여드릴께요.

00:03:06.967 --> 00:03:13.227
이건 실제로 array가 [1, 2, 3, 4, 5, 6]으로 평가되죠.
[1, 2, 3, 4, 5, 6]에

00:03:13.227 --> 00:03:17.496
이 괄호랑 filter가 실행되죠.

00:03:17.496 --> 00:03:23.869
이거 전체가 실제로 뭐가 되죠?

00:03:23.869 --> 00:03:26.465
JavaScript에서 이 전체 부분이
뭘로 변할지 말하고 싶으신 분

00:03:26.465 --> 00:03:26.984
손들어 주세요.

00:03:26.984 --> 00:03:27.876
네, Eric.

00:03:27.876 --> 00:03:29.437
Eric: 배열 [3, 4, 5, 6]이요.

00:03:29.437 --> 00:03:34.591
Will Sentance: 맞았어요.
이건 [3, 4, 5, 6]으로 평가되죠.

00:03:34.591 --> 00:03:41.763
이제 저 배열은 어떤 함수의 모음에 접근가능하죠, Eric?

00:03:41.763 --> 00:03:43.285
Eric: prototype 체인이요.

00:03:43.285 --> 00:03:45.163
Will Sentance: 어디로 연결되냐면,

00:03:45.163 --> 00:03:50.032
어디로 가냐면요,
Will Sentance: 이

00:03:50.032 --> 00:03:54.002
모든 배열에서 접근 가능한 공유된 함수 모음으로 가죠.

00:03:54.002 --> 00:04:00.494
그 말은, 이 결과를 저장할 label을 만들고,

00:04:00.494 --> 00:04:04.343
이걸 가지고 이 함수들을 얻을 필요가 있나요?

00:04:04.343 --> 00:04:05.584
혹은 할 수 있을까요?

00:04:05.584 --> 00:04:07.243
David가 고개를 흔들었어요. 맞았죠.

00:04:07.243 --> 00:04:11.632
혹은 이 오른쪽 끝에 .reduce를

00:04:11.632 --> 00:04:16.693
적을 수 있나요?
제가 원하는 아무거나 될 수 있죠.

00:04:16.693 --> 00:04:19.146
이 뒤에 바로 붙일 수 있다는 걸 알아야해요.

00:04:19.146 --> 00:04:23.200
그 말은 greaterThan2로 호출된
array.filter는 [3, 4, 5, 6]이 될거예요.

00:04:23.200 --> 00:04:25.488
원래는 [1, 2, 3, 4, 5, 6]이지만요.

00:04:25.488 --> 00:04:28.522
그리고 거기에 reduce 메소드를 실행하죠.
왜냐하면 배열은, 모든 배열은

00:04:28.522 --> 00:04:30.710
이 공유된 함수들에 접근이 가능하니까요.

00:04:30.710 --> 00:04:32.224
.reduce를 붙이는거죠.

00:04:32.224 --> 00:04:35.585
빠르게 reduce가 어떻게 동작하는지
빠르게 되새겨보조

00:04:35.585 --> 00:04:43.125
그래서 [3, 4, 5, 6]에 0을 넣어서 reduce하면

00:04:43.125 --> 00:04:47.736
어떻게 처음 2개를 조합하죠,
Virginia, 조합 규칙을

00:04:47.736 --> 00:04:50.265
add라고 한다면요?

00:04:50.265 --> 00:04:52.329
여기, 3이죠.

00:04:52.329 --> 00:04:56.916
그리소 그 다음이랑 조합하면 7이고,
이 조합 결과값이랑 조합해서

00:04:56.916 --> 00:04:58.456
두 개를 한 개로 줄이는거죠.

00:04:58.456 --> 00:05:03.942
두 개가 하나로 되면,
우린 그거랑 다음 값을 조합하죠. 그건 12예요.

00:05:03.942 --> 00:05:07.976
그리고 이것의 결과는 18이죠.

00:05:07.976 --> 00:05:12.790
그 말은, 이 부분의 평가값이 뭔가요, David?

00:05:12.790 --> 00:05:15.490
David: 18이요.
Will Sentance: 18이 되죠, 18이 됩니다.

00:05:15.490 --> 00:05:17.768
이거죠, 여러분.

00:05:17.768 --> 00:05:23.112
그 말은 greaterThan2랑 호출된
array.filter는 [3, 4, 5, 6]으로 평가되고,

00:05:23.112 --> 00:05:26.605
그리고 거기에 .reduce를 하면 18로 평가가 되죠.

00:05:26.605 --> 00:05:31.848
이 말은 이 전체 블럭은 18로 평가된단거죠.

00:05:31.848 --> 00:05:33.827
Alex, 이제 이 18로 뭘 하죠?

00:05:33.827 --> 00:05:35.046
Alex: sumOfGreaterThan2에 저장해요.

00:05:35.046 --> 00:05:37.184
Will Sentance: sumOfGreaterThan2에
저장하죠. 맞아요.

00:05:37.184 --> 00:05:39.469
원래 초기의 array도 가지고 있죠.

00:05:39.469 --> 00:05:43.976
우린 이걸 sumOfGreaterThan2에 저장해요.

00:05:43.976 --> 00:05:48.082
아주 좋은 이름이죠?

00:05:48.082 --> 00:05:52.034
우린 배열을 [3, 4, 5, 6]으로 거르고, 합쳤으니까요.