WEBVTT

00:00:00.000 --> 00:00:01.948
Will Sentance: 약간의 보너스를 드릴께요.

00:00:01.948 --> 00:00:03.822
여기서 실제로 일어나는 일은요.

00:00:03.822 --> 00:00:09.319
실제로, Virginia가 물었던 걸 보면,
음 잠시만요, 우리가 이 코드를 나눠주는건가요?

00:00:09.319 --> 00:00:12.303
하나의 함수나 어떤 것에서
코드를 전달한다는게 무슨 의미일까요?

00:00:12.303 --> 00:00:14.037
실제로 의미하는 바는요.

00:00:14.037 --> 00:00:16.260
그리고 이건 약간의 보너스예요 여러분.

00:00:16.260 --> 00:00:20.558
실제로, JavaScript에서, 함수, 객체, 배열,

00:00:20.558 --> 00:00:26.165
number, string, boolean,
undefined같은 게 아닌 건요.

00:00:26.165 --> 00:00:29.527
그것들은 아주 엄격하게 제한된 메모리인

00:00:29.527 --> 00:00:32.725
이 부분에 직접 저장되지 않습니다.

00:00:32.725 --> 00:00:38.011
대신 그것들은, 어디 저장되냐면, 단순하게 표현할건데요.

00:00:38.011 --> 00:00:40.178
왜냐하면, 우리가 이것과 데이터 통신을 할 필요는 없기 때문이죠.

00:00:40.178 --> 00:00:42.352
우리가 이걸 반드시 알아야 할 필요는 없지만,

00:00:42.352 --> 00:00:45.997
일부 사람들에게 더 확실하게
이걸 보여줄 방법을 제공할 수 있어요.

00:00:45.997 --> 00:00:50.349
실제로 매우 유연하고, 어지러운 아무거나 다 집어넣는,

00:00:50.349 --> 00:00:53.843
Memory 저장소가 있는데 이걸 Heap이라고 합니다.
JavaScript의 내부에 숨어있죠.

00:00:53.843 --> 00:00:55.576
대부분의 프로그래밍 언어들에서도요.

00:00:55.576 --> 00:01:00.926
그리고 여기로 들어가면,
실제로, add3같은 함수가 선언될 때마다

00:01:00.926 --> 00:01:04.813
이건 이 Local Memory에 직접 저장되지 않아요.

00:01:04.813 --> 00:01:07.692
그 대신 이건 이 아래 Heap에 저장되죠.

00:01:07.692 --> 00:01:10.140
그래서 add3 함수는 선언되자마자,

00:01:10.140 --> 00:01:11.766
실제로 이 아래에 저장이 됩니다.

00:01:11.766 --> 00:01:13.330
Global Memory도 아니예요.

00:01:13.330 --> 00:01:19.541
이건 완전히 분리되어있는,

00:01:19.541 --> 00:01:21.457
이 아래 완전 분리된 Memory의 저장소입니다.

00:01:21.457 --> 00:01:23.714
여기 add3 함수가 있어요.

00:01:23.714 --> 00:01:27.929
우린 실제로 이 함수를 직접
이 Local Memory에 저장하지 않습니다.

00:01:27.929 --> 00:01:32.079
대신 우린, 우편번호같은 주소를 저장하죠.

00:01:32.079 --> 00:01:36.893
뭐 아무거나, 10012라면,
그건 여기 아래 있는 컴퓨터의 Memory의 위치가 되고

00:01:36.893 --> 00:01:40.379
거기에 실제로 함수가 저장되어 있는거죠.

00:01:40.379 --> 00:01:43.712
이게 Virginia의 질문의 힌트가 될 거 같아요.

00:01:43.712 --> 00:01:46.832
우리가 add3를 반환할 때
실제로 벌어지는 일은

00:01:46.832 --> 00:01:50.349
add3를 볼 때,
이 함수 정의를 잡는게 아니예요.

00:01:50.349 --> 00:01:55.652
전 이 아래에 저장된 버전의 연결링크를 잡는거죠.

00:01:55.652 --> 00:02:00.650
functionCreator를 실행하고 반환할 때 만들어진걸요.

00:02:00.650 --> 00:02:04.347
그래서 generatedFunc를 실행할 때, 무엇을 해야하죠?

00:02:04.347 --> 00:02:08.230
그건 add3로 만들어졌던 함수가 되지만,

00:02:08.230 --> 00:02:12.446
그것의 label인 add3는
오직 functionCreator 내에서만 존재했던거고,

00:02:12.446 --> 00:02:15.794
함수의 코드는 영구적이고, 이 Heap에 저장되어있는거죠.

00:02:15.794 --> 00:02:17.838
label은 우리에게 아주 의미가 있는건 아니예요.

00:02:17.838 --> 00:02:20.386
우리가 이 label을 넘기는건

00:02:20.386 --> 00:02:25.288
여기 아래 저장된 함수로의 위치인거죠.

00:02:25.288 --> 00:02:26.913
이게 질문의 답이 됐나요, Virginia?

00:02:26.913 --> 00:02:27.862
이거에 더 말할 게 있나요?

00:02:27.862 --> 00:02:33.465
Virginia: 그럼 그 다음, 만약 다시 functionCreator를
새로운 label이랑 실행하면,

00:02:33.465 --> 00:02:35.698
같은 위치를 가리키나요?

00:02:35.698 --> 00:02:36.229
Will Sentance: 완전 다릅니다. 완전 달라요.

00:02:36.229 --> 00:02:41.141
functionCreator가 다시 실행되면,
새로운 Local Memory가 만들어지고,

00:02:41.141 --> 00:02:45.151
새로운 0값의 counter 새로운 add3 함수가

00:02:45.151 --> 00:02:49.817
저장될거고, 대충 10013이라고 하죠.
이거의 새로운 복사본인거예요.

00:02:49.817 --> 00:02:51.765
Virginia: 그럼 이건 2개의 다른 위치가 되는거네요?

00:02:51.765 --> 00:02:53.319
Will Sentance: 그렇죠.

00:02:53.319 --> 00:02:54.272
Virginia: 알았어요.
Will Sentance: 확실히

00:02:54.272 --> 00:02:55.108
이걸 전달하는게 아니예요

00:02:55.108 --> 00:02:58.049
add3의 전체 코드를 반환하는게 아닙니다.

00:02:58.049 --> 00:03:01.053
add3의 코드를 잡고 그걸 generatedFunc에
저장한다는 걸 말한건

00:03:01.053 --> 00:03:02.341
은유적으로 말한거예요.

00:03:02.341 --> 00:03:07.277
그 대신, 우린 연결 링크를 전달하죠.
JavaScript의 복잡한 Memory 어딘가

00:03:07.277 --> 00:03:08.303
add3가 저장된 곳을요.

00:03:08.303 --> 00:03:10.039
Global과 무관해요.
이건 Global Memory가 아닙니다.

00:03:10.039 --> 00:03:14.200
왜냐하면 이건 Memory 내부에 숨겨진 거고,
그 안에 모든 배열, 객체,

00:03:14.200 --> 00:03:17.053
그리고 함수의 선언이 있어요.
그것들이 전부 여기 아래 있습니다.

00:03:17.053 --> 00:03:20.519
우리가 Local Memory에 이걸 저장할 때,

00:03:20.519 --> 00:03:24.680
심지어 Global Memory에 저장할 때도,
이건 연결 링크예요.

00:03:24.680 --> 00:03:29.948
어떤 공유된, 이 아래 영구적인
Memory 저장소로 가는 링크죠.

00:03:29.948 --> 00:03:30.848
아, 영구적인건 아닙니다.

00:03:30.848 --> 00:03:34.149
이 아래의 Memory 저장소는 우리가 직접 통신하지 않아요.

00:03:34.149 --> 00:03:38.923
우린 그저 여기로 가는 링크만 저장하는거고,
그 말은, 우리가 이 링크를 전달할 수 있다는건

00:03:38.923 --> 00:03:42.476
여전히 이 링크는 최초에
저장된 함수로 갈 수 있다는거죠.

00:03:42.476 --> 00:03:43.862
항상 이 이야기를 꺼내진 않아요.

00:03:43.862 --> 00:03:45.498
여러분들에게 약간의 보너스가 되길 바랍니다.

00:03:45.498 --> 00:03:48.615
혹시 이해가 안됐더라도, 크게 중요하진 않아요.

00:03:48.615 --> 00:03:53.719
그냥 항상 우리가 그 이름을 빼고,
함수의 코드 전체를 반환하는거라고 생각하세요.

00:03:53.719 --> 00:03:59.561
그리고 그걸 새로운 전역 Label인
generatedFunc에 저장한다고요.

00:03:59.561 --> 00:04:04.422
이제 질문은, 그리고 여러분들은
우리가 왜 이런 일을 해야하는지에 대해 알아내기 시작했단거죠.

00:04:04.422 --> 00:04:09.094
왜 제가 다른 함수 안에 함수를 저장하고,

00:04:09.094 --> 00:04:13.085
그걸 사용하지도 않고 반환했을까요?

00:04:13.085 --> 00:04:14.963
Will Sentance: 뭘 알거냐면, 그거 아니예요.

00:04:14.963 --> 00:04:18.986
우린 가장 강력한 힘을 얻을겁니다.

00:04:18.986 --> 00:04:22.287
방금 말한건 이 섹션의 타이틀일뿐이고 그렇지 않아요.

00:04:22.287 --> 00:04:24.509
전 처음부터 말했죠.

00:04:24.509 --> 00:04:28.303
함수를 반환하는 것으로 강력한 힘을 얻을거예요.

00:04:28.303 --> 00:04:30.934
이 작은 함수를 반환하는 것은

00:04:30.934 --> 00:04:34.279
의심의 여지없이 JavaScript의
가장 강력한 특징이예요.

00:04:34.279 --> 00:04:38.863
그리고 그것은 Functional Programming을
넘어서 모든 것에 적용되는겁니다.

00:04:38.863 --> 00:04:42.190
이 테크닉은 비동기 JavaScript와 비동기 Callback에 대한

00:04:42.190 --> 00:04:45.805
상태 지속성에게 가장 큰 영향을 미칩니다.

00:04:45.805 --> 00:04:49.279
이건 Iterator와 Generator의 내부에도 쓰이죠.

00:04:49.279 --> 00:04:52.167
비동기 관련된 건 전부 내부에 이게 있어요.

00:04:52.167 --> 00:04:55.576
이건 JavaScript에서 가장 중요한 개념입니다.

00:04:55.576 --> 00:04:57.072
제가 제일 좋아하는거구요.

00:04:57.072 --> 00:04:59.829
그것의 가장 중요한 개념은 이벤트 루프입니다.

00:04:59.829 --> 00:05:04.313
이 개념은 모든 JavaScript에서 가장 영향력이 있고

00:05:04.313 --> 00:05:08.739
솔직히 많은 오해도 있지만, 이건 정말 지배적이예요.