WEBVTT

00:00:00.000 --> 00:00:05.362
Will Sentance: Functional Programming으로
가는 먼 길에서

00:00:05.362 --> 00:00:11.075
가장 중요한 함수로 계속 이어갑시다.

00:00:11.075 --> 00:00:15.582
그건 reduce입니다. 잠시 후에
여기로 돌아갈거지만,

00:00:15.582 --> 00:00:20.508
Functional Programming에서
가장 강력한 함수를 보도록 하죠.

00:00:20.508 --> 00:00:25.085
아마도 모든 프로그래밍에서
가장 다재다능한 함수일거예요.

00:00:25.085 --> 00:00:29.052
제 경우에 가장 중요한 JavaScript 함수는
그것의 유용성과, 그것이 얼마나 중요한지,

00:00:29.052 --> 00:00:31.726
얼마나 복잡한지에 대한 측면에서 봤을 때,
fetch입니다.

00:00:31.726 --> 00:00:37.478
만약 여러분들이 Asynchronous Hard Part를 봤다면요,
지금 보세요.

00:00:37.478 --> 00:00:43.136
1번은 Functional Programming나, JavaScript,

00:00:43.136 --> 00:00:46.818
모든 것에서 가장 중요한 것은
reduce입니다.

00:00:46.818 --> 00:00:48.415
모든 Higher Order Function에서
가장 변화무쌍하죠.

00:00:48.415 --> 00:00:53.223
여러분,
reduce로 우리가 할 수 있는 것은

00:00:53.223 --> 00:00:57.983
아주 심오하고, 우린  Functional Programming에서,
가장 중요한 목표를

00:00:57.983 --> 00:01:01.993
달성하기 위해 그걸 사용할 거예요.

00:01:01.993 --> 00:01:08.159
그 내부에서, 지금 말해야겠어요,
함수 합성은 reduce 기반으로 처리됩니다.

00:01:08.159 --> 00:01:11.891
reduce를 통해 문제를 살펴보는 마인드의 변환이 필요해요.

00:01:11.891 --> 00:01:14.909
그게 결국 함수 합성을 이끌어냅니다.

00:01:14.909 --> 00:01:18.928
음, 우린 이미 reduce처리를 봤어요.
실제로 reduce를 했죠. 아직 깨닫지 못했을 뿐입니다.

00:01:18.928 --> 00:01:23.321
여기 map 함수가 있죠.
[1, 2, 3]을 가지고 각 요소를 곱합니다.

00:01:23.321 --> 00:01:28.136
먼저 이걸 들고, 2를 곱한 뒤에
그걸 output에 넣는 거죠. 배열에요.

00:01:28.136 --> 00:01:29.674
그리고 그 다음 요소를 가지고

00:01:29.674 --> 00:01:34.225
multiplyBy2 함수를 실행해서
4를 얻어서 output에 넣죠. 맞죠?

00:01:34.225 --> 00:01:37.088
우린 여기 몇 가지 가정을 했어요 여러분.

00:01:37.088 --> 00:01:39.929
여기 아래 부분에 이걸 보여드릴께요.

00:01:39.929 --> 00:01:41.432
몇 가지 가정을 했죠.

00:01:41.432 --> 00:01:46.751
음. 여기다 할 수 있을 것 같아요,
여기다 할까요?

00:01:46.751 --> 00:01:49.142
좋아요, 우린 몇 가지 가정을 했어요.

00:01:50.835 --> 00:01:54.904
Will Sentance: [1, 2, 3]은 입력이죠.
여기 할께요.

00:01:57.462 --> 00:02:02.210
우리가 가정했던 map은 첫 번째 요소와

00:02:02.210 --> 00:02:07.521
두 번째 요소 그리고 이거까지를 가지고 뭐랑 조합했었죠?
Seth?

00:02:07.521 --> 00:02:10.232
각 개별 요소들이 뭐를 통해 변화되었죠?

00:02:10.232 --> 00:02:11.509
Seth: Callback인가요?

00:02:11.509 --> 00:02:14.489
Will Sentance: Callback을 사용해서
이걸 뭐로 결합했죠?

00:02:14.489 --> 00:02:15.258
Seth: 새로운 배열이요.

00:02:15.258 --> 00:02:16.774
Will Sentance: 새로운 배열이죠.

00:02:16.774 --> 00:02:19.231
왜 우린 배열을 만들었죠?

00:02:19.231 --> 00:02:20.636
있던 게 아니죠.

00:02:20.636 --> 00:02:25.329
우리가 했던 것을 정확하게 명시하고 제대로 인지해보죠.

00:02:25.329 --> 00:02:30.233
우린 [1, 2, 3]의 첫 번째 요소를 가지고,
발상을 전환하는게 필요해요.

00:02:30.233 --> 00:02:34.526
만약 누군가가 map이 실제로 이렇게 동작한다고 머리로 생각했다면,

00:02:34.526 --> 00:02:37.529
수학 마법사나 지니였을 거에요.

00:02:37.529 --> 00:02:41.874
실제로 1을 가지고, 이걸 뭐랑 결합하냐면,

00:02:44.481 --> 00:02:46.800
빈 배열이죠.

00:02:46.800 --> 00:02:49.774
multiplyBy2를 거치고 나서요.

00:02:49.774 --> 00:02:55.830
1에 2가 곱해진 값이 있는 배열을 얻기 위해
그걸 빈 배열에 결합하죠.

00:02:55.830 --> 00:02:57.839
이게 실제로 우리가 한거죠.

00:02:57.839 --> 00:03:01.498
우린 배열을 가지고 있는걸로 가정했어요.

00:03:01.498 --> 00:03:04.561
생각을 뒤집어보죠.

00:03:04.561 --> 00:03:09.154
실제로 우리가 한 일은 첫 번째 요소를 가져와서

00:03:09.154 --> 00:03:13.358
2를 곱한 다음 빈 배열에 결합한거였죠.

00:03:13.358 --> 00:03:15.740
Jasmine, 어떻게 2를 결합했죠?

00:03:15.740 --> 00:03:17.034
이걸 어떻게 결합했죠?

00:03:17.034 --> 00:03:19.145
이 배열이랑 숫자를 어떻게 결합했어요?

00:03:19.145 --> 00:03:20.681
Jasmine: 삽입해서요?

00:03:20.681 --> 00:03:21.922
Will Sentance: 어떤 메소드를 사용했죠?

00:03:21.922 --> 00:03:22.952
Jasmine: Push요.
Will Sentance: Push죠.

00:03:22.952 --> 00:03:27.905
전 이 곱해진 요소를 사용하여 결합하고, Push한거죠.

00:03:27.905 --> 00:03:33.073
그리고, 이 결합된 걸 입력으로

00:03:33.073 --> 00:03:39.114
다음 요소랑 결합합니다. 똑같이 2배로요.

00:03:39.114 --> 00:03:44.025
2배가 되는 요소는,
요소인 2가 있는 배열에,

00:03:44.025 --> 00:03:46.456
2를 곱한 2를 어떻게 결합하죠?

00:03:46.456 --> 00:03:50.216
어떻게 이 2개를 결합해서 하나로 만들죠?

00:03:50.216 --> 00:03:51.004
Bivanesh: Push로요.

00:03:51.004 --> 00:03:53.677
Will Sentance: Push하는거죠. 정확해요.

00:03:55.313 --> 00:03:56.527
Will Sentance: 이거죠.

00:03:57.568 --> 00:04:00.402
Will Sentance: 이제 2랑 4가 있고, 이건 하나죠.

00:04:00.402 --> 00:04:02.757
이걸 아는 건 아주 중요해요.

00:04:02.757 --> 00:04:04.476
하나의 본체예요.

00:04:04.476 --> 00:04:05.621
하나의 값입니다.

00:04:05.621 --> 00:04:08.517
2개로 나뉜 게 아니라 1개예요.

00:04:08.517 --> 00:04:10.145
숫자가 하나이듯,

00:04:10.145 --> 00:04:11.603
문자열이 하나이듯,

00:04:11.603 --> 00:04:12.548
객체가 하나이듯요.

00:04:12.548 --> 00:04:14.754
그 안에 뭐가 엄청 많아도, 1개죠.

00:04:14.754 --> 00:04:21.197
그리고 전 마지막 요소를 두 배로 하여, 이것과 결합해요.
Bivanesh,

00:04:21.197 --> 00:04:23.195
한 번 더 도와주세요.

00:04:23.195 --> 00:04:26.053
Bivanesh: Push해요.
Will Sentance: 이걸 Push하죠.

00:04:26.053 --> 00:04:31.201
그리고 보시면 [1, 2, 3]이 [2, 4, 6]이 됐죠.

00:04:31.201 --> 00:04:37.138
이 개념 구조가 아니라, 이거예요.

00:04:37.138 --> 00:04:42.882
map을 하면서 실제로 한 건,
각 요소를 가지고 2를 곱해서

00:04:42.882 --> 00:04:47.864
배열에 Push하는 거고,
좀 더 일반적인 의미로 제가 하는 건

00:04:47.864 --> 00:04:51.503
첫 번째 요소를 가지고, 2배를 하죠.

00:04:51.503 --> 00:04:56.913
그리고 그걸 빈 배열에 Push함으로써 결합해요.

00:04:56.913 --> 00:05:01.964
reduce 하는 건, 이 2가지로부터,
첫 번째 요소와

00:05:01.964 --> 00:05:07.154
배열이요.
이 2개를 하나로 줄이는 거예요.

00:05:07.154 --> 00:05:11.930
그리고 2가지로부터 가져온 줄인 것의 결과는,
가격을 낮추고

00:05:11.930 --> 00:05:13.043
내리는거죠.

00:05:13.043 --> 00:05:15.053
이 2개를 1개로 줄인 거고,

00:05:15.053 --> 00:05:18.850
그 2개를 하나로 만든 reduce의 결과값을 가지고

00:05:18.850 --> 00:05:23.771
다음 요소랑 결합해서 또 줄이는거죠.
이게 1개가 되는거죠. 1개요.

00:05:23.771 --> 00:05:28.211
이걸 이 요소랑 결합하는거예요.
몇 개나되죠, David? 이 숫자랑,

00:05:28.211 --> 00:05:31.106
배열이랑은요? 몇 개나 되죠?

00:05:31.106 --> 00:05:32.934
David: 2개요.
Will Sentance: 2개죠.

00:05:32.934 --> 00:05:34.645
그리고 이게 어떻게 줄어들죠?

00:05:34.645 --> 00:05:37.038
David: 1개요.
Will Sentance: 1개로죠. 이거죠.

00:05:37.038 --> 00:05:40.849
그리고 이걸 2배를 하고 그 요소를 Push 했죠.

00:05:40.849 --> 00:05:45.560
그리고 이거 하나랑 다음 것을 가지고,
이 요소를 2배로 하고,

00:05:45.560 --> 00:05:50.188
이거랑 결합해서 1개를 얻죠.
완전 같은 거예요.

00:05:50.188 --> 00:05:54.331
우리가 copyArrayAndManipulate에서
했던 일을 생각할 때,

00:05:54.331 --> 00:05:57.439
각 요소를 취하고, 무언가를 그것과 결합하고

00:05:57.439 --> 00:06:00.419
그걸 만들어가는 거에 대해 생각나시면 손 들어주세요.

00:06:00.419 --> 00:06:03.944
그걸 뭐라고 하죠?

00:06:03.944 --> 00:06:12.103
이걸 accumulator라고 합니다.
이건 여러분들이 생각한 요소를 취하고,

00:06:12.104 --> 00:06:16.184
이 accumulator랑 합쳐 줄이는거죠.

00:06:16.184 --> 00:06:20.574
2가 들어있는 배열을 얻기 위해
이거랑 우리가 조합을 하고,

00:06:20.574 --> 00:06:25.331
그리고 다음 요소를 가지고 2배를 한 뒤
이 두 가지를 또 감소시키죠.

00:06:25.331 --> 00:06:29.528
이것들을 줄이는 거예요
2개를 가지고 1개로요. 2개를 1개로입니다.

00:06:29.528 --> 00:06:32.090
그리고 또 이 2개를 줄이죠.

00:06:32.090 --> 00:06:35.714
다음 요소와 2개를 1개로 줄인 줄인 결과를
1개가 되는거죠. 1개가 된거예요.

00:06:35.714 --> 00:06:39.865
2개를 1개로 줄이는 reduce의 출력인거예요. 1개죠 결국

00:06:39.865 --> 00:06:41.480
이게 하나가 아니란 건 알지만 하나인거예요.

00:06:41.480 --> 00:06:42.682
배열은 1개인거죠.

00:06:42.682 --> 00:06:46.202
함수를 단일 항목으로 반환하는 모든 거죠,
배열을 반환할 수 있어요.

00:06:46.202 --> 00:06:49.065
그리고 그 1개를 변수로 저장하게 될 거구요.

00:06:49.065 --> 00:06:50.243
이걸 또 배열로 저장할 수 있죠.

00:06:50.243 --> 00:06:55.866
만약 마음 속에 2개를 1개로 매핑하는 것,

00:06:55.866 --> 00:07:00.928
그 reduce의 결과를 가지고 다음 요소랑 결합해서 1개로 만들고,

00:07:00.928 --> 00:07:05.632
또 1개로 만드는 것에 대해 떠오르는 게 있으면 손 들어주세요.

00:07:05.632 --> 00:07:08.725
이걸 반환하는 걸 아시는-
Sam, 당신은-

00:07:08.725 --> 00:07:11.195
Sam: 축약식 이름이 map인데,

00:07:11.195 --> 00:07:13.667
그건 MapReduce의 축약이예요.

00:07:13.667 --> 00:07:18.718
Will Sentance: 보세요, 재능있는 사람이 있을거라고 했잖아요.

00:07:18.718 --> 00:07:20.187
천재군요.

00:07:20.187 --> 00:07:24.733
하지만 실제로 이건 우리가 map을 하는 과정에서

00:07:24.733 --> 00:07:29.826
2개를 1개로, 또 2개를 1개로, 2개를 1개로 reduce하는거예요.

00:07:29.826 --> 00:07:36.339
그리고 이것의 강력한 점이 뭐냐면요, 여기서,
우린 가정했죠.

00:07:36.339 --> 00:07:42.340
우리는 배열을 누적시켜가면서 각 요소를 줄여나갔죠.

00:07:42.340 --> 00:07:43.782
하지만 여러분들 이거 아나요?

00:07:45.604 --> 00:07:53.401
Will Sentance: 우린 이걸 숫자로 줄일 수 있어요.

00:07:53.401 --> 00:07:56.730
2를 1로, 숫자 1을 0으로 어떻게 줄일 수 있죠?

00:07:56.730 --> 00:07:58.247
뭐 되게 많은 방법이 있을 수 있어요.

00:07:58.247 --> 00:07:59.775
하지만 어떻게 2개를 1개로 줄이죠, Seth?

00:07:59.775 --> 00:08:00.921
Seth: 더해요.
Will Sentance: 더하죠.

00:08:00.921 --> 00:08:02.577
뺄 수도 있죠.

00:08:02.577 --> 00:08:04.671
곱할수도 있고, 지루하죠.

00:08:04.671 --> 00:08:09.688
[웃음] 정말 놀라운 reduce입니다.

00:08:09.688 --> 00:08:14.475
네, 0과 1이 더하기를 통해 reduce 될 거고,

00:08:14.475 --> 00:08:18.959
그래서 0과 1을 reduce 하면 뭐죠, Seth?

00:08:18.959 --> 00:08:20.238
Seth: 1이요
Will Sentance: 1이죠, 그리고 1과

00:08:20.238 --> 00:08:21.982
2를 reduce하면?

00:08:21.982 --> 00:08:23.185
Seth: 3이요.

00:08:23.185 --> 00:08:28.502
Will Sentance: 더해져서 3이죠,
3과 3을 reduce하면, 중요해요.

00:08:28.502 --> 00:08:33.424
이전의 reduce 결과가 입력값이 되어져

00:08:33.424 --> 00:08:38.753
다음 요소랑 더한 것이되고,
그게 또 다음 요소랑 2개를 1개로 reduce하는거죠.

00:08:38.753 --> 00:08:41.446
3이랑 3이 더해지면 뭘 얻죠, Seth?

00:08:41.446 --> 00:08:42.812
Seth: 6이요.
Will Sentance: 6이죠, 좋아요.

00:08:42.812 --> 00:08:43.484
이거죠.

00:08:45.037 --> 00:08:49.818
Will Sentance: 지금 여러분, 정말 여러분
모두에게 강조하고 싶은 건

00:08:49.818 --> 00:08:53.747
reduce는 [1, 2, 3]이 6이 되는게 아니예요.

00:08:53.747 --> 00:08:59.240
우리의 reduce는
늘 2개로부터 1개가 되는 겁니다.

00:08:59.240 --> 00:09:04.006
그게 입력된 array의 각 요소에 반복되는거죠.

00:09:04.006 --> 00:09:07.601
2개를 1개로 줄였죠. 2가 있는 배열을 가지고,

00:09:07.601 --> 00:09:11.931
그걸 다음 요소인 2랑 reduce하면 2랑 4고,
그 2랑 4를

00:09:11.931 --> 00:09:16.461
다음 요소랑 reduce하죠.
이 2개를 1개로 줄이는거예요.

00:09:16.461 --> 00:09:21.484
그리고 우리는 이 패러다임 즉, accumulator와 각 요소 단위로

00:09:21.484 --> 00:09:25.933
reduce되는 데이터 모델을 거의 보지 못했어요.

00:09:25.933 --> 00:09:33.390
좋아요, 실제로 이렇게 2개를 1개로
결합하는 규칙을 말해보죠.

00:09:33.390 --> 00:09:37.770
2개를 1개로 줄이는 걸 뭐라고들 하죠, Jasmine?

00:09:37.770 --> 00:09:41.059
Jasmine: [웅얼웅얼]
Will Sentance: 네, 그런데

00:09:41.059 --> 00:09:44.868
사실 제가 이런 이름들을 싫어해서 그러는 게 아니예요.

00:09:44.868 --> 00:09:46.341
이건 안 좋은 이름이 아닙니다.

00:09:46.341 --> 00:09:49.385
그들은 2개를 1개로 결합하는 방법인

00:09:49.385 --> 00:09:51.668
이 함수, 이 코드죠,
instructions를 이렇게 부릅니다.

00:09:51.668 --> 00:09:54.389
multiplyBy2를 통해 더하고, 그 요소를 Push하죠.

00:09:54.389 --> 00:09:56.533
그게 이 2개를 결합하는 방법이죠?

00:09:56.533 --> 00:10:02.561
우린 이걸 2로 곱하고, 배열에 Push하는 걸로 결합하죠.

00:10:02.561 --> 00:10:07.473
사람들은 이걸 reducer라고 합니다.
2개를 1개로 줄인다는거죠.

00:10:07.473 --> 00:10:12.023
2개를 하나로 결합하는 규칙이예요.

00:10:12.023 --> 00:10:15.299
2개를 하나로, 2개를 하나로

00:10:15.299 --> 00:10:20.229
2개를 하나로, 2개를 하나로,
2개를 하나로요.

00:10:20.229 --> 00:10:26.717
데이터를 취하는 이 패러다임으로
무엇을 할 수 있는지가 아주 어렵죠.

00:10:26.717 --> 00:10:31.853
사실 전 이걸 알려드리고 싶지 않았어요.

00:10:31.853 --> 00:10:36.258
하지만, 이건 Functional Programming에서
우리가 사용하는 가장 중요한 도구예요.

00:10:36.258 --> 00:10:40.259
함수들의 백업을 재결합 하게 해주죠.

00:10:40.259 --> 00:10:41.808
왜냐하면, 우리는 모든 걸 하나의 라인에 쓰고

00:10:41.808 --> 00:10:44.335
다른 함수들로 저장을 한 뒤,
여러분들은 그것들을 다시 결합해야해요.

00:10:44.335 --> 00:10:49.946
전 그게 아주 읽기 쉬운 방식으로
이걸 내부에서 사용한다고 생각해요.

00:10:49.946 --> 00:10:54.605
우린 다 그걸 할거예요, 일단 지금은, 
우린 이미 봤으니, 이해할 수 있어요.

00:10:54.605 --> 00:10:57.798
음, 실제로, 어쨌거나,
우린 여기 숫자 0이랑 동작이 되죠,

00:10:57.798 --> 00:10:59.691
문자열이랑도 결합할 수 있어요.

00:10:59.691 --> 00:11:03.857
만약 문자열 1이랑 결합하면 어떤 게 될 지 아는 분,
Charles, 뭘 얻죠?

00:11:03.857 --> 00:11:04.522
Charles: 문자열이요.

00:11:04.522 --> 00:11:05.506
Will Sentance: 문자열 1이죠?

00:11:05.506 --> 00:11:07.680
그럼 그 문자열 1이랑 2랑 결합하면요?

00:11:07.680 --> 00:11:10.774
문자열, 어떤 문자열이죠?

00:11:10.774 --> 00:11:11.399
Charles: "12"요.

00:11:11.399 --> 00:11:13.153
Will Sentance: "12"죠,
[웃음] 대단한 언어예요 이건.

00:11:13.153 --> 00:11:15.612
그럼 "12"랑 "3"이랑 결합하면요?

00:11:15.612 --> 00:11:16.519
Charles: "123"이요.

00:11:16.519 --> 00:11:19.059
Will Sentance: "123"이죠, 동일한 자료형이 아닌 경우에도,

00:11:19.059 --> 00:11:20.650
결합하는 아주 엄격한 강제죠.

00:11:21.890 --> 00:11:25.600
그래서 만약 여러분들이 이런 걸
목표로 함수를 만들기 원한다면,

00:11:25.600 --> 00:11:30.210
우린 저 2개를 다루는 함수를 작성해야해요.

00:11:30.210 --> 00:11:35.580
하나는 요소와 요소를 결합하는 아무 accumulator인데,

00:11:35.580 --> 00:11:40.800
결합의 결과가 다음 요소와 함께 사용되어

00:11:40.800 --> 00:11:43.949
두 개를 하나로 합치고, 그 결과가 또 하나로 합쳐지는거죠.

00:11:45.500 --> 00:11:49.757
그리고 2개를 하나로, 2개를 하나로, 2개를 하나로, 이렇게

00:11:49.757 --> 00:11:53.020
요소들을 결합하기 위한 함수인데, 그걸 reducer라고 부릅니다.