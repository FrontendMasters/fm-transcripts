WEBVTT

00:00:00.000 --> 00:00:02.459
Will Sentance: Function Decoration입니다.

00:00:02.459 --> 00:00:07.458
이제 우리는 함수를 우리의 작업에
더 쉽게 맞춰지도록 변경할겁니다.

00:00:07.458 --> 00:00:11.018
만약 우리가 작은 코드 블럭이나
함수를 계속 사용한다면,

00:00:11.018 --> 00:00:14.166
아주 간단하고 작은 함수가
계속 반복되서 사용된다면요.

00:00:14.166 --> 00:00:20.808
이상적으로, 작은 변화에 대해선
코드를 다시 작성할 필요가 없어야겠죠.

00:00:20.808 --> 00:00:23.521
자, 우리가 할 수 있는게 하나 있어요.
Higher Order Function을 쓰는겁니다.

00:00:23.521 --> 00:00:24.501
함수가 하나 있고,

00:00:24.501 --> 00:00:28.251
다시 작성할 필요가 없고, 그게 실행될 때
특별한 조건을 삽입해서 약간 변경하는겁니다.

00:00:28.251 --> 00:00:31.759
문제는, Higher Order Function에
copyArrayManipulate나

00:00:31.759 --> 00:00:35.450
map같은 placeholder를 남겨야했다는거죠.
placeholder가 있어야해요.

00:00:35.450 --> 00:00:41.990
map을 실행할 때, 배열의 각 요소를 지나갈 때
뭘 할지에 대해서 정확히 명시해야하죠.

00:00:41.990 --> 00:00:45.020
하지만, 때때로 placeholder를 남기지 않고도
함수를 변경하고 싶을 때가 있어요.

00:00:45.020 --> 00:00:51.141
뭔가 새로운 기능들을 그 함수에 넣고 싶은거죠.

00:00:51.141 --> 00:00:54.901
저장한 이후에 함수의 바디 영역을 수정할 수 있나요?

00:00:54.901 --> 00:00:57.572
여러분 다 같이?

00:00:57.572 --> 00:00:59.764
없죠. 그렇게 할 수 없어요.

00:00:59.764 --> 00:01:04.635
한 번 함수가 저장되면,
뭐 배열로 들어가서 각각의 요소를 들어갈 수 없고

00:01:04.635 --> 00:01:06.110
뭔가를 추가하거나 지울 수가 없죠.

00:01:06.110 --> 00:01:09.961
함수 코드가 한번 저장되면,
그 안으로 다시 들어갈 수가 없고

00:01:09.961 --> 00:01:11.789
그거랑 뭔갈 할 수가 없어요.
이미 설정이 되버린겁니다.

00:01:13.775 --> 00:01:16.437
Will Sentance: 그래서 함수가 수정될 수 있기를 바라지만,

00:01:16.437 --> 00:01:18.622
처음부터 그걸 재작성할 수는 없는거죠.

00:01:18.622 --> 00:01:24.295
그래서 그 대신,
Function Decoration이라는 테크닉을 쓸거예요.

00:01:24.295 --> 00:01:29.641
저장되어있는 함수를 수정하는 것처럼 보일 겁니다.

00:01:29.641 --> 00:01:31.624
그렇게 하는 것처럼 보일거예요.

00:01:31.624 --> 00:01:34.804
하지만 실제로는 그렇게 하지 않을거예요.

00:01:34.804 --> 00:01:39.500
그 대신, 그건 새로운 함수를 만들어서,

00:01:39.500 --> 00:01:44.539
그 새로운 함수의 안에,

00:01:44.539 --> 00:01:49.822
수정하고 싶은 함수를 어떤 방법으로 넣는거죠.

00:01:49.822 --> 00:01:54.057
그래서 우리가 새로운 함수를 실행할 때,
그건 기존 함수를 실행하는 것처럼 보일거고,

00:01:54.057 --> 00:01:55.587
약간은 다르게 동작할거예요.

00:01:55.587 --> 00:01:57.389
그건 우리 함수가 약간 수정된 것처럼 보일겁니다.

00:01:57.389 --> 00:01:59.156
하지만 실제로 우린 새로운 함수를 만든거고,

00:01:59.156 --> 00:02:01.870
그건 우리가 수정하고 싶은 함수가 있는 곳인거죠.

00:02:01.870 --> 00:02:06.276
그래서 새로운 함수는
원래 함수처럼 보일 건데 수정이 된거죠.

00:02:06.276 --> 00:02:06.817
이겁니다.

00:02:06.817 --> 00:02:10.386
그래서 특히, 만약 여러분들이
영구적인 메모리를 추가하길 원하면,

00:02:10.386 --> 00:02:12.457
예를 들어, 우리가 저장한 기존 함수에요.

00:02:12.457 --> 00:02:15.862
영구적인 메모리, 백팩의 기능을 추가할 수 있나요?

00:02:15.862 --> 00:02:17.932
제가 저장한 기존 함수예요.

00:02:17.932 --> 00:02:22.289
만약 함수가 저장됐으면,
그게 저장된 후에 백팩을 달아줄 수 있나요?

00:02:23.449 --> 00:02:24.826
Will Sentance: 그건 확실히 아니죠.

00:02:24.826 --> 00:02:29.133
그걸 하기 위해선 오직 함수가
다른 함수의 실행 안에서 얻어지고,

00:02:29.133 --> 00:02:30.838
그게 반환되는 수밖에 없어요.

00:02:30.838 --> 00:02:35.162
만야 그렇게 못한다면, 어떻게 영구적인 메모리를 줄 수 있죠?

00:02:35.162 --> 00:02:36.593
음, 방법이 있어요.

00:02:36.593 --> 00:02:39.026
이렇게 하고 싶을 때 효과적이죠.

00:02:39.026 --> 00:02:44.139
그래서 예를 들어, 만약 함수를 편집하고 싶다면,
아, 전통적인 것이 하나 있습니다.

00:02:45.709 --> 00:02:49.021
Will Sentance: 함수를 편집하고 싶다고 가정해보죠.

00:02:49.021 --> 00:02:53.709
multiplyBy2가 한 번만 실행되게
제약을 건다라고 해보죠.

00:02:53.709 --> 00:02:57.454
그러니까 그걸 딱 한 번만 실행하는거예요.
이제부터 이건 오직 한 번만 실행되도록 고쳐지는거죠.

00:02:57.454 --> 00:03:01.124
한 번 실행하면,
10으로 multiplyBy2를 실행한다고 하면,

00:03:01.124 --> 00:03:05.437
그걸 다시 실행하면, Sorry가 나오는거죠.
이미 실행해서 더 이상 실행할 수 없어요. 라고요.

00:03:05.437 --> 00:03:08.474
이건 프로그래밍에서
늘상 우리가 사용하길 원하는 테크닉이예요.

00:03:08.474 --> 00:03:11.081
종종 게임같은 거에서 함수의 호출에
제한을 걸고 싶어하죠.

00:03:11.081 --> 00:03:12.508
예를 들어, Tic Tac Toe면,

00:03:12.508 --> 00:03:16.125
주어진 셀에서 함수가 한 번만 호출되도록
제약을 걸고 싶을거예요.

00:03:16.125 --> 00:03:19.498
0에서 X로 바꾼 다음, 다시 돌리지 않는거죠.

00:03:19.498 --> 00:03:21.230
한 번만 실행하도록 제약을 걸고 싶은거죠.

00:03:21.230 --> 00:03:24.951
multiplyBy2 함수를 편집할 수는 없지만,

00:03:24.951 --> 00:03:30.139
우린 백팩에 이걸 한 번만 실행할 수 있다고 줄 수 있죠.
한 번 저장해서요.

00:03:30.139 --> 00:03:34.797
그래서 Function Decoration이라고 하는
테크닉을 이용할거예요.

00:03:34.797 --> 00:03:40.448
전 oncify라는 함수를 사용할건데, 
그 함수는

00:03:40.448 --> 00:03:45.844
multiplyBy2 함수를
변화하는 것처럼 보일거예요.

00:03:45.844 --> 00:03:50.863
multiplyBy2를 넣어서요.

00:03:50.863 --> 00:03:53.956
그건 아무거나 한 번만 실행하게 제약을 거는거죠.

00:03:53.956 --> 00:03:56.121
엄청 사기치는 것처럼 보이겠죠.

00:03:56.121 --> 00:04:02.847
실제로는, oncify 내부에서
새로운 함수를 만들거고

00:04:02.847 --> 00:04:09.347
oncify 내에서 새로운 함수를 설정하면, 백팩이 있나요?

00:04:09.347 --> 00:04:10.340
네 그럴거예요.

00:04:10.340 --> 00:04:13.289
그걸 반환할거고, 저기서 호출이 되면요.

00:04:13.289 --> 00:04:14.886
그리고 oncifiedMultiplyBy2에 저장될겁니다.

00:04:14.886 --> 00:04:18.084
oncifiedMultiplyBy2는 multiplyBy2처럼 동작할거예요.

00:04:18.084 --> 00:04:19.009
처음 회차에는요.

00:04:19.009 --> 00:04:22.181
하지만 실제로는, 그건 multiplyBy2처럼 동작하지 않을거예요.

00:04:22.181 --> 00:04:25.520
실제로, 그 안에서,

00:04:25.520 --> 00:04:30.167
이건 백팩에서 실행될거예요.

00:04:30.167 --> 00:04:33.810
multiplyBy2 함수가요.

00:04:33.810 --> 00:04:39.734
백팩을 확인해보면 counter는 0이죠.

00:04:39.734 --> 00:04:42.903
그리고, 분기문을 수행하면 이제 1이 되고,

00:04:42.903 --> 00:04:45.871
그리고 한 번 더 oncifiedMultiplyBy2를 실행하면,

00:04:45.871 --> 00:04:50.470
Sorry가 나올거예요.
백팩의 counter가 1이니까 다시 실행할 수가 없는거죠.

00:04:50.470 --> 00:04:55.643
근데 여기가 정말 재밌는 처리가 될거예요.

00:04:55.643 --> 00:04:56.641
자 전 우리가 다른 방법을 찾고 있다고 했죠.

00:04:56.641 --> 00:05:00.566
이걸 전체적으로 매핑할건데, 다른 방법을 봐보죠.

00:05:00.566 --> 00:05:02.742
oncifiedMultiplyBy2는

00:05:02.742 --> 00:05:06.877
oncify에서 나온 내부 함수가 될 거고,

00:05:08.092 --> 00:05:11.578
Will Sentance: multiplyBy2를
편집한 것 처럼 보이지만 아니죠.

00:05:11.578 --> 00:05:12.215
여러분들은 함수를 편집할 수 없어요.

00:05:12.215 --> 00:05:14.917
이건 multiplyBy2처럼 보일거예요.

00:05:14.917 --> 00:05:20.345
실제로 oncifiedMultiplyBy2라는 이름을 붙일 수도 있고,

00:05:20.345 --> 00:05:23.742
뭐 잘 모르겠지만 multiplyBy2Once든 뭐든요.

00:05:23.742 --> 00:05:27.290
이건 multiplyBy2를 편집한것처럼 보일거란거고,
그게 아니란거죠.

00:05:27.290 --> 00:05:29.204
실제로 그게 하는건요?

00:05:29.204 --> 00:05:33.641
백팩에 접근할 수 있는 새로운 함수를 만들죠.

00:05:33.641 --> 00:05:37.817
우린 함수를 한 번만 호출하도록 제한할 백팩이 필요해요.

00:05:37.817 --> 00:05:39.296
이거 강조했어요.

00:05:39.296 --> 00:05:42.356
함수를 한번 실행하고,
한 번만 실행하게 제한하려면,

00:05:42.356 --> 00:05:45.286
기억하는게 필요하죠. 이전에 실행한걸요.

00:05:45.286 --> 00:05:47.778
그렇지 않으면 어떻게 한 번만
실행하도록 제한하겠어요?

00:05:47.778 --> 00:05:50.933
일반적인 함수는 이전 실행을 기억하지 못하고,

00:05:50.933 --> 00:05:52.762
이전에 실행한 걸 알지 못하죠.

00:05:52.762 --> 00:05:55.167
그래서 우린 백팩을 가진 함수가 필요하고,

00:05:55.167 --> 00:05:57.517
그게 정확히 여기에서 일어나는 일이죠.

00:05:57.517 --> 00:06:00.110
하지만 나중에 백팩에 multiplyBy2를 줄 수 없죠.

00:06:00.110 --> 00:06:02.757
그래서 그 대신 그걸 꾸미는거예요.

00:06:02.757 --> 00:06:06.485
Functional Programming에서 그 의미는

00:06:06.485 --> 00:06:09.727
새로운 함수를 만들고, oncify의 내부의

00:06:09.727 --> 00:06:14.589
inner를 호출하고, 그 안에서 counter를 확인할거고,

00:06:14.589 --> 00:06:19.209
그럼 그건 oncifiedMultiplyBy2의
첫 번째 호출의 백팩에 있는

00:06:19.209 --> 00:06:23.450
지속적인 counter에 접근을 가진단거죠.

00:06:23.450 --> 00:06:26.796
그럼 이건 multiplyBy2를 변형하지 않으면서

00:06:26.796 --> 00:06:29.975
multiplyBy2를 다시 하진 않게 되겠죠.

00:06:29.975 --> 00:06:35.719
이것들은 Closure를 사용한거고,
Closure는 함수에

00:06:35.719 --> 00:06:40.842
영구적인 메모리를 주는 원리로,
함수의 기능을 극대화하죠.

00:06:40.842 --> 00:06:46.161
multiplyBy2에 새로운 기능을 추가한거예요.
처음 이 함수를 저장할 때요.

00:06:47.468 --> 00:06:52.045
그리고 알고 보면
Functional Programming의 핵심 원리인거죠.

00:06:52.045 --> 00:06:56.875
여러분 일단 새로운 함수를 만듦으로써,

00:06:56.875 --> 00:07:01.207
가짜로 편집이 되는 함수를 깨달으시다면,

00:07:01.207 --> 00:07:06.123
한 번 실행할 함수를 전달받아

00:07:06.123 --> 00:07:09.560
실행 될 새로운 함수를 말하는 겁니다.

00:07:09.560 --> 00:07:16.321
이걸 깨달으신다면, 여러분들은 백팩에
counter같은 데이터만 저장하고 싶지 않을겁니다.

00:07:16.321 --> 00:07:21.708
예를 들어, 여러분들은 실제로 2개의 입력을

00:07:21.708 --> 00:07:26.542
가지는 함수를 저장할 수 있어요.

00:07:26.542 --> 00:07:29.970
예를 들어 하나는 아니지만,
하나는 입력을 필요로 하는 기능같은거요.

00:07:29.970 --> 00:07:34.462
이건 아마 Seth의
마지막 의문을 해소해줄겁니다.

00:07:34.462 --> 00:07:38.092
Functional Programming의 목표였죠.
모든 함수 리스트가 있고,

00:07:38.092 --> 00:07:42.372
그 함수의 목록들이 하나 실행하고,
그리고 다음 걸 실행하고, 자동적으로요.

00:07:42.372 --> 00:07:44.881
Point Free 스타일로요.
이것들을 참조로 실행하지 않고,

00:07:44.881 --> 00:07:48.400
괄호로 하지 않고, 입력도 사용하지 않죠.

00:07:48.400 --> 00:07:51.061
따라서 함수의 목록에서
다른 함수를 차례로 사용하는 함수에

00:07:51.061 --> 00:07:53.720
두 개의 입력이 필요한 경우

00:07:53.720 --> 00:07:56.761
전체 세팅이 깨질거고, 이런 모든 걸 잠시 뒤에 볼거예요.

00:07:56.761 --> 00:08:01.680
일단 지금은, 이걸 해보죠.
[의역]우린 multiplyBy2처럼

00:08:01.680 --> 00:08:06.524
동작하는 가짜 함수를 만들거예요.

00:08:06.524 --> 00:08:10.316
multiplyBy2를 하지만, 사실은

00:08:10.316 --> 00:08:15.138
그 안에서 multiplyBy2를 실행하는 완전 다른함수죠.

00:08:15.138 --> 00:08:18.245
그리고 그 안에 multiplyBy2 함수를 잘 보관하고 있을거고,

00:08:18.245 --> 00:08:23.406
그건 oncifiedMultiplyBy2의 백팩에 있죠.