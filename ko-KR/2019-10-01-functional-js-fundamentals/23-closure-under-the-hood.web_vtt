WEBVTT

00:00:00.290 --> 00:00:02.230
점점 더 중요해졌습니다.

00:00:02.230 --> 00:00:04.140
완벽하지 않다는 걸 이해해보죠.

00:00:04.140 --> 00:00:07.450
Alex, 첫 번째 라인입니다. 뭘 저장하죠?

00:00:07.450 --> 00:00:10.700
Alex: functionCreator라는 label의 함수를 선언해요.

00:00:10.700 --> 00:00:13.260
Will Sentance: 훌륭해요, 이거죠. 평범합니다.

00:00:13.260 --> 00:00:19.940
그걸 Global Memory에 저장하죠,
functionCreator는 함수입니다.

00:00:19.940 --> 00:00:21.345
여러분, 이제 거의 다 왔어요.

00:00:21.345 --> 00:00:24.210
[웃음] 사실 아니예요.

00:00:24.210 --> 00:00:30.570
좋아요, 다음 라인은, Anna입니다.
다음 라인의 left-hand 영역은요?

00:00:30.570 --> 00:00:33.400
Anna: generatedFunc라는 함수를 선언해요.

00:00:34.740 --> 00:00:36.210
Will Sentance: 음 전 그렇게 말하지 않을 겁니다.

00:00:36.210 --> 00:00:41.046
generatedFunc라는 label을 선언한다고해야죠.

00:00:41.046 --> 00:00:46.372
그리고 그 안으로 저장되는 건 뭐죠, Anna?

00:00:46.372 --> 00:00:48.590
Anna: functionCreator의 결과요.

00:00:48.590 --> 00:00:49.620
Will Sentance: 맞았나요?

00:00:49.620 --> 00:00:51.000
맞았죠.

00:00:51.000 --> 00:00:55.450
맞앗어요. 결과죠, 그 실행된 아..

00:00:55.450 --> 00:00:59.950
실행된 functionCreator의 결과를 실행하는거죠.

00:00:59.950 --> 00:01:01.510
그리고, 뭐가 그러라고 하는거죠?

00:01:01.510 --> 00:01:06.550
right-hand 영역에 그런 작업을 하라고
어떤 기호가 말하는거죠?

00:01:06.550 --> 00:01:07.590
Anna: 괄호요.

00:01:07.590 --> 00:01:09.530
Will Sentance: 괄호죠, 맞았어요.

00:01:11.320 --> 00:01:15.960
JavaScript에서 가장 큰 차이점은 이 한 줄이 가장 어렵다는 것을

00:01:15.960 --> 00:01:17.920
발견하는 사람이 아주 많다는 거죠.

00:01:17.920 --> 00:01:19.710
사실 뭐 알아내는거라기 보단, 이건 약간 속임수에 가까워요.

00:01:19.710 --> 00:01:22.640
우리가 함수를 실행할 때 무엇을 하고 있는지

00:01:22.640 --> 00:01:24.060
알아야 한다는 것과 더 비슷해요.

00:01:24.060 --> 00:01:25.470
우리가 함수를 이야기할 때,

00:01:25.470 --> 00:01:28.460
우리가 label을 선언할 때 하는 건
이 라인에서 무슨 일이 일어나는지 알기 위해서죠.

00:01:28.460 --> 00:01:29.610
좋아요, 이거죠, generatedFunc요.

00:01:29.610 --> 00:01:34.267
일단 지금은 초기화가 안되어있죠,
제가 왜 그렇게 말했죠?

00:01:34.267 --> 00:01:36.243
왜 초기화가 안됐다고 했죠?

00:01:36.243 --> 00:01:41.276
undefined는 var를 사용하여 right-hand 영역에

00:01:41.276 --> 00:01:46.687
함수의 출력이 될 label을 선언했을 때 발생하는 일이예요.

00:01:46.687 --> 00:01:49.268
함수가 실행되는 동안 기본적으로 한번 찾고,

00:01:49.268 --> 00:01:52.790
그 다음 함수 호출의 결과로 재정의하겠죠.

00:01:52.790 --> 00:01:56.070
constant로 작업하면, 여러분들은 2개의 데이터 타입으로

00:01:56.070 --> 00:01:59.146
바꿀 수가 없죠. 여러분들은 초기값으로
undefined를 선언할 수 없어요.

00:01:59.146 --> 00:02:01.300
기본은, 그걸 찾은 다음 함수의 호출 결과를 얻으면,

00:02:01.300 --> 00:02:05.570
그 호출 결과가 무엇이든간에 굉장히 빠르게 바뀌죠.

00:02:05.570 --> 00:02:11.177
대신, 여러분들은 실제로
right-hand 영역의 실행 결과를 얻을 때까지

00:02:11.177 --> 00:02:15.170
generatedFunc라는 label을 완전 선언하지 않아요.

00:02:15.170 --> 00:02:16.680
이건 아까랑 관련- 죄송해요. 여러분.

00:02:16.680 --> 00:02:19.650
이건 아까 Charles의 질문과 관련이 있어요.

00:02:19.650 --> 00:02:22.100
undefined vs 초기화에 대한거였죠.

00:02:22.100 --> 00:02:25.570
generatedFunc가 선언됐고, 우리가 뭘 해야하죠,

00:02:25.570 --> 00:02:30.430
Anna, 실행해가지고 결국 generatedFunc에 저장할 그게 뭐죠?

00:02:30.430 --> 00:02:31.307
generatedFunc에 저장하기 위해

00:02:31.307 --> 00:02:33.720
행해서 알아내야할 것이 뭐죠?

00:02:33.720 --> 00:02:34.597
Anna: functionCreator요.

00:02:34.597 --> 00:02:40.905
Will Sentance: functionCreator죠. 실행 해보죠.

00:02:40.905 --> 00:02:44.400
좋아요, 그럼 functionCreator를 실행할겁니다.

00:02:44.400 --> 00:02:46.260
Anna, 새로운 뭐가 필요하죠?

00:02:49.030 --> 00:02:49.811
Anna: Execution Context요.

00:02:49.811 --> 00:02:50.339
Will Sentance: 좋아요.

00:02:50.339 --> 00:02:51.070
Anna: [웃음]
Will Sentance: 그리고

00:02:51.070 --> 00:02:57.790
우린 여기에서 뭐가 나오던지간에
generatedFunc에 저장될거라는걸 알죠.

00:02:57.790 --> 00:03:03.449
이제 Execution Context를 만들어보죠.

00:03:05.752 --> 00:03:10.270
Will Sentance: 그리고,
[웃음] 마름모가 됏네요.

00:03:10.270 --> 00:03:13.830
Chalres, 그 안으로 가서 첫 번째 라인입니다.

00:03:13.830 --> 00:03:14.570
우리가 뭘 하죠?

00:03:14.570 --> 00:03:15.750
이걸 사용하진 않을거에요.

00:03:15.750 --> 00:03:16.470
그냥 보여주려구요.

00:03:16.470 --> 00:03:19.210
전 그냥 여러분들이 이 Memory에
저장할 것들을 아는 걸 확인하고자 해요.

00:03:19.210 --> 00:03:21.280
Memory에 저장되는 첫 번째가 뭐죠?

00:03:21.280 --> 00:03:22.467
Charles: counter고 0이예요.

00:03:22.467 --> 00:03:24.684
Will Sentance: counter는 0이죠, 정확해요.

00:03:24.684 --> 00:03:27.920
좋아요, 이걸 위한 Call Stack도 그릴께요.

00:03:27.920 --> 00:03:32.080
혼동하지 않는 것에 대해 생각하는 것이

00:03:32.080 --> 00:03:33.260
점점 중요해졌죠.

00:03:35.770 --> 00:03:37.090
좋아요, 그리고

00:03:37.090 --> 00:03:41.830
첫 번째는 항상 Global이 있죠,
그리고 뭐가 추가되죠, Michael?

00:03:43.808 --> 00:03:47.620
Michael: add3요, 아, functionCreator요.

00:03:47.620 --> 00:03:48.350
Will Sentance: functionCreator죠.

00:03:48.350 --> 00:03:50.190
왜냐하면 지금 우리가 어떤 함수를 호출했죠, Michael?

00:03:51.580 --> 00:03:53.490
Michael: functionCreator를 호출했어요.

00:03:53.490 --> 00:03:55.990
Will Sentance: functionCreator죠,
이게 Call Stack에 추가됐죠.

00:03:55.990 --> 00:04:01.722
왜냐하면 지금 우리가 하는
Execution Context는 functionCreator니까요.

00:04:01.722 --> 00:04:05.960
우리의 Thread of Execution은
functionCreator로 넘어갔어요.

00:04:05.960 --> 00:04:10.200
그게 우리가 현재 있는 곳이고,
그게 Call Stack의 Top이죠, 그렇죠?

00:04:10.200 --> 00:04:14.100
David, Local Memory에
counter가 0이라고 했어요.

00:04:14.100 --> 00:04:17.017
David, 다음 라인입니다. 뭘 하나요?

00:04:17.017 --> 00:04:20.314
David: add3라는 label로 함수를 선언해요.

00:04:20.314 --> 00:04:22.690
Will Sentance: add3죠.

00:04:26.120 --> 00:04:28.369
좋아요, 이제 이걸 사용하나요, David?

00:04:28.369 --> 00:04:29.198
David: 지금 당장은 아니예요.
Will Sentance: 그럼,

00:04:29.198 --> 00:04:31.428
그 대신 우리가 뭘 하죠?

00:04:31.428 --> 00:04:32.450
David: 반환을 합니다.

00:04:32.450 --> 00:04:37.725
Will Sentance: 맞아요.
여기에 쓸께요. return add3;

00:04:37.725 --> 00:04:39.405
혹시 제게 말해주실 분?

00:04:39.405 --> 00:04:42.350
return문에서 JavaScript가 실제로 하는건요?

00:04:42.350 --> 00:04:45.110
Jasmine, JavaScript가 return문에서
하는 일이 뭔지 말해줄 수 있나요?

00:04:45.110 --> 00:04:46.160
return add3에서요?

00:04:46.160 --> 00:04:47.680
Jasmine: add3로 함수를 대체시켜요.

00:04:48.890 --> 00:04:49.690
Will Sentance: 여러분 이거 들었나요?

00:04:49.690 --> 00:04:54.320
정확해요. label을 이용해서 함수의 정의를 보고,

00:04:54.320 --> 00:04:59.000
그리고 함수 정의인 (num) => {} 뭐 이런

00:04:59.000 --> 00:04:59.860
함수의 바디를 잡아요.

00:04:59.860 --> 00:05:03.860
저 전체를 가지고 이걸 호출한

00:05:03.860 --> 00:05:09.080
functionCreator의 반환으로 내보내죠.
그리고 Jasmine 어디에 저장하죠?

00:05:09.080 --> 00:05:09.900
Jasmine: generatedFunc요.

00:05:09.900 --> 00:05:12.900
Will Sentance: generatedFunc죠. 맞아요.

00:05:12.900 --> 00:05:15.220
generatedFunc로 가죠.

00:05:16.950 --> 00:05:22.033
이건 최초 이름이 add3로 되어있었지만,

00:05:22.033 --> 00:05:27.238
이제 우린 그 코드 전체를 잡아서

00:05:27.238 --> 00:05:30.521
그걸 제일 밑으로 보냈죠. 이름이 없어요.

00:05:30.521 --> 00:05:32.105
이름을 잃고 반환됩니다.

00:05:32.105 --> 00:05:34.440
Jasmine이 말했듯 우린
그냥 이 함수를 찾는데만 사용하는거죠.

00:05:34.440 --> 00:05:37.140
그리고 그건 generatedFunc로 저장됐구요.

00:05:37.140 --> 00:05:43.320
만약 이제 console.log(generatedFunc)를 하면,
입력인 input과 바디인

00:05:43.320 --> 00:05:47.800
{ const result = num + 3; return result }인
함수를 보겠죠.

00:05:47.800 --> 00:05:49.380
이건 이제 generatedFunc죠.

00:05:51.350 --> 00:05:55.624
이게 함수로부터 나온 다른 함수의 의미예요.

00:05:55.624 --> 00:06:01.750
그럼 이제, Call Stack에서 Pop되고, 여기 전체는 끝이죠.

00:06:01.750 --> 00:06:05.120
음, 이론적으로는요.
Execution Context는 사라지죠.

00:06:05.120 --> 00:06:07.516
이 실행된 코드는 전부 지워졌죠.

00:06:07.516 --> 00:06:14.160
그리고 [웅얼웅얼]
좋아요, 그리고

00:06:15.570 --> 00:06:21.230
우린 다시 Global로 돌아왔고, 어디를 보죠, 어떤 라인이죠?

00:06:21.230 --> 00:06:22.250
Sam, left-hand 영역이요.

00:06:23.850 --> 00:06:24.631
Sam: result요.

00:06:24.631 --> 00:06:25.375
Will Sentance: result죠.

00:06:25.375 --> 00:06:30.230
그리고 right-hand 영역은
어떤 함수의 실행을 말하죠, Sam?

00:06:30.230 --> 00:06:31.440
Sam: generatedFunc요.

00:06:31.440 --> 00:06:34.022
Will Sentance: generatedFunc를 실행하고,

00:06:34.022 --> 00:06:39.120
generatedFunc의 원래 이름은 뭐죠, Sam?

00:06:39.120 --> 00:06:41.354
Sam: functionCreator요.

00:06:41.354 --> 00:06:42.610
Will Sentance: 아, 그렇게 생각하기가 쉽죠. 그렇죠?

00:06:43.840 --> 00:06:46.380
generatedFunc가 뭐죠?

00:06:46.380 --> 00:06:46.970
Sam: add3요.

00:06:49.070 --> 00:06:52.757
Will Sentance: 여러분, 진짜로 10~15년 경력의

00:06:52.757 --> 00:06:58.135
대단한 엔지니어들도, 여전히 매번 헷갈려해요.

00:06:58.135 --> 00:07:01.773
만약 아직도 이게 뭔지 정확하게
머리 속에 와닿지 않으신다면,

00:07:01.773 --> 00:07:05.952
Closure를 이해하는 것에 어려움을 느끼실 거예요.

00:07:05.952 --> 00:07:10.990
전 정말 강조하고 싶어요, Sam은 제가 말했던

00:07:10.990 --> 00:07:14.350
그런 회사에 있는 락-

00:07:14.350 --> 00:07:18.940
슈퍼스타 개발자가 있는데,
그녀도 여러분들 같았어요.

00:07:20.350 --> 00:07:23.080
매번 이게 사람들에게 갔었죠.

00:07:23.080 --> 00:07:27.690
저 함수로 가서 실행을 한 번 하고,
그게 generatedFunc에 저장됐죠.

00:07:27.690 --> 00:07:30.360
그건 add의 기능이고,

00:07:30.360 --> 00:07:36.710
이건 generatedFunc의 저 라인에 있으며
이전엔 add3라고 되어있었죠.

00:07:36.710 --> 00:07:39.750
고마워요, Sam 솔직하게 해줘서 고마워요. 사실 모두들

00:07:39.750 --> 00:07:42.560
아마 똑같은 생각을 했을거니까요.

00:07:42.560 --> 00:07:43.700
Sam에게 감사를 표합니다.

00:07:43.700 --> 00:07:48.360
그럼 generatedFunc는, Jasmine,
이건 원래 뭘로 만들어졌죠?

00:07:49.480 --> 00:07:50.515
Jasmine: add3요.
Will Sentance: add3였죠.

00:07:50.515 --> 00:07:53.390
이 함수의 정의는 add3로 되어있었죠.

00:07:53.390 --> 00:07:56.510
이젠 이게 Global의 label인
generatedFunc가 됐습니다.

00:07:56.510 --> 00:07:59.440
그건 이 함수 내에서 counter를 저장했던 것처럼
초기에 저장 됐을 때

00:07:59.440 --> 00:08:00.780
생성된 함수 내부의 label였죠.

00:08:02.190 --> 00:08:05.920
하지만, 우린 이것의 코드를 가지고,
이걸 사용했던 건, 오직 add3로 반환할 때였죠.

00:08:05.920 --> 00:08:08.620
우린 이 함수의 코드를 찾기 위해
그 label을 사용했던 것뿐이죠.

00:08:08.620 --> 00:08:10.725
generatedFunc에 반환해서 저장하려구요.

00:08:10.725 --> 00:08:13.488
여러분들은 중 몇몇 분은, 아 알았다 할 수 있어요.

00:08:13.488 --> 00:08:16.232
확실히 말하는데요 여러분, 이건 정말 어려운거예요.

00:08:16.232 --> 00:08:21.109
generatedFunc로 나온 이건 실제로,
David, 이 코드는 이전에 뭐였죠?

00:08:21.109 --> 00:08:21.681
David: add3요.

00:08:21.681 --> 00:08:26.542
Will Sentance: add3죠, functionCreator의
내부의 add3로 저장됐던 이후에,

00:08:26.542 --> 00:08:31.620
전 add3를 더 이상 참조할 수 없단거죠.
이건 사라졌어요.

00:08:31.620 --> 00:08:33.930
제가 이걸 새로운 전역 Label로 저장하지 않았더라면요.

00:08:33.930 --> 00:08:37.100
David, 제가 add3에 저장했던 것이
어떤 새로운 전역 Label로 들어갔죠?

00:08:37.100 --> 00:08:37.990
David: generatedFunc요.

00:08:37.990 --> 00:08:39.180
Will Sentance: generatedFunc죠.

00:08:39.180 --> 00:08:42.840
그럼 제가 generatedFunc를 실행할 때,
그게 실제로는 뭐라구요? Eric?

00:08:42.840 --> 00:08:43.392
Eric: add3요.

00:08:43.392 --> 00:08:46.610
Will Sentance: add3죠, 그럼 만약 제가 add3를
밖에서 Global에서 참조하고 싶을 때

00:08:46.610 --> 00:08:48.227
그것의 새로운 이름은 뭐죠, Andrew?

00:08:48.227 --> 00:08:50.189
Andrew: generated-
Will Sentance: generatedFunc죠.

00:08:50.189 --> 00:08:53.501
generatedFunc는
실제로 functionCreator인가요, Andrew?

00:08:53.501 --> 00:08:54.268
Andrew: 아니요.
Will Sentance: 아니죠.

00:08:54.268 --> 00:08:58.348
Andrew, generatedFunc가
실제로 전체 functionCreator 코드에 대한

00:08:58.348 --> 00:09:00.580
새로운 label을 만들려면 뭘 해야하죠?

00:09:02.030 --> 00:09:06.413
generatedFunc는 실제로 functionCreator의
label일 뿐이니까 해당 라인에서

00:09:06.413 --> 00:09:07.900
변경해야할 부분이 뭐죠?

00:09:07.900 --> 00:09:09.200
Andrew: 괄호를 지웁니다.

00:09:09.200 --> 00:09:11.530
Will Sentance: 괄호를 지우면 되죠. Andrew가 맞았어요.

00:09:11.530 --> 00:09:16.087
좋아요, 이건 functionCreator를 한 번 실행한 것의 결과죠.

00:09:16.087 --> 00:09:17.071
좋아요.

00:09:17.071 --> 00:09:19.460
음, 여러분들이 이걸 이해했는지 모르겠어요. 장담하는데,

00:09:19.460 --> 00:09:21.500
이건 꽤 까다롭습니다.

00:09:21.500 --> 00:09:26.090
그럼, generatedFunc를 실행해보죠.
새로운 Execution Context죠.

00:09:27.790 --> 00:09:30.130
이거고, 이걸 Call Stack에 넣습니다.

00:09:30.130 --> 00:09:32.550
죄송해요. 여러분, 사과할께요.

00:09:32.550 --> 00:09:37.659
generatedFunc를 실행하면서
우리가 만드는 새로운-

00:09:37.659 --> 00:09:44.325
학생들: Execution Context
Will Sentance: generatedFunc는 이전에 add3였죠.

00:09:44.325 --> 00:09:50.399
네, add3죠. 여기에 입력을, 아 죄송합니다. 2죠.
다른 함수들을 너무 많이 처리했어요.

00:09:50.399 --> 00:09:55.840
입력이 2라는 걸 생각할 수가 없었어요. 죄송해요 여러분.

00:09:55.840 --> 00:10:00.135
이거죠, 입력 2예요. 해보죠.

00:10:00.135 --> 00:10:02.405
입력이 2인 generatedFunc입니다.

00:10:02.405 --> 00:10:06.280
이제, 제 생각에 이건 특히 좀 어려워요.

00:10:06.280 --> 00:10:10.126
이 부분들이 특히 좀 어려운 건

00:10:10.126 --> 00:10:14.140
개발자로서 우리가 generatedFunc에서
뭘 하는지 알아내는 거죠.

00:10:14.140 --> 00:10:19.400
우리 눈을 어디 둬야하죠, Alex?
generatedFunc가 하는 걸 알아내려면요?

00:10:19.400 --> 00:10:21.598
Alex: 뭐가 될 지 모르겠지만,
functionCreator의 리턴을 보면 됩니다.

00:10:21.598 --> 00:10:24.320
Will Sentance: 음, 아주 정교한 답변이었어요. 네.

00:10:24.320 --> 00:10:28.520
근데, 사실은 우린 제가 해야할 것처럼
add3로 가면됩니다.

00:10:28.520 --> 00:10:33.450
그래서 우린 JavaScript의 Thread가 functionCreator로

00:10:33.450 --> 00:10:36.810
되돌아간다는 잘못된 생각을 하게 되죠.

00:10:36.810 --> 00:10:40.480
확실히 아니죠. 그리고 Alex가 말함으로써 강조했죠.

00:10:40.480 --> 00:10:43.200
실제로 generatedFunc에 저장된 걸

00:10:43.200 --> 00:10:48.200
가서 보면, 그건 add3의 코드 전체인걸요.

00:10:48.200 --> 00:10:52.910
사실, 이 F는 저장되어있는 add3의 코드를 표현한거죠.

00:10:52.910 --> 00:10:56.260
이제 우리가 Global에 있으면,
이제 다시 functionCreator로 되돌아가지 않죠.

00:10:56.260 --> 00:10:57.620
이건 끝났어요. 사라졌습니다.

00:10:57.620 --> 00:11:02.319
그 대신, 우린 여기로 가서 코드를 보는거죠.

00:11:02.319 --> 00:11:07.308
그건, 음 대충 num이고 반환은 num + 3이죠.
요약하면요.

00:11:07.308 --> 00:11:09.800
여기가 바로 우리가 봐야할 곳이예요.
네 말해요. Virginia.

00:11:09.800 --> 00:11:13.690
Virginia: 간단한 질문인데, 그래서 add3를 반환할 때,

00:11:13.690 --> 00:11:16.580
선생님이 이걸 말 그대로, add3의

00:11:16.580 --> 00:11:17.470
복사라고-
Will Sentance: 네.

00:11:17.470 --> 00:11:19.640
Virginia: 그럼, 음 말할 때 음 이렇게 말했죠.

00:11:19.640 --> 00:11:22.080
generatedFunc(2)는 add3랑 같다고요.

00:11:22.080 --> 00:11:26.237
그럼 이런 2개의 다른 복사본은 메모리에-

00:11:26.237 --> 00:11:27.796
Will Sentance: generatedFunc(2)는-

00:11:27.796 --> 00:11:29.047
Virginia: 그럼 전 다시 가서 이렇게 말할 수 있나요

00:11:29.047 --> 00:11:31.860
generatedFunc(2)는 functionGenerator랑 같다고요?

00:11:31.860 --> 00:11:33.610
Will Sentance: functionCreator가 되는 건-

00:11:33.610 --> 00:11:34.590
Virginia: 그거랑 똑같은-

00:11:34.590 --> 00:11:35.526
Will Sentance: 아뇨, 아뇨,

00:11:35.526 --> 00:11:37.640
그건 결국 끝에 뭐죠?

00:11:37.640 --> 00:11:40.850
기술적인 커뮤니케이션을 하는 게 얼마나 중요한지 아나요?

00:11:40.850 --> 00:11:43.390
자, Virginia의 질문을 잠깐 봐보죠.

00:11:43.390 --> 00:11:44.560
우린 일단 한번 이걸 거쳤죠.

00:11:44.560 --> 00:11:47.050
하지만, 전 Virginia가 이 질문을 하기 전을
다시 떠올려보길 바랍니다.

00:11:47.050 --> 00:11:50.810
뭐라고 했냐면, 다시 돌아가서
generatedFunc(2)가 functionCreator랑

00:11:50.810 --> 00:11:52.138
같다면-
Virginia: 아,

00:11:52.138 --> 00:11:52.882
functionCreator의 호출이요.
Will Sentance: 그게 중요해요.

00:11:52.882 --> 00:11:56.260
잠시 후에 다시 질문을 볼건데, Virginia, 약속해요.

00:11:56.260 --> 00:12:00.900
그런데, 네, 잠시 후에 다시 질문을 볼께요 약속해요, Virginia.

00:12:00.900 --> 00:12:04.240
하지만 지금은, generatedFunc에 들어가보죠.

00:12:04.240 --> 00:12:08.220
우리가 이걸 실행하면요, 모두 다같이,
generatedFunc는 함수의 정의고

00:12:08.220 --> 00:12:13.075
그건 functionCreator안에 있을 때 뭐라고 되어있었죠?

00:12:13.075 --> 00:12:16.764
학생들: add3요.
Will Sentance: 네, 좋아요. 맞았어요.

00:12:16.764 --> 00:12:18.320
그리고 그 안에 들어가보죠.

00:12:19.430 --> 00:12:23.830
근데 누가 multiplyBy2 함수라고 했나요?

00:12:23.830 --> 00:12:26.410
음 어떤 분이 말한 건데 아주 좋은 복습이었어요.

00:12:26.410 --> 00:12:29.380
좋아요, 이 안으로 갑시다.

00:12:29.380 --> 00:12:32.660
우린 불행히도, 비록 이걸 할 필요는 없더라도,
우린 여길 볼 수 있죠.

00:12:32.660 --> 00:12:36.170
어떤 parameter가 이 2를 할당받나요, Michael?

00:12:36.170 --> 00:12:38.500
Michael: num이요.
Will Sentance: num이죠.

00:12:38.500 --> 00:12:41.230
만약 functionCreator를
다시 보고 싶으시면 손들어주세요.

00:12:41.230 --> 00:12:43.542
물론, 우리 모두 나왔던 함수 모두를 기억하지는 못하죠.

00:12:43.542 --> 00:12:46.926
하지만, 저 2개의 라인 사이 가운데서

00:12:46.926 --> 00:12:50.430
console.log(generatedFunc)를 보셨으면 해요.

00:12:50.430 --> 00:12:53.685
그리고 우린 항상 우리 자신 스스로가
console.log(generatedFunc)를

00:12:53.685 --> 00:12:57.640
사용해서 거기에서 실행하고 있는 코드가
무엇인지 알아내야 해요.

00:12:57.640 --> 00:13:00.580
그래서 우리는 코드가 저기에 없기 때문에

00:13:00.580 --> 00:13:02.460
처음 저장된 코드로 돌아간다고 생각하면 안되는거죠.

00:13:02.460 --> 00:13:05.625
다시 Thread가 뒤로 돌아가지 않아요. 알았죠?

00:13:05.625 --> 00:13:12.640
좋아요, num은 2죠.
그러면 result는 2 + 3이니까 5죠.

00:13:12.640 --> 00:13:19.270
그리고 우린 이 result의 값을 반환하죠. 그게 어디로 가냐면,
왜 제가 둘 다 result라고 했을까요?

00:13:19.270 --> 00:13:20.820
여러분, 전 이걸 바꿨다고 생각했어요.

00:13:20.820 --> 00:13:26.088
이 result의 값이 반환되면,
여러분 어떤 Global의 const로 가죠?

00:13:26.088 --> 00:13:26.836
학생들: result요.

00:13:26.836 --> 00:13:29.570
Will Sentance: 저 때문에 좋지 않은 풀이가 됐네요.
죄송합니다.

00:13:30.770 --> 00:13:36.230
알아두세요. 이건 다른 영역이고,
서로가 override 되는 것도 아닙니다.

00:13:36.230 --> 00:13:36.730
좋아요.

00:13:39.547 --> 00:13:43.580
Will Sentance: 뭘 물어보려고 했죠?

00:13:43.580 --> 00:13:44.740
아 제가 말하려고 했던건요.

00:13:44.740 --> 00:13:48.690
엄지를 들건데요, Virginia의 질문을 먼저 볼께요.

00:13:48.690 --> 00:13:54.110
엄지를 드는 건 잠시 뒤에하죠.
우린 functionCreator 코드를 저장했죠. 저기예요.

00:13:54.110 --> 00:13:58.350
그리고 우린 generatedFunc라는 label을 저장했죠.

00:13:58.350 --> 00:14:03.332
functionCreator의 첫 번째 실행에서
나오는 걸 위해서요.

00:14:03.332 --> 00:14:06.894
괄호가 말하는 건 functionCreater를 실행하라는 거고

00:14:06.894 --> 00:14:10.100
거기로 갔었을 때, 새로운 함수인 add3를 만들죠.

00:14:10.100 --> 00:14:14.130
그리고 그걸 사용하기 보다, 그 코드 자체를 반환했어요.

00:14:15.200 --> 00:14:17.970
그리고 새로운 label인 generatedFunc에
저장해 달았죠.

00:14:17.970 --> 00:14:24.660
그리고 그 때부터 영원히 generatedFunc는
functionCreator와 완전 무관해지죠.

00:14:24.660 --> 00:14:28.880
그건 오직 이제 여기에 저장된
add3함수만 보는거예요.

00:14:28.880 --> 00:14:33.380
그래서 우리가 그걸 싱행하는거고,
우리가 generatedFunc를 실행하고 그건 그냥 add3예요.

00:14:33.380 --> 00:14:34.820
우린 그냥 할 수 있어요. 좀 이상하더라도요.

00:14:34.820 --> 00:14:38.066
우린 그 끝에 괄호를 달죠. 문제 없어요.

00:14:38.066 --> 00:14:41.889
그리고 이건 add3를 입력값 2로 실행하는거고,

00:14:41.889 --> 00:14:45.713
그럼 이건 num이 2가 되고
result는 2 + 3이고 5가 됩니다.

00:14:45.713 --> 00:14:49.760
그리고 이 result의 반환값을
Global의 constant인 result에 넣죠.

00:14:49.760 --> 00:14:54.250
좋아요, 여러분. 여러분들은 지금 이게
도대체 뭘 한거야 라고 생각할 수 있어요.

00:14:54.250 --> 00:14:57.423
왜 우리가 Global로 선언할 수 있는 함수를
다른 함수 안에

00:14:57.423 --> 00:14:58.294
저장했을까요?

00:14:58.294 --> 00:15:02.818
우린 JavaScript에서 함수에게 가장 큰 힘을 주는 게
이 함수라는 걸 알게 될겁니다.