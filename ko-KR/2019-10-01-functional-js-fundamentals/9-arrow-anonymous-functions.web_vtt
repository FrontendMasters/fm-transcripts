WEBVTT

00:00:00.000 --> 00:00:03.785
[의역다수] 
Will Sentance: 이제 Arrow와 Anonymouse 함수로

00:00:03.785 --> 00:00:05.837
들어가보죠.

00:00:05.837 --> 00:00:07.979
이건 오늘 배웠던 다른 섹션들과 달라요.

00:00:07.979 --> 00:00:09.907
원하시면 랩탑을 거기 두세요.

00:00:09.907 --> 00:00:14.331
오늘 이야기 한 다른 파트들과 다르게,

00:00:14.331 --> 00:00:18.503
Functional Programming 세계의
깊은 영역입니다.

00:00:18.503 --> 00:00:19.781
이건 Closure쪽에 좀 더 가까워요.

00:00:19.781 --> 00:00:22.512
제가 여러분들에게 확실하게 해주고 싶은 몇 가지들이 있고,

00:00:22.512 --> 00:00:25.488
우리가 점점 정교한 Functional Programming에 접어들면서

00:00:25.488 --> 00:00:28.852
더는 혼란을 일으키지 않을거예요.

00:00:28.852 --> 00:00:32.610
그럼, 여기 Arrow Function이 있어요.
알아보시죠,

00:00:32.610 --> 00:00:36.216
지금 우린 다 이것에 익숙해져 있어요.

00:00:36.216 --> 00:00:38.186
괄호 안에 Parameter가 있죠.

00:00:38.186 --> 00:00:44.943
이 multiplyBy2라고 하면, 마지막에 여러분이
실행시킬 때 나온 placeholder죠.

00:00:44.943 --> 00:00:50.978
이건 argument인 2로 채워지고,
그리고 2*2를 반환하죠.

00:00:50.978 --> 00:00:56.404
이 함수는 하는 일이 하나 밖에 없죠.

00:00:56.404 --> 00:01:01.610
처리하고 반환하는 거죠. 2를 곱한 뒤에

00:01:01.610 --> 00:01:06.394
반환하는거예요. 하는 일이 하나뿐이죠.

00:01:06.394 --> 00:01:09.444
JavaScript는 이제 이걸 더 축약하도록 해줘요.

00:01:09.444 --> 00:01:12.677
함수의 바디에 return 키워드와

00:01:12.677 --> 00:01:16.414
반환할 출력값 외에 다른 코드가 없는 경우

00:01:16.414 --> 00:01:20.920
하나의 표현식이죠, 반환되어져 나갈

00:01:20.920 --> 00:01:22.896
출력값으로 처리될 것이죠.

00:01:22.896 --> 00:01:26.266
우린 사실 음, 먼저 우린 이걸
하나의 라인에 다 둘 수 있어요.

00:01:26.266 --> 00:01:28.630
첫번째 라인인 muitiplyBy2를 헷갈리지 마세요.

00:01:28.630 --> 00:01:29.939
다른 함수랑 똑같은거예요.

00:01:29.939 --> 00:01:31.681
그냥 하나의 라인에 다 쓴겁니다.

00:01:31.681 --> 00:01:33.744
음, 만약 이걸 하나의 라인으로 쓴다면,

00:01:33.744 --> 00:01:36.949
JavaScript는 무엇을 도와줄 지 알아요.

00:01:36.949 --> 00:01:40.743
함수의 바디에 쓰여질 중괄호가 필요 없죠.

00:01:40.743 --> 00:01:44.026
만약 하나의 라인으로 return 키워드를 넣을거라면,

00:01:44.026 --> 00:01:45.951
그 return 키워드도 필요가 없다는 것도 알죠.

00:01:45.951 --> 00:01:47.705
우린 그걸 알죠, 여러분들도 알거예요.

00:01:47.705 --> 00:01:53.059
그 말은, 여기 2번째 라인을 보면,
multiplyBy2의 input은

00:01:53.059 --> 00:01:58.124
또는 parameter인 input은
실제로 return input*2인거죠.

00:01:58.124 --> 00:02:00.109
하지만 확실히 위에 있는 코드와 똑같아요.

00:02:00.109 --> 00:02:01.567
변한 건 없어요.

00:02:01.567 --> 00:02:04.669
그냥 조금 더 축약해서 쓰는 방법인거예요.

00:02:04.669 --> 00:02:08.036
삽입된거죠. 어떤 단어가 삽입된거죠,
Sam, input*2 앞에요.

00:02:08.036 --> 00:02:09.779
JavaScript가 어떤 단어를 넣었을까요?

00:02:09.779 --> 00:02:11.046
자동적으로요.
Sam: return이요.

00:02:11.046 --> 00:02:12.566
Will Sentance: return이죠.

00:02:12.566 --> 00:02:17.130
좋아요. 우리가 위 코드를
좀 더 확실히 알기 위해 다이어그램을

00:02:17.130 --> 00:02:19.892
그릴거예요.
하지만 알아두세요. 우린 심지어 괄호도 지울 수 있다는 걸요.

00:02:19.892 --> 00:02:24.163
만약 들어올 parameter인 placeholder가 하나 뿐이라면요.

00:02:24.163 --> 00:02:29.701
그리고 굉장히 깔끔해보이는 문법을 갖게 된거죠.
문법이란건 function를 의미한거예요.

00:02:29.701 --> 00:02:34.164
하지만 약간 뭔가 다르더라도, 전 여러분들이 그걸
마술이라고 생각하지 않았으면 좋겠어요.

00:02:34.164 --> 00:02:36.722
잘 모르겠어요. 전 다르다고 생각해요.

00:02:36.722 --> 00:02:38.988
이걸 하나씩 해보면서 확실히 알아보죠.

00:02:38.988 --> 00:02:42.295
아무튼, 이것들 각각은 다른 파일의 코드예요.

00:02:42.295 --> 00:02:44.871
그러니 multiplyBy2를 Overriding
하는거라고 생각하지 마세요.

00:02:44.871 --> 00:02:47.047
한 번 이걸 진행해보죠.

00:02:47.047 --> 00:02:49.970
여기 가장 밑에 2라인이예요. Sam, 도와주세요.

00:02:49.970 --> 00:02:55.366
첫번째 라인이죠, 가능한 간단하게요.
첫번째 라인에서 뭘 하죠?

00:02:55.366 --> 00:02:56.790
Sam: multiplyBy2를 선언해요.

00:02:56.790 --> 00:02:57.693
Will Sentance: 뭘로요?

00:02:57.693 --> 00:02:59.581
Sam: const로요.

00:02:59.581 --> 00:03:00.733
Will Sentance: 함수로입니다.

00:03:00.733 --> 00:03:01.396
네.

00:03:01.396 --> 00:03:03.638
const는 label이죠 하지만 이건 함수라고 하죠.

00:03:03.638 --> 00:03:07.842
다시 되새겨보죠. 이건 함수예요.

00:03:07.842 --> 00:03:10.915
multiplyBy2 함수를 선언한거예요.

00:03:10.915 --> 00:03:16.435
좋아요. 여기에 미니 Memory를 그릴께요.

00:03:16.435 --> 00:03:21.829
multiplyBy2 함수를 선언하겠습니다.

00:03:21.829 --> 00:03:23.998
이거고, 왼쪽에서 보이듯이

00:03:23.998 --> 00:03:27.411
여기에 쓸 parameter는

00:03:27.411 --> 00:03:32.056
전 때때로 이렇게 그리는 걸 좋아하죠.
입력/출력이고, input*2이예요.

00:03:32.056 --> 00:03:35.387
아주 작게 썼다는 걸 알지만,
이걸 가까이서 보진 않을겁니다.

00:03:35.387 --> 00:03:38.051
이거구요. 좋아요, 저장했죠.

00:03:38.051 --> 00:03:42.177
다음 라인은요, Virginia.

00:03:42.177 --> 00:03:43.396
Virginia: output이란 label을 선언합니다.

00:03:43.396 --> 00:03:46.732
Will Sentance: 네, 그리고 여기로 가서 실행하죠.

00:03:46.732 --> 00:03:47.962
어떤거죠, Virginia?

00:03:47.962 --> 00:03:49.140
Virginia: multiplyBy2요.

00:03:49.140 --> 00:03:52.017
Will Sentance: 정확해요.
multiplyBy2는 어떤 argument로 하죠?

00:03:52.017 --> 00:03:52.803
Virginia: 3이요.

00:03:52.803 --> 00:03:55.680
Will Sentance: 3이라는 arguement와 함께죠.

00:03:55.680 --> 00:03:58.482
그리고 평소대로 새로운-?
Vriginia, 뭐죠?

00:03:58.482 --> 00:03:59.306
Virginia: Execution Context요.

00:03:59.306 --> 00:04:00.181
Will Sentance: Execution Context죠.

00:04:00.181 --> 00:04:01.352
이거예요.

00:04:01.352 --> 00:04:05.228
들어가죠.
Virginia paremeter가 뭐죠,

00:04:05.228 --> 00:04:10.841
argument로 채워질 placeholder는요?

00:04:10.841 --> 00:04:11.929
Virginia: input이요.
Will Sentance: input이죠.

00:04:11.929 --> 00:04:14.994
괄호가 없을수도 있고,
function이란 키워드가 없을수도 있지만,

00:04:14.994 --> 00:04:16.765
여전히 일반적인 함수입니다.

00:04:16.765 --> 00:04:20.848
input엔 뭐가 할당되죠, Jasmine?

00:04:20.848 --> 00:04:22.645
Jasmine: 3이요.
Will Sentance: 3이죠.

00:04:22.645 --> 00:04:25.576
그리고 함수의 바디는 뭔가요?

00:04:25.576 --> 00:04:28.606
Sam, 어떤 키워드가 자동적으로 삽입되죠?

00:04:28.606 --> 00:04:30.571
Sam: return이요.
Will Sentance: return input * 2죠.

00:04:30.571 --> 00:04:34.144
이건 실제로 3이구요.

00:04:34.144 --> 00:04:37.579
여러분들도 알거라고 확신해요.
이건 실제로 3이예요.

00:04:37.579 --> 00:04:39.649
input * 2는

00:04:39.649 --> 00:04:44.483
3 * 2고 이걸 반환해서

00:04:45.823 --> 00:04:48.990
output으로 넣죠.
약간 쉬는 느낌이죠?

00:04:48.990 --> 00:04:51.703
이건 그냥, 이걸 학습이라고 하진 않죠.

00:04:51.703 --> 00:04:55.760
전 아무도 arrow function과
암묵적인 return이 있는 아주 짧은 버전을

00:04:55.760 --> 00:04:58.869
보는 사람이 없다는 걸 확실히 하고 싶어요.

00:04:58.869 --> 00:05:01.635
암묵적이란 말은 우리가 직접 말하지 않고,
알아서 된다는 거죠.

00:05:01.635 --> 00:05:03.489
마술같은 일인가요?

00:05:03.489 --> 00:05:06.519
아니죠. 그냥 다른 것과 같은 함수예요.

00:05:06.519 --> 00:05:07.482
알았죠?

00:05:07.482 --> 00:05:08.568
정말 강조했어요.

00:05:08.568 --> 00:05:10.322
여러분은 이미 모두 알고 있었을거예요.

00:05:10.322 --> 00:05:12.234
하지만 전 이게 혼란을 많이 일으킨다고 생각해요.

00:05:12.234 --> 00:05:14.490
음, 이제 이걸 써보죠.

00:05:14.490 --> 00:05:18.757
좋아요, Arrow Function,
Functional Programming 패러다임에 딱 맞죠.

00:05:18.757 --> 00:05:23.533
Functional Programming에서 각 라인은
독립적이고, 자기 자신만 건드리고, 다른 결과가 없이

00:05:23.533 --> 00:05:25.990
그 결과를 돌려놓죠.

00:05:25.990 --> 00:05:29.561
그리고 우리가 그것이 어떤 데이터를 사용하는지
정확히 알도록 label이 만들어져있죠.

00:05:29.561 --> 00:05:33.286
음, 만약 한 라인으로 이걸 얻는다면, 이건 입력과

00:05:33.286 --> 00:05:35.516
출력이 있고, 하나의 결과만 내겠죠.

00:05:35.516 --> 00:05:39.799
우리는 어떤 식으로든 입력을 받는 것 외에는

00:05:39.799 --> 00:05:43.894
그 단일 라인에서 많은 일을 하지 않을 것입니다.
그리고 바로 같은 라인으로 되돌리거나,

00:05:43.894 --> 00:05:48.052
Arrow Function의 스타일을 강조하는 것은 옳지 않습니다.

00:05:48.052 --> 00:05:48.702
보면 입력 출력이 같은 라인이죠.

00:05:48.702 --> 00:05:52.695
Arrow Function은 기존 함수를 압축하는 걸 강조하죠.

00:05:52.695 --> 00:05:53.229
좋아요.

00:05:53.229 --> 00:05:57.664
좋아요,
이제, copyArrayAndManipulate를 복습해보죠.

00:05:57.664 --> 00:05:59.084
여기 그 개념이 있죠.

00:05:59.084 --> 00:06:01.764
여기 copyArrayManipulate가 있고,
여기 multiplyBy2가 있어요.

00:06:01.764 --> 00:06:05.993
이걸 [1, 2, 3]이랑 multiplyBy2로 호출했죠.

00:06:05.993 --> 00:06:11.185
이게 축약형이예요.
multiplyBy2죠 같은 함수예요.

00:06:11.185 --> 00:06:13.229
바뀐 게 하나도 없죠.

00:06:13.229 --> 00:06:16.456
parameter는 input이죠.

00:06:16.456 --> 00:06:19.924
input * 2를 반환하죠.

00:06:19.924 --> 00:06:25.318
그걸 instructions로 받죠.
이건 parameter로 input을 사용하고, input * 2를 반환하죠.

00:06:25.318 --> 00:06:29.954
이 말은 instructions를 실행할 때 실제로는 2인

00:06:29.954 --> 00:06:33.999
parameter로써 input이 있고, 
이걸로 instructions를 실행한단거예요.

00:06:33.999 --> 00:06:39.339
그리고 결국 input으로 실행된 instruction가
multiplyBy2인거죠.

00:06:39.339 --> 00:06:43.582
array의 1번째 위치는, 여기서 봤던 것처럼

00:06:43.582 --> 00:06:48.992
2이고, instructions의 input도 2죠.
그럼 2를 가지고,

00:06:48.992 --> 00:06:54.509
이걸 input으로 받아 2*2인 4를 반환해서

00:06:54.509 --> 00:06:59.202
결국 실제로는 multiplyBy2에 이 숫자를 넣은거죠.

00:06:59.202 --> 00:07:00.610
아닌 것 같으면 멈춰주세요.

00:07:00.610 --> 00:07:01.887
맞죠?

00:07:01.887 --> 00:07:03.093
대단한 변화는 아니죠.

00:07:05.966 --> 00:07:09.703
Will Sentance: 우린 심지어
Higher Order Function에

00:07:09.703 --> 00:07:12.494
Callback Function을 삽입하는 함수를 넣을 수도 있어요.

00:07:12.494 --> 00:07:14.527
multiplyBy2를 직접적으로요.

00:07:14.527 --> 00:07:18.052
그걸 익명이라고 하죠. label이 없어요.

00:07:18.052 --> 00:07:20.989
자 보세요, multiplyBy2예요.

00:07:20.989 --> 00:07:26.991
parameter로 input이 있고,
바디는 return input * 2로 저장되어있죠.

00:07:26.991 --> 00:07:30.936
그리고 이름으로 연결되어 있어요.

00:07:30.936 --> 00:07:35.001
사람들은 이런 멋진 영어이름이나,

00:07:35.001 --> 00:07:38.779
사람이 읽기 쉬운 이름으로 저장하는 걸
싫어하는 편입니다.

00:07:38.779 --> 00:07:42.532
간접적으로 쓰는 걸 좋아해요.

00:07:42.532 --> 00:07:46.125
여기에 그 문제가 있는데,
만약 여러분들이 그게 무엇을 하고 있는지

00:07:46.125 --> 00:07:48.448
이해한다면 문제될 것이 없지만, 그렇지 않다면 문제가 있어요.

00:07:48.448 --> 00:07:52.713
전 말 그대로 사람들이 argument가 5가지로 줄었다는 것을

00:07:52.713 --> 00:07:57.342
 시점까지 사람들이 항상 어떻게 생각하는지 알고 있어요.

00:07:57.342 --> 00:08:01.625
그들은 이 비트들 각각이 매개변수에 있다고 생각하기 때문이죠.

00:08:01.625 --> 00:08:03.490
copyArrayManipulate에요.

00:08:03.490 --> 00:08:08.413
숫자 2가 들어간 input이라는 것과는 반대로

00:08:08.413 --> 00:08:13.258
저건 함수의 코드고, 그건

00:08:13.258 --> 00:08:17.961
저 multiplyBy2 함수의 코드고,

00:08:17.961 --> 00:08:22.236
그게 여기 들어간거죠.

00:08:22.236 --> 00:08:28.099
어떤 색으로 할까요.
자 이제 여길 이름 없이 하는거예요.

00:08:28.099 --> 00:08:30.633
이걸 직접 그냥 삽입하는거죠.

00:08:30.633 --> 00:08:33.259
그런데, 어떤 label이 주어지죠 Anna?

00:08:33.259 --> 00:08:38.855
copyArrayManiplulate 내에서,
multiplyBy2라고 알았던 코드를 사용하기 위해서요.

00:08:38.855 --> 00:08:43.963
copyArrayManipulate 내에서 바로 사용되었던 label이요.

00:08:43.963 --> 00:08:44.536
Anna: instructions요.

00:08:44.536 --> 00:08:45.527
Will Sentance: instructions죠.

00:08:45.527 --> 00:08:48.411
그 말은 우리가 multiplyBy2라는 label을 신경쓴건가요?

00:08:48.411 --> 00:08:50.647
확실히 아니죠.

00:08:50.647 --> 00:08:51.772
그게 다 여기에서 하는거예요.

00:08:51.772 --> 00:08:56.712
그 말은 결국 끝에 multiplyBy2라는 label은
이 함수를 찾고 넣기 위해서만

00:08:56.712 --> 00:08:57.779
필요한거였죠.

00:08:57.779 --> 00:09:02.846
만약 이걸 직접 넣는다면,
우린 이걸 이름으로

00:09:02.846 --> 00:09:07.717
찾을 필요가 없이 그냥 넣어주면 되죠.

00:09:07.717 --> 00:09:10.664
어쨌거나 우린 이걸 instrucitons라는
label로 사용하니까요.

00:09:10.664 --> 00:09:15.641
가독성을 뺀다면 바뀐 건 없죠.
저한텐 그렇게 보이지만 사실은 아니예요.

00:09:15.641 --> 00:09:18.668
제 말은 이 방법을 사람들이 많이 씁니다.

00:09:18.668 --> 00:09:21.810
우린 이걸 오늘 여기서 많이 사용하진 않을거예요

00:09:21.810 --> 00:09:25.978
왜냐하면 저는 이게 실제로 일어나고 있는 일들을
더 어렵게 만든다고 생각하거든요.

00:09:25.978 --> 00:09:30.981
제 생각은 이 방식은 사람들이 이 라인이
바로 저기서 실행된다고 생각하게 만드는 것 같아요

00:09:30.981 --> 00:09:34.029
근데 완전히 아니죠. 나중에 이 안에서 실행될 label에

00:09:34.029 --> 00:09:38.504
저장한다기 보다는 그냥 그걸 가지고 있는 거죠.

00:09:38.504 --> 00:09:39.575
그게 맞는거라고 이해해요.

00:09:39.575 --> 00:09:43.477
그 대신, 여러분들은 이걸 들고, 바로 삽입하는거죠.

00:09:43.477 --> 00:09:47.789
하지만 여전히 copyArrayManipulate 내에서
instructions에 괄호가

00:09:47.789 --> 00:09:50.338
붙인 걸 보게 될 때까지는 실행하지 않아요.

00:09:50.338 --> 00:09:53.645
그리고 나서 그 코드를 보고 실행하는거죠.

00:09:53.645 --> 00:09:57.503
하지만 이건 많은 혼란을 야기합니다.
왜 이것이 제가 말하는 것처럼,

00:09:57.503 --> 00:10:00.506
다른 사람들의 코드를 보지 않고 실행할 수 있는 테크닉인지요.

00:10:00.506 --> 00:10:04.697
제가 전에 보지 못했던 것을 확실히 하기 위해서요.
이것이 약간 틈인 것 같아요.

00:10:04.697 --> 00:10:08.574
좋아요, 여러분, 막간의 내용이었어요. 
제가 보여드린 것에 대해 엄지를 들어주세요.

00:10:08.574 --> 00:10:11.824
이 직접적인 방식은 코드에 label이 필요하지 않기 때문에,

00:10:11.824 --> 00:10:15.042
어쨌든 multiplyBy2라는 label을 내부에서 사용하지 않기 때문이죠.

00:10:15.042 --> 00:10:19.760
우린 이 코드를 쓰는거고, 우리가 이 함수를 찾기 위해서만

00:10:19.760 --> 00:10:23.108
multiplyBy2를 사용할 수 있죠
우리가 여기에 저장했던 걸 꺼내서 넣어주려구요.

00:10:23.108 --> 00:10:26.947
만약 우리가 이걸 직접 넣는다면,
multiplyBy2라는 label은 필요가 없죠.

00:10:26.947 --> 00:10:31.328
엄지를 들어주세요 여러분, 놓쳤다, 완벽하게 이해했다, 질문이 있다.

00:10:31.328 --> 00:10:32.158
괜찮아요.

00:10:32.158 --> 00:10:33.209
좋아요.

00:10:33.209 --> 00:10:34.073
좋습니다. 여러분.