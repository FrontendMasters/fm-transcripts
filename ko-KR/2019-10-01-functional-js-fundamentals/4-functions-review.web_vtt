WEBVTT

00:00:00.000 --> 00:00:06.239
Will Sentance: 이제,
Higher Order Function의 매력을 알아보죠.

00:00:06.239 --> 00:00:09.276
바로 다음 슬라이드에서,
어떤 작업을 볼텐데요.

00:00:09.276 --> 00:00:14.033
함수죠. 아주 아주 비슷해보일거예요.

00:00:14.033 --> 00:00:18.800
반드시 좋아질거예요.
그리고 세 번째 슬라이드에서

00:00:18.800 --> 00:00:22.409
약간의 변화만으로 동일한 함수를 보게 될 겁니다.

00:00:22.409 --> 00:00:25.282
우리 스스로에게 물어야 해요.
더 좋은 방법이 있을거라구요.

00:00:25.282 --> 00:00:30.594
하지만 말 그대로 앞으로 몇 분은 좀 지루할 수도 있어요.

00:00:30.594 --> 00:00:35.410
하지만 여러분들이 지루한 걸 봐야,
실수를 되풀이 하지 않을겁니다.

00:00:35.410 --> 00:00:40.395
여러분들이 이런 비슷한 상황을
다시 다루지 않아야해요.

00:00:40.395 --> 00:00:45.605
다시 이런 일을 마주하지 않아야해요.

00:00:45.605 --> 00:00:48.230
한 번만 수행하는 반복 가능한 작업을

00:00:48.230 --> 00:00:53.092
처리함에 있어서,
더 이상 오래 끌 필요가 없어요.

00:00:53.092 --> 00:00:55.697
이런 식으로 처리하는 일이 없도록 해야합니다.

00:00:55.697 --> 00:00:57.642
미래에 이러지 않도록 노력해야해요.

00:00:57.642 --> 00:01:02.131
여러분들이 본능적으로 더 좋게 유지하도록 해야할거예요.

00:01:02.131 --> 00:01:03.087
[웃음] 좋아요.

00:01:03.087 --> 00:01:08.043
[웃음] 네, 좋아요.

00:01:08.043 --> 00:01:09.550
Michael: 이걸 메타라고 하죠.

00:01:09.550 --> 00:01:12.033
Will Sentance: Seth, 첫 번째 라인이예요, 뭘 하죠?

00:01:12.033 --> 00:01:15.430
결국엔 좋아 보일거예요. 그렇죠?

00:01:15.430 --> 00:01:18.321
Will Sentance: 꽤 큰 문제죠.

00:01:18.321 --> 00:01:19.398
Michael: Global Context요.

00:01:19.398 --> 00:01:23.531
Will Sentance: 네, Global Context죠,
메모리에 뭘 저장하죠, Seth?

00:01:23.531 --> 00:01:27.537
Michael: 너무 긴 이름이예요,
copyArrayAndMultiplyBy2요.

00:01:27.537 --> 00:01:31.399
Will Sentance: copyArray-, 의미적으로 명확하죠.

00:01:31.399 --> 00:01:36.404
copyArrayAndMultiplyBy2를 저장하죠 이렇게요.

00:01:36.404 --> 00:01:41.038
다음 라인은, Charles가 합시다,
copyArrayAndMultiplyBy2를 했다면,

00:01:41.038 --> 00:01:44.713
다음 라인은 뭐죠, Charles,
실제로 뭘 하죠?

00:01:44.713 --> 00:01:46.997
Charles: myArray가 될거예요.

00:01:46.997 --> 00:01:47.703
Will Sentance: 네.

00:01:47.703 --> 00:01:53.189
Charles: 그리고 거기에 1, 2, 3이 할당될겁니다.

00:01:53.189 --> 00:01:54.662
Will Sentance: 배열 1, 2, 3이죠. 좋아요.

00:01:54.662 --> 00:02:00.326
다음 라인이예요, 누가 아직 안했죠?
Mike, [웃음] Michael

00:02:00.326 --> 00:02:04.830
Michael, 다음으로 하는 일의 left-hand 영역은요?

00:02:04.830 --> 00:02:07.387
Michael: result에 할당해요.

00:02:07.387 --> 00:02:10.530
result에 함수의 호출을-
Will Sentance: 네.

00:02:10.530 --> 00:02:11.119
Michael: 할당해요.

00:02:11.119 --> 00:02:14.502
Will Sentance: 실행한
copyArrayAndMultiplyBy2의 반환값이죠.

00:02:14.502 --> 00:02:16.855
여러분, 기술적인
의사소통의 레벨에 있어서,

00:02:16.855 --> 00:02:19.918
이렇게 처음에 다루기가 좀 큰 걸 만나게 되면,

00:02:19.918 --> 00:02:23.164
품질에 집중하고,
좀 더 상세하게 하려고 하세요.

00:02:23.164 --> 00:02:26.781
그게 여러분의 코드를 다른 사람이 실제로 구현할 수 있도록

00:02:26.781 --> 00:02:29.083
더 상세한 수준으로 하는 능력입니다.

00:02:29.083 --> 00:02:30.694
그냥 여러분이 말하는 걸 들음으로써 구현하도록요.

00:02:30.694 --> 00:02:32.866
그게 시니어 개발자의 핵심 역량 중 하나예요.

00:02:32.866 --> 00:02:35.178
그리고 코드 베이스의 이해를 바탕으로,

00:02:35.178 --> 00:02:39.287
아직 그 코드를 보지 못한 사람들이 이해하도록 만드는거죠.
이게 진짜 스킬이예요.

00:02:39.287 --> 00:02:41.512
훌륭해요, 그래서 result가 선언되었죠.

00:02:41.512 --> 00:02:45.503
이제 우리가 copyArrayAndMultiplyBy2를

00:02:45.503 --> 00:02:51.032
[1, 2, 3]으로 실행하는동안

00:02:51.032 --> 00:02:57.032
잠깐 대기하겠죠. 이렇게요.

00:02:57.032 --> 00:02:59.794
만들건데, 여러분 모두가 아직은 이걸 말하는데

00:02:59.794 --> 00:03:03.012
질리지 않기 때문에
제 대신 말해줄 수 있을 것 같네요.

00:03:03.012 --> 00:03:04.879
새로운-?

00:03:04.879 --> 00:03:06.752
Michael: Execution Context.

00:03:06.752 --> 00:03:07.624
Will Sentance: 너무 좋아요,

00:03:07.624 --> 00:03:11.823
온라인 수강생 분들도 활발하게
채팅해줬으면 좋겠어요.

00:03:11.823 --> 00:03:16.588
이렇게있죠, Thread of Execution이 들어가고,
Local Memory가 있죠.

00:03:16.588 --> 00:03:20.436
전 계속 써야해서 이 필기를 좀 깔끔하게 유지해볼게요.

00:03:20.436 --> 00:03:24.526
Local Memory에선, 뭐가 있죠?

00:03:24.526 --> 00:03:27.234
David, 처음은요?

00:03:27.234 --> 00:03:30.311
David: const output이요.

00:03:30.311 --> 00:03:32.362
Will Sentance: 그건 두 번째로 하는거예요.

00:03:32.362 --> 00:03:35.941
David: 죄송해요, Parameter가 들어와요 음-

00:03:35.941 --> 00:03:36.821
Will Sentance: 전 심지어 이렇게까지 말하죠.

00:03:36.821 --> 00:03:38.415
Parameter가 들어오는게 아니예요.

00:03:38.415 --> 00:03:41.568
Parameter는 저기에서 기다리고,
Argument가 들어오는거죠.

00:03:41.568 --> 00:03:46.540
Parameter는 placeholder예요.
array라는 label은 뭘로 채워지죠?

00:03:46.540 --> 00:03:47.077
David?

00:03:47.077 --> 00:03:48.244
David: myArray인 [1, 2, 3]이요.

00:03:48.244 --> 00:03:50.944
Will Sentance: 정확해요, 그게 뭐죠?

00:03:50.944 --> 00:03:51.756
David: 값이요.

00:03:51.756 --> 00:03:54.914
Will Sentance: 네, 이런 상황에서 종종 노드를 뭘로 쓰죠?

00:03:56.981 --> 00:03:57.758
Will Sentance: Jasmine?

00:03:57.758 --> 00:03:59.727
Jasmine: Argument요.
Will Sentance: Argument죠. 훌륭해요.

00:03:59.727 --> 00:04:03.790
Parameter고, Argument고
Parameter고, Argument예요.

00:04:03.790 --> 00:04:05.231
David, 이게 뭐죠?

00:04:05.231 --> 00:04:06.120
David: 배열이요.

00:04:06.120 --> 00:04:09.508
Jasmine: [웃음]
Will Sentance: David!

00:04:09.508 --> 00:04:10.958
농담한거죠?

00:04:10.958 --> 00:04:11.807
David: 네, 웃자고 해봤어요.

00:04:11.807 --> 00:04:16.103
Will Sentance: [웃음] 빵터졌어요, 좋아요.

00:04:16.103 --> 00:04:18.274
잊어야죠, 좋아요. 괜찮나요?

00:04:18.274 --> 00:04:21.231
output은 선언된 빈 배열이죠.
우리가 필요한 거예요 그렇죠?

00:04:21.231 --> 00:04:23.654
우린 input 배열에서 하나씩 꺼내고,
새로운 output 배열을 만들고,

00:04:23.654 --> 00:04:24.935
input을 순회하면서

00:04:24.935 --> 00:04:27.665
각 요소를 2배로 만들고,
output에 넣으니까요. 이해가죠?

00:04:27.665 --> 00:04:29.720
어려운 건 아니지만 계속 가보죠.

00:04:29.720 --> 00:04:34.368
이제, for-loop를 만났죠,
전 for-loop을 이런 식의 다이어그램으로 그릴겁니다.

00:04:34.368 --> 00:04:39.266
[1, 2, 3]을 가지고,
Thread가 실행되는

00:04:39.266 --> 00:04:42.466
이 왼쪽 영역을 작업 공간처럼 쓸거예요.

00:04:42.466 --> 00:04:46.166
이걸 복사하는게 아니죠, 여기에서 처리하는거예요.

00:04:46.166 --> 00:04:48.069
for-loop 동작 방식은,

00:04:48.069 --> 00:04:51.394
전 개념적으로 loop 순회를 말하는 걸 좋아하지 않아요.

00:04:51.394 --> 00:04:54.964
이것의 바디에 처음 도달했을 때,
i의 값은 실제로 뭐죠, Sam?

00:04:54.964 --> 00:04:56.112
Sam: 0이요
Will Sentance: 0이죠.

00:04:56.112 --> 00:04:59.103
array의 0번째 위치는 뭐죠?

00:04:59.103 --> 00:05:01.235
array의 0번째 위치는요?

00:05:01.235 --> 00:05:02.417
array의 0번째 인덱스는요?

00:05:02.417 --> 00:05:03.099
Sam: 그게 인덱스예요.

00:05:03.099 --> 00:05:04.103
Will Sentance: 네

00:05:04.103 --> 00:05:06.054
[웃음] array의 0은요?

00:05:06.054 --> 00:05:06.629
Sam: 1이요.
학생: 0이요.

00:05:06.629 --> 00:05:07.754
Will Sentance: 1이죠.

00:05:07.754 --> 00:05:08.693
1이죠?

00:05:08.693 --> 00:05:11.151
네, David, array[0]은 1이예요.

00:05:11.151 --> 00:05:15.232
array는 1, 2, 3이죠.
array의 0번째 위치는 1이예요.

00:05:15.232 --> 00:05:19.424
여러분이 1을 가지고, 뭘 하죠, Mike?

00:05:19.424 --> 00:05:20.200
Mike: 그걸 2로 곱해요.

00:05:20.200 --> 00:05:24.383
Will Sentance: 2로 곱하죠,
그래서 2가 되고, 그걸로 뭘하죠?

00:05:24.383 --> 00:05:25.150
Jasmine?

00:05:25.150 --> 00:05:27.175
Jasmine: 그걸 Push해요.
Will Sentance: 뭐에다가

00:05:27.175 --> 00:05:28.285
Push 하죠?

00:05:28.285 --> 00:05:29.017
Jasmine: output에요.

00:05:29.017 --> 00:05:30.047
Will Sentance: output 배열이죠.

00:05:30.047 --> 00:05:36.624
이제 for-loop 순회고,
이번에는 Andrew입니다. i가 뭐죠?

00:05:36.624 --> 00:05:37.757
Andrew: 1이요.
Will Sentance: 1이죠.

00:05:37.757 --> 00:05:41.805
array의 1번째 위치는요? Andrew?

00:05:41.805 --> 00:05:42.423
Andrew: 2요.

00:05:42.423 --> 00:05:46.399
Will Sentance: 2죠, 그건 그렇고,
걱정하지 않아도 됩니다.

00:05:46.399 --> 00:05:49.807
여기에서 말을 했지만 iterator에 대해 i의 값과

00:05:49.807 --> 00:05:54.433
배열에서 찾고 싶은 값을 구분해서 말하는 경험을 하길 원했어요.

00:05:54.433 --> 00:05:55.965
그리고 지속적으로

00:05:55.965 --> 00:06:01.371
제가 i의 값이 뭔지 물었을 때 열 번 중 여덟 번을 말할 것입니다.

00:06:01.371 --> 00:06:06.778
실제로 사람들의 머리속에 있는 그 요소의 위치에 대해

00:06:06.778 --> 00:06:11.307
그다지 요소에 신경 쓰지 않기 때문에 1이라고 해요.

00:06:11.307 --> 00:06:14.693
어떤 제안에 서명을 해도 걱정 마세요.

00:06:14.693 --> 00:06:19.066
2x2는 4죠, 우린 그걸 output에 push해요.
이제 2, 4, 6예요.

00:06:19.066 --> 00:06:21.881
그래서 output은 [2, 4, 6] 입니다.

00:06:21.881 --> 00:06:25.033
이제 for-loop을 끝냈어요.
좀 빨리 넘어갔어요.

00:06:25.033 --> 00:06:29.450
Virginia, [1, 2, 3]을 입력으로 호출된
copyArrayAndMultiplyBy2의

00:06:29.450 --> 00:06:33.432
마지막 라인은요,
우리가 기가막힌 output 배열을 얻었지만,

00:06:33.432 --> 00:06:37.322
이 Execution Context안에 갇혀있어요.
이걸 어떻게 빼내죠, Virginia?

00:06:37.322 --> 00:06:37.962
Virginia: return으로요.

00:06:37.962 --> 00:06:39.707
Will Sentance: 뭘 반환하죠?

00:06:39.707 --> 00:06:41.571
Virginia: 배열이요.

00:06:41.571 --> 00:06:46.027
Will Sentance: 확실하게,
output의 값인 배열을 반환한거죠.

00:06:46.027 --> 00:06:49.123
그 밖으로요, Virginia,
어떤 Global Label로 하죠?

00:06:49.123 --> 00:06:49.822
Virginia: result요.

00:06:49.822 --> 00:06:56.283
Will Sentance: result로 해요.
[2, 4, 6]이예요

00:06:56.283 --> 00:07:00.649
좋아요, 전 배열 [1, 2, 3]을 넣고,
각각의 요소가 2배가 된,

00:07:00.649 --> 00:07:05.109
[2, 4, 6]의 배열을 새로 얻었고,
이건 딱히 드문 작업이 아니예요.

00:07:05.109 --> 00:07:07.358
이 함수가 괜찮나요?

00:07:07.358 --> 00:07:08.942
이 함수가 기가 막힌가요?

00:07:08.942 --> 00:07:13.971
여러분들은 다음에 나올
독특한 함수에 더 무릎을 칠 거예요.

00:07:15.301 --> 00:07:19.627
다릅니다.

00:07:19.627 --> 00:07:20.733
우리가 뭘 하죠?

00:07:20.733 --> 00:07:22.712
여기 아래에서 바로 시작할거예요, 괜찮죠?

00:07:22.712 --> 00:07:27.073
Alex, 완전히 다른 이 함수의
첫 번째 라인에서 하는게 뭐죠?

00:07:27.073 --> 00:07:28.803
다르죠.

00:07:31.271 --> 00:07:34.424
Alex: copyArrayAndDivideBy2의
label을 저장해요.

00:07:34.424 --> 00:07:38.021
Will Sentance: 네, 정확해요.
이건 완전히 새로운 App이예요.

00:07:38.021 --> 00:07:43.377
여기 이 부분은 완전 새로운 App이예요,
그러니 Memory가 섞인다고

00:07:43.377 --> 00:07:47.809
생각하지 마세요.
copyArrayAndDivide2예요.

00:07:47.809 --> 00:07:52.061
이 전체가 새로운 함수고,
우리는 이 코드 전체를 다시

00:07:52.061 --> 00:07:54.845
쓰고 저장하는 겁니다.

00:07:54.845 --> 00:07:57.306
다음 라인은요, Alex?

00:07:57.306 --> 00:07:59.077
Alex: myArray라는 label을
만들어 저장해요.

00:07:59.077 --> 00:08:00.272
Will Sentance: 네.

00:08:00.272 --> 00:08:01.651
Alex: 값은 [1, 2, 3]이예요.

00:08:01.651 --> 00:08:06.661
Will Sentance: 네, 좋아요, 정확합니다
[1, 2, 3], 다음 라인은요, Sam?

00:08:06.661 --> 00:08:08.629
Sam: 음, 선언해요 copy를 아

00:08:08.629 --> 00:08:13.952
copyArrayAndDivideBy2를 호출합니다.
Will Sentance: 맞아요, 근데, left-hand 영역이

00:08:13.952 --> 00:08:19.278
먼저예요. 네, result를 선언하죠.
그럼 지금 당장 뭐죠?

00:08:19.278 --> 00:08:21.931
Will Sentance: 초기화되지 않았죠. 네.

00:08:21.931 --> 00:08:25.769
우린 아직 여기에 뭐가 저장될지 몰라요, 알았죠?

00:08:25.769 --> 00:08:29.510
우린 여기에 무엇이 저장될 지
평가하기 위해 뭘 해야할 지 알죠.

00:08:29.510 --> 00:08:31.583
우린 들어가서 실행하죠, Sam?

00:08:31.583 --> 00:08:34.987
Sam: 호출해요.
Will Sentance: 계속요.

00:08:34.987 --> 00:08:36.272
Sam: copyArrayAndDivideBy2를요.

00:08:36.272 --> 00:08:40.949
Will Sentance: DivideBy2죠,
argument는 뭘로 하죠?

00:08:40.949 --> 00:08:41.733
Sam: myArray요.

00:08:41.733 --> 00:08:43.642
Will Sentance: 그것의 값은요?

00:08:43.642 --> 00:08:44.596
Sam: 1, 2, 3이요.

00:08:44.596 --> 00:08:46.394
Will Sentance: 1, 2, 3이죠, 훌륭해요.

00:08:46.394 --> 00:08:54.230
이거고, 이것의 출력이 result에 저장될 겁니다.

00:08:54.230 --> 00:08:57.901
그럼 뭘 새롭게 만들죠?

00:08:57.901 --> 00:08:58.484
Sam: Execution Context요.

00:08:58.484 --> 00:09:01.781
Will Sentance: Execution Context죠,
[웃음] 음, 이미

00:09:01.781 --> 00:09:05.173
Mike의 목소리가 먼저 나왔네요.

00:09:05.173 --> 00:09:10.626
[웃음] 여깄죠.
이제 들어가죠.

00:09:10.626 --> 00:09:13.821
Local Memory안에서

00:09:13.821 --> 00:09:18.797
가장 먼저 가지는게 뭐죠?

00:09:18.797 --> 00:09:22.307
여기서 기술적인 의사소통을
가능하면 자세히 해보려고 하세요.

00:09:22.307 --> 00:09:25.330
가능한대로 자세히 하려고 시도해보세요,
David, 일어나요.

00:09:25.330 --> 00:09:28.253
Local Memory에서 가지는게 뭐죠, David?

00:09:28.253 --> 00:09:32.705
David: 배열을 가지는데 parameter입니다.

00:09:34.522 --> 00:09:35.964
Will Sentance: 아뇨, 다시 해주세요.

00:09:35.964 --> 00:09:38.026
David: Argument요.

00:09:38.026 --> 00:09:39.712
Will Sentance: Argument죠, 맞았어요, David.

00:09:39.712 --> 00:09:41.869
고마워요, David, 잘 왔어요.

00:09:41.869 --> 00:09:45.387
이것도 마찬가지로 진행되죠, Parameter요, David?

00:09:45.387 --> 00:09:45.924
David: array요.

00:09:45.924 --> 00:09:48.674
Will Sentance: array죠. 이게
placeholder의 이름이예요.

00:09:48.674 --> 00:09:50.106
실제 값으로 채워질거죠.

00:09:50.106 --> 00:09:50.988
David가 아주 잘해줬어요.

00:09:50.988 --> 00:09:51.877
고마워요, David.

00:09:51.877 --> 00:09:53.532
이렇게죠, array.

00:09:53.532 --> 00:09:55.654
다음 라인은요, Jasmine?

00:09:55.654 --> 00:09:56.975
Jasmine: output을 선언해요.

00:09:56.975 --> 00:10:00.238
Will Sentance: 네, 정확히, 함수의 바디에 추가되죠.

00:10:00.238 --> 00:10:02.102
output은 빈 배열이죠.

00:10:02.102 --> 00:10:07.020
이제 이 output 배열을 사용하죠,
input으로부터 각 요소로 채워넣어봅시다.

00:10:07.020 --> 00:10:08.091
이번엔 반이예요.

00:10:08.091 --> 00:10:13.980
좋아요, for-loop을 여기에 도식화 합니다.

00:10:13.980 --> 00:10:20.919
[1, 2, 3] 이고, 아주 쉽죠.
output은 빈 배열이구요.

00:10:20.919 --> 00:10:23.046
이렇게예요. 좋아요.

00:10:23.046 --> 00:10:29.052
그리고, Ana 첫 번째 순회에서
body로 가기 전  i의 값은 뭐죠?

00:10:29.052 --> 00:10:31.444
Anna: 0이요.
Will Sentance: 0이죠, 배열의 0번째

00:10:31.444 --> 00:10:32.212
위치는요?

00:10:32.212 --> 00:10:32.837
Anna: 1이요.

00:10:32.837 --> 00:10:35.377
Will Sentance: 1이죠, 1/2는요?

00:10:35.377 --> 00:10:36.864
Anna: .5요.

00:10:36.864 --> 00:10:41.155
Will Sentance: .5가 아니죠. 네,
영국 발음을 널리 알리기 위해서,

00:10:41.155 --> 00:10:41.948
.5가 아니라

00:10:44.131 --> 00:10:46.677
Will Sentance: 전 이런 발음으로 말할 수 없어요.

00:10:46.677 --> 00:10:50.324
.5가 아니죠, 그리고 이걸로 뭘하죠, Anna?

00:10:50.324 --> 00:10:51.579
0.5로 뭘 하죠?

00:10:54.620 --> 00:10:55.650
Anna: 그걸 output에 Push해요.

00:10:55.650 --> 00:10:56.820
Will Sentance: output에 Push하죠. 좋아요.

00:10:56.820 --> 00:10:58.230
고마워요, Anna, 이렇게 되죠.

00:10:59.290 --> 00:11:03.920
이제, i의 값은 뭐죠, Jasmine?

00:11:03.920 --> 00:11:04.670
Jasmine: 1이요.

00:11:04.670 --> 00:11:06.540
Will Sentance: i의 값은 1이죠,
array의 1번째는요?

00:11:06.540 --> 00:11:08.400
Jasmine: 2요.
Will Sentance: 2/2는요?

00:11:08.400 --> 00:11:10.100
Anna: 1이요.
Will Sentance: 1이죠, 그걸로 뭘 하죠?

00:11:10.100 --> 00:11:11.402
Jasmine: 그걸 Push해요.
Will Sentance: 좋아요.

00:11:11.402 --> 00:11:12.841
그리고 마지막은 1.5예요.

00:11:12.841 --> 00:11:16.221
이렇게죠. 0.5, 1, 1.5.

00:11:16.221 --> 00:11:22.458
이제 이 배열 즉, output의 배열을 가지고,
어디로 반환하죠, Jasmine?

00:11:22.458 --> 00:11:23.820
Jasmine: result요.
Will Sentance: result로죠. 훌륭해요.

00:11:23.820 --> 00:11:24.576
Jasmine, 고마워요.

00:11:26.709 --> 00:11:27.323
Will Sentance: 이거죠.