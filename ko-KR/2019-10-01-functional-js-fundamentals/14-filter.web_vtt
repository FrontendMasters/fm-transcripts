WEBVTT

00:00:00.000 --> 00:00:04.326
Will Sentance: 사실 JavaScript에는 모든 배열들이

00:00:04.326 --> 00:00:10.003
접근 가능한 내장함수가 굉장히 많다고 했죠.
Higher Order Function들이요.

00:00:10.003 --> 00:00:14.838
각각을 순회하고 돌면서 배열은 그 배열에 오른쪽에

00:00:14.838 --> 00:00:19.702
.filter를 해요.
이건 [1, 2, 3, 4, 5, 6].filter가 될 겁니다.

00:00:19.702 --> 00:00:21.711
그리고 어떤 함수를 실행하죠

00:00:21.711 --> 00:00:23.986
보세요, 이거죠. greaterThan2요.

00:00:23.986 --> 00:00:27.496
이건 숫자를 받아와서 이 숫자가 2보다 큰지 작은지를

00:00:27.496 --> 00:00:31.170
평가한 결과를 반환하죠. true나 false로요.
그 다음 다른 일을 하죠.

00:00:31.170 --> 00:00:32.257
이건 약간 달라요.

00:00:32.257 --> 00:00:34.511
우리는 MDN으로 가서 어떻게 썼나 봐야해요.

00:00:34.511 --> 00:00:38.121
우린 여기서 하나 더 할거예요.
filter라고 하는걸요.

00:00:38.121 --> 00:00:42.100
그리고 우린 Chaining Higher Order Function이라고
하는 걸 볼거예요.

00:00:42.100 --> 00:00:46.362
전 그게 가장 Functional Programming스러운 스타일의
코드 작성이라고 생각하지 않아요.

00:00:46.362 --> 00:00:51.898
그러나 우리는 실제로 사람들이 JavaScript에서
그렇게 하는 걸 보게 될거예요.

00:00:51.898 --> 00:00:56.456
그리고 그 후 우린 다시 활력을 얻을거예요.

00:00:56.456 --> 00:00:59.005
왜냐면 점심 시간이니까요.

00:00:59.005 --> 00:01:03.684
그러나 그 때까지 나뉘어진 작은 미니 함수들을 작성하고

00:01:03.684 --> 00:01:08.604
하나씩 하나씩 정렬하고 각 기능을 수행하는

00:01:08.604 --> 00:01:14.020
Functional Programming 스타일을 볼 수 있도록
다시 정신 차려야해요.

00:01:14.020 --> 00:01:17.734
그리고 그 작은 함수들을 큰 작업으로 조합해갈 거예요,

00:01:17.734 --> 00:01:22.696
마치 음악에서 작은 음표들을 가지고
커다란 멜로디를 만드는 것처럼요.

00:01:25.128 --> 00:01:27.248
Will Sentance: 보낸 이의 이력서 끝이 어딘가에 있을거예요.

00:01:27.248 --> 00:01:29.163
토너, 그 문장이 끝날겁니다.

00:01:29.163 --> 00:01:30.193
다시 해보죠.

00:01:30.193 --> 00:01:30.790
좋아요.

00:01:30.790 --> 00:01:32.205
Alex: [웃음]
Will Sentance: 좋아요, 시작하죠.

00:01:32.205 --> 00:01:36.925
그럼 실제로 JavaScript가
내부에서 어떻게 동작하는지 보죠.

00:01:36.925 --> 00:01:41.982
JavaScript가 시작되자마자,
그것의 Memory를 열고 데이터를 저장해요.

00:01:41.982 --> 00:01:47.542
실제로는 그 뒤에서죠.
그게 뭘 붙이냐면,

00:01:47.542 --> 00:01:52.309
여기에 써보죠.
그건 함수로 가득한 객체로

00:01:52.309 --> 00:01:56.752
내장되어있고 모든 배열이 접근 가능하죠.

00:01:56.752 --> 00:02:04.151
그래서 우리가 했던 reduce도 여기에 있어요. filter도 있죠.

00:02:04.151 --> 00:02:09.232
그리고 map도 있죠.

00:02:09.232 --> 00:02:13.702
그리고 forEach도 있어요.

00:02:13.702 --> 00:02:14.858
뭐 이런 것들이 있어요.

00:02:14.858 --> 00:02:15.860
저기 있는 것들은 다 쓴 것 같은데, 맞나요?

00:02:15.860 --> 00:02:18.621
flatMap도 있을거고, 딴 게 하나 더 있을 것 같네요.

00:02:18.621 --> 00:02:20.229
좋아요, 이것들은 모두 모든 배열에서 접근 가능하죠.

00:02:20.229 --> 00:02:22.084
자 가보죠.

00:02:22.084 --> 00:02:26.632
첫 번째 라인입니다. 우리가 선언하는 배열이 뭐죠, Alex?

00:02:26.632 --> 00:02:27.991
Alex: 그것의 실제 값이요?

00:02:27.991 --> 00:02:30.139
Will Sentance: 그냥 첫 번째 라인에서 하는 걸 말해주세요.

00:02:30.139 --> 00:02:33.140
Alex: 상수 label인 array를 두고요.

00:02:33.140 --> 00:02:33.994
Will Sentance: 네.

00:02:33.994 --> 00:02:37.178
Alex: 메모리에요.
그리고 그 값은 [1, 2, 3, 4, 5, 6]입니다.

00:02:37.178 --> 00:02:37.696
Will Sentance: 좋아요.

00:02:37.696 --> 00:02:41.719
전 Alex가 한 것처럼 깔끔한
기술적인 의사소통을 좋아해요. 고마워요.

00:02:41.719 --> 00:02:44.787
[1, 2, 3, 4, 5, 6]이죠.

00:02:44.787 --> 00:02:45.626
이거죠.

00:02:45.626 --> 00:02:48.953
좋아요, 그리고 다음 라인은, David.

00:02:48.953 --> 00:02:53.537
David: const로 greaterThan2를 선언해요.

00:02:53.537 --> 00:02:54.699
Will Sentance: const는 이제 함수죠.

00:02:57.919 --> 00:02:58.689
Will Sentance: [웃음] 이거 보세요.

00:02:58.689 --> 00:03:05.283
전 F 박스랑 greatherThan2를 바꿨어요.
이건 그냥 평범한 함수에요.

00:03:05.283 --> 00:03:09.706
제가 진짜로 강조하는 건 David,
const라고 말할 것도 없어요 이건 그냥 함수입니다.

00:03:09.706 --> 00:03:10.570
함수예요.

00:03:10.570 --> 00:03:11.193
함수요.

00:03:11.193 --> 00:03:16.726
함수예요. 이건 num을 가지고, 결과값을 반환하죠.

00:03:16.726 --> 00:03:21.808
네, 2보다  큰 지 작은지에 대한 true/false인 boolean이죠.

00:03:21.808 --> 00:03:23.882
그래서 이게 3이랑 실행되면,
true를 반환할겁니다.

00:03:23.882 --> 00:03:26.940
그리고 1이랑 실행되면, false를 반환하겠죠.

00:03:26.940 --> 00:03:33.129
좋아요, 이제 마지막 라인이요, Virginia.

00:03:33.129 --> 00:03:35.824
Virginia: 음 그러니까-
Will Sentance: left-hand 영역부터요?

00:03:35.824 --> 00:03:38.641
Virginia: 네, filteredArray를 label로 해요.

00:03:38.641 --> 00:03:39.826
Will Sentance: 완벽해요, 좋아요.

00:03:39.826 --> 00:03:42.407
그리고 right-hand 영역은 뭘 하라고 하죠?

00:03:42.407 --> 00:03:44.333
Virginia: array의 뭔가를 실행하라구요.

00:03:44.333 --> 00:03:47.300
Will Sentance: 네, 그리고 우리가 실행할건요?

00:03:47.300 --> 00:03:48.978
Virginia: greaterThan2 filter요.

00:03:48.978 --> 00:03:50.382
Will Sentance: filter예요, filter예요.

00:03:50.382 --> 00:03:52.790
확실히 greaterThan2는 아닙니다.

00:03:52.790 --> 00:03:53.738
Virginia: reducer랑 같이있는 filter요.

00:03:53.738 --> 00:03:57.574
Will Sentance: 오..reducer는 아니예요.

00:03:57.574 --> 00:04:02.161
reducer는 특별한 함수죠. 그걸 reduce에서 받아주죠.
reduce는 reduce의 배열의

00:04:02.161 --> 00:04:06.223
각 요소와 accumulator를 가지고 조합을 해서 결과를 얻어내고

00:04:06.223 --> 00:04:09.588
그 결과는 reducer를 통해 나오죠.

00:04:09.588 --> 00:04:11.088
그리고 그 다음 요소와 반복하구요. 걱정말아요.

00:04:11.088 --> 00:04:14.080
네, 저기선 Callback에 멈춰있죠. 좋아요.

00:04:14.080 --> 00:04:18.073
좋아요, 그래서 filteredArray죠.

00:04:20.278 --> 00:04:23.124
Will Sentance: 이건 아주 일반적이고 사용하기 좋은 함수죠.

00:04:23.124 --> 00:04:25.328
전 이것에 대해 아주 자세히 설명하진 않을거예요.

00:04:25.328 --> 00:04:28.334
Execution Context를 그려가면서 보진 않을께요.

00:04:28.334 --> 00:04:33.016
생략된 버전의 Execution Context로 알려드릴께요.

00:04:33.016 --> 00:04:39.864
이거고, 입력은 greaterThan2

00:04:39.864 --> 00:04:45.864
함수의 전체죠.

00:04:45.864 --> 00:04:53.272
이거고, num을 가지고 num > 2를 반환하죠.

00:04:53.272 --> 00:04:57.203
실제로 배열 각 부분을 평가해서 그대로 똑바로 넣을 거예요.

00:04:57.203 --> 00:05:00.818
그것이 진행되는 방향으로 똑바로 있죠.

00:05:00.818 --> 00:05:04.769
그래서 좀 더 보기 쉽게 실제로 보면,

00:05:04.769 --> 00:05:09.935
이건

00:05:09.935 --> 00:05:17.398
[1, 2, 3, 4, 5, 6].filter죠.

00:05:17.398 --> 00:05:20.253
이거 별로네요.

00:05:20.253 --> 00:05:24.325
이건 좀 길게 보면 별로 좋은 것 같지 않네요.

00:05:24.325 --> 00:05:28.254
여길 좀 지우죠.

00:05:28.254 --> 00:05:31.986
was if you rub really,
제가 정말 열심히 문지르면,

00:05:31.986 --> 00:05:37.885
진짜 열심히 문지르면 되네요.

00:05:37.885 --> 00:05:44.464
좋아요, 여기서부터 시작하죠, filteredArray는

00:05:44.464 --> 00:05:49.562
결과값으로 평가될건데요.

00:05:49.562 --> 00:05:57.960
호출된 array 즉,
[1, 2, 3, 4, 5, 6].filter의 결과겠죠.

00:05:57.960 --> 00:05:59.519
filter 메소드죠.

00:05:59.519 --> 00:06:02.790
그럼 어떻게 filter 메소드에 접근할 수 있죠?

00:06:02.790 --> 00:06:07.543
음, 저 배열은 그것의 객체 버전과 묶여있죠.

00:06:07.543 --> 00:06:13.343
이거에 너무 메달리진 않죠. __proto__ 속성을 통해서입니다.

00:06:13.343 --> 00:06:15.744
어디로 가죠?

00:06:15.744 --> 00:06:18.412
어디로 가죠, Michael?

00:06:18.412 --> 00:06:19.473
Michael: prototype으로요?

00:06:19.473 --> 00:06:24.199
Will Sentance: 네, 좀 짧은데, 여기 이 함수로 가득한 객체로

00:06:24.199 --> 00:06:25.543
접근하는거죠.

00:06:25.543 --> 00:06:29.939
그래서 우리가 [1, 2, 3, 4, 5, 6].filter를 하면,
우린 여기로 가서 array를 찾고,

00:06:29.939 --> 00:06:32.497
[1, 2, 3, 4, 5, 6]의 객체 부분을요.

00:06:32.497 --> 00:06:37.407
그리고 이건 여기 아래에 우리가 사용할 수 있는
함수들의 리스트로 연결되어있고, filter를 찾으면,

00:06:37.407 --> 00:06:38.468
그걸 가지고 사용하는거죠.

00:06:38.468 --> 00:06:39.718
만들어볼까요.

00:06:39.718 --> 00:06:41.795
네, Execution Context를 만드는거예요.

00:06:41.795 --> 00:06:43.332
이거죠.

00:06:43.332 --> 00:06:46.046
Local Memory에 뭐가 있는지 같은 건 넘어갈께요.

00:06:46.046 --> 00:06:49.836
filter가 하는 것에 대해 좀 더 일반적으로 이야기할께요.
여러분,

00:06:49.836 --> 00:06:52.679
전 이걸 알아내기 위해 MDN에서 뭘 해야하는지 알려드릴께요.

00:06:52.679 --> 00:06:57.262
이 안에서 하는 첫 번째는 만드는 건데, 
가장 처음 하는게 뭘까요?

00:06:57.262 --> 00:06:59.010
아시는 분? 음 Sam이 알까요?

00:06:59.010 --> 00:06:59.808
David?

00:06:59.808 --> 00:07:01.253
David: 빈 배열을 만드나요?

00:07:01.253 --> 00:07:01.899
Will Sentance: 맞아요.

00:07:01.899 --> 00:07:06.816
빈 배열이죠. 좋아요 잘했어요.
여기 빈 배열을 만들어서

00:07:06.816 --> 00:07:11.819
여기에 아무거나 붙일 수 있죠.
그리고 이 함수, greaterThan2를

00:07:11.819 --> 00:07:17.183
0번째의 요소와 실행하고, 1번째 요소 그리고 계속 가죠.

00:07:17.183 --> 00:07:22.153
그 요소를 가지고, greaterThan2 함수의
Execution Context에 전달하죠.

00:07:22.153 --> 00:07:26.626
그래서 넘어온 num parameter는 1이 될거고,

00:07:26.626 --> 00:07:30.744
1 > 2를 하면, false를 반환할거고

00:07:30.744 --> 00:07:32.462
그 요소에서 넘어갈거예요.