WEBVTT

00:00:00.000 --> 00:00:01.640
Will Sentance: 이게 사이드 이펙트예요.

00:00:01.640 --> 00:00:03.703
함수의 결과가,

00:00:03.703 --> 00:00:08.913
아 기억해두세요, 이건 특별히 더 나쁜 케이스예요.

00:00:08.913 --> 00:00:14.701
이 함수를 실행할 때, 이 부분의 결과는
반드시 숫자 10이 되어야 하는거죠.

00:00:14.701 --> 00:00:17.095
우린 그걸 여기에서 사용하죠, 그렇죠?

00:00:17.095 --> 00:00:21.942
우린 그 결과값을 다음 함수의
실행에 넣는데, 여기에선

00:00:21.942 --> 00:00:22.979
그게 divideBy5죠.

00:00:22.979 --> 00:00:24.821
If instead running add 3,
만약 add3를 실행하는 대신,

00:00:24.821 --> 00:00:29.718
여기에선 입력이 22였죠, 기억하시나요?

00:00:29.718 --> 00:00:33.295
add3가 있죠.

00:00:33.295 --> 00:00:37.776
만약 우리가 이 add3를 쓴다면,
이건 전역 상태의 결과에 영향을 끼치죠.

00:00:37.776 --> 00:00:40.138
Global Memory의 결과가 됩니다.

00:00:40.138 --> 00:00:42.965
다시 말하지만, 이미 똑같은 걸 말했었어요.
여러분들은 이미 이해했을겁니다.

00:00:42.965 --> 00:00:47.723
근데 만약 Global에 영향을 미친다면,
add3 함수는 3만 더하는게 아니죠.

00:00:47.723 --> 00:00:50.117
이건 더하기 3과 알 수 없는 함수예요.

00:00:50.117 --> 00:00:54.607
여기있는 add3 라인의 개념은 완전히 자기충족적이고

00:00:54.607 --> 00:00:57.490
그 라인 아래의 하나의 결과만 가지죠.

00:00:57.490 --> 00:01:00.821
그리고 나머지 라인들에 연관된 의존성이 하나도 없죠.

00:01:00.821 --> 00:01:04.600
나머지랑 의존하는 게 하나도 없어요.
완전히 별개예요.

00:01:04.600 --> 00:01:06.700
그리고 각각의 라인 속에서,

00:01:06.700 --> 00:01:10.000
우리는 그게 무엇을 하고 있는지 정확히 확인하고,
그것이 다른 코드 라인에

00:01:10.000 --> 00:01:11.767
어떤 종속성에 따른 영향을 주는지 확인해야 합니다.

00:01:11.767 --> 00:01:13.054
모든 게 다 개별이여야하죠.

00:01:15.007 --> 00:01:18.097
Will Sentance: 만약 이 함수가
그 자체의 라인을 벗어난 결과를

00:01:18.097 --> 00:01:18.930
만들어낼 수 있다면

00:01:18.930 --> 00:01:22.337
그리고 그 라인에서 Local Memory에서 뭔가를 참조하는 경우,

00:01:22.337 --> 00:01:25.307
특히 이 짧은 함수는 한 줄이지만, Local Memory는 아니죠.

00:01:25.307 --> 00:01:29.609
그렇다면, 순수하지 않은거예요.
여기 이 모델을 다 깨버리는거죠.

00:01:29.609 --> 00:01:33.121
일단 여기에서 질문을 좀 받아볼께요.
여러분들이 이걸 이해했다면,

00:01:33.121 --> 00:01:35.435
다른 식으로 반복하고 싶진 않거든요.

00:01:35.435 --> 00:01:37.540
모르겠다, 알겠다, 질문있다.

00:01:37.540 --> 00:01:38.181
좋아요.

00:01:38.181 --> 00:01:39.840
몇몇 분들이 이해가 잘 안됐나보네요.

00:01:39.840 --> 00:01:42.310
좋아요, 저는 가끔 이걸 너무 끌 때가 있어요.

00:01:43.330 --> 00:01:47.040
좋아요, 그 반환값이 하나의 결과인
순수한 함수가 필요합니다.

00:01:48.780 --> 00:01:54.720
음, 이런 경우에 사이드 이펙트가 없는지 확인해보죠.

00:01:54.720 --> 00:01:56.350
우리가 놓친 사이드 이펙트가 있을 수 있어요.

00:01:57.690 --> 00:02:02.160
순수함수는 만약 우리가 해당 라인에서
오직 하나의 결과만을 원하고,

00:02:02.160 --> 00:02:06.190
참조 투명성을 유지하길 원하고,
이 함수의 결과로 똑같이 대체가 가능하길 원한다는 걸

00:02:06.190 --> 00:02:11.100
만족시켜야하고, 이렇게 되면, 함수가 순수한겁니다.

00:02:11.100 --> 00:02:14.220
데이터를 보존하고 조작하지 않아야 하죠.

00:02:15.690 --> 00:02:20.392
여기 우리가 놓친 문제가 있었어요.
여러분들이 깨닫지 못한 사이드 이펙트죠.

00:02:20.392 --> 00:02:23.817
JavaScript가 함수를 실행할 때 전달하는 것과 관련해서요.

00:02:23.817 --> 00:02:26.721
여기 [1, 2, 3]이 있습니다.

00:02:26.721 --> 00:02:30.101
multiplyBy2는 함수죠.

00:02:30.101 --> 00:02:33.461
우린 [1, 2, 3]에 map을 실행할거예요

00:02:33.461 --> 00:02:37.830
그리고 그건 1x2를 하고, 2x2를 하고,

00:02:37.830 --> 00:02:42.722
3x2를 하겠죠. 그리고 어떤 이유로
그것들을 새로운 배열에 저장할거예요.

00:02:42.722 --> 00:02:47.012
왜냐하면 map에 던져진

00:02:47.012 --> 00:02:51.952
[1, 2, 3]은
[1, 2, 3]의 복사값이

00:02:51.952 --> 00:02:56.121
map의 Execution Context에
전달된 게 아니거든요.

00:02:56.121 --> 00:03:00.709
사실 이건 전역에 저장된 버전의 연결 링크예요.

00:03:02.180 --> 00:03:06.480
그 말은, 만약 map안에서
여러분들이 전달 받은 배열을

00:03:06.480 --> 00:03:10.420
변형하기 시작하면,
Global의 array도 같이 변한다는거죠.

00:03:11.450 --> 00:03:15.340
그리고 여러분들이
멋있고 깔끔하며 외부에 영향이 없다고

00:03:15.340 --> 00:03:21.130
생각한 코드 라인이,
실제로는 그 라인의 입력을 통하게 되는거죠.

00:03:21.130 --> 00:03:25.140
Global에 영향을 주죠, 여러분들의 코드에서

00:03:25.140 --> 00:03:27.700
다른 라인에 영향을 줄 수 있는 거예요.

00:03:27.700 --> 00:03:32.484
만약 map이 내부에서 입력으로 들어온 [1, 2, 3]을 변이하지 않고,

00:03:32.484 --> 00:03:35.888
바꾸지 않는 방식으로 동작한다면,

00:03:35.888 --> 00:03:41.592
새로운 배열을 만들고 각 요소를 취해 그것들을 곱하는 대신,

00:03:41.592 --> 00:03:46.123
그 배열 안에 붙인다면, 이건 맞는 게 아니죠.

00:03:46.123 --> 00:03:50.759
여러분들은 동일한 코드 라인을 사용하여
동일한 처리를 얻지 못합니다.

00:03:50.759 --> 00:03:52.347
여러분들은 처음 [2, 4, 6]을 얻고

00:03:52.347 --> 00:03:56.020
같은 배열을 다시 사용하는 경우
다음 슬라이드에 있는 걸 얻을건데요.

00:03:56.020 --> 00:03:57.260
그게 뭘까요, Seth?

00:03:58.800 --> 00:03:59.608
David? Duke?

00:03:59.608 --> 00:04:00.346
David: [4, 8, 12]요.

00:04:00.346 --> 00:04:03.613
Will Sentance: 맞았어요, [4, 8, 12]죠.

00:04:03.613 --> 00:04:06.667
만약 함수에서 입력 배열을 변이시키면,
순수한게 아니예요.

00:04:06.667 --> 00:04:08.190
예측할 수 없죠.

00:04:08.190 --> 00:04:10.110
그걸 읽고, 그 라인의 출력값을 보는 것만으로

00:04:10.110 --> 00:04:12.090
이게 뭘 하는건지 알아낼 수가 없죠.

00:04:12.090 --> 00:04:17.760
모든 노력이 물거품이 되죠. 왜냐하면, 배열을 변이시키면,

00:04:17.760 --> 00:04:21.600
map에 던져진 배열이 변하는 것이기 때문입니다.
잠깐 다이어그램으로 봐보죠.

00:04:21.600 --> 00:04:22.344
공간이 없네요.

00:04:22.344 --> 00:04:24.468
우리가 이 전체 세트에서 할 마지막 파트입니다.

00:04:24.468 --> 00:04:30.104
여기에 그릴께요.

00:04:30.104 --> 00:04:33.193
음, 그냥 써보죠.

00:04:33.193 --> 00:04:35.641
여러분들이 Pair Programming으로
들어가기 전에 하는 이 섹션의

00:04:35.641 --> 00:04:36.218
마지막입니다.

00:04:36.218 --> 00:04:39.223
Anna, 첫 번째 라인입니다. 뭘 하죠?

00:04:39.223 --> 00:04:42.732
Anna: array라는 [1, 2, 3]을 선언해요.

00:04:42.732 --> 00:04:47.229
Will Sentance: [1, 2, 3]이죠, 좋아요.

00:04:47.229 --> 00:04:50.070
다음 라인은, Alex?

00:04:50.070 --> 00:04:52.550
Alex: 함수를 선언합니다. multiplyBy2요.

00:04:52.550 --> 00:04:53.230
Will Sentance: 고마워요, Alex.

00:04:53.230 --> 00:04:55.710
함수라고 해줘서 고마워요. 좋았어요.

00:04:58.510 --> 00:04:59.886
좋아요.

00:04:59.886 --> 00:05:02.508
이해하죠?

00:05:02.508 --> 00:05:05.569
다음 라인은, Chales?

00:05:05.569 --> 00:05:08.113
Charles: result를 선언해요.

00:05:08.113 --> 00:05:08.925
Will Sentance: 좋아요.

00:05:08.925 --> 00:05:13.987
그럼 result는 [1, 2, 3].map이고,

00:05:13.987 --> 00:05:21.750
우리가 지금 기억하는 건
배열의 각 요소를 취하는 함수라는거죠.

00:05:21.750 --> 00:05:27.352
새로운 배열을 만들죠.
그 자신 안에서 스스로

00:05:27.352 --> 00:05:33.059
새로운 배열을 만들고,
각 요소를 사용하죠. 1, 2, 3을요.

00:05:33.059 --> 00:05:35.140
각 요소를 취하고

00:05:35.140 --> 00:05:39.720
원래의 버전의 참조를 이용해서 넘어가는게 아니죠.

00:05:39.720 --> 00:05:42.746
그 Memory안에 복사를 하는 방식으로 처리하죠.

00:05:42.746 --> 00:05:47.293
값으로요. 사실 복사는 아니고,
새로운 값으로 저장하는거죠.

00:05:47.293 --> 00:05:51.556
이 map안에서 2를 곱하죠.

00:05:51.556 --> 00:05:56.581
새로운 배열을 만들고, [1, 2, 3]을 받아서

00:05:56.581 --> 00:06:02.694
1, 2, 3을 각각 취한 뒤 2를 곱해요.

00:06:02.694 --> 00:06:06.249
우리가 이렇게 하지 않고,
만약 우리가 이 입력 배열을 조작한다면,

00:06:06.249 --> 00:06:10.518
넘어온 배열이요, 이 배열을 변경한다면요.

00:06:10.518 --> 00:06:16.291
그 말은, 여기에서 다른 모든 라인에
영향을 준다는 거예요.

00:06:16.291 --> 00:06:19.352
왜냐하면 제 코드의 다른 곳에서
이 배열을 참조할 수 있으니까요.

00:06:19.352 --> 00:06:24.151
그 말은, 이 array.mp의 실행에 의존한다는거죠.

00:06:24.151 --> 00:06:26.781
만약 map이 우리가 원하는대로
동작하지 않는다면요.

00:06:26.781 --> 00:06:30.880
입력받은 [1, 2, 3]을 변화한다면요.

00:06:30.880 --> 00:06:36.343
우린 우리가 실행하는 모든 코드 라인이 자기 충족적인지

00:06:36.343 --> 00:06:41.710
확인하기 위해 파악해내야 하죠.
그 원래의 버전과 연결된 링크에 의해

00:06:41.710 --> 00:06:47.198
참조로 전달된 데이터가 변하는지 안하는지를요.

00:06:47.198 --> 00:06:52.129
그것은 우리가 순수함수의 규칙을 어겨버리는 걸
우리가 깨닫지도 못하게

00:06:52.129 --> 00:06:54.178
하는 잘 보이지도 않는 부분인거죠.